{"mappings":"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","sources":["model-viewer.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * True if the custom elements polyfill is in use.\n */\nconst isCEPolyfill =\n  typeof window !== 'undefined' &&\n  window.customElements != null &&\n  window.customElements.polyfillWrapFlushCallback !== undefined;\n/**\n * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from\n * `container`.\n */\nconst removeNodes = (container, start, end = null) => {\n  while (start !== end) {\n    const n = start.nextSibling;\n    container.removeChild(start);\n    start = n;\n  }\n};\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nconst nodeMarker = `<!--${marker}-->`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nconst boundAttributeSuffix = '$lit$';\n/**\n * An updatable Template that tracks the location of dynamic parts.\n */\nclass Template {\n  constructor(result, element) {\n    this.parts = [];\n    this.element = element;\n    const nodesToRemove = [];\n    const stack = [];\n    // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n    const walker = document.createTreeWalker(\n      element.content,\n      133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n      null,\n      false,\n    );\n    // Keeps track of the last index associated with a part. We try to delete\n    // unnecessary nodes, but we never want to associate two different parts\n    // to the same index. They must have a constant node between.\n    let lastPartIndex = 0;\n    let index = -1;\n    let partIndex = 0;\n    const {\n      strings,\n      values: { length },\n    } = result;\n    while (partIndex < length) {\n      const node = walker.nextNode();\n      if (node === null) {\n        // We've exhausted the content inside a nested template element.\n        // Because we still have parts (the outer for-loop), we know:\n        // - There is a template in the stack\n        // - The walker will find a nextNode outside the template\n        walker.currentNode = stack.pop();\n        continue;\n      }\n      index++;\n      if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n        if (node.hasAttributes()) {\n          const attributes = node.attributes;\n          const { length } = attributes;\n          // Per\n          // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n          // attributes are not guaranteed to be returned in document order.\n          // In particular, Edge/IE can return them out of order, so we cannot\n          // assume a correspondence between part index and attribute index.\n          let count = 0;\n          for (let i = 0; i < length; i++) {\n            if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n              count++;\n            }\n          }\n          while (count-- > 0) {\n            // Get the template literal section leading up to the first\n            // expression in this attribute\n            const stringForPart = strings[partIndex];\n            // Find the attribute name\n            const name = lastAttributeNameRegex.exec(stringForPart)[2];\n            // Find the corresponding attribute\n            // All bound attributes have had a suffix added in\n            // TemplateResult#getHTML to opt out of special attribute\n            // handling. To look up the attribute value we also need to add\n            // the suffix.\n            const attributeLookupName =\n              name.toLowerCase() + boundAttributeSuffix;\n            const attributeValue = node.getAttribute(attributeLookupName);\n            node.removeAttribute(attributeLookupName);\n            const statics = attributeValue.split(markerRegex);\n            this.parts.push({\n              type: 'attribute',\n              index,\n              name,\n              strings: statics,\n            });\n            partIndex += statics.length - 1;\n          }\n        }\n        if (node.tagName === 'TEMPLATE') {\n          stack.push(node);\n          walker.currentNode = node.content;\n        }\n      } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n        const data = node.data;\n        if (data.indexOf(marker) >= 0) {\n          const parent = node.parentNode;\n          const strings = data.split(markerRegex);\n          const lastIndex = strings.length - 1;\n          // Generate a new text node for each literal section\n          // These nodes are also used as the markers for node parts\n          for (let i = 0; i < lastIndex; i++) {\n            let insert;\n            let s = strings[i];\n            if (s === '') {\n              insert = createMarker();\n            } else {\n              const match = lastAttributeNameRegex.exec(s);\n              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                s =\n                  s.slice(0, match.index) +\n                  match[1] +\n                  match[2].slice(0, -boundAttributeSuffix.length) +\n                  match[3];\n              }\n              insert = document.createTextNode(s);\n            }\n            parent.insertBefore(insert, node);\n            this.parts.push({ type: 'node', index: ++index });\n          }\n          // If there's no text, we must insert a comment to mark our place.\n          // Else, we can trust it will stick around after cloning.\n          if (strings[lastIndex] === '') {\n            parent.insertBefore(createMarker(), node);\n            nodesToRemove.push(node);\n          } else {\n            node.data = strings[lastIndex];\n          }\n          // We have a part for each match found\n          partIndex += lastIndex;\n        }\n      } else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n        if (node.data === marker) {\n          const parent = node.parentNode;\n          // Add a new marker node to be the startNode of the Part if any of\n          // the following are true:\n          //  * We don't have a previousSibling\n          //  * The previousSibling is already the start of a previous part\n          if (node.previousSibling === null || index === lastPartIndex) {\n            index++;\n            parent.insertBefore(createMarker(), node);\n          }\n          lastPartIndex = index;\n          this.parts.push({ type: 'node', index });\n          // If we don't have a nextSibling, keep this node so we have an end.\n          // Else, we can remove it to save future costs.\n          if (node.nextSibling === null) {\n            node.data = '';\n          } else {\n            nodesToRemove.push(node);\n            index--;\n          }\n          partIndex++;\n        } else {\n          let i = -1;\n          while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            this.parts.push({ type: 'node', index: -1 });\n            partIndex++;\n          }\n        }\n      }\n    }\n    // Remove text binding nodes after the walk to not disturb the TreeWalker\n    for (const n of nodesToRemove) {\n      n.parentNode.removeChild(n);\n    }\n  }\n}\nconst endsWith = (str, suffix) => {\n  const index = str.length - suffix.length;\n  return index >= 0 && str.slice(index) === suffix;\n};\nconst isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nconst createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst lastAttributeNameRegex =\n  // eslint-disable-next-line no-control-regex\n  /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst walkerNodeFilter = 133; /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nfunction removeNodesFromTemplate(template, nodesToRemove) {\n  const {\n    element: { content },\n    parts,\n  } = template;\n  const walker = document.createTreeWalker(\n    content,\n    walkerNodeFilter,\n    null,\n    false,\n  );\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let part = parts[partIndex];\n  let nodeIndex = -1;\n  let removeCount = 0;\n  const nodesToRemoveInTemplate = [];\n  let currentRemovingNode = null;\n  while (walker.nextNode()) {\n    nodeIndex++;\n    const node = walker.currentNode;\n    // End removal if stepped past the removing node\n    if (node.previousSibling === currentRemovingNode) {\n      currentRemovingNode = null;\n    }\n    // A node to remove was found in the template\n    if (nodesToRemove.has(node)) {\n      nodesToRemoveInTemplate.push(node);\n      // Track node we're removing\n      if (currentRemovingNode === null) {\n        currentRemovingNode = node;\n      }\n    }\n    // When removing, increment count by which to adjust subsequent part indices\n    if (currentRemovingNode !== null) {\n      removeCount++;\n    }\n    while (part !== undefined && part.index === nodeIndex) {\n      // If part is in a removed node deactivate it by setting index to -1 or\n      // adjust the index as needed.\n      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n      // go to the next active part.\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n      part = parts[partIndex];\n    }\n  }\n  nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));\n}\nconst countNodes = (node) => {\n  let count = node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ ? 0 : 1;\n  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n  while (walker.nextNode()) {\n    count++;\n  }\n  return count;\n};\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n  for (let i = startIndex + 1; i < parts.length; i++) {\n    const part = parts[i];\n    if (isTemplatePartActive(part)) {\n      return i;\n    }\n  }\n  return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nfunction insertNodeIntoTemplate(template, node, refNode = null) {\n  const {\n    element: { content },\n    parts,\n  } = template;\n  // If there's no refNode, then put node at end of template.\n  // No part indices need to be shifted in this case.\n  if (refNode === null || refNode === undefined) {\n    content.appendChild(node);\n    return;\n  }\n  const walker = document.createTreeWalker(\n    content,\n    walkerNodeFilter,\n    null,\n    false,\n  );\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let insertCount = 0;\n  let walkerIndex = -1;\n  while (walker.nextNode()) {\n    walkerIndex++;\n    const walkerNode = walker.currentNode;\n    if (walkerNode === refNode) {\n      insertCount = countNodes(node);\n      refNode.parentNode.insertBefore(node, refNode);\n    }\n    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n      // If we've inserted the node, simply adjust all subsequent parts\n      if (insertCount > 0) {\n        while (partIndex !== -1) {\n          parts[partIndex].index += insertCount;\n          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n        return;\n      }\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n    }\n  }\n}\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\nconst isDirective = (o) => {\n  return typeof o === 'function' && directives.has(o);\n};\n\n/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nconst noChange = {};\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nconst nothing = {};\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nclass TemplateInstance {\n  constructor(template, processor, options) {\n    this.__parts = [];\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n  update(values) {\n    let i = 0;\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.setValue(values[i]);\n      }\n      i++;\n    }\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.commit();\n      }\n    }\n  }\n  _clone() {\n    // There are a number of steps in the lifecycle of a template instance's\n    // DOM fragment:\n    //  1. Clone - create the instance fragment\n    //  2. Adopt - adopt into the main document\n    //  3. Process - find part markers and create parts\n    //  4. Upgrade - upgrade custom elements\n    //  5. Update - set node, attribute, property, etc., values\n    //  6. Connect - connect to the document. Optional and outside of this\n    //     method.\n    //\n    // We have a few constraints on the ordering of these steps:\n    //  * We need to upgrade before updating, so that property values will pass\n    //    through any property setters.\n    //  * We would like to process before upgrading so that we're sure that the\n    //    cloned fragment is inert and not disturbed by self-modifying DOM.\n    //  * We want custom elements to upgrade even in disconnected fragments.\n    //\n    // Given these constraints, with full custom elements support we would\n    // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n    //\n    // But Safari does not implement CustomElementRegistry#upgrade, so we\n    // can not implement that order and still have upgrade-before-update and\n    // upgrade disconnected fragments. So we instead sacrifice the\n    // process-before-upgrade constraint, since in Custom Elements v1 elements\n    // must not modify their light DOM in the constructor. We still have issues\n    // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n    // that don't strictly adhere to the no-modification rule because shadow\n    // DOM, which may be created in the constructor, is emulated by being placed\n    // in the light DOM.\n    //\n    // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n    // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n    // in one step.\n    //\n    // The Custom Elements v1 polyfill supports upgrade(), so the order when\n    // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n    // Connect.\n    const fragment = isCEPolyfill\n      ? this.template.element.content.cloneNode(true)\n      : document.importNode(this.template.element.content, true);\n    const stack = [];\n    const parts = this.template.parts;\n    // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n    const walker = document.createTreeWalker(\n      fragment,\n      133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n      null,\n      false,\n    );\n    let partIndex = 0;\n    let nodeIndex = 0;\n    let part;\n    let node = walker.nextNode();\n    // Loop through all the nodes and parts of a template\n    while (partIndex < parts.length) {\n      part = parts[partIndex];\n      if (!isTemplatePartActive(part)) {\n        this.__parts.push(undefined);\n        partIndex++;\n        continue;\n      }\n      // Progress the tree walker until we find our next part's node.\n      // Note that multiple parts may share the same node (attribute parts\n      // on a single element), so this loop may not run at all.\n      while (nodeIndex < part.index) {\n        nodeIndex++;\n        if (node.nodeName === 'TEMPLATE') {\n          stack.push(node);\n          walker.currentNode = node.content;\n        }\n        if ((node = walker.nextNode()) === null) {\n          // We've exhausted the content inside a nested template element.\n          // Because we still have parts (the outer for-loop), we know:\n          // - There is a template in the stack\n          // - The walker will find a nextNode outside the template\n          walker.currentNode = stack.pop();\n          node = walker.nextNode();\n        }\n      }\n      // We've arrived at our part's node.\n      if (part.type === 'node') {\n        const part = this.processor.handleTextExpression(this.options);\n        part.insertAfterNode(node.previousSibling);\n        this.__parts.push(part);\n      } else {\n        this.__parts.push(\n          ...this.processor.handleAttributeExpressions(\n            node,\n            part.name,\n            part.strings,\n            this.options,\n          ),\n        );\n      }\n      partIndex++;\n    }\n    if (isCEPolyfill) {\n      document.adoptNode(fragment);\n      customElements.upgrade(fragment);\n    }\n    return fragment;\n  }\n}\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy =\n  window.trustedTypes &&\n  trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });\nconst commentMarker = ` ${marker} `;\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nclass TemplateResult {\n  constructor(strings, values, type, processor) {\n    this.strings = strings;\n    this.values = values;\n    this.type = type;\n    this.processor = processor;\n  }\n  /**\n   * Returns a string of HTML used to create a `<template>` element.\n   */\n  getHTML() {\n    const l = this.strings.length - 1;\n    let html = '';\n    let isCommentBinding = false;\n    for (let i = 0; i < l; i++) {\n      const s = this.strings[i];\n      // For each binding we want to determine the kind of marker to insert\n      // into the template source before it's parsed by the browser's HTML\n      // parser. The marker type is based on whether the expression is in an\n      // attribute, text, or comment position.\n      //   * For node-position bindings we insert a comment with the marker\n      //     sentinel as its text content, like <!--{{lit-guid}}-->.\n      //   * For attribute bindings we insert just the marker sentinel for the\n      //     first binding, so that we support unquoted attribute bindings.\n      //     Subsequent bindings can use a comment marker because multi-binding\n      //     attributes must be quoted.\n      //   * For comment bindings we insert just the marker sentinel so we don't\n      //     close the comment.\n      //\n      // The following code scans the template source, but is *not* an HTML\n      // parser. We don't need to track the tree structure of the HTML, only\n      // whether a binding is inside a comment, and if not, if it appears to be\n      // the first binding in an attribute.\n      const commentOpen = s.lastIndexOf('<!--');\n      // We're in comment position if we have a comment open with no following\n      // comment close. Because <-- can appear in an attribute value there can\n      // be false positives.\n      isCommentBinding =\n        (commentOpen > -1 || isCommentBinding) &&\n        s.indexOf('-->', commentOpen + 1) === -1;\n      // Check to see if we have an attribute-like sequence preceding the\n      // expression. This can match \"name=value\" like structures in text,\n      // comments, and attribute values, so there can be false-positives.\n      const attributeMatch = lastAttributeNameRegex.exec(s);\n      if (attributeMatch === null) {\n        // We're only in this branch if we don't have a attribute-like\n        // preceding sequence. For comments, this guards against unusual\n        // attribute values like <div foo=\"<!--${'bar'}\">. Cases like\n        // <!-- foo=${'bar'}--> are handled correctly in the attribute branch\n        // below.\n        html += s + (isCommentBinding ? commentMarker : nodeMarker);\n      } else {\n        // For attributes we use just a marker sentinel, and also append a\n        // $lit$ suffix to the name to opt-out of attribute-specific parsing\n        // that IE and Edge do for style and certain SVG attributes.\n        html +=\n          s.substr(0, attributeMatch.index) +\n          attributeMatch[1] +\n          attributeMatch[2] +\n          boundAttributeSuffix +\n          attributeMatch[3] +\n          marker;\n      }\n    }\n    html += this.strings[l];\n    return html;\n  }\n  getTemplateElement() {\n    const template = document.createElement('template');\n    let value = this.getHTML();\n    if (policy !== undefined) {\n      // this is secure because `this.strings` is a TemplateStringsArray.\n      // TODO: validate this when\n      // https://github.com/tc39/proposal-array-is-template-object is\n      // implemented.\n      value = policy.createHTML(value);\n    }\n    template.innerHTML = value;\n    return template;\n  }\n}\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst isPrimitive = (value) => {\n  return (\n    value === null ||\n    !(typeof value === 'object' || typeof value === 'function')\n  );\n};\nconst isIterable = (value) => {\n  return (\n    Array.isArray(value) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    !!(value && value[Symbol.iterator])\n  );\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nclass AttributeCommitter {\n  constructor(element, name, strings) {\n    this.dirty = true;\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      this.parts[i] = this._createPart();\n    }\n  }\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n  _createPart() {\n    return new AttributePart(this);\n  }\n  _getValue() {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    const parts = this.parts;\n    // If we're assigning an attribute via syntax like:\n    //    attr=\"${foo}\"  or  attr=${foo}\n    // but not\n    //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\n    // then we don't want to coerce the attribute value into one long\n    // string. Instead we want to just return the value itself directly,\n    // so that sanitizeDOMValue can get the actual value rather than\n    // String(value)\n    // The exception is if v is an array, in which case we do want to smash\n    // it together into a string without calling String() on the array.\n    //\n    // This also allows trusted values (when using TrustedTypes) being\n    // assigned to DOM sinks without being stringified in the process.\n    if (l === 1 && strings[0] === '' && strings[1] === '') {\n      const v = parts[0].value;\n      if (typeof v === 'symbol') {\n        return String(v);\n      }\n      if (typeof v === 'string' || !isIterable(v)) {\n        return v;\n      }\n    }\n    let text = '';\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = parts[i];\n      if (part !== undefined) {\n        const v = part.value;\n        if (isPrimitive(v) || !isIterable(v)) {\n          text += typeof v === 'string' ? v : String(v);\n        } else {\n          for (const t of v) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        }\n      }\n    }\n    text += strings[l];\n    return text;\n  }\n  commit() {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue());\n    }\n  }\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\nclass AttributePart {\n  constructor(committer) {\n    this.value = undefined;\n    this.committer = committer;\n  }\n  setValue(value) {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      this.value = value;\n      // If the value is a not a directive, dirty the committer so that it'll\n      // call setAttribute. If the value is a directive, it'll dirty the\n      // committer if it calls setValue().\n      if (!isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n  commit() {\n    while (isDirective(this.value)) {\n      const directive = this.value;\n      this.value = noChange;\n      directive(this);\n    }\n    if (this.value === noChange) {\n      return;\n    }\n    this.committer.commit();\n  }\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nclass NodePart {\n  constructor(options) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.options = options;\n  }\n  /**\n   * Appends this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendInto(container) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n  /**\n   * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n   * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n   * such as those that appear in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterNode(ref) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling;\n  }\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendIntoPart(part) {\n    part.__insert((this.startNode = createMarker()));\n    part.__insert((this.endNode = createMarker()));\n  }\n  /**\n   * Inserts this part after the `ref` part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterPart(ref) {\n    ref.__insert((this.startNode = createMarker()));\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    if (this.startNode.parentNode === null) {\n      return;\n    }\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    const value = this.__pendingValue;\n    if (value === noChange) {\n      return;\n    }\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this.__commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this.__commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this.__commitNode(value);\n    } else if (isIterable(value)) {\n      this.__commitIterable(value);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this.__commitText(value);\n    }\n  }\n  __insert(node) {\n    this.endNode.parentNode.insertBefore(node, this.endNode);\n  }\n  __commitNode(value) {\n    if (this.value === value) {\n      return;\n    }\n    this.clear();\n    this.__insert(value);\n    this.value = value;\n  }\n  __commitText(value) {\n    const node = this.startNode.nextSibling;\n    value = value == null ? '' : value;\n    // If `value` isn't already a string, we explicitly convert it here in case\n    // it can't be implicitly converted - i.e. it's a symbol.\n    const valueAsString = typeof value === 'string' ? value : String(value);\n    if (\n      node === this.endNode.previousSibling &&\n      node.nodeType === 3 /* Node.TEXT_NODE */\n    ) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if this.value is primitive?\n      node.data = valueAsString;\n    } else {\n      this.__commitNode(document.createTextNode(valueAsString));\n    }\n    this.value = value;\n  }\n  __commitTemplateResult(value) {\n    const template = this.options.templateFactory(value);\n    if (\n      this.value instanceof TemplateInstance &&\n      this.value.template === template\n    ) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance = new TemplateInstance(\n        template,\n        value.processor,\n        this.options,\n      );\n      const fragment = instance._clone();\n      instance.update(value.values);\n      this.__commitNode(fragment);\n      this.value = instance;\n    }\n  }\n  __commitIterable(value) {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    }\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this.value;\n    let partIndex = 0;\n    let itemPart;\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex];\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart.endNode);\n    }\n  }\n  clear(startNode = this.startNode) {\n    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n  }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nclass BooleanAttributePart {\n  constructor(element, name, strings) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error(\n        'Boolean attributes can only contain a single expression',\n      );\n    }\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n    const value = !!this.__pendingValue;\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n      this.value = value;\n    }\n    this.__pendingValue = noChange;\n  }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nclass PropertyCommitter extends AttributeCommitter {\n  constructor(element, name, strings) {\n    super(element, name, strings);\n    this.single =\n      strings.length === 2 && strings[0] === '' && strings[1] === '';\n  }\n  _createPart() {\n    return new PropertyPart(this);\n  }\n  _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n    return super._getValue();\n  }\n  commit() {\n    if (this.dirty) {\n      this.dirty = false;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.element[this.name] = this._getValue();\n    }\n  }\n}\nclass PropertyPart extends AttributePart {}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n(() => {\n  try {\n    const options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      },\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.addEventListener('test', options, options);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.removeEventListener('test', options, options);\n  } catch (_e) {\n    // event options not supported\n  }\n})();\nclass EventPart {\n  constructor(element, eventName, eventContext) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n    this.__boundHandleEvent = (e) => this.handleEvent(e);\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n    const newListener = this.__pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener =\n      newListener == null ||\n      (oldListener != null &&\n        (newListener.capture !== oldListener.capture ||\n          newListener.once !== oldListener.once ||\n          newListener.passive !== oldListener.passive));\n    const shouldAddListener =\n      newListener != null && (oldListener == null || shouldRemoveListener);\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.eventName,\n        this.__boundHandleEvent,\n        this.__options,\n      );\n    }\n    if (shouldAddListener) {\n      this.__options = getOptions(newListener);\n      this.element.addEventListener(\n        this.eventName,\n        this.__boundHandleEvent,\n        this.__options,\n      );\n    }\n    this.value = newListener;\n    this.__pendingValue = noChange;\n  }\n  handleEvent(event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      this.value.handleEvent(event);\n    }\n  }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) =>\n  o &&\n  (eventOptionsSupported\n    ? { capture: o.capture, passive: o.passive, once: o.once }\n    : o.capture);\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nfunction templateFactory(result) {\n  let templateCache = templateCaches.get(result.type);\n  if (templateCache === undefined) {\n    templateCache = {\n      stringsArray: new WeakMap(),\n      keyString: new Map(),\n    };\n    templateCaches.set(result.type, templateCache);\n  }\n  let template = templateCache.stringsArray.get(result.strings);\n  if (template !== undefined) {\n    return template;\n  }\n  // If the TemplateStringsArray is new, generate a key from the strings\n  // This key is shared between all templates with identical content\n  const key = result.strings.join(marker);\n  // Check if we already have a Template for this key\n  template = templateCache.keyString.get(key);\n  if (template === undefined) {\n    // If we have not seen this key before, create a new Template\n    template = new Template(result, result.getTemplateElement());\n    // Cache the Template for this key\n    templateCache.keyString.set(key, template);\n  }\n  // Cache all future queries for this TemplateStringsArray\n  templateCache.stringsArray.set(result.strings, template);\n  return template;\n}\nconst templateCaches = new Map();\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst parts = new WeakMap();\n/**\n * Renders a template result or other value to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result Any value renderable by NodePart - typically a TemplateResult\n *     created by evaluating a template tag like `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nconst render$1 = (result, container, options) => {\n  let part = parts.get(container);\n  if (part === undefined) {\n    removeNodes(container, container.firstChild);\n    parts.set(\n      container,\n      (part = new NodePart(Object.assign({ templateFactory }, options))),\n    );\n    part.appendInto(container);\n  }\n  part.setValue(result);\n  part.commit();\n};\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * Creates Parts when a template is instantiated.\n */\nclass DefaultTemplateProcessor {\n  /**\n   * Create parts for an attribute-position binding, given the event, attribute\n   * name, and string literals.\n   *\n   * @param element The element containing the binding\n   * @param name  The attribute name\n   * @param strings The string literals. There are always at least two strings,\n   *   event for fully-controlled bindings with a single expression.\n   */\n  handleAttributeExpressions(element, name, strings, options) {\n    const prefix = name[0];\n    if (prefix === '.') {\n      const committer = new PropertyCommitter(element, name.slice(1), strings);\n      return committer.parts;\n    }\n    if (prefix === '@') {\n      return [new EventPart(element, name.slice(1), options.eventContext)];\n    }\n    if (prefix === '?') {\n      return [new BooleanAttributePart(element, name.slice(1), strings)];\n    }\n    const committer = new AttributeCommitter(element, name, strings);\n    return committer.parts;\n  }\n  /**\n   * Create parts for a text-position binding.\n   * @param templateFactory\n   */\n  handleTextExpression(options) {\n    return new NodePart(options);\n  }\n}\nconst defaultTemplateProcessor = new DefaultTemplateProcessor();\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\nif (typeof window !== 'undefined') {\n  (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');\n}\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nconst html = (strings, ...values) =>\n  new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\nlet compatibleShadyCSSVersion = true;\nif (typeof window.ShadyCSS === 'undefined') {\n  compatibleShadyCSSVersion = false;\n} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n  console.warn(\n    `Incompatible ShadyCSS version detected. ` +\n      `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +\n      `@webcomponents/shadycss@1.3.1.`,\n  );\n  compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName) => (result) => {\n  const cacheKey = getTemplateCacheKey(result.type, scopeName);\n  let templateCache = templateCaches.get(cacheKey);\n  if (templateCache === undefined) {\n    templateCache = {\n      stringsArray: new WeakMap(),\n      keyString: new Map(),\n    };\n    templateCaches.set(cacheKey, templateCache);\n  }\n  let template = templateCache.stringsArray.get(result.strings);\n  if (template !== undefined) {\n    return template;\n  }\n  const key = result.strings.join(marker);\n  template = templateCache.keyString.get(key);\n  if (template === undefined) {\n    const element = result.getTemplateElement();\n    if (compatibleShadyCSSVersion) {\n      window.ShadyCSS.prepareTemplateDom(element, scopeName);\n    }\n    template = new Template(result, element);\n    templateCache.keyString.set(key, template);\n  }\n  templateCache.stringsArray.set(result.strings, template);\n  return template;\n};\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName) => {\n  TEMPLATE_TYPES.forEach((type) => {\n    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n    if (templates !== undefined) {\n      templates.keyString.forEach((template) => {\n        const {\n          element: { content },\n        } = template;\n        // IE 11 doesn't support the iterable param Set constructor\n        const styles = new Set();\n        Array.from(content.querySelectorAll('style')).forEach((s) => {\n          styles.add(s);\n        });\n        removeNodesFromTemplate(template, styles);\n      });\n    }\n  });\n};\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles = (scopeName, renderedDOM, template) => {\n  shadyRenderSet.add(scopeName);\n  // If `renderedDOM` is stamped from a Template, then we need to edit that\n  // Template's underlying template element. Otherwise, we create one here\n  // to give to ShadyCSS, which still requires one while scoping.\n  const templateElement = !!template\n    ? template.element\n    : document.createElement('template');\n  // Move styles out of rendered DOM and store.\n  const styles = renderedDOM.querySelectorAll('style');\n  const { length } = styles;\n  // If there are no styles, skip unnecessary work\n  if (length === 0) {\n    // Ensure prepareTemplateStyles is called to support adding\n    // styles via `prepareAdoptedCssText` since that requires that\n    // `prepareTemplateStyles` is called.\n    //\n    // ShadyCSS will only update styles containing @apply in the template\n    // given to `prepareTemplateStyles`. If no lit Template was given,\n    // ShadyCSS will not be able to update uses of @apply in any relevant\n    // template. However, this is not a problem because we only create the\n    // template for the purpose of supporting `prepareAdoptedCssText`,\n    // which doesn't support @apply at all.\n    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n    return;\n  }\n  const condensedStyle = document.createElement('style');\n  // Collect styles into a single style. This helps us make sure ShadyCSS\n  // manipulations will not prevent us from being able to fix up template\n  // part indices.\n  // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n  // currently does this anyway. When it does not, this should be changed.\n  for (let i = 0; i < length; i++) {\n    const style = styles[i];\n    style.parentNode.removeChild(style);\n    condensedStyle.textContent += style.textContent;\n  }\n  // Remove styles from nested templates in this scope.\n  removeStylesFromLitTemplates(scopeName);\n  // And then put the condensed style into the \"root\" template passed in as\n  // `template`.\n  const content = templateElement.content;\n  if (!!template) {\n    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n  } else {\n    content.insertBefore(condensedStyle, content.firstChild);\n  }\n  // Note, it's important that ShadyCSS gets the template that `lit-html`\n  // will actually render so that it can update the style inside when\n  // needed (e.g. @apply native Shadow DOM case).\n  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n  const style = content.querySelector('style');\n  if (window.ShadyCSS.nativeShadow && style !== null) {\n    // When in native Shadow DOM, ensure the style created by ShadyCSS is\n    // included in initially rendered output (`renderedDOM`).\n    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n  } else if (!!template) {\n    // When no style is left in the template, parts will be broken as a\n    // result. To fix this, we put back the style node ShadyCSS removed\n    // and then tell lit to remove that node from the template.\n    // There can be no style in the template in 2 cases (1) when Shady DOM\n    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n    // is in use ShadyCSS removes the style if it contains no content.\n    // NOTE, ShadyCSS creates its own style so we can safely add/remove\n    // `condensedStyle` here.\n    content.insertBefore(condensedStyle, content.firstChild);\n    const removes = new Set();\n    removes.add(condensedStyle);\n    removeNodesFromTemplate(template, removes);\n  }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nconst render = (result, container, options) => {\n  if (!options || typeof options !== 'object' || !options.scopeName) {\n    throw new Error('The `scopeName` option is required.');\n  }\n  const scopeName = options.scopeName;\n  const hasRendered = parts.has(container);\n  const needsScoping =\n    compatibleShadyCSSVersion &&\n    container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&\n    !!container.host;\n  // Handle first render to a scope specially...\n  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n  // On first scope render, render into a fragment; this cannot be a single\n  // fragment that is reused since nested renders can occur synchronously.\n  const renderContainer = firstScopeRender\n    ? document.createDocumentFragment()\n    : container;\n  render$1(\n    result,\n    renderContainer,\n    Object.assign(\n      { templateFactory: shadyTemplateFactory(scopeName) },\n      options,\n    ),\n  );\n  // When performing first scope render,\n  // (1) We've rendered into a fragment so that there's a chance to\n  // `prepareTemplateStyles` before sub-elements hit the DOM\n  // (which might cause them to render based on a common pattern of\n  // rendering in a custom element's `connectedCallback`);\n  // (2) Scope the template with ShadyCSS one time only for this scope.\n  // (3) Render the fragment into the container and make sure the\n  // container knows its `part` is the one we just rendered. This ensures\n  // DOM will be re-used on subsequent renders.\n  if (firstScopeRender) {\n    const part = parts.get(renderContainer);\n    parts.delete(renderContainer);\n    // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n    // that should apply to `renderContainer` even if the rendered value is\n    // not a TemplateInstance. However, it will only insert scoped styles\n    // into the document if `prepareTemplateStyles` has already been called\n    // for the given scope name.\n    const template =\n      part.value instanceof TemplateInstance ? part.value.template : undefined;\n    prepareTemplateStyles(scopeName, renderContainer, template);\n    removeNodes(container, container.firstChild);\n    container.appendChild(renderContainer);\n    parts.set(container, part);\n  }\n  // After elements have hit the DOM, update styling if this is the\n  // initial render to this container.\n  // This is needed whenever dynamic changes are made so it would be\n  // safest to do every render; however, this would regress performance\n  // so we leave it up to the user to call `ShadyCSS.styleElement`\n  // for dynamic changes.\n  if (!hasRendered && needsScoping) {\n    window.ShadyCSS.styleElement(container.host);\n  }\n};\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nvar _a$c;\n/**\n * Use this module if you want to create your own base class extending\n * [[UpdatingElement]].\n * @packageDocumentation\n */\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\nwindow.JSCompiler_renameProperty = (prop, _obj) => prop;\nconst defaultConverter = {\n  toAttribute(value, type) {\n    switch (type) {\n      case Boolean:\n        return value ? '' : null;\n      case Object:\n      case Array:\n        // if the value is `null` or `undefined` pass this through\n        // to allow removing/no change behavior.\n        return value == null ? value : JSON.stringify(value);\n    }\n    return value;\n  },\n  fromAttribute(value, type) {\n    switch (type) {\n      case Boolean:\n        return value !== null;\n      case Number:\n        return value === null ? null : Number(value);\n      case Object:\n      case Array:\n        // Type assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n        return JSON.parse(value);\n    }\n    return value;\n  },\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nconst notEqual = (value, old) => {\n  // This ensures (old==NaN, value==NaN) always returns false\n  return old !== value && (old === old || value === value);\n};\nconst defaultPropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual,\n};\nconst STATE_HAS_UPDATED = 1;\nconst STATE_UPDATE_REQUESTED = 1 << 2;\nconst STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;\nconst STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;\n/**\n * The Closure JS Compiler doesn't currently have good support for static\n * property semantics where \"this\" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */\nconst finalized = 'finalized';\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n * @noInheritDoc\n */\nclass UpdatingElement extends HTMLElement {\n  constructor() {\n    super();\n    this.initialize();\n  }\n  /**\n   * Returns a list of attributes corresponding to the registered properties.\n   * @nocollapse\n   */\n  static get observedAttributes() {\n    // note: piggy backing on this to ensure we're finalized.\n    this.finalize();\n    const attributes = [];\n    // Use forEach so this works even if for/of loops are compiled to for loops\n    // expecting arrays\n    this._classProperties.forEach((v, p) => {\n      const attr = this._attributeNameForProperty(p, v);\n      if (attr !== undefined) {\n        this._attributeToPropertyMap.set(attr, p);\n        attributes.push(attr);\n      }\n    });\n    return attributes;\n  }\n  /**\n   * Ensures the private `_classProperties` property metadata is created.\n   * In addition to `finalize` this is also called in `createProperty` to\n   * ensure the `@property` decorator can add property metadata.\n   */\n  /** @nocollapse */\n  static _ensureClassProperties() {\n    // ensure private storage for property declarations.\n    if (\n      !this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))\n    ) {\n      this._classProperties = new Map();\n      // NOTE: Workaround IE11 not supporting Map constructor argument.\n      const superProperties = Object.getPrototypeOf(this)._classProperties;\n      if (superProperties !== undefined) {\n        superProperties.forEach((v, k) => this._classProperties.set(k, v));\n      }\n    }\n  }\n  /**\n   * Creates a property accessor on the element prototype if one does not exist\n   * and stores a PropertyDeclaration for the property with the given options.\n   * The property setter calls the property's `hasChanged` property option\n   * or uses a strict identity check to determine whether or not to request\n   * an update.\n   *\n   * This method may be overridden to customize properties; however,\n   * when doing so, it's important to call `super.createProperty` to ensure\n   * the property is setup correctly. This method calls\n   * `getPropertyDescriptor` internally to get a descriptor to install.\n   * To customize what properties do when they are get or set, override\n   * `getPropertyDescriptor`. To customize the options for a property,\n   * implement `createProperty` like this:\n   *\n   * static createProperty(name, options) {\n   *   options = Object.assign(options, {myOption: true});\n   *   super.createProperty(name, options);\n   * }\n   *\n   * @nocollapse\n   */\n  static createProperty(name, options = defaultPropertyDeclaration) {\n    // Note, since this can be called by the `@property` decorator which\n    // is called before `finalize`, we ensure storage exists for property\n    // metadata.\n    this._ensureClassProperties();\n    this._classProperties.set(name, options);\n    // Do not generate an accessor if the prototype already has one, since\n    // it would be lost otherwise and that would never be the user's intention;\n    // Instead, we expect users to call `requestUpdate` themselves from\n    // user-defined accessors. Note that if the super has an accessor we will\n    // still overwrite it\n    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {\n      return;\n    }\n    const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n    const descriptor = this.getPropertyDescriptor(name, key, options);\n    if (descriptor !== undefined) {\n      Object.defineProperty(this.prototype, name, descriptor);\n    }\n  }\n  /**\n   * Returns a property descriptor to be defined on the given named property.\n   * If no descriptor is returned, the property will not become an accessor.\n   * For example,\n   *\n   *   class MyElement extends LitElement {\n   *     static getPropertyDescriptor(name, key, options) {\n   *       const defaultDescriptor =\n   *           super.getPropertyDescriptor(name, key, options);\n   *       const setter = defaultDescriptor.set;\n   *       return {\n   *         get: defaultDescriptor.get,\n   *         set(value) {\n   *           setter.call(this, value);\n   *           // custom action.\n   *         },\n   *         configurable: true,\n   *         enumerable: true\n   *       }\n   *     }\n   *   }\n   *\n   * @nocollapse\n   */\n  static getPropertyDescriptor(name, key, options) {\n    return {\n      // tslint:disable-next-line:no-any no symbol in index\n      get() {\n        return this[key];\n      },\n      set(value) {\n        const oldValue = this[name];\n        this[key] = value;\n        this.requestUpdateInternal(name, oldValue, options);\n      },\n      configurable: true,\n      enumerable: true,\n    };\n  }\n  /**\n   * Returns the property options associated with the given property.\n   * These options are defined with a PropertyDeclaration via the `properties`\n   * object or the `@property` decorator and are registered in\n   * `createProperty(...)`.\n   *\n   * Note, this method should be considered \"final\" and not overridden. To\n   * customize the options for a given property, override `createProperty`.\n   *\n   * @nocollapse\n   * @final\n   */\n  static getPropertyOptions(name) {\n    return (\n      (this._classProperties && this._classProperties.get(name)) ||\n      defaultPropertyDeclaration\n    );\n  }\n  /**\n   * Creates property accessors for registered properties and ensures\n   * any superclasses are also finalized.\n   * @nocollapse\n   */\n  static finalize() {\n    // finalize any superclasses\n    const superCtor = Object.getPrototypeOf(this);\n    if (!superCtor.hasOwnProperty(finalized)) {\n      superCtor.finalize();\n    }\n    this[finalized] = true;\n    this._ensureClassProperties();\n    // initialize Map populated in observedAttributes\n    this._attributeToPropertyMap = new Map();\n    // make any properties\n    // Note, only process \"own\" properties since this element will inherit\n    // any properties defined on the superClass, and finalization ensures\n    // the entire prototype chain is finalized.\n    if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n      const props = this.properties;\n      // support symbols in properties (IE11 does not support this)\n      const propKeys = [\n        ...Object.getOwnPropertyNames(props),\n        ...(typeof Object.getOwnPropertySymbols === 'function'\n          ? Object.getOwnPropertySymbols(props)\n          : []),\n      ];\n      // This for/of is ok because propKeys is an array\n      for (const p of propKeys) {\n        // note, use of `any` is due to TypeSript lack of support for symbol in\n        // index types\n        // tslint:disable-next-line:no-any no symbol in index\n        this.createProperty(p, props[p]);\n      }\n    }\n  }\n  /**\n   * Returns the property name for the given attribute `name`.\n   * @nocollapse\n   */\n  static _attributeNameForProperty(name, options) {\n    const attribute = options.attribute;\n    return attribute === false\n      ? undefined\n      : typeof attribute === 'string'\n      ? attribute\n      : typeof name === 'string'\n      ? name.toLowerCase()\n      : undefined;\n  }\n  /**\n   * Returns true if a property should request an update.\n   * Called when a property value is set and uses the `hasChanged`\n   * option for the property if present or a strict identity check.\n   * @nocollapse\n   */\n  static _valueHasChanged(value, old, hasChanged = notEqual) {\n    return hasChanged(value, old);\n  }\n  /**\n   * Returns the property value for the given attribute value.\n   * Called via the `attributeChangedCallback` and uses the property's\n   * `converter` or `converter.fromAttribute` property option.\n   * @nocollapse\n   */\n  static _propertyValueFromAttribute(value, options) {\n    const type = options.type;\n    const converter = options.converter || defaultConverter;\n    const fromAttribute =\n      typeof converter === 'function' ? converter : converter.fromAttribute;\n    return fromAttribute ? fromAttribute(value, type) : value;\n  }\n  /**\n   * Returns the attribute value for the given property value. If this\n   * returns undefined, the property will *not* be reflected to an attribute.\n   * If this returns null, the attribute will be removed, otherwise the\n   * attribute will be set to the value.\n   * This uses the property's `reflect` and `type.toAttribute` property options.\n   * @nocollapse\n   */\n  static _propertyValueToAttribute(value, options) {\n    if (options.reflect === undefined) {\n      return;\n    }\n    const type = options.type;\n    const converter = options.converter;\n    const toAttribute =\n      (converter && converter.toAttribute) || defaultConverter.toAttribute;\n    return toAttribute(value, type);\n  }\n  /**\n   * Performs element initialization. By default captures any pre-set values for\n   * registered properties.\n   */\n  initialize() {\n    this._updateState = 0;\n    this._updatePromise = new Promise(\n      (res) => (this._enableUpdatingResolver = res),\n    );\n    this._changedProperties = new Map();\n    this._saveInstanceProperties();\n    // ensures first update will be caught by an early access of\n    // `updateComplete`\n    this.requestUpdateInternal();\n  }\n  /**\n   * Fixes any properties set on the instance before upgrade time.\n   * Otherwise these would shadow the accessor and break these properties.\n   * The properties are stored in a Map which is played back after the\n   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n   * (<=41), properties created for native platform properties like (`id` or\n   * `name`) may not have default values set in the element constructor. On\n   * these browsers native properties appear on instances and therefore their\n   * default value will overwrite any element default (e.g. if the element sets\n   * this.id = 'id' in the constructor, the 'id' will become '' since this is\n   * the native platform default).\n   */\n  _saveInstanceProperties() {\n    // Use forEach so this works even if for/of loops are compiled to for loops\n    // expecting arrays\n    this.constructor._classProperties.forEach((_v, p) => {\n      if (this.hasOwnProperty(p)) {\n        const value = this[p];\n        delete this[p];\n        if (!this._instanceProperties) {\n          this._instanceProperties = new Map();\n        }\n        this._instanceProperties.set(p, value);\n      }\n    });\n  }\n  /**\n   * Applies previously saved instance properties.\n   */\n  _applyInstanceProperties() {\n    // Use forEach so this works even if for/of loops are compiled to for loops\n    // expecting arrays\n    // tslint:disable-next-line:no-any\n    this._instanceProperties.forEach((v, p) => (this[p] = v));\n    this._instanceProperties = undefined;\n  }\n  connectedCallback() {\n    // Ensure first connection completes an update. Updates cannot complete\n    // before connection.\n    this.enableUpdating();\n  }\n  enableUpdating() {\n    if (this._enableUpdatingResolver !== undefined) {\n      this._enableUpdatingResolver();\n      this._enableUpdatingResolver = undefined;\n    }\n  }\n  /**\n   * Allows for `super.disconnectedCallback()` in extensions while\n   * reserving the possibility of making non-breaking feature additions\n   * when disconnecting at some point in the future.\n   */\n  disconnectedCallback() {}\n  /**\n   * Synchronizes property values when attributes change.\n   */\n  attributeChangedCallback(name, old, value) {\n    if (old !== value) {\n      this._attributeToProperty(name, value);\n    }\n  }\n  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\n    const ctor = this.constructor;\n    const attr = ctor._attributeNameForProperty(name, options);\n    if (attr !== undefined) {\n      const attrValue = ctor._propertyValueToAttribute(value, options);\n      // an undefined value does not change the attribute.\n      if (attrValue === undefined) {\n        return;\n      }\n      // Track if the property is being reflected to avoid\n      // setting the property again via `attributeChangedCallback`. Note:\n      // 1. this takes advantage of the fact that the callback is synchronous.\n      // 2. will behave incorrectly if multiple attributes are in the reaction\n      // stack at time of calling. However, since we process attributes\n      // in `update` this should not be possible (or an extreme corner case\n      // that we'd like to discover).\n      // mark state reflecting\n      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;\n      if (attrValue == null) {\n        this.removeAttribute(attr);\n      } else {\n        this.setAttribute(attr, attrValue);\n      }\n      // mark state not reflecting\n      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;\n    }\n  }\n  _attributeToProperty(name, value) {\n    // Use tracking info to avoid deserializing attribute value if it was\n    // just set from a property setter.\n    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {\n      return;\n    }\n    const ctor = this.constructor;\n    // Note, hint this as an `AttributeMap` so closure clearly understands\n    // the type; it has issues with tracking types through statics\n    // tslint:disable-next-line:no-unnecessary-type-assertion\n    const propName = ctor._attributeToPropertyMap.get(name);\n    if (propName !== undefined) {\n      const options = ctor.getPropertyOptions(propName);\n      // mark state reflecting\n      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;\n      this[propName] =\n        // tslint:disable-next-line:no-any\n        ctor._propertyValueFromAttribute(value, options);\n      // mark state not reflecting\n      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;\n    }\n  }\n  /**\n   * This protected version of `requestUpdate` does not access or return the\n   * `updateComplete` promise. This promise can be overridden and is therefore\n   * not free to access.\n   */\n  requestUpdateInternal(name, oldValue, options) {\n    let shouldRequestUpdate = true;\n    // If we have a property key, perform property update steps.\n    if (name !== undefined) {\n      const ctor = this.constructor;\n      options = options || ctor.getPropertyOptions(name);\n      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {\n        if (!this._changedProperties.has(name)) {\n          this._changedProperties.set(name, oldValue);\n        }\n        // Add to reflecting properties set.\n        // Note, it's important that every change has a chance to add the\n        // property to `_reflectingProperties`. This ensures setting\n        // attribute + property reflects correctly.\n        if (\n          options.reflect === true &&\n          !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)\n        ) {\n          if (this._reflectingProperties === undefined) {\n            this._reflectingProperties = new Map();\n          }\n          this._reflectingProperties.set(name, options);\n        }\n      } else {\n        // Abort the request if the property should not be considered changed.\n        shouldRequestUpdate = false;\n      }\n    }\n    if (!this._hasRequestedUpdate && shouldRequestUpdate) {\n      this._updatePromise = this._enqueueUpdate();\n    }\n  }\n  /**\n   * Requests an update which is processed asynchronously. This should\n   * be called when an element should update based on some state not triggered\n   * by setting a property. In this case, pass no arguments. It should also be\n   * called when manually implementing a property setter. In this case, pass the\n   * property `name` and `oldValue` to ensure that any configured property\n   * options are honored. Returns the `updateComplete` Promise which is resolved\n   * when the update completes.\n   *\n   * @param name {PropertyKey} (optional) name of requesting property\n   * @param oldValue {any} (optional) old value of requesting property\n   * @returns {Promise} A Promise that is resolved when the update completes.\n   */\n  requestUpdate(name, oldValue) {\n    this.requestUpdateInternal(name, oldValue);\n    return this.updateComplete;\n  }\n  /**\n   * Sets up the element to asynchronously update.\n   */\n  async _enqueueUpdate() {\n    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;\n    try {\n      // Ensure any previous update has resolved before updating.\n      // This `await` also ensures that property changes are batched.\n      await this._updatePromise;\n    } catch (e) {\n      // Ignore any previous errors. We only care that the previous cycle is\n      // done. Any error should have been handled in the previous update.\n    }\n    const result = this.performUpdate();\n    // If `performUpdate` returns a Promise, we await it. This is done to\n    // enable coordinating updates with a scheduler. Note, the result is\n    // checked to avoid delaying an additional microtask unless we need to.\n    if (result != null) {\n      await result;\n    }\n    return !this._hasRequestedUpdate;\n  }\n  get _hasRequestedUpdate() {\n    return this._updateState & STATE_UPDATE_REQUESTED;\n  }\n  get hasUpdated() {\n    return this._updateState & STATE_HAS_UPDATED;\n  }\n  /**\n   * Performs an element update. Note, if an exception is thrown during the\n   * update, `firstUpdated` and `updated` will not be called.\n   *\n   * You can override this method to change the timing of updates. If this\n   * method is overridden, `super.performUpdate()` must be called.\n   *\n   * For instance, to schedule updates to occur just before the next frame:\n   *\n   * ```\n   * protected async performUpdate(): Promise<unknown> {\n   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n   *   super.performUpdate();\n   * }\n   * ```\n   */\n  performUpdate() {\n    // Abort any update if one is not pending when this is called.\n    // This can happen if `performUpdate` is called early to \"flush\"\n    // the update.\n    if (!this._hasRequestedUpdate) {\n      return;\n    }\n    // Mixin instance properties once, if they exist.\n    if (this._instanceProperties) {\n      this._applyInstanceProperties();\n    }\n    let shouldUpdate = false;\n    const changedProperties = this._changedProperties;\n    try {\n      shouldUpdate = this.shouldUpdate(changedProperties);\n      if (shouldUpdate) {\n        this.update(changedProperties);\n      } else {\n        this._markUpdated();\n      }\n    } catch (e) {\n      // Prevent `firstUpdated` and `updated` from running when there's an\n      // update exception.\n      shouldUpdate = false;\n      // Ensure element can accept additional updates after an exception.\n      this._markUpdated();\n      throw e;\n    }\n    if (shouldUpdate) {\n      if (!(this._updateState & STATE_HAS_UPDATED)) {\n        this._updateState = this._updateState | STATE_HAS_UPDATED;\n        this.firstUpdated(changedProperties);\n      }\n      this.updated(changedProperties);\n    }\n  }\n  _markUpdated() {\n    this._changedProperties = new Map();\n    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;\n  }\n  /**\n   * Returns a Promise that resolves when the element has completed updating.\n   * The Promise value is a boolean that is `true` if the element completed the\n   * update without triggering another update. The Promise result is `false` if\n   * a property was set inside `updated()`. If the Promise is rejected, an\n   * exception was thrown during the update.\n   *\n   * To await additional asynchronous work, override the `_getUpdateComplete`\n   * method. For example, it is sometimes useful to await a rendered element\n   * before fulfilling this Promise. To do this, first await\n   * `super._getUpdateComplete()`, then any subsequent state.\n   *\n   * @returns {Promise} The Promise returns a boolean that indicates if the\n   * update resolved without triggering another update.\n   */\n  get updateComplete() {\n    return this._getUpdateComplete();\n  }\n  /**\n   * Override point for the `updateComplete` promise.\n   *\n   * It is not safe to override the `updateComplete` getter directly due to a\n   * limitation in TypeScript which means it is not possible to call a\n   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n   * This method should be overridden instead. For example:\n   *\n   *   class MyElement extends LitElement {\n   *     async _getUpdateComplete() {\n   *       await super._getUpdateComplete();\n   *       await this._myChild.updateComplete;\n   *     }\n   *   }\n   * @deprecated Override `getUpdateComplete()` instead for forward\n   *     compatibility with `lit-element` 3.0 / `@lit/reactive-element`.\n   */\n  _getUpdateComplete() {\n    return this.getUpdateComplete();\n  }\n  /**\n   * Override point for the `updateComplete` promise.\n   *\n   * It is not safe to override the `updateComplete` getter directly due to a\n   * limitation in TypeScript which means it is not possible to call a\n   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n   * This method should be overridden instead. For example:\n   *\n   *   class MyElement extends LitElement {\n   *     async getUpdateComplete() {\n   *       await super.getUpdateComplete();\n   *       await this._myChild.updateComplete;\n   *     }\n   *   }\n   */\n  getUpdateComplete() {\n    return this._updatePromise;\n  }\n  /**\n   * Controls whether or not `update` should be called when the element requests\n   * an update. By default, this method always returns `true`, but this can be\n   * customized to control when to update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   */\n  shouldUpdate(_changedProperties) {\n    return true;\n  }\n  /**\n   * Updates the element. This method reflects property values to attributes.\n   * It can be overridden to render and keep updated element DOM.\n   * Setting properties inside this method will *not* trigger\n   * another update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   */\n  update(_changedProperties) {\n    if (\n      this._reflectingProperties !== undefined &&\n      this._reflectingProperties.size > 0\n    ) {\n      // Use forEach so this works even if for/of loops are compiled to for\n      // loops expecting arrays\n      this._reflectingProperties.forEach((v, k) =>\n        this._propertyToAttribute(k, this[k], v),\n      );\n      this._reflectingProperties = undefined;\n    }\n    this._markUpdated();\n  }\n  /**\n   * Invoked whenever the element is updated. Implement to perform\n   * post-updating tasks via DOM APIs, for example, focusing an element.\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   */\n  updated(_changedProperties) {}\n  /**\n   * Invoked when the element is first updated. Implement to perform one time\n   * work on the element after update.\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   */\n  firstUpdated(_changedProperties) {}\n}\n_a$c = finalized;\n/**\n * Marks class as having finished creating properties.\n */\nUpdatingElement[_a$c] = true;\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst standardProperty = (options, element) => {\n  // When decorating an accessor, pass it through and add property metadata.\n  // Note, the `hasOwnProperty` check in `createProperty` ensures we don't\n  // stomp over the user's accessor.\n  if (\n    element.kind === 'method' &&\n    element.descriptor &&\n    !('value' in element.descriptor)\n  ) {\n    return Object.assign(Object.assign({}, element), {\n      finisher(clazz) {\n        clazz.createProperty(element.key, options);\n      },\n    });\n  } else {\n    // createProperty() takes care of defining the property, but we still\n    // must return some kind of descriptor, so return a descriptor for an\n    // unused prototype field. The finisher calls createProperty().\n    return {\n      kind: 'field',\n      key: Symbol(),\n      placement: 'own',\n      descriptor: {},\n      // When @babel/plugin-proposal-decorators implements initializers,\n      // do this instead of the initializer below. See:\n      // https://github.com/babel/babel/issues/9260 extras: [\n      //   {\n      //     kind: 'initializer',\n      //     placement: 'own',\n      //     initializer: descriptor.initializer,\n      //   }\n      // ],\n      initializer() {\n        if (typeof element.initializer === 'function') {\n          this[element.key] = element.initializer.call(this);\n        }\n      },\n      finisher(clazz) {\n        clazz.createProperty(element.key, options);\n      },\n    };\n  }\n};\nconst legacyProperty = (options, proto, name) => {\n  proto.constructor.createProperty(name, options);\n};\n/**\n * A property decorator which creates a LitElement property which reflects a\n * corresponding attribute value. A [[`PropertyDeclaration`]] may optionally be\n * supplied to configure property features.\n *\n * This decorator should only be used for public fields. Private or protected\n * fields should use the [[`internalProperty`]] decorator.\n *\n * @example\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nfunction property(options) {\n  // tslint:disable-next-line:no-any decorator\n  return (protoOrDescriptor, name) =>\n    name !== undefined\n      ? legacyProperty(options, protoOrDescriptor, name)\n      : standardProperty(options, protoOrDescriptor);\n}\n\n/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n/**\n * Whether the current browser supports `adoptedStyleSheets`.\n */\nconst supportsAdoptingStyleSheets =\n  window.ShadowRoot &&\n  (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&\n  'adoptedStyleSheets' in Document.prototype &&\n  'replace' in CSSStyleSheet.prototype;\nconst constructionToken = Symbol();\nclass CSSResult {\n  constructor(cssText, safeToken) {\n    if (safeToken !== constructionToken) {\n      throw new Error(\n        'CSSResult is not constructable. Use `unsafeCSS` or `css` instead.',\n      );\n    }\n    this.cssText = cssText;\n  }\n  // Note, this is a getter so that it's lazy. In practice, this means\n  // stylesheets are not created until the first element instance is made.\n  get styleSheet() {\n    if (this._styleSheet === undefined) {\n      // Note, if `supportsAdoptingStyleSheets` is true then we assume\n      // CSSStyleSheet is constructable.\n      if (supportsAdoptingStyleSheets) {\n        this._styleSheet = new CSSStyleSheet();\n        this._styleSheet.replaceSync(this.cssText);\n      } else {\n        this._styleSheet = null;\n      }\n    }\n    return this._styleSheet;\n  }\n  toString() {\n    return this.cssText;\n  }\n}\n/**\n * Wrap a value for interpolation in a [[`css`]] tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\nconst unsafeCSS = (value) => {\n  return new CSSResult(String(value), constructionToken);\n};\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n(window['litElementVersions'] || (window['litElementVersions'] = [])).push(\n  '2.5.1',\n);\n/**\n * Sentinal value used to avoid calling lit-html's render function when\n * subclasses do not implement `render`\n */\nconst renderNotImplemented = {};\n/**\n * Base element class that manages element properties and attributes, and\n * renders a lit-html template.\n *\n * To define a component, subclass `LitElement` and implement a\n * `render` method to provide the component's template. Define properties\n * using the [[`properties`]] property or the [[`property`]] decorator.\n */\nclass LitElement extends UpdatingElement {\n  /**\n   * Return the array of styles to apply to the element.\n   * Override this method to integrate into a style management system.\n   *\n   * @nocollapse\n   */\n  static getStyles() {\n    return this.styles;\n  }\n  /** @nocollapse */\n  static _getUniqueStyles() {\n    // Only gather styles once per class\n    if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {\n      return;\n    }\n    // Take care not to call `this.getStyles()` multiple times since this\n    // generates new CSSResults each time.\n    // TODO(sorvell): Since we do not cache CSSResults by input, any\n    // shared styles will generate new stylesheet objects, which is wasteful.\n    // This should be addressed when a browser ships constructable\n    // stylesheets.\n    const userStyles = this.getStyles();\n    if (Array.isArray(userStyles)) {\n      // De-duplicate styles preserving the _last_ instance in the set.\n      // This is a performance optimization to avoid duplicated styles that can\n      // occur especially when composing via subclassing.\n      // The last item is kept to try to preserve the cascade order with the\n      // assumption that it's most important that last added styles override\n      // previous styles.\n      const addStyles = (styles, set) =>\n        styles.reduceRight(\n          (set, s) =>\n            // Note: On IE set.add() does not return the set\n            Array.isArray(s) ? addStyles(s, set) : (set.add(s), set),\n          set,\n        );\n      // Array.from does not work on Set in IE, otherwise return\n      // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()\n      const set = addStyles(userStyles, new Set());\n      const styles = [];\n      set.forEach((v) => styles.unshift(v));\n      this._styles = styles;\n    } else {\n      this._styles = userStyles === undefined ? [] : [userStyles];\n    }\n    // Ensure that there are no invalid CSSStyleSheet instances here. They are\n    // invalid in two conditions.\n    // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but\n    //     this is impossible to check except via .replaceSync or use\n    // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is\n    //     false)\n    this._styles = this._styles.map((s) => {\n      if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {\n        // Flatten the cssText from the passed constructible stylesheet (or\n        // undetectable non-constructible stylesheet). The user might have\n        // expected to update their stylesheets over time, but the alternative\n        // is a crash.\n        const cssText = Array.prototype.slice\n          .call(s.cssRules)\n          .reduce((css, rule) => css + rule.cssText, '');\n        return unsafeCSS(cssText);\n      }\n      return s;\n    });\n  }\n  /**\n   * Performs element initialization. By default this calls\n   * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and\n   * captures any pre-set values for registered properties.\n   */\n  initialize() {\n    super.initialize();\n    this.constructor._getUniqueStyles();\n    this.renderRoot = this.createRenderRoot();\n    // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\n    // element's getRootNode(). While this could be done, we're choosing not to\n    // support this now since it would require different logic around de-duping.\n    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\n      this.adoptStyles();\n    }\n  }\n  /**\n   * Returns the node into which the element should render and by default\n   * creates and returns an open shadowRoot. Implement to customize where the\n   * element's DOM is rendered. For example, to render into the element's\n   * childNodes, return `this`.\n   * @returns {Element|DocumentFragment} Returns a node into which to render.\n   */\n  createRenderRoot() {\n    return this.attachShadow(this.constructor.shadowRootOptions);\n  }\n  /**\n   * Applies styling to the element shadowRoot using the [[`styles`]]\n   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\n   * available and will fallback otherwise. When Shadow DOM is polyfilled,\n   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\n   * is available but `adoptedStyleSheets` is not, styles are appended to the\n   * end of the `shadowRoot` to [mimic spec\n   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n   */\n  adoptStyles() {\n    const styles = this.constructor._styles;\n    if (styles.length === 0) {\n      return;\n    }\n    // There are three separate cases here based on Shadow DOM support.\n    // (1) shadowRoot polyfilled: use ShadyCSS\n    // (2) shadowRoot.adoptedStyleSheets available: use it\n    // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\n    // rendering\n    if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\n      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(\n        styles.map((s) => s.cssText),\n        this.localName,\n      );\n    } else if (supportsAdoptingStyleSheets) {\n      this.renderRoot.adoptedStyleSheets = styles.map((s) =>\n        s instanceof CSSStyleSheet ? s : s.styleSheet,\n      );\n    } else {\n      // This must be done after rendering so the actual style insertion is done\n      // in `update`.\n      this._needsShimAdoptedStyleSheets = true;\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    // Note, first update/render handles styleElement so we only call this if\n    // connected after first update.\n    if (this.hasUpdated && window.ShadyCSS !== undefined) {\n      window.ShadyCSS.styleElement(this);\n    }\n  }\n  /**\n   * Updates the element. This method reflects property values to attributes\n   * and calls `render` to render DOM via lit-html. Setting properties inside\n   * this method will *not* trigger another update.\n   * @param _changedProperties Map of changed properties with old values\n   */\n  update(changedProperties) {\n    // Setting properties in `render` should not trigger an update. Since\n    // updates are allowed after super.update, it's important to call `render`\n    // before that.\n    const templateResult = this.render();\n    super.update(changedProperties);\n    // If render is not implemented by the component, don't call lit-html render\n    if (templateResult !== renderNotImplemented) {\n      this.constructor.render(templateResult, this.renderRoot, {\n        scopeName: this.localName,\n        eventContext: this,\n      });\n    }\n    // When native Shadow DOM is used but adoptedStyles are not supported,\n    // insert styling after rendering to ensure adoptedStyles have highest\n    // priority.\n    if (this._needsShimAdoptedStyleSheets) {\n      this._needsShimAdoptedStyleSheets = false;\n      this.constructor._styles.forEach((s) => {\n        const style = document.createElement('style');\n        style.textContent = s.cssText;\n        this.renderRoot.appendChild(style);\n      });\n    }\n  }\n  /**\n   * Invoked on each update to perform rendering tasks. This method may return\n   * any value renderable by lit-html's `NodePart` - typically a\n   * `TemplateResult`. Setting properties inside this method will *not* trigger\n   * the element to update.\n   */\n  render() {\n    return renderNotImplemented;\n  }\n}\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n *\n * Note this property name is a string to prevent breaking Closure JS Compiler\n * optimizations. See updating-element.ts for more information.\n */\nLitElement['finalized'] = true;\n/**\n * Reference to the underlying library method used to render the element's\n * DOM. By default, points to the `render` method from lit-html's shady-render\n * module.\n *\n * **Most users will never need to touch this property.**\n *\n * This  property should not be confused with the `render` instance method,\n * which should be overridden to define a template for the element.\n *\n * Advanced users creating a new base class based on LitElement can override\n * this property to point to a custom render method with a signature that\n * matches [shady-render's `render`\n * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).\n *\n * @nocollapse\n */\nLitElement.render = render;\n/** @nocollapse */\nLitElement.shadowRootOptions = { mode: 'open' };\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// NOTE(cdata): The HAS_WEBXR_* constants can be enabled in Chrome by turning on\n// the appropriate flags. However, just because we have the API does not\n// guarantee that AR will work.\nconst HAS_WEBXR_DEVICE_API =\n  navigator.xr != null &&\n  self.XRSession != null &&\n  navigator.xr.isSessionSupported != null;\nconst HAS_WEBXR_HIT_TEST_API =\n  HAS_WEBXR_DEVICE_API && self.XRSession.prototype.requestHitTestSource;\nconst HAS_RESIZE_OBSERVER = self.ResizeObserver != null;\nconst HAS_INTERSECTION_OBSERVER = self.IntersectionObserver != null;\nconst IS_WEBXR_AR_CANDIDATE = HAS_WEBXR_HIT_TEST_API;\n(() => {\n  const userAgent = navigator.userAgent || navigator.vendor || self.opera;\n  let check = false;\n  // eslint-disable-next-line\n  if (\n    /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(\n      userAgent,\n    ) ||\n    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(\n      userAgent.substr(0, 4),\n    )\n  ) {\n    check = true;\n  }\n  return check;\n})();\n/\\bCrOS\\b/.test(navigator.userAgent);\nconst IS_ANDROID = /android/i.test(navigator.userAgent);\n// Prior to iOS 13, detecting iOS Safari was relatively straight-forward.\n// As of iOS 13, Safari on iPad (in its default configuration) reports the same\n// user-agent string as Safari on desktop MacOS. Strictly speaking, we only care\n// about iOS for the purposes if selecting for cases where Quick Look is known\n// to be supported. However, for API correctness purposes, we must rely on\n// known, detectable signals to distinguish iOS Safari from MacOS Safari. At the\n// time of this writing, there are no non-iOS/iPadOS Apple devices with\n// multi-touch displays.\n// @see https://stackoverflow.com/questions/57765958/how-to-detect-ipad-and-ipad-os-version-in-ios-13-and-up\n// @see https://forums.developer.apple.com/thread/119186\n// @see https://github.com/google/model-viewer/issues/758\nconst IS_IOS =\n  (/iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream) ||\n  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\nconst IS_AR_QUICKLOOK_CANDIDATE = (() => {\n  const tempAnchor = document.createElement('a');\n  return Boolean(\n    tempAnchor.relList &&\n      tempAnchor.relList.supports &&\n      tempAnchor.relList.supports('ar'),\n  );\n})();\n// @see https://developer.chrome.com/multidevice/user-agent\n/Safari\\//.test(navigator.userAgent);\nconst IS_FIREFOX = /firefox/i.test(navigator.userAgent);\nconst IS_OCULUS = /OculusBrowser/.test(navigator.userAgent);\nIS_IOS && /CriOS\\//.test(navigator.userAgent);\nconst IS_SCENEVIEWER_CANDIDATE = IS_ANDROID && !IS_FIREFOX && !IS_OCULUS;\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CloseIcon = html` <svg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24px\"\n  height=\"24px\"\n  viewBox=\"0 0 24 24\"\n  fill=\"#000000\"\n>\n  <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components -->\n  <defs>\n    <filter id=\"drop-shadow\" x=\"-100%\" y=\"-100%\" width=\"300%\" height=\"300%\">\n      <feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"1\" />\n      <feOffset dx=\"0\" dy=\"0\" result=\"offsetblur\" />\n      <feFlood flood-color=\"#000000\" />\n      <feComposite in2=\"offsetblur\" operator=\"in\" />\n      <feMerge>\n        <feMergeNode />\n        <feMergeNode in=\"SourceGraphic\" />\n      </feMerge>\n    </filter>\n  </defs>\n  <path\n    filter=\"url(#drop-shadow)\"\n    d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"\n  />\n  <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n</svg>`;\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ControlsPrompt = html` <svg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  width=\"25\"\n  height=\"36\"\n>\n  <defs>\n    <path id=\"A\" d=\"M.001.232h24.997V36H.001z\" />\n  </defs>\n  <g transform=\"translate(-11 -4)\" fill=\"none\" fill-rule=\"evenodd\">\n    <path fill-opacity=\"0\" fill=\"#fff\" d=\"M0 0h44v44H0z\" />\n    <g transform=\"translate(11 3)\">\n      <path\n        d=\"M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z\"\n        fill-opacity=\".5\"\n        fill=\"#e4e4e4\"\n      />\n      <path\n        d=\"M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91\"\n        fill-opacity=\".6\"\n        fill=\"#000\"\n      />\n      <path\n        d=\"M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z\"\n        fill=\"#fff\"\n      />\n      <g transform=\"translate(0 .769)\">\n        <mask id=\"B\" fill=\"#fff\">\n          <use xlink:href=\"#A\" />\n        </mask>\n        <path\n          d=\"M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325\"\n          fill-opacity=\".05\"\n          fill=\"#000\"\n          mask=\"url(#B)\"\n        />\n      </g>\n    </g>\n  </g>\n</svg>`;\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ARGlyph = html` <svg\n  version=\"1.1\"\n  id=\"view_x5F_in_x5F_AR_x5F_icon\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  x=\"0px\"\n  y=\"0px\"\n  width=\"24px\"\n  height=\"24px\"\n  viewBox=\"0 0 24 24\"\n  enable-background=\"new 0 0 24 24\"\n  xml:space=\"preserve\"\n>\n  <rect id=\"Bounding_Box\" x=\"0\" y=\"0\" fill=\"none\" width=\"24\" height=\"24\" />\n  <g id=\"Art_layer\">\n    <path d=\"M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z\" />\n    <path d=\"M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z\" />\n    <path d=\"M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z\" />\n    <path d=\"M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z\" />\n    <g>\n      <path\n        d=\"M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n\t\t\tl5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n\t\t\tl4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z\"\n      />\n    </g>\n  </g>\n</svg>`;\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst templateResult = html` <style>\n    :host {\n      display: block;\n      position: relative;\n      contain: strict;\n      width: 300px;\n      height: 150px;\n    }\n\n    /* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n    :host([data-js-focus-visible]:focus:not(.focus-visible)),\n    :host([data-js-focus-visible]) :focus:not(.focus-visible) {\n      outline: none;\n    }\n\n    .container {\n      position: relative;\n    }\n\n    .userInput {\n      width: 100%;\n      height: 100%;\n      display: block;\n      position: relative;\n      overflow: hidden;\n    }\n\n    canvas {\n      position: absolute;\n      display: none;\n      pointer-events: none;\n      /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n      transform: translateZ(0);\n    }\n\n    canvas.show {\n      display: block;\n    }\n\n    /* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n    .screen-reader-only {\n      border: 0;\n      clip: rect(0, 0, 0, 0);\n      height: 1px;\n      margin: -1px;\n      overflow: hidden;\n      padding: 0;\n      position: absolute;\n      white-space: nowrap;\n      width: 1px;\n    }\n\n    .slot {\n      position: absolute;\n      pointer-events: none;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n    }\n\n    .slot > * {\n      pointer-events: initial;\n    }\n\n    .annotation-wrapper ::slotted(*) {\n      opacity: var(--max-hotspot-opacity, 1);\n      transition: opacity 0.3s;\n    }\n\n    .pointer-tumbling .annotation-wrapper ::slotted(*) {\n      pointer-events: none;\n    }\n\n    .annotation-wrapper ::slotted(*) {\n      pointer-events: initial;\n    }\n\n    .annotation-wrapper.hide ::slotted(*) {\n      opacity: var(--min-hotspot-opacity, 0.25);\n    }\n\n    .slot.poster {\n      opacity: 0;\n      transition: opacity 0.3s 0.3s;\n      background-color: inherit;\n    }\n\n    .slot.poster.show {\n      opacity: 1;\n      transition: none;\n    }\n\n    .slot.poster.quick {\n      transition: none;\n    }\n\n    .slot.poster > * {\n      pointer-events: initial;\n    }\n\n    .slot.poster:not(.show) > * {\n      pointer-events: none;\n    }\n\n    #default-poster {\n      width: 100%;\n      height: 100%;\n      /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n      display: block;\n      position: absolute;\n      border: none;\n      padding: 0;\n      background-size: contain;\n      background-repeat: no-repeat;\n      background-position: center;\n      background-color: var(--poster-color, #fff);\n      background-image: var(--poster-image, none);\n    }\n\n    #default-progress-bar {\n      display: block;\n      position: relative;\n      width: 100%;\n      height: 100%;\n      pointer-events: none;\n      overflow: hidden;\n    }\n\n    #default-progress-bar > .mask {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background: var(--progress-mask, #fff);\n      transition: opacity 0.3s;\n      opacity: 0.2;\n    }\n\n    #default-progress-bar > .bar {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: var(--progress-bar-height, 5px);\n      background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n      transition: transform 0.09s;\n      transform-origin: top left;\n      transform: scaleX(0);\n      overflow: hidden;\n    }\n\n    #default-progress-bar > .bar.hide {\n      transition: opacity 0.3s 1s;\n      opacity: 0;\n    }\n\n    .slot.interaction-prompt {\n      display: var(--interaction-prompt-display, flex);\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      pointer-events: none;\n      align-items: center;\n      justify-content: center;\n\n      opacity: 0;\n      will-change: opacity;\n      overflow: hidden;\n      transition: opacity 0.3s;\n    }\n\n    .slot.interaction-prompt.visible {\n      opacity: 1;\n    }\n\n    .slot.interaction-prompt > .animated-container {\n      will-change: transform, opacity;\n    }\n\n    .slot.interaction-prompt > * {\n      pointer-events: none;\n    }\n\n    .slot.ar-button {\n      -moz-user-select: none;\n      -webkit-tap-highlight-color: transparent;\n      user-select: none;\n\n      display: var(--ar-button-display, block);\n    }\n\n    .slot.ar-button:not(.enabled) {\n      display: none;\n    }\n\n    .fab {\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      box-sizing: border-box;\n      width: 40px;\n      height: 40px;\n      cursor: pointer;\n      background-color: #fff;\n      box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n      border-radius: 100px;\n    }\n\n    .fab > * {\n      opacity: 0.87;\n    }\n\n    #default-ar-button {\n      position: absolute;\n      bottom: 16px;\n      right: 16px;\n      transform: scale(var(--ar-button-scale, 1));\n      transform-origin: bottom right;\n    }\n\n    .slot.default {\n      pointer-events: none;\n    }\n\n    .slot.progress-bar {\n      pointer-events: none;\n    }\n\n    .slot.exit-webxr-ar-button {\n      pointer-events: none;\n    }\n\n    .slot.exit-webxr-ar-button:not(.enabled) {\n      display: none;\n    }\n\n    #default-exit-webxr-ar-button {\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      position: absolute;\n      top: 16px;\n      right: 16px;\n      width: 40px;\n      height: 40px;\n      box-sizing: border-box;\n    }\n\n    #default-exit-webxr-ar-button > svg {\n      fill: #fff;\n    }\n  </style>\n  <div class=\"container\">\n    <div\n      class=\"userInput\"\n      tabindex=\"0\"\n      role=\"img\"\n      aria-label=\"A depiction of a 3D model\"\n      aria-live=\"polite\"\n    >\n      <div class=\"slot canvas\">\n        <slot name=\"canvas\">\n          <canvas></canvas>\n        </slot>\n      </div>\n    </div>\n\n    <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS -->\n    <div class=\"slot poster\">\n      <slot name=\"poster\">\n        <button\n          type=\"button\"\n          id=\"default-poster\"\n          aria-hidden=\"true\"\n          aria-label=\"Activate to view in 3D!\"\n        ></button>\n      </slot>\n    </div>\n\n    <div class=\"slot ar-button\">\n      <slot name=\"ar-button\">\n        <a\n          id=\"default-ar-button\"\n          part=\"default-ar-button\"\n          class=\"fab\"\n          tabindex=\"2\"\n          aria-label=\"View this 3D model up close\"\n        >\n          ${ARGlyph}\n        </a>\n      </slot>\n    </div>\n\n    <div class=\"slot interaction-prompt\">\n      <div class=\"animated-container\">\n        <slot name=\"interaction-prompt\" aria-hidden=\"true\">\n          ${ControlsPrompt}\n        </slot>\n      </div>\n    </div>\n\n    <div class=\"slot default\">\n      <slot></slot>\n\n      <div class=\"slot progress-bar\">\n        <slot name=\"progress-bar\">\n          <div id=\"default-progress-bar\" aria-hidden=\"true\">\n            <div class=\"mask\" part=\"default-progress-mask\"></div>\n            <div class=\"bar\" part=\"default-progress-bar\"></div>\n          </div>\n        </slot>\n      </div>\n\n      <div class=\"slot exit-webxr-ar-button\">\n        <slot name=\"exit-webxr-ar-button\">\n          <a\n            id=\"default-exit-webxr-ar-button\"\n            part=\"default-exit-webxr-ar-button\"\n            tabindex=\"3\"\n            aria-label=\"Exit AR\"\n            aria-hidden=\"true\"\n          >\n            ${CloseIcon}\n          </a>\n        </slot>\n      </div>\n    </div>\n  </div>`;\nconst makeTemplate = (shadowRoot) => {\n  render$1(templateResult, shadowRoot);\n};\n\n/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '133';\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst FlatShading = 1;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst CubeUVRefractionMapping = 307;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedShort565Type = 1019;\nconst UnsignedInt248Type = 1020;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst RGBEFormat = RGBAFormat;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\nconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\nconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\nconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\nconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\nconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\nconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\nconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\nconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\nconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\nconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\nconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\nconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\nconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\nconst GammaEncoding = 3007;\nconst RGBEEncoding = 3002;\nconst LogLuvEncoding = 3003;\nconst RGBM7Encoding = 3004;\nconst RGBM16Encoding = 3005;\nconst RGBDEncoding = 3006;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\nconst KeepStencilOp = 7680;\nconst AlwaysStencilFunc = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst GLSL3 = '300 es';\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n  addEventListener(type, listener) {\n    if (this._listeners === undefined) this._listeners = {};\n\n    const listeners = this._listeners;\n\n    if (listeners[type] === undefined) {\n      listeners[type] = [];\n    }\n\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  }\n\n  hasEventListener(type, listener) {\n    if (this._listeners === undefined) return false;\n\n    const listeners = this._listeners;\n\n    return (\n      listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1\n    );\n  }\n\n  removeEventListener(type, listener) {\n    if (this._listeners === undefined) return;\n\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n\n    if (listenerArray !== undefined) {\n      const index = listenerArray.indexOf(listener);\n\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this._listeners === undefined) return;\n\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n\n    if (listenerArray !== undefined) {\n      event.target = this;\n\n      // Make a copy, in case listeners are removed while iterating.\n      const array = listenerArray.slice(0);\n\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n\n      event.target = null;\n    }\n  }\n}\n\nlet _seed = 1234567;\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n//\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\n\nconst hasRandomUUID = typeof crypto !== 'undefined' && 'randomUUID' in crypto;\n\nfunction generateUUID() {\n  if (hasRandomUUID) {\n    return crypto.randomUUID().toUpperCase();\n  }\n\n  // TODO Remove this code when crypto.randomUUID() is available everywhere\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = (Math.random() * 0xffffffff) | 0;\n  const d1 = (Math.random() * 0xffffffff) | 0;\n  const d2 = (Math.random() * 0xffffffff) | 0;\n  const d3 = (Math.random() * 0xffffffff) | 0;\n  const uuid =\n    _lut[d0 & 0xff] +\n    _lut[(d0 >> 8) & 0xff] +\n    _lut[(d0 >> 16) & 0xff] +\n    _lut[(d0 >> 24) & 0xff] +\n    '-' +\n    _lut[d1 & 0xff] +\n    _lut[(d1 >> 8) & 0xff] +\n    '-' +\n    _lut[((d1 >> 16) & 0x0f) | 0x40] +\n    _lut[(d1 >> 24) & 0xff] +\n    '-' +\n    _lut[(d2 & 0x3f) | 0x80] +\n    _lut[(d2 >> 8) & 0xff] +\n    '-' +\n    _lut[(d2 >> 16) & 0xff] +\n    _lut[(d2 >> 24) & 0xff] +\n    _lut[d3 & 0xff] +\n    _lut[(d3 >> 8) & 0xff] +\n    _lut[(d3 >> 16) & 0xff] +\n    _lut[(d3 >> 24) & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase();\n}\n\nfunction clamp$1(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\n// compute euclidian modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo(n, m) {\n  return ((n % m) + m) % m;\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear(x, a1, a2, b1, b2) {\n  return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp(x, y, value) {\n  if (x !== y) {\n    return (value - x) / (y - x);\n  } else {\n    return 0;\n  }\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt));\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong(x, length = 1) {\n  return length - Math.abs(euclideanModulo(x, length * 2) - length);\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n\n  x = (x - min) / (max - min);\n\n  return x * x * (3 - 2 * x);\n}\n\nfunction smootherstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n\n  x = (x - min) / (max - min);\n\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\n// Random integer from <low, high> interval\nfunction randInt(low, high) {\n  return low + Math.floor(Math.random() * (high - low + 1));\n}\n\n// Random float from <low, high> interval\nfunction randFloat(low, high) {\n  return low + Math.random() * (high - low);\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread(range) {\n  return range * (0.5 - Math.random());\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom(s) {\n  if (s !== undefined) _seed = s % 2147483647;\n\n  // Park-Miller algorithm\n\n  _seed = (_seed * 16807) % 2147483647;\n\n  return (_seed - 1) / 2147483646;\n}\n\nfunction degToRad(degrees) {\n  return degrees * DEG2RAD;\n}\n\nfunction radToDeg(radians) {\n  return radians * RAD2DEG;\n}\n\nfunction isPowerOfTwo(value) {\n  return (value & (value - 1)) === 0 && value !== 0;\n}\n\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\nfunction floorPowerOfTwo(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\n\nfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n  // rotations are applied to the axes in the order specified by 'order'\n  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n  // angles are in radians\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n\n  const c2 = cos(b / 2);\n  const s2 = sin(b / 2);\n\n  const c13 = cos((a + c) / 2);\n  const s13 = sin((a + c) / 2);\n\n  const c1_3 = cos((a - c) / 2);\n  const s1_3 = sin((a - c) / 2);\n\n  const c3_1 = cos((c - a) / 2);\n  const s3_1 = sin((c - a) / 2);\n\n  switch (order) {\n    case 'XYX':\n      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n      break;\n\n    case 'YZY':\n      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n      break;\n\n    case 'ZXZ':\n      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n      break;\n\n    case 'XZX':\n      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n      break;\n\n    case 'YXY':\n      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n      break;\n\n    case 'ZYZ':\n      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n      break;\n\n    default:\n      console.warn(\n        'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +\n          order,\n      );\n  }\n}\n\nvar MathUtils = /*#__PURE__*/ Object.freeze({\n  __proto__: null,\n  DEG2RAD: DEG2RAD,\n  RAD2DEG: RAD2DEG,\n  generateUUID: generateUUID,\n  clamp: clamp$1,\n  euclideanModulo: euclideanModulo,\n  mapLinear: mapLinear,\n  inverseLerp: inverseLerp,\n  lerp: lerp,\n  damp: damp,\n  pingpong: pingpong,\n  smoothstep: smoothstep,\n  smootherstep: smootherstep,\n  randInt: randInt,\n  randFloat: randFloat,\n  randFloatSpread: randFloatSpread,\n  seededRandom: seededRandom,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  isPowerOfTwo: isPowerOfTwo,\n  ceilPowerOfTwo: ceilPowerOfTwo,\n  floorPowerOfTwo: floorPowerOfTwo,\n  setQuaternionFromProperEuler: setQuaternionFromProperEuler,\n});\n\nclass Vector2 {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  get width() {\n    return this.x;\n  }\n\n  set width(value) {\n    this.x = value;\n  }\n\n  get height() {\n    return this.y;\n  }\n\n  set height(value) {\n    this.y = value;\n  }\n\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n\n    return this;\n  }\n\n  setX(x) {\n    this.x = x;\n\n    return this;\n  }\n\n  setY(y) {\n    this.y = y;\n\n    return this;\n  }\n\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.x, this.y);\n  }\n\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n\n    return this;\n  }\n\n  add(v, w) {\n    if (w !== undefined) {\n      console.warn(\n        'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',\n      );\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n\n    return this;\n  }\n\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n\n    return this;\n  }\n\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n\n    return this;\n  }\n\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n\n    return this;\n  }\n\n  sub(v, w) {\n    if (w !== undefined) {\n      console.warn(\n        'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',\n      );\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n\n    return this;\n  }\n\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n\n    return this;\n  }\n\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n\n    return this;\n  }\n\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n\n    return this;\n  }\n\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n\n    return this;\n  }\n\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n\n    return this;\n  }\n\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  applyMatrix3(m) {\n    const x = this.x,\n      y = this.y;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[3] * y + e[6];\n    this.y = e[1] * x + e[4] * y + e[7];\n\n    return this;\n  }\n\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n\n    return this;\n  }\n\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n\n    return this;\n  }\n\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n\n    return this;\n  }\n\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n\n    return this;\n  }\n\n  clampLength(min, max) {\n    const length = this.length();\n\n    return this.divideScalar(length || 1).multiplyScalar(\n      Math.max(min, Math.min(max, length)),\n    );\n  }\n\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n\n    return this;\n  }\n\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n\n    return this;\n  }\n\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n\n    return this;\n  }\n\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\n    return this;\n  }\n\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n\n    return this;\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n\n  cross(v) {\n    return this.x * v.y - this.y * v.x;\n  }\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y);\n  }\n\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  angle() {\n    // computes the angle in radians with respect to the positive x-axis\n\n    const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n\n    return angle;\n  }\n\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n      dy = this.y - v.y;\n    return dx * dx + dy * dy;\n  }\n\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n  }\n\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n\n    return this;\n  }\n\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n\n    return this;\n  }\n\n  equals(v) {\n    return v.x === this.x && v.y === this.y;\n  }\n\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== undefined) {\n      console.warn(\n        'THREE.Vector2: offset has been removed from .fromBufferAttribute().',\n      );\n    }\n\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n\n    return this;\n  }\n\n  rotateAround(center, angle) {\n    const c = Math.cos(angle),\n      s = Math.sin(angle);\n\n    const x = this.x - center.x;\n    const y = this.y - center.y;\n\n    this.x = x * c - y * s + center.x;\n    this.y = x * s + y * c + center.y;\n\n    return this;\n  }\n\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n\n    return this;\n  }\n\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n  }\n}\n\nVector2.prototype.isVector2 = true;\n\nclass Matrix3 {\n  constructor() {\n    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n    if (arguments.length > 0) {\n      console.error(\n        'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.',\n      );\n    }\n  }\n\n  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    const te = this.elements;\n\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] = n23;\n    te[8] = n33;\n\n    return this;\n  }\n\n  identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n\n    return this;\n  }\n\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, 1);\n    zAxis.setFromMatrix3Column(this, 2);\n\n    return this;\n  }\n\n  setFromMatrix4(m) {\n    const me = m.elements;\n\n    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n\n    return this;\n  }\n\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n\n    const a11 = ae[0],\n      a12 = ae[3],\n      a13 = ae[6];\n    const a21 = ae[1],\n      a22 = ae[4],\n      a23 = ae[7];\n    const a31 = ae[2],\n      a32 = ae[5],\n      a33 = ae[8];\n\n    const b11 = be[0],\n      b12 = be[3],\n      b13 = be[6];\n    const b21 = be[1],\n      b22 = be[4],\n      b23 = be[7];\n    const b31 = be[2],\n      b32 = be[5],\n      b33 = be[8];\n\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n    return this;\n  }\n\n  multiplyScalar(s) {\n    const te = this.elements;\n\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n\n    return this;\n  }\n\n  determinant() {\n    const te = this.elements;\n\n    const a = te[0],\n      b = te[1],\n      c = te[2],\n      d = te[3],\n      e = te[4],\n      f = te[5],\n      g = te[6],\n      h = te[7],\n      i = te[8];\n\n    return (\n      a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g\n    );\n  }\n\n  invert() {\n    const te = this.elements,\n      n11 = te[0],\n      n21 = te[1],\n      n31 = te[2],\n      n12 = te[3],\n      n22 = te[4],\n      n32 = te[5],\n      n13 = te[6],\n      n23 = te[7],\n      n33 = te[8],\n      t11 = n33 * n22 - n32 * n23,\n      t12 = n32 * n13 - n33 * n12,\n      t13 = n23 * n12 - n22 * n13,\n      det = n11 * t11 + n21 * t12 + n31 * t13;\n\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n    const detInv = 1 / det;\n\n    te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    te[2] = (n32 * n21 - n31 * n22) * detInv;\n\n    te[3] = t12 * detInv;\n    te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * n11) * detInv;\n\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n\n    return this;\n  }\n\n  transpose() {\n    let tmp;\n    const m = this.elements;\n\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n\n    return this;\n  }\n\n  getNormalMatrix(matrix4) {\n    return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n\n  transposeIntoArray(r) {\n    const m = this.elements;\n\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n\n    return this;\n  }\n\n  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n\n    this.set(\n      sx * c,\n      sx * s,\n      -sx * (c * cx + s * cy) + cx + tx,\n      -sy * s,\n      sy * c,\n      -sy * (-s * cx + c * cy) + cy + ty,\n      0,\n      0,\n      1,\n    );\n\n    return this;\n  }\n\n  scale(sx, sy) {\n    const te = this.elements;\n\n    te[0] *= sx;\n    te[3] *= sx;\n    te[6] *= sx;\n    te[1] *= sy;\n    te[4] *= sy;\n    te[7] *= sy;\n\n    return this;\n  }\n\n  rotate(theta) {\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n\n    const te = this.elements;\n\n    const a11 = te[0],\n      a12 = te[3],\n      a13 = te[6];\n    const a21 = te[1],\n      a22 = te[4],\n      a23 = te[7];\n\n    te[0] = c * a11 + s * a21;\n    te[3] = c * a12 + s * a22;\n    te[6] = c * a13 + s * a23;\n\n    te[1] = -s * a11 + c * a21;\n    te[4] = -s * a12 + c * a22;\n    te[7] = -s * a13 + c * a23;\n\n    return this;\n  }\n\n  translate(tx, ty) {\n    const te = this.elements;\n\n    te[0] += tx * te[2];\n    te[3] += tx * te[5];\n    te[6] += tx * te[8];\n    te[1] += ty * te[2];\n    te[4] += ty * te[5];\n    te[7] += ty * te[8];\n\n    return this;\n  }\n\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n\n    for (let i = 0; i < 9; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n\n    return true;\n  }\n\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 9; i++) {\n      this.elements[i] = array[i + offset];\n    }\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n\n    return array;\n  }\n\n  clone() {\n    return new this.constructor().fromArray(this.elements);\n  }\n}\n\nMatrix3.prototype.isMatrix3 = true;\n\nfunction arrayMax(array) {\n  if (array.length === 0) return -Infinity;\n\n  let max = array[0];\n\n  for (let i = 1, l = array.length; i < l; ++i) {\n    if (array[i] > max) max = array[i];\n  }\n\n  return max;\n}\n\nfunction createElementNS(name) {\n  return document.createElementNS('http://www.w3.org/1999/xhtml', name);\n}\n\nlet _canvas;\n\nclass ImageUtils {\n  static getDataURL(image) {\n    if (/^data:/i.test(image.src)) {\n      return image.src;\n    }\n\n    if (typeof HTMLCanvasElement == 'undefined') {\n      return image.src;\n    }\n\n    let canvas;\n\n    if (image instanceof HTMLCanvasElement) {\n      canvas = image;\n    } else {\n      if (_canvas === undefined) _canvas = createElementNS('canvas');\n\n      _canvas.width = image.width;\n      _canvas.height = image.height;\n\n      const context = _canvas.getContext('2d');\n\n      if (image instanceof ImageData) {\n        context.putImageData(image, 0, 0);\n      } else {\n        context.drawImage(image, 0, 0, image.width, image.height);\n      }\n\n      canvas = _canvas;\n    }\n\n    if (canvas.width > 2048 || canvas.height > 2048) {\n      console.warn(\n        'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',\n        image,\n      );\n\n      return canvas.toDataURL('image/jpeg', 0.6);\n    } else {\n      return canvas.toDataURL('image/png');\n    }\n  }\n}\n\nlet textureId = 0;\n\nclass Texture$1 extends EventDispatcher {\n  constructor(\n    image = Texture$1.DEFAULT_IMAGE,\n    mapping = Texture$1.DEFAULT_MAPPING,\n    wrapS = ClampToEdgeWrapping,\n    wrapT = ClampToEdgeWrapping,\n    magFilter = LinearFilter,\n    minFilter = LinearMipmapLinearFilter,\n    format = RGBAFormat,\n    type = UnsignedByteType,\n    anisotropy = 1,\n    encoding = LinearEncoding,\n  ) {\n    super();\n\n    Object.defineProperty(this, 'id', { value: textureId++ });\n\n    this.uuid = generateUUID();\n\n    this.name = '';\n\n    this.image = image;\n    this.mipmaps = [];\n\n    this.mapping = mapping;\n\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n\n    this.anisotropy = anisotropy;\n\n    this.format = format;\n    this.internalFormat = null;\n    this.type = type;\n\n    this.offset = new Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new Vector2(0, 0);\n    this.rotation = 0;\n\n    this.matrixAutoUpdate = true;\n    this.matrix = new Matrix3();\n\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n    //\n    // Also changing the encoding after already used by a Material will not automatically make the Material\n    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n    this.encoding = encoding;\n\n    this.version = 0;\n    this.onUpdate = null;\n\n    this.isRenderTargetTexture = false;\n  }\n\n  updateMatrix() {\n    this.matrix.setUvTransform(\n      this.offset.x,\n      this.offset.y,\n      this.repeat.x,\n      this.repeat.y,\n      this.rotation,\n      this.center.x,\n      this.center.y,\n    );\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.name = source.name;\n\n    this.image = source.image;\n    this.mipmaps = source.mipmaps.slice(0);\n\n    this.mapping = source.mapping;\n\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n\n    this.anisotropy = source.anisotropy;\n\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.encoding = source.encoding;\n\n    return this;\n  }\n\n  toJSON(meta) {\n    const isRootObject = meta === undefined || typeof meta === 'string';\n\n    if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n      return meta.textures[this.uuid];\n    }\n\n    const output = {\n      metadata: {\n        version: 4.5,\n        type: 'Texture',\n        generator: 'Texture.toJSON',\n      },\n\n      uuid: this.uuid,\n      name: this.name,\n\n      mapping: this.mapping,\n\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n\n      wrap: [this.wrapS, this.wrapT],\n\n      format: this.format,\n      type: this.type,\n      encoding: this.encoding,\n\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n\n      flipY: this.flipY,\n\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment,\n    };\n\n    if (this.image !== undefined) {\n      // TODO: Move to THREE.Image\n\n      const image = this.image;\n\n      if (image.uuid === undefined) {\n        image.uuid = generateUUID(); // UGH\n      }\n\n      if (!isRootObject && meta.images[image.uuid] === undefined) {\n        let url;\n\n        if (Array.isArray(image)) {\n          // process array of images e.g. CubeTexture\n\n          url = [];\n\n          for (let i = 0, l = image.length; i < l; i++) {\n            // check cube texture with data textures\n\n            if (image[i].isDataTexture) {\n              url.push(serializeImage(image[i].image));\n            } else {\n              url.push(serializeImage(image[i]));\n            }\n          }\n        } else {\n          // process single image\n\n          url = serializeImage(image);\n        }\n\n        meta.images[image.uuid] = {\n          uuid: image.uuid,\n          url: url,\n        };\n      }\n\n      output.image = image.uuid;\n    }\n\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n\n    return output;\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' });\n  }\n\n  transformUv(uv) {\n    if (this.mapping !== UVMapping) return uv;\n\n    uv.applyMatrix3(this.matrix);\n\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n\n          break;\n      }\n    }\n\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n\n          break;\n      }\n    }\n\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n\n    return uv;\n  }\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n}\n\nTexture$1.DEFAULT_IMAGE = undefined;\nTexture$1.DEFAULT_MAPPING = UVMapping;\n\nTexture$1.prototype.isTexture = true;\n\nfunction serializeImage(image) {\n  if (\n    (typeof HTMLImageElement !== 'undefined' &&\n      image instanceof HTMLImageElement) ||\n    (typeof HTMLCanvasElement !== 'undefined' &&\n      image instanceof HTMLCanvasElement) ||\n    (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)\n  ) {\n    // default images\n\n    return ImageUtils.getDataURL(image);\n  } else {\n    if (image.data) {\n      // images of DataTexture\n\n      return {\n        data: Array.prototype.slice.call(image.data),\n        width: image.width,\n        height: image.height,\n        type: image.data.constructor.name,\n      };\n    } else {\n      console.warn('THREE.Texture: Unable to serialize Texture.');\n      return {};\n    }\n  }\n}\n\nclass Vector4 {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  get width() {\n    return this.z;\n  }\n\n  set width(value) {\n    this.z = value;\n  }\n\n  get height() {\n    return this.w;\n  }\n\n  set height(value) {\n    this.w = value;\n  }\n\n  set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n\n    return this;\n  }\n\n  setX(x) {\n    this.x = x;\n\n    return this;\n  }\n\n  setY(y) {\n    this.y = y;\n\n    return this;\n  }\n\n  setZ(z) {\n    this.z = z;\n\n    return this;\n  }\n\n  setW(w) {\n    this.w = w;\n\n    return this;\n  }\n\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      case 3:\n        this.w = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      case 3:\n        return this.w;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.x, this.y, this.z, this.w);\n  }\n\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    this.w = v.w !== undefined ? v.w : 1;\n\n    return this;\n  }\n\n  add(v, w) {\n    if (w !== undefined) {\n      console.warn(\n        'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',\n      );\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n\n    return this;\n  }\n\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    this.w += s;\n\n    return this;\n  }\n\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n\n    return this;\n  }\n\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    this.w += v.w * s;\n\n    return this;\n  }\n\n  sub(v, w) {\n    if (w !== undefined) {\n      console.warn(\n        'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',\n      );\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n\n    return this;\n  }\n\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    this.w -= s;\n\n    return this;\n  }\n\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n\n    return this;\n  }\n\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    this.w *= v.w;\n\n    return this;\n  }\n\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n\n    return this;\n  }\n\n  applyMatrix4(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z,\n      w = this.w;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\n    return this;\n  }\n\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  setAxisAngleFromQuaternion(q) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n    // q is assumed to be normalized\n\n    this.w = 2 * Math.acos(q.w);\n\n    const s = Math.sqrt(1 - q.w * q.w);\n\n    if (s < 0.0001) {\n      this.x = 1;\n      this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n      this.y = q.y / s;\n      this.z = q.z / s;\n    }\n\n    return this;\n  }\n\n  setAxisAngleFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    let angle, x, y, z; // variables for result\n    const epsilon = 0.01, // margin to allow for rounding errors\n      epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees\n      te = m.elements,\n      m11 = te[0],\n      m12 = te[4],\n      m13 = te[8],\n      m21 = te[1],\n      m22 = te[5],\n      m23 = te[9],\n      m31 = te[2],\n      m32 = te[6],\n      m33 = te[10];\n\n    if (\n      Math.abs(m12 - m21) < epsilon &&\n      Math.abs(m13 - m31) < epsilon &&\n      Math.abs(m23 - m32) < epsilon\n    ) {\n      // singularity found\n      // first check for identity matrix which must have +1 for all terms\n      // in leading diagonal and zero in other terms\n\n      if (\n        Math.abs(m12 + m21) < epsilon2 &&\n        Math.abs(m13 + m31) < epsilon2 &&\n        Math.abs(m23 + m32) < epsilon2 &&\n        Math.abs(m11 + m22 + m33 - 3) < epsilon2\n      ) {\n        // this singularity is identity matrix so angle = 0\n\n        this.set(1, 0, 0, 0);\n\n        return this; // zero angle, arbitrary axis\n      }\n\n      // otherwise this singularity is angle = 180\n\n      angle = Math.PI;\n\n      const xx = (m11 + 1) / 2;\n      const yy = (m22 + 1) / 2;\n      const zz = (m33 + 1) / 2;\n      const xy = (m12 + m21) / 4;\n      const xz = (m13 + m31) / 4;\n      const yz = (m23 + m32) / 4;\n\n      if (xx > yy && xx > zz) {\n        // m11 is the largest diagonal term\n\n        if (xx < epsilon) {\n          x = 0;\n          y = 0.707106781;\n          z = 0.707106781;\n        } else {\n          x = Math.sqrt(xx);\n          y = xy / x;\n          z = xz / x;\n        }\n      } else if (yy > zz) {\n        // m22 is the largest diagonal term\n\n        if (yy < epsilon) {\n          x = 0.707106781;\n          y = 0;\n          z = 0.707106781;\n        } else {\n          y = Math.sqrt(yy);\n          x = xy / y;\n          z = yz / y;\n        }\n      } else {\n        // m33 is the largest diagonal term so base result on this\n\n        if (zz < epsilon) {\n          x = 0.707106781;\n          y = 0.707106781;\n          z = 0;\n        } else {\n          z = Math.sqrt(zz);\n          x = xz / z;\n          y = yz / z;\n        }\n      }\n\n      this.set(x, y, z, angle);\n\n      return this; // return 180 deg rotation\n    }\n\n    // as we have reached here there are no singularities so we can handle normally\n\n    let s = Math.sqrt(\n      (m32 - m23) * (m32 - m23) +\n        (m13 - m31) * (m13 - m31) +\n        (m21 - m12) * (m21 - m12),\n    ); // used to normalize\n\n    if (Math.abs(s) < 0.001) s = 1;\n\n    // prevent divide by zero, should not happen if matrix is orthogonal and should be\n    // caught by singularity test above, but I've left it in just in case\n\n    this.x = (m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n\n    return this;\n  }\n\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    this.w = Math.min(this.w, v.w);\n\n    return this;\n  }\n\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    this.w = Math.max(this.w, v.w);\n\n    return this;\n  }\n\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n    this.w = Math.max(min.w, Math.min(max.w, this.w));\n\n    return this;\n  }\n\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    this.w = Math.max(minVal, Math.min(maxVal, this.w));\n\n    return this;\n  }\n\n  clampLength(min, max) {\n    const length = this.length();\n\n    return this.divideScalar(length || 1).multiplyScalar(\n      Math.max(min, Math.min(max, length)),\n    );\n  }\n\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = Math.floor(this.w);\n\n    return this;\n  }\n\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n\n    return this;\n  }\n\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = Math.round(this.w);\n\n    return this;\n  }\n\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n\n    return this;\n  }\n\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n\n    return this;\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n\n  lengthSq() {\n    return (\n      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w\n    );\n  }\n\n  length() {\n    return Math.sqrt(\n      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,\n    );\n  }\n\n  manhattanLength() {\n    return (\n      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)\n    );\n  }\n\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n\n    return this;\n  }\n\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n\n    return this;\n  }\n\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n  }\n\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== undefined) {\n      console.warn(\n        'THREE.Vector4: offset has been removed from .fromBufferAttribute().',\n      );\n    }\n\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    this.w = attribute.getW(index);\n\n    return this;\n  }\n\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    this.w = Math.random();\n\n    return this;\n  }\n\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n    yield this.w;\n  }\n}\n\nVector4.prototype.isVector4 = true;\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass WebGLRenderTarget extends EventDispatcher {\n  constructor(width, height, options = {}) {\n    super();\n\n    this.width = width;\n    this.height = height;\n    this.depth = 1;\n\n    this.scissor = new Vector4(0, 0, width, height);\n    this.scissorTest = false;\n\n    this.viewport = new Vector4(0, 0, width, height);\n\n    this.texture = new Texture$1(\n      undefined,\n      options.mapping,\n      options.wrapS,\n      options.wrapT,\n      options.magFilter,\n      options.minFilter,\n      options.format,\n      options.type,\n      options.anisotropy,\n      options.encoding,\n    );\n    this.texture.isRenderTargetTexture = true;\n\n    this.texture.image = { width: width, height: height, depth: 1 };\n\n    this.texture.generateMipmaps =\n      options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    this.texture.internalFormat =\n      options.internalFormat !== undefined ? options.internalFormat : null;\n    this.texture.minFilter =\n      options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n    this.depthBuffer =\n      options.depthBuffer !== undefined ? options.depthBuffer : true;\n    this.stencilBuffer =\n      options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n    this.depthTexture =\n      options.depthTexture !== undefined ? options.depthTexture : null;\n  }\n\n  setTexture(texture) {\n    texture.image = {\n      width: this.width,\n      height: this.height,\n      depth: this.depth,\n    };\n\n    this.texture = texture;\n  }\n\n  setSize(width, height, depth = 1) {\n    if (\n      this.width !== width ||\n      this.height !== height ||\n      this.depth !== depth\n    ) {\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n\n      this.texture.image.width = width;\n      this.texture.image.height = height;\n      this.texture.image.depth = depth;\n\n      this.dispose();\n    }\n\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, width, height);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.width = source.width;\n    this.height = source.height;\n    this.depth = source.depth;\n\n    this.viewport.copy(source.viewport);\n\n    this.texture = source.texture.clone();\n    this.texture.image = { ...this.texture.image }; // See #20328.\n\n    this.depthBuffer = source.depthBuffer;\n    this.stencilBuffer = source.stencilBuffer;\n    this.depthTexture = source.depthTexture;\n\n    return this;\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' });\n  }\n}\n\nWebGLRenderTarget.prototype.isWebGLRenderTarget = true;\n\nclass WebGLMultipleRenderTargets extends WebGLRenderTarget {\n  constructor(width, height, count) {\n    super(width, height);\n\n    const texture = this.texture;\n\n    this.texture = [];\n\n    for (let i = 0; i < count; i++) {\n      this.texture[i] = texture.clone();\n    }\n  }\n\n  setSize(width, height, depth = 1) {\n    if (\n      this.width !== width ||\n      this.height !== height ||\n      this.depth !== depth\n    ) {\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n\n      for (let i = 0, il = this.texture.length; i < il; i++) {\n        this.texture[i].image.width = width;\n        this.texture[i].image.height = height;\n        this.texture[i].image.depth = depth;\n      }\n\n      this.dispose();\n    }\n\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, width, height);\n\n    return this;\n  }\n\n  copy(source) {\n    this.dispose();\n\n    this.width = source.width;\n    this.height = source.height;\n    this.depth = source.depth;\n\n    this.viewport.set(0, 0, this.width, this.height);\n    this.scissor.set(0, 0, this.width, this.height);\n\n    this.depthBuffer = source.depthBuffer;\n    this.stencilBuffer = source.stencilBuffer;\n    this.depthTexture = source.depthTexture;\n\n    this.texture.length = 0;\n\n    for (let i = 0, il = source.texture.length; i < il; i++) {\n      this.texture[i] = source.texture[i].clone();\n    }\n\n    return this;\n  }\n}\n\nWebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;\n\nclass WebGLMultisampleRenderTarget extends WebGLRenderTarget {\n  constructor(width, height, options) {\n    super(width, height, options);\n\n    this.samples = 4;\n  }\n\n  copy(source) {\n    super.copy.call(this, source);\n\n    this.samples = source.samples;\n\n    return this;\n  }\n}\n\nWebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;\n\nclass Quaternion {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n\n  static slerp(qa, qb, qm, t) {\n    console.warn(\n      'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.',\n    );\n    return qm.slerpQuaternions(qa, qb, t);\n  }\n\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n    // fuzz-free, array-based Quaternion SLERP operation\n\n    let x0 = src0[srcOffset0 + 0],\n      y0 = src0[srcOffset0 + 1],\n      z0 = src0[srcOffset0 + 2],\n      w0 = src0[srcOffset0 + 3];\n\n    const x1 = src1[srcOffset1 + 0],\n      y1 = src1[srcOffset1 + 1],\n      z1 = src1[srcOffset1 + 2],\n      w1 = src1[srcOffset1 + 3];\n\n    if (t === 0) {\n      dst[dstOffset + 0] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n      return;\n    }\n\n    if (t === 1) {\n      dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset + 2] = z1;\n      dst[dstOffset + 3] = w1;\n      return;\n    }\n\n    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - t;\n      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n        dir = cos >= 0 ? 1 : -1,\n        sqrSin = 1 - cos * cos;\n\n      // Skip the Slerp for tiny steps to avoid numeric problems:\n      if (sqrSin > Number.EPSILON) {\n        const sin = Math.sqrt(sqrSin),\n          len = Math.atan2(sin, cos * dir);\n\n        s = Math.sin(s * len) / sin;\n        t = Math.sin(t * len) / sin;\n      }\n\n      const tDir = t * dir;\n\n      x0 = x0 * s + x1 * tDir;\n      y0 = y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w0 = w0 * s + w1 * tDir;\n\n      // Normalize in case we just did a lerp:\n      if (s === 1 - t) {\n        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n\n        x0 *= f;\n        y0 *= f;\n        z0 *= f;\n        w0 *= f;\n      }\n    }\n\n    dst[dstOffset] = x0;\n    dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + 3] = w0;\n  }\n\n  static multiplyQuaternionsFlat(\n    dst,\n    dstOffset,\n    src0,\n    srcOffset0,\n    src1,\n    srcOffset1,\n  ) {\n    const x0 = src0[srcOffset0];\n    const y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const w0 = src0[srcOffset0 + 3];\n\n    const x1 = src1[srcOffset1];\n    const y1 = src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w1 = src1[srcOffset1 + 3];\n\n    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n    return dst;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n\n  get z() {\n    return this._z;\n  }\n\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n\n  get w() {\n    return this._w;\n  }\n\n  set w(value) {\n    this._w = value;\n    this._onChangeCallback();\n  }\n\n  set(x, y, z, w) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._w);\n  }\n\n  copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromEuler(euler, update) {\n    if (!(euler && euler.isEuler)) {\n      throw new Error(\n        'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',\n      );\n    }\n\n    const x = euler._x,\n      y = euler._y,\n      z = euler._z,\n      order = euler._order;\n\n    // http://www.mathworks.com/matlabcentral/fileexchange/\n    // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    //\tcontent/SpinCalc.m\n\n    const cos = Math.cos;\n    const sin = Math.sin;\n\n    const c1 = cos(x / 2);\n    const c2 = cos(y / 2);\n    const c3 = cos(z / 2);\n\n    const s1 = sin(x / 2);\n    const s2 = sin(y / 2);\n    const s3 = sin(z / 2);\n\n    switch (order) {\n      case 'XYZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'YXZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      case 'ZXY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'ZYX':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      case 'YZX':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'XZY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      default:\n        console.warn(\n          'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +\n            order,\n        );\n    }\n\n    if (update !== false) this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromAxisAngle(axis, angle) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n    // assumes axis is normalized\n\n    const halfAngle = angle / 2,\n      s = Math.sin(halfAngle);\n\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    const te = m.elements,\n      m11 = te[0],\n      m12 = te[4],\n      m13 = te[8],\n      m21 = te[1],\n      m22 = te[5],\n      m23 = te[9],\n      m31 = te[2],\n      m32 = te[6],\n      m33 = te[10],\n      trace = m11 + m22 + m33;\n\n    if (trace > 0) {\n      const s = 0.5 / Math.sqrt(trace + 1.0);\n\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromUnitVectors(vFrom, vTo) {\n    // assumes direction vectors vFrom and vTo are normalized\n\n    let r = vFrom.dot(vTo) + 1;\n\n    if (r < Number.EPSILON) {\n      // vFrom and vTo point in opposite directions\n\n      r = 0;\n\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = -vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w = r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n        this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      this._w = r;\n    }\n\n    return this.normalize();\n  }\n\n  angleTo(q) {\n    return 2 * Math.acos(Math.abs(clamp$1(this.dot(q), -1, 1)));\n  }\n\n  rotateTowards(q, step) {\n    const angle = this.angleTo(q);\n\n    if (angle === 0) return this;\n\n    const t = Math.min(1, step / angle);\n\n    this.slerp(q, t);\n\n    return this;\n  }\n\n  identity() {\n    return this.set(0, 0, 0, 1);\n  }\n\n  invert() {\n    // quaternion is assumed to have unit length\n\n    return this.conjugate();\n  }\n\n  conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  dot(v) {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n\n  lengthSq() {\n    return (\n      this._x * this._x +\n      this._y * this._y +\n      this._z * this._z +\n      this._w * this._w\n    );\n  }\n\n  length() {\n    return Math.sqrt(\n      this._x * this._x +\n        this._y * this._y +\n        this._z * this._z +\n        this._w * this._w,\n    );\n  }\n\n  normalize() {\n    let l = this.length();\n\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  multiply(q, p) {\n    if (p !== undefined) {\n      console.warn(\n        'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.',\n      );\n      return this.multiplyQuaternions(q, p);\n    }\n\n    return this.multiplyQuaternions(this, q);\n  }\n\n  premultiply(q) {\n    return this.multiplyQuaternions(q, this);\n  }\n\n  multiplyQuaternions(a, b) {\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n    const qax = a._x,\n      qay = a._y,\n      qaz = a._z,\n      qaw = a._w;\n    const qbx = b._x,\n      qby = b._y,\n      qbz = b._z,\n      qbw = b._w;\n\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  slerp(qb, t) {\n    if (t === 0) return this;\n    if (t === 1) return this.copy(qb);\n\n    const x = this._x,\n      y = this._y,\n      z = this._z,\n      w = this._w;\n\n    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n\n    if (cosHalfTheta >= 1.0) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n\n      return this;\n    }\n\n    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n    if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t;\n      this._w = s * w + t * this._w;\n      this._x = s * x + t * this._x;\n      this._y = s * y + t * this._y;\n      this._z = s * z + t * this._z;\n\n      this.normalize();\n      this._onChangeCallback();\n\n      return this;\n    }\n\n    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n      ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  slerpQuaternions(qa, qb, t) {\n    this.copy(qa).slerp(qb, t);\n  }\n\n  random() {\n    // Derived from http://planning.cs.uiuc.edu/node198.html\n    // Note, this source uses w, x, y, z ordering,\n    // so we swap the order below.\n\n    const u1 = Math.random();\n    const sqrt1u1 = Math.sqrt(1 - u1);\n    const sqrtu1 = Math.sqrt(u1);\n\n    const u2 = 2 * Math.PI * Math.random();\n\n    const u3 = 2 * Math.PI * Math.random();\n\n    return this.set(\n      sqrt1u1 * Math.cos(u2),\n      sqrtu1 * Math.sin(u3),\n      sqrtu1 * Math.cos(u3),\n      sqrt1u1 * Math.sin(u2),\n    );\n  }\n\n  equals(quaternion) {\n    return (\n      quaternion._x === this._x &&\n      quaternion._y === this._y &&\n      quaternion._z === this._z &&\n      quaternion._w === this._w\n    );\n  }\n\n  fromArray(array, offset = 0) {\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index) {\n    this._x = attribute.getX(index);\n    this._y = attribute.getY(index);\n    this._z = attribute.getZ(index);\n    this._w = attribute.getW(index);\n\n    return this;\n  }\n\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n\n    return this;\n  }\n\n  _onChangeCallback() {}\n}\n\nQuaternion.prototype.isQuaternion = true;\n\nclass Vector3 {\n  constructor(x = 0, y = 0, z = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  set(x, y, z) {\n    if (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n\n    return this;\n  }\n\n  setX(x) {\n    this.x = x;\n\n    return this;\n  }\n\n  setY(y) {\n    this.y = y;\n\n    return this;\n  }\n\n  setZ(z) {\n    this.z = z;\n\n    return this;\n  }\n\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n\n    return this;\n  }\n\n  add(v, w) {\n    if (w !== undefined) {\n      console.warn(\n        'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',\n      );\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n\n    return this;\n  }\n\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n\n    return this;\n  }\n\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n\n    return this;\n  }\n\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n\n    return this;\n  }\n\n  sub(v, w) {\n    if (w !== undefined) {\n      console.warn(\n        'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',\n      );\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n\n    return this;\n  }\n\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n\n    return this;\n  }\n\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n\n    return this;\n  }\n\n  multiply(v, w) {\n    if (w !== undefined) {\n      console.warn(\n        'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.',\n      );\n      return this.multiplyVectors(v, w);\n    }\n\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n\n    return this;\n  }\n\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n\n    return this;\n  }\n\n  multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n\n    return this;\n  }\n\n  applyEuler(euler) {\n    if (!(euler && euler.isEuler)) {\n      console.error(\n        'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',\n      );\n    }\n\n    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n  }\n\n  applyAxisAngle(axis, angle) {\n    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n  }\n\n  applyMatrix3(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n\n    return this;\n  }\n\n  applyNormalMatrix(m) {\n    return this.applyMatrix3(m).normalize();\n  }\n\n  applyMatrix4(m) {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n\n    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n\n    return this;\n  }\n\n  applyQuaternion(q) {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const qx = q.x,\n      qy = q.y,\n      qz = q.z,\n      qw = q.w;\n\n    // calculate quat * vector\n\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n    return this;\n  }\n\n  project(camera) {\n    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(\n      camera.projectionMatrix,\n    );\n  }\n\n  unproject(camera) {\n    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(\n      camera.matrixWorld,\n    );\n  }\n\n  transformDirection(m) {\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n\n    return this.normalize();\n  }\n\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n\n    return this;\n  }\n\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n\n    return this;\n  }\n\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n\n    return this;\n  }\n\n  clamp(min, max) {\n    // assumes min < max, componentwise\n\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n\n    return this;\n  }\n\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n\n    return this;\n  }\n\n  clampLength(min, max) {\n    const length = this.length();\n\n    return this.divideScalar(length || 1).multiplyScalar(\n      Math.max(min, Math.min(max, length)),\n    );\n  }\n\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n\n    return this;\n  }\n\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n\n    return this;\n  }\n\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n\n    return this;\n  }\n\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\n    return this;\n  }\n\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n\n    return this;\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  }\n\n  // TODO lengthSquared?\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  }\n\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n\n    return this;\n  }\n\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n\n    return this;\n  }\n\n  cross(v, w) {\n    if (w !== undefined) {\n      console.warn(\n        'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.',\n      );\n      return this.crossVectors(v, w);\n    }\n\n    return this.crossVectors(this, v);\n  }\n\n  crossVectors(a, b) {\n    const ax = a.x,\n      ay = a.y,\n      az = a.z;\n    const bx = b.x,\n      by = b.y,\n      bz = b.z;\n\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n\n    return this;\n  }\n\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n\n    if (denominator === 0) return this.set(0, 0, 0);\n\n    const scalar = v.dot(this) / denominator;\n\n    return this.copy(v).multiplyScalar(scalar);\n  }\n\n  projectOnPlane(planeNormal) {\n    _vector$c.copy(this).projectOnVector(planeNormal);\n\n    return this.sub(_vector$c);\n  }\n\n  reflect(normal) {\n    // reflect incident vector off plane orthogonal to normal\n    // normal is assumed to have unit length\n\n    return this.sub(\n      _vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)),\n    );\n  }\n\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n\n    if (denominator === 0) return Math.PI / 2;\n\n    const theta = this.dot(v) / denominator;\n\n    // clamp, to handle numerical problems\n\n    return Math.acos(clamp$1(theta, -1, 1));\n  }\n\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n      dy = this.y - v.y,\n      dz = this.z - v.z;\n\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  manhattanDistanceTo(v) {\n    return (\n      Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)\n    );\n  }\n\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n  }\n\n  setFromSphericalCoords(radius, phi, theta) {\n    const sinPhiRadius = Math.sin(phi) * radius;\n\n    this.x = sinPhiRadius * Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = sinPhiRadius * Math.cos(theta);\n\n    return this;\n  }\n\n  setFromCylindrical(c) {\n    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n  }\n\n  setFromCylindricalCoords(radius, theta, y) {\n    this.x = radius * Math.sin(theta);\n    this.y = y;\n    this.z = radius * Math.cos(theta);\n\n    return this;\n  }\n\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n\n    return this;\n  }\n\n  setFromMatrixScale(m) {\n    const sx = this.setFromMatrixColumn(m, 0).length();\n    const sy = this.setFromMatrixColumn(m, 1).length();\n    const sz = this.setFromMatrixColumn(m, 2).length();\n\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n\n    return this;\n  }\n\n  setFromMatrixColumn(m, index) {\n    return this.fromArray(m.elements, index * 4);\n  }\n\n  setFromMatrix3Column(m, index) {\n    return this.fromArray(m.elements, index * 3);\n  }\n\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  }\n\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== undefined) {\n      console.warn(\n        'THREE.Vector3: offset has been removed from .fromBufferAttribute().',\n      );\n    }\n\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n\n    return this;\n  }\n\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n\n    return this;\n  }\n\n  randomDirection() {\n    // Derived from https://mathworld.wolfram.com/SpherePointPicking.html\n\n    const u = (Math.random() - 0.5) * 2;\n    const t = Math.random() * Math.PI * 2;\n    const f = Math.sqrt(1 - u ** 2);\n\n    this.x = f * Math.cos(t);\n    this.y = f * Math.sin(t);\n    this.z = u;\n\n    return this;\n  }\n\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n  }\n}\n\nVector3.prototype.isVector3 = true;\n\nconst _vector$c = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n  constructor(\n    min = new Vector3(+Infinity, +Infinity, +Infinity),\n    max = new Vector3(-Infinity, -Infinity, -Infinity),\n  ) {\n    this.min = min;\n    this.max = max;\n  }\n\n  set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n\n    return this;\n  }\n\n  setFromArray(array) {\n    let minX = +Infinity;\n    let minY = +Infinity;\n    let minZ = +Infinity;\n\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n\n    return this;\n  }\n\n  setFromBufferAttribute(attribute) {\n    let minX = +Infinity;\n    let minY = +Infinity;\n    let minZ = +Infinity;\n\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n\n    for (let i = 0, l = attribute.count; i < l; i++) {\n      const x = attribute.getX(i);\n      const y = attribute.getY(i);\n      const z = attribute.getZ(i);\n\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n\n    return this;\n  }\n\n  setFromPoints(points) {\n    this.makeEmpty();\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n\n    return this;\n  }\n\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n\n    return this;\n  }\n\n  setFromObject(object) {\n    this.makeEmpty();\n\n    return this.expandByObject(object);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n\n    return this;\n  }\n\n  makeEmpty() {\n    this.min.x = this.min.y = this.min.z = +Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n\n    return this;\n  }\n\n  isEmpty() {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n    return (\n      this.max.x < this.min.x ||\n      this.max.y < this.min.y ||\n      this.max.z < this.min.z\n    );\n  }\n\n  getCenter(target) {\n    return this.isEmpty()\n      ? target.set(0, 0, 0)\n      : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n\n  getSize(target) {\n    return this.isEmpty()\n      ? target.set(0, 0, 0)\n      : target.subVectors(this.max, this.min);\n  }\n\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n\n    return this;\n  }\n\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n\n    return this;\n  }\n\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n\n    return this;\n  }\n\n  expandByObject(object) {\n    // Computes the world-axis-aligned bounding box of an object (including its children),\n    // accounting for both the object's, and children's, world transforms\n\n    object.updateWorldMatrix(false, false);\n\n    const geometry = object.geometry;\n\n    if (geometry !== undefined) {\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n\n      _box$3.copy(geometry.boundingBox);\n      _box$3.applyMatrix4(object.matrixWorld);\n\n      this.union(_box$3);\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      this.expandByObject(children[i]);\n    }\n\n    return this;\n  }\n\n  containsPoint(point) {\n    return point.x < this.min.x ||\n      point.x > this.max.x ||\n      point.y < this.min.y ||\n      point.y > this.max.y ||\n      point.z < this.min.z ||\n      point.z > this.max.z\n      ? false\n      : true;\n  }\n\n  containsBox(box) {\n    return (\n      this.min.x <= box.min.x &&\n      box.max.x <= this.max.x &&\n      this.min.y <= box.min.y &&\n      box.max.y <= this.max.y &&\n      this.min.z <= box.min.z &&\n      box.max.z <= this.max.z\n    );\n  }\n\n  getParameter(point, target) {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n\n    return target.set(\n      (point.x - this.min.x) / (this.max.x - this.min.x),\n      (point.y - this.min.y) / (this.max.y - this.min.y),\n      (point.z - this.min.z) / (this.max.z - this.min.z),\n    );\n  }\n\n  intersectsBox(box) {\n    // using 6 splitting planes to rule out intersections.\n    return box.max.x < this.min.x ||\n      box.min.x > this.max.x ||\n      box.max.y < this.min.y ||\n      box.min.y > this.max.y ||\n      box.max.z < this.min.z ||\n      box.min.z > this.max.z\n      ? false\n      : true;\n  }\n\n  intersectsSphere(sphere) {\n    // Find the point on the AABB closest to the sphere center.\n    this.clampPoint(sphere.center, _vector$b);\n\n    // If that point is inside the sphere, the AABB and sphere intersect.\n    return (\n      _vector$b.distanceToSquared(sphere.center) <=\n      sphere.radius * sphere.radius\n    );\n  }\n\n  intersectsPlane(plane) {\n    // We compute the minimum and maximum dot product values. If those values\n    // are on the same side (back or front) of the plane, then there is no intersection.\n\n    let min, max;\n\n    if (plane.normal.x > 0) {\n      min = plane.normal.x * this.min.x;\n      max = plane.normal.x * this.max.x;\n    } else {\n      min = plane.normal.x * this.max.x;\n      max = plane.normal.x * this.min.x;\n    }\n\n    if (plane.normal.y > 0) {\n      min += plane.normal.y * this.min.y;\n      max += plane.normal.y * this.max.y;\n    } else {\n      min += plane.normal.y * this.max.y;\n      max += plane.normal.y * this.min.y;\n    }\n\n    if (plane.normal.z > 0) {\n      min += plane.normal.z * this.min.z;\n      max += plane.normal.z * this.max.z;\n    } else {\n      min += plane.normal.z * this.max.z;\n      max += plane.normal.z * this.min.z;\n    }\n\n    return min <= -plane.constant && max >= -plane.constant;\n  }\n\n  intersectsTriangle(triangle) {\n    if (this.isEmpty()) {\n      return false;\n    }\n\n    // compute box center and extents\n    this.getCenter(_center);\n    _extents.subVectors(this.max, _center);\n\n    // translate triangle to aabb origin\n    _v0$2.subVectors(triangle.a, _center);\n    _v1$7.subVectors(triangle.b, _center);\n    _v2$3.subVectors(triangle.c, _center);\n\n    // compute edge vectors for triangle\n    _f0.subVectors(_v1$7, _v0$2);\n    _f1.subVectors(_v2$3, _v1$7);\n    _f2.subVectors(_v0$2, _v2$3);\n\n    // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n    let axes = [\n      0,\n      -_f0.z,\n      _f0.y,\n      0,\n      -_f1.z,\n      _f1.y,\n      0,\n      -_f2.z,\n      _f2.y,\n      _f0.z,\n      0,\n      -_f0.x,\n      _f1.z,\n      0,\n      -_f1.x,\n      _f2.z,\n      0,\n      -_f2.x,\n      -_f0.y,\n      _f0.x,\n      0,\n      -_f1.y,\n      _f1.x,\n      0,\n      -_f2.y,\n      _f2.x,\n      0,\n    ];\n    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n      return false;\n    }\n\n    // test 3 face normals from the aabb\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n      return false;\n    }\n\n    // finally testing the face normal of the triangle\n    // use already existing triangle edge vectors here\n    _triangleNormal.crossVectors(_f0, _f1);\n    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n\n    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);\n  }\n\n  clampPoint(point, target) {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n\n  distanceToPoint(point) {\n    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);\n\n    return clampedPoint.sub(point).length();\n  }\n\n  getBoundingSphere(target) {\n    this.getCenter(target.center);\n\n    target.radius = this.getSize(_vector$b).length() * 0.5;\n\n    return target;\n  }\n\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n\n    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n    if (this.isEmpty()) this.makeEmpty();\n\n    return this;\n  }\n\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n\n    return this;\n  }\n\n  applyMatrix4(matrix) {\n    // transform of empty box is an empty box.\n    if (this.isEmpty()) return this;\n\n    // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n    this.setFromPoints(_points);\n\n    return this;\n  }\n\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n\n    return this;\n  }\n\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}\n\nBox3.prototype.isBox3 = true;\n\nconst _points = [\n  /*@__PURE__*/ new Vector3(),\n  /*@__PURE__*/ new Vector3(),\n  /*@__PURE__*/ new Vector3(),\n  /*@__PURE__*/ new Vector3(),\n  /*@__PURE__*/ new Vector3(),\n  /*@__PURE__*/ new Vector3(),\n  /*@__PURE__*/ new Vector3(),\n  /*@__PURE__*/ new Vector3(),\n];\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\n\nconst _box$3 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes(axes, v0, v1, v2, extents) {\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i);\n    // project the aabb onto the seperating axis\n    const r =\n      extents.x * Math.abs(_testAxis.x) +\n      extents.y * Math.abs(_testAxis.y) +\n      extents.z * Math.abs(_testAxis.z);\n    // project all 3 vertices of the triangle onto the seperating axis\n    const p0 = v0.dot(_testAxis);\n    const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis);\n    // actual test, basically see if either of the most extreme of the triangle points intersects r\n    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      // points of the projected triangle are outside the projected half-length of the aabb\n      // the axis is seperating and we can exit\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _toFarthestPoint = /*@__PURE__*/ new Vector3();\nconst _toPoint = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n  constructor(center = new Vector3(), radius = -1) {\n    this.center = center;\n    this.radius = radius;\n  }\n\n  set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n\n    return this;\n  }\n\n  setFromPoints(points, optionalCenter) {\n    const center = this.center;\n\n    if (optionalCenter !== undefined) {\n      center.copy(optionalCenter);\n    } else {\n      _box$2.setFromPoints(points).getCenter(center);\n    }\n\n    let maxRadiusSq = 0;\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n\n    this.radius = Math.sqrt(maxRadiusSq);\n\n    return this;\n  }\n\n  copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n\n    return this;\n  }\n\n  isEmpty() {\n    return this.radius < 0;\n  }\n\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n\n    return this;\n  }\n\n  containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n\n  distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  }\n\n  intersectsSphere(sphere) {\n    const radiusSum = this.radius + sphere.radius;\n\n    return (\n      sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum\n    );\n  }\n\n  intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n\n  intersectsPlane(plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n\n  clampPoint(point, target) {\n    const deltaLengthSq = this.center.distanceToSquared(point);\n\n    target.copy(point);\n\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n\n    return target;\n  }\n\n  getBoundingBox(target) {\n    if (this.isEmpty()) {\n      // Empty sphere produces empty bounding box\n      target.makeEmpty();\n      return target;\n    }\n\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n\n    return target;\n  }\n\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n    return this;\n  }\n\n  translate(offset) {\n    this.center.add(offset);\n\n    return this;\n  }\n\n  expandByPoint(point) {\n    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n\n    _toPoint.subVectors(point, this.center);\n\n    const lengthSq = _toPoint.lengthSq();\n\n    if (lengthSq > this.radius * this.radius) {\n      const length = Math.sqrt(lengthSq);\n      const missingRadiusHalf = (length - this.radius) * 0.5;\n\n      // Nudge this sphere towards the target point. Add half the missing distance to radius,\n      // and the other half to position. This gives a tighter enclosure, instead of if\n      // the whole missing distance were just added to radius.\n\n      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n      this.radius += missingRadiusHalf;\n    }\n\n    return this;\n  }\n\n  union(sphere) {\n    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n\n    // To enclose another sphere into this sphere, we only need to enclose two points:\n    // 1) Enclose the farthest point on the other sphere into this sphere.\n    // 2) Enclose the opposite point of the farthest point into this sphere.\n\n    _toFarthestPoint\n      .subVectors(sphere.center, this.center)\n      .normalize()\n      .multiplyScalar(sphere.radius);\n\n    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));\n    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));\n\n    return this;\n  }\n\n  equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n    this.origin = origin;\n    this.direction = direction;\n  }\n\n  set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n\n    return this;\n  }\n\n  copy(ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n\n    return this;\n  }\n\n  at(t, target) {\n    return target.copy(this.direction).multiplyScalar(t).add(this.origin);\n  }\n\n  lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n\n    return this;\n  }\n\n  recast(t) {\n    this.origin.copy(this.at(t, _vector$a));\n\n    return this;\n  }\n\n  closestPointToPoint(point, target) {\n    target.subVectors(point, this.origin);\n\n    const directionDistance = target.dot(this.direction);\n\n    if (directionDistance < 0) {\n      return target.copy(this.origin);\n    }\n\n    return target\n      .copy(this.direction)\n      .multiplyScalar(directionDistance)\n      .add(this.origin);\n  }\n\n  distanceToPoint(point) {\n    return Math.sqrt(this.distanceSqToPoint(point));\n  }\n\n  distanceSqToPoint(point) {\n    const directionDistance = _vector$a\n      .subVectors(point, this.origin)\n      .dot(this.direction);\n\n    // point behind the ray\n\n    if (directionDistance < 0) {\n      return this.origin.distanceToSquared(point);\n    }\n\n    _vector$a\n      .copy(this.direction)\n      .multiplyScalar(directionDistance)\n      .add(this.origin);\n\n    return _vector$a.distanceToSquared(point);\n  }\n\n  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n    // It returns the min distance between the ray and the segment\n    // defined by v0 and v1\n    // It can also set two optional targets :\n    // - The closest point on the ray\n    // - The closest point on the segment\n\n    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n    _segDir.copy(v1).sub(v0).normalize();\n    _diff.copy(this.origin).sub(_segCenter);\n\n    const segExtent = v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir);\n    const b0 = _diff.dot(this.direction);\n    const b1 = -_diff.dot(_segDir);\n    const c = _diff.lengthSq();\n    const det = Math.abs(1 - a01 * a01);\n    let s0, s1, sqrDist, extDet;\n\n    if (det > 0) {\n      // The ray and segment are not parallel.\n\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            // region 0\n            // Minimum at interior points of ray and segment.\n\n            const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= invDet;\n            sqrDist =\n              s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n          } else {\n            // region 1\n\n            s1 = segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          // region 5\n\n          s1 = -segExtent;\n          s0 = Math.max(0, -(a01 * s1 + b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      } else {\n        if (s1 <= -extDet) {\n          // region 4\n\n          s0 = Math.max(0, -(-a01 * segExtent + b0));\n          s1 =\n            s0 > 0\n              ? -segExtent\n              : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        } else if (s1 <= extDet) {\n          // region 3\n\n          s0 = 0;\n          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 + 2 * b1) + c;\n        } else {\n          // region 2\n\n          s0 = Math.max(0, -(a01 * segExtent + b0));\n          s1 =\n            s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      }\n    } else {\n      // Ray and segment are parallel.\n\n      s1 = a01 > 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n    }\n\n    if (optionalPointOnRay) {\n      optionalPointOnRay\n        .copy(this.direction)\n        .multiplyScalar(s0)\n        .add(this.origin);\n    }\n\n    if (optionalPointOnSegment) {\n      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n    }\n\n    return sqrDist;\n  }\n\n  intersectSphere(sphere, target) {\n    _vector$a.subVectors(sphere.center, this.origin);\n    const tca = _vector$a.dot(this.direction);\n    const d2 = _vector$a.dot(_vector$a) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n\n    if (d2 > radius2) return null;\n\n    const thc = Math.sqrt(radius2 - d2);\n\n    // t0 = first intersect point - entrance on front of sphere\n    const t0 = tca - thc;\n\n    // t1 = second intersect point - exit point on back of sphere\n    const t1 = tca + thc;\n\n    // test to see if both t0 and t1 are behind the ray - if so, return null\n    if (t0 < 0 && t1 < 0) return null;\n\n    // test to see if t0 is behind the ray:\n    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n    // in order to always return an intersect point that is in front of the ray.\n    if (t0 < 0) return this.at(t1, target);\n\n    // else t0 is in front of the ray, so return the first collision point scaled by t0\n    return this.at(t0, target);\n  }\n\n  intersectsSphere(sphere) {\n    return (\n      this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius\n    );\n  }\n\n  distanceToPlane(plane) {\n    const denominator = plane.normal.dot(this.direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      }\n\n      // Null is preferable to undefined since undefined means.... it is undefined\n\n      return null;\n    }\n\n    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n\n    // Return if the ray never intersects the plane\n\n    return t >= 0 ? t : null;\n  }\n\n  intersectPlane(plane, target) {\n    const t = this.distanceToPlane(plane);\n\n    if (t === null) {\n      return null;\n    }\n\n    return this.at(t, target);\n  }\n\n  intersectsPlane(plane) {\n    // check if the ray lies on the plane first\n\n    const distToPoint = plane.distanceToPoint(this.origin);\n\n    if (distToPoint === 0) {\n      return true;\n    }\n\n    const denominator = plane.normal.dot(this.direction);\n\n    if (denominator * distToPoint < 0) {\n      return true;\n    }\n\n    // ray origin is behind the plane (and is pointing behind it)\n\n    return false;\n  }\n\n  intersectBox(box, target) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n    const invdirx = 1 / this.direction.x,\n      invdiry = 1 / this.direction.y,\n      invdirz = 1 / this.direction.z;\n\n    const origin = this.origin;\n\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n\n    if (tmin > tymax || tymin > tmax) return null;\n\n    // These lines also handle the case where tmin or tmax is NaN\n    // (result of 0 * Infinity). x !== x returns true if x is NaN\n\n    if (tymin > tmin || tmin !== tmin) tmin = tymin;\n\n    if (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n\n    if (tmin > tzmax || tzmin > tmax) return null;\n\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n\n    //return point closest to the ray (positive side)\n\n    if (tmax < 0) return null;\n\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n\n  intersectsBox(box) {\n    return this.intersectBox(box, _vector$a) !== null;\n  }\n\n  intersectTriangle(a, b, c, backfaceCulling, target) {\n    // Compute the offset origin, edges, and normal.\n\n    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n    _edge1.subVectors(b, a);\n    _edge2.subVectors(c, a);\n    _normal$1.crossVectors(_edge1, _edge2);\n\n    // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n    let DdN = this.direction.dot(_normal$1);\n    let sign;\n\n    if (DdN > 0) {\n      if (backfaceCulling) return null;\n      sign = 1;\n    } else if (DdN < 0) {\n      sign = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    }\n\n    _diff.subVectors(this.origin, a);\n    const DdQxE2 =\n      sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n\n    // b1 < 0, no intersection\n    if (DdQxE2 < 0) {\n      return null;\n    }\n\n    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n\n    // b2 < 0, no intersection\n    if (DdE1xQ < 0) {\n      return null;\n    }\n\n    // b1+b2 > 1, no intersection\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    }\n\n    // Line intersects triangle, check if ray does.\n    const QdN = -sign * _diff.dot(_normal$1);\n\n    // t < 0, no intersection\n    if (QdN < 0) {\n      return null;\n    }\n\n    // Ray intersects triangle.\n    return this.at(QdN / DdN, target);\n  }\n\n  applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    this.direction.transformDirection(matrix4);\n\n    return this;\n  }\n\n  equals(ray) {\n    return (\n      ray.origin.equals(this.origin) && ray.direction.equals(this.direction)\n    );\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\n\nclass Matrix4 {\n  constructor() {\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n    if (arguments.length > 0) {\n      console.error(\n        'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.',\n      );\n    }\n  }\n\n  set(\n    n11,\n    n12,\n    n13,\n    n14,\n    n21,\n    n22,\n    n23,\n    n24,\n    n31,\n    n32,\n    n33,\n    n34,\n    n41,\n    n42,\n    n43,\n    n44,\n  ) {\n    const te = this.elements;\n\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n\n    return this;\n  }\n\n  identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  clone() {\n    return new Matrix4().fromArray(this.elements);\n  }\n\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = me[15];\n\n    return this;\n  }\n\n  copyPosition(m) {\n    const te = this.elements,\n      me = m.elements;\n\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n\n    return this;\n  }\n\n  setFromMatrix3(m) {\n    const me = m.elements;\n\n    this.set(\n      me[0],\n      me[3],\n      me[6],\n      0,\n      me[1],\n      me[4],\n      me[7],\n      0,\n      me[2],\n      me[5],\n      me[8],\n      0,\n      0,\n      0,\n      0,\n      1,\n    );\n\n    return this;\n  }\n\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrixColumn(this, 0);\n    yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, 2);\n\n    return this;\n  }\n\n  makeBasis(xAxis, yAxis, zAxis) {\n    this.set(\n      xAxis.x,\n      yAxis.x,\n      zAxis.x,\n      0,\n      xAxis.y,\n      yAxis.y,\n      zAxis.y,\n      0,\n      xAxis.z,\n      yAxis.z,\n      zAxis.z,\n      0,\n      0,\n      0,\n      0,\n      1,\n    );\n\n    return this;\n  }\n\n  extractRotation(m) {\n    // this method does not support reflection matrices\n\n    const te = this.elements;\n    const me = m.elements;\n\n    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n\n    te[0] = me[0] * scaleX;\n    te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n\n    te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * scaleY;\n    te[7] = 0;\n\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n\n    return this;\n  }\n\n  makeRotationFromEuler(euler) {\n    if (!(euler && euler.isEuler)) {\n      console.error(\n        'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.',\n      );\n    }\n\n    const te = this.elements;\n\n    const x = euler.x,\n      y = euler.y,\n      z = euler.z;\n    const a = Math.cos(x),\n      b = Math.sin(x);\n    const c = Math.cos(y),\n      d = Math.sin(y);\n    const e = Math.cos(z),\n      f = Math.sin(z);\n\n    if (euler.order === 'XYZ') {\n      const ae = a * e,\n        af = a * f,\n        be = b * e,\n        bf = b * f;\n\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else if (euler.order === 'YXZ') {\n      const ce = c * e,\n        cf = c * f,\n        de = d * e,\n        df = d * f;\n\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZXY') {\n      const ce = c * e,\n        cf = c * f,\n        de = d * e,\n        df = d * f;\n\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZYX') {\n      const ae = a * e,\n        af = a * f,\n        be = b * e,\n        bf = b * f;\n\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n    } else if (euler.order === 'YZX') {\n      const ac = a * c,\n        ad = a * d,\n        bc = b * c,\n        bd = b * d;\n\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    } else if (euler.order === 'XZY') {\n      const ac = a * c,\n        ad = a * d,\n        bc = b * c,\n        bd = b * d;\n\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n    }\n\n    // bottom row\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n\n    // last column\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n\n    return this;\n  }\n\n  makeRotationFromQuaternion(q) {\n    return this.compose(_zero, q, _one);\n  }\n\n  lookAt(eye, target, up) {\n    const te = this.elements;\n\n    _z.subVectors(eye, target);\n\n    if (_z.lengthSq() === 0) {\n      // eye and target are in the same position\n\n      _z.z = 1;\n    }\n\n    _z.normalize();\n    _x.crossVectors(up, _z);\n\n    if (_x.lengthSq() === 0) {\n      // up and z are parallel\n\n      if (Math.abs(up.z) === 1) {\n        _z.x += 0.0001;\n      } else {\n        _z.z += 0.0001;\n      }\n\n      _z.normalize();\n      _x.crossVectors(up, _z);\n    }\n\n    _x.normalize();\n    _y.crossVectors(_z, _x);\n\n    te[0] = _x.x;\n    te[4] = _y.x;\n    te[8] = _z.x;\n    te[1] = _x.y;\n    te[5] = _y.y;\n    te[9] = _z.y;\n    te[2] = _x.z;\n    te[6] = _y.z;\n    te[10] = _z.z;\n\n    return this;\n  }\n\n  multiply(m, n) {\n    if (n !== undefined) {\n      console.warn(\n        'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.',\n      );\n      return this.multiplyMatrices(m, n);\n    }\n\n    return this.multiplyMatrices(this, m);\n  }\n\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n\n    const a11 = ae[0],\n      a12 = ae[4],\n      a13 = ae[8],\n      a14 = ae[12];\n    const a21 = ae[1],\n      a22 = ae[5],\n      a23 = ae[9],\n      a24 = ae[13];\n    const a31 = ae[2],\n      a32 = ae[6],\n      a33 = ae[10],\n      a34 = ae[14];\n    const a41 = ae[3],\n      a42 = ae[7],\n      a43 = ae[11],\n      a44 = ae[15];\n\n    const b11 = be[0],\n      b12 = be[4],\n      b13 = be[8],\n      b14 = be[12];\n    const b21 = be[1],\n      b22 = be[5],\n      b23 = be[9],\n      b24 = be[13];\n    const b31 = be[2],\n      b32 = be[6],\n      b33 = be[10],\n      b34 = be[14];\n    const b41 = be[3],\n      b42 = be[7],\n      b43 = be[11],\n      b44 = be[15];\n\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n    return this;\n  }\n\n  multiplyScalar(s) {\n    const te = this.elements;\n\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n\n    return this;\n  }\n\n  determinant() {\n    const te = this.elements;\n\n    const n11 = te[0],\n      n12 = te[4],\n      n13 = te[8],\n      n14 = te[12];\n    const n21 = te[1],\n      n22 = te[5],\n      n23 = te[9],\n      n24 = te[13];\n    const n31 = te[2],\n      n32 = te[6],\n      n33 = te[10],\n      n34 = te[14];\n    const n41 = te[3],\n      n42 = te[7],\n      n43 = te[11],\n      n44 = te[15];\n\n    //TODO: make this more efficient\n    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n    return (\n      n41 *\n        (+n14 * n23 * n32 -\n          n13 * n24 * n32 -\n          n14 * n22 * n33 +\n          n12 * n24 * n33 +\n          n13 * n22 * n34 -\n          n12 * n23 * n34) +\n      n42 *\n        (+n11 * n23 * n34 -\n          n11 * n24 * n33 +\n          n14 * n21 * n33 -\n          n13 * n21 * n34 +\n          n13 * n24 * n31 -\n          n14 * n23 * n31) +\n      n43 *\n        (+n11 * n24 * n32 -\n          n11 * n22 * n34 -\n          n14 * n21 * n32 +\n          n12 * n21 * n34 +\n          n14 * n22 * n31 -\n          n12 * n24 * n31) +\n      n44 *\n        (-n13 * n22 * n31 -\n          n11 * n23 * n32 +\n          n11 * n22 * n33 +\n          n13 * n21 * n32 -\n          n12 * n21 * n33 +\n          n12 * n23 * n31)\n    );\n  }\n\n  transpose() {\n    const te = this.elements;\n    let tmp;\n\n    tmp = te[1];\n    te[1] = te[4];\n    te[4] = tmp;\n    tmp = te[2];\n    te[2] = te[8];\n    te[8] = tmp;\n    tmp = te[6];\n    te[6] = te[9];\n    te[9] = tmp;\n\n    tmp = te[3];\n    te[3] = te[12];\n    te[12] = tmp;\n    tmp = te[7];\n    te[7] = te[13];\n    te[13] = tmp;\n    tmp = te[11];\n    te[11] = te[14];\n    te[14] = tmp;\n\n    return this;\n  }\n\n  setPosition(x, y, z) {\n    const te = this.elements;\n\n    if (x.isVector3) {\n      te[12] = x.x;\n      te[13] = x.y;\n      te[14] = x.z;\n    } else {\n      te[12] = x;\n      te[13] = y;\n      te[14] = z;\n    }\n\n    return this;\n  }\n\n  invert() {\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    const te = this.elements,\n      n11 = te[0],\n      n21 = te[1],\n      n31 = te[2],\n      n41 = te[3],\n      n12 = te[4],\n      n22 = te[5],\n      n32 = te[6],\n      n42 = te[7],\n      n13 = te[8],\n      n23 = te[9],\n      n33 = te[10],\n      n43 = te[11],\n      n14 = te[12],\n      n24 = te[13],\n      n34 = te[14],\n      n44 = te[15],\n      t11 =\n        n23 * n34 * n42 -\n        n24 * n33 * n42 +\n        n24 * n32 * n43 -\n        n22 * n34 * n43 -\n        n23 * n32 * n44 +\n        n22 * n33 * n44,\n      t12 =\n        n14 * n33 * n42 -\n        n13 * n34 * n42 -\n        n14 * n32 * n43 +\n        n12 * n34 * n43 +\n        n13 * n32 * n44 -\n        n12 * n33 * n44,\n      t13 =\n        n13 * n24 * n42 -\n        n14 * n23 * n42 +\n        n14 * n22 * n43 -\n        n12 * n24 * n43 -\n        n13 * n22 * n44 +\n        n12 * n23 * n44,\n      t14 =\n        n14 * n23 * n32 -\n        n13 * n24 * n32 -\n        n14 * n22 * n33 +\n        n12 * n24 * n33 +\n        n13 * n22 * n34 -\n        n12 * n23 * n34;\n\n    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n    if (det === 0)\n      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n    const detInv = 1 / det;\n\n    te[0] = t11 * detInv;\n    te[1] =\n      (n24 * n33 * n41 -\n        n23 * n34 * n41 -\n        n24 * n31 * n43 +\n        n21 * n34 * n43 +\n        n23 * n31 * n44 -\n        n21 * n33 * n44) *\n      detInv;\n    te[2] =\n      (n22 * n34 * n41 -\n        n24 * n32 * n41 +\n        n24 * n31 * n42 -\n        n21 * n34 * n42 -\n        n22 * n31 * n44 +\n        n21 * n32 * n44) *\n      detInv;\n    te[3] =\n      (n23 * n32 * n41 -\n        n22 * n33 * n41 -\n        n23 * n31 * n42 +\n        n21 * n33 * n42 +\n        n22 * n31 * n43 -\n        n21 * n32 * n43) *\n      detInv;\n\n    te[4] = t12 * detInv;\n    te[5] =\n      (n13 * n34 * n41 -\n        n14 * n33 * n41 +\n        n14 * n31 * n43 -\n        n11 * n34 * n43 -\n        n13 * n31 * n44 +\n        n11 * n33 * n44) *\n      detInv;\n    te[6] =\n      (n14 * n32 * n41 -\n        n12 * n34 * n41 -\n        n14 * n31 * n42 +\n        n11 * n34 * n42 +\n        n12 * n31 * n44 -\n        n11 * n32 * n44) *\n      detInv;\n    te[7] =\n      (n12 * n33 * n41 -\n        n13 * n32 * n41 +\n        n13 * n31 * n42 -\n        n11 * n33 * n42 -\n        n12 * n31 * n43 +\n        n11 * n32 * n43) *\n      detInv;\n\n    te[8] = t13 * detInv;\n    te[9] =\n      (n14 * n23 * n41 -\n        n13 * n24 * n41 -\n        n14 * n21 * n43 +\n        n11 * n24 * n43 +\n        n13 * n21 * n44 -\n        n11 * n23 * n44) *\n      detInv;\n    te[10] =\n      (n12 * n24 * n41 -\n        n14 * n22 * n41 +\n        n14 * n21 * n42 -\n        n11 * n24 * n42 -\n        n12 * n21 * n44 +\n        n11 * n22 * n44) *\n      detInv;\n    te[11] =\n      (n13 * n22 * n41 -\n        n12 * n23 * n41 -\n        n13 * n21 * n42 +\n        n11 * n23 * n42 +\n        n12 * n21 * n43 -\n        n11 * n22 * n43) *\n      detInv;\n\n    te[12] = t14 * detInv;\n    te[13] =\n      (n13 * n24 * n31 -\n        n14 * n23 * n31 +\n        n14 * n21 * n33 -\n        n11 * n24 * n33 -\n        n13 * n21 * n34 +\n        n11 * n23 * n34) *\n      detInv;\n    te[14] =\n      (n14 * n22 * n31 -\n        n12 * n24 * n31 -\n        n14 * n21 * n32 +\n        n11 * n24 * n32 +\n        n12 * n21 * n34 -\n        n11 * n22 * n34) *\n      detInv;\n    te[15] =\n      (n12 * n23 * n31 -\n        n13 * n22 * n31 +\n        n13 * n21 * n32 -\n        n11 * n23 * n32 -\n        n12 * n21 * n33 +\n        n11 * n22 * n33) *\n      detInv;\n\n    return this;\n  }\n\n  scale(v) {\n    const te = this.elements;\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n\n    return this;\n  }\n\n  getMaxScaleOnAxis() {\n    const te = this.elements;\n\n    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n  }\n\n  makeTranslation(x, y, z) {\n    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeRotationX(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n\n    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeRotationY(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n\n    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeRotationZ(theta) {\n    const c = Math.cos(theta),\n      s = Math.sin(theta);\n\n    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeRotationAxis(axis, angle) {\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const t = 1 - c;\n    const x = axis.x,\n      y = axis.y,\n      z = axis.z;\n    const tx = t * x,\n      ty = t * y;\n\n    this.set(\n      tx * x + c,\n      tx * y - s * z,\n      tx * z + s * y,\n      0,\n      tx * y + s * z,\n      ty * y + c,\n      ty * z - s * x,\n      0,\n      tx * z - s * y,\n      ty * z + s * x,\n      t * z * z + c,\n      0,\n      0,\n      0,\n      0,\n      1,\n    );\n\n    return this;\n  }\n\n  makeScale(x, y, z) {\n    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeShear(xy, xz, yx, yz, zx, zy) {\n    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  compose(position, quaternion, scale) {\n    const te = this.elements;\n\n    const x = quaternion._x,\n      y = quaternion._y,\n      z = quaternion._z,\n      w = quaternion._w;\n    const x2 = x + x,\n      y2 = y + y,\n      z2 = z + z;\n    const xx = x * x2,\n      xy = x * y2,\n      xz = x * z2;\n    const yy = y * y2,\n      yz = y * z2,\n      zz = z * z2;\n    const wx = w * x2,\n      wy = w * y2,\n      wz = w * z2;\n\n    const sx = scale.x,\n      sy = scale.y,\n      sz = scale.z;\n\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n\n    te[12] = position.x;\n    te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n\n    return this;\n  }\n\n  decompose(position, quaternion, scale) {\n    const te = this.elements;\n\n    let sx = _v1$5.set(te[0], te[1], te[2]).length();\n    const sy = _v1$5.set(te[4], te[5], te[6]).length();\n    const sz = _v1$5.set(te[8], te[9], te[10]).length();\n\n    // if determine is negative, we need to invert one scale\n    const det = this.determinant();\n    if (det < 0) sx = -sx;\n\n    position.x = te[12];\n    position.y = te[13];\n    position.z = te[14];\n\n    // scale the rotation part\n    _m1$2.copy(this);\n\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n\n    _m1$2.elements[0] *= invSX;\n    _m1$2.elements[1] *= invSX;\n    _m1$2.elements[2] *= invSX;\n\n    _m1$2.elements[4] *= invSY;\n    _m1$2.elements[5] *= invSY;\n    _m1$2.elements[6] *= invSY;\n\n    _m1$2.elements[8] *= invSZ;\n    _m1$2.elements[9] *= invSZ;\n    _m1$2.elements[10] *= invSZ;\n\n    quaternion.setFromRotationMatrix(_m1$2);\n\n    scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n\n    return this;\n  }\n\n  makePerspective(left, right, top, bottom, near, far) {\n    if (far === undefined) {\n      console.warn(\n        'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.',\n      );\n    }\n\n    const te = this.elements;\n    const x = (2 * near) / (right - left);\n    const y = (2 * near) / (top - bottom);\n\n    const a = (right + left) / (right - left);\n    const b = (top + bottom) / (top - bottom);\n    const c = -(far + near) / (far - near);\n    const d = (-2 * far * near) / (far - near);\n\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n\n    return this;\n  }\n\n  makeOrthographic(left, right, top, bottom, near, far) {\n    const te = this.elements;\n    const w = 1.0 / (right - left);\n    const h = 1.0 / (top - bottom);\n    const p = 1.0 / (far - near);\n\n    const x = (right + left) * w;\n    const y = (top + bottom) * h;\n    const z = (far + near) * p;\n\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = -2 * p;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n\n    return this;\n  }\n\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n\n    for (let i = 0; i < 16; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n\n    return true;\n  }\n\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 16; i++) {\n      this.elements[i] = array[i + offset];\n    }\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n\n    return array;\n  }\n}\n\nMatrix4.prototype.isMatrix4 = true;\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3(0, 0, 0);\nconst _one = /*@__PURE__*/ new Vector3(1, 1, 1);\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix$1 = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n\n  get z() {\n    return this._z;\n  }\n\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n\n  get order() {\n    return this._order;\n  }\n\n  set order(value) {\n    this._order = value;\n    this._onChangeCallback();\n  }\n\n  set(x, y, z, order = this._order) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._order);\n  }\n\n  copy(euler) {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z = euler._z;\n    this._order = euler._order;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromRotationMatrix(m, order = this._order, update = true) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    const te = m.elements;\n    const m11 = te[0],\n      m12 = te[4],\n      m13 = te[8];\n    const m21 = te[1],\n      m22 = te[5],\n      m23 = te[9];\n    const m31 = te[2],\n      m32 = te[6],\n      m33 = te[10];\n\n    switch (order) {\n      case 'XYZ':\n        this._y = Math.asin(clamp$1(m13, -1, 1));\n\n        if (Math.abs(m13) < 0.9999999) {\n          this._x = Math.atan2(-m23, m33);\n          this._z = Math.atan2(-m12, m11);\n        } else {\n          this._x = Math.atan2(m32, m22);\n          this._z = 0;\n        }\n\n        break;\n\n      case 'YXZ':\n        this._x = Math.asin(-clamp$1(m23, -1, 1));\n\n        if (Math.abs(m23) < 0.9999999) {\n          this._y = Math.atan2(m13, m33);\n          this._z = Math.atan2(m21, m22);\n        } else {\n          this._y = Math.atan2(-m31, m11);\n          this._z = 0;\n        }\n\n        break;\n\n      case 'ZXY':\n        this._x = Math.asin(clamp$1(m32, -1, 1));\n\n        if (Math.abs(m32) < 0.9999999) {\n          this._y = Math.atan2(-m31, m33);\n          this._z = Math.atan2(-m12, m22);\n        } else {\n          this._y = 0;\n          this._z = Math.atan2(m21, m11);\n        }\n\n        break;\n\n      case 'ZYX':\n        this._y = Math.asin(-clamp$1(m31, -1, 1));\n\n        if (Math.abs(m31) < 0.9999999) {\n          this._x = Math.atan2(m32, m33);\n          this._z = Math.atan2(m21, m11);\n        } else {\n          this._x = 0;\n          this._z = Math.atan2(-m12, m22);\n        }\n\n        break;\n\n      case 'YZX':\n        this._z = Math.asin(clamp$1(m21, -1, 1));\n\n        if (Math.abs(m21) < 0.9999999) {\n          this._x = Math.atan2(-m23, m22);\n          this._y = Math.atan2(-m31, m11);\n        } else {\n          this._x = 0;\n          this._y = Math.atan2(m13, m33);\n        }\n\n        break;\n\n      case 'XZY':\n        this._z = Math.asin(-clamp$1(m12, -1, 1));\n\n        if (Math.abs(m12) < 0.9999999) {\n          this._x = Math.atan2(m32, m22);\n          this._y = Math.atan2(m13, m11);\n        } else {\n          this._x = Math.atan2(-m23, m33);\n          this._y = 0;\n        }\n\n        break;\n\n      default:\n        console.warn(\n          'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +\n            order,\n        );\n    }\n\n    this._order = order;\n\n    if (update === true) this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromQuaternion(q, order, update) {\n    _matrix$1.makeRotationFromQuaternion(q);\n\n    return this.setFromRotationMatrix(_matrix$1, order, update);\n  }\n\n  setFromVector3(v, order = this._order) {\n    return this.set(v.x, v.y, v.z, order);\n  }\n\n  reorder(newOrder) {\n    // WARNING: this discards revolution information -bhouston\n\n    _quaternion$3.setFromEuler(this);\n\n    return this.setFromQuaternion(_quaternion$3, newOrder);\n  }\n\n  equals(euler) {\n    return (\n      euler._x === this._x &&\n      euler._y === this._y &&\n      euler._z === this._z &&\n      euler._order === this._order\n    );\n  }\n\n  fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    this._z = array[2];\n    if (array[3] !== undefined) this._order = array[3];\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._order;\n\n    return array;\n  }\n\n  toVector3(optionalResult) {\n    if (optionalResult) {\n      return optionalResult.set(this._x, this._y, this._z);\n    } else {\n      return new Vector3(this._x, this._y, this._z);\n    }\n  }\n\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n\n    return this;\n  }\n\n  _onChangeCallback() {}\n}\n\nEuler.prototype.isEuler = true;\n\nEuler.DefaultOrder = 'XYZ';\nEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\n\nclass Layers {\n  constructor() {\n    this.mask = 1 | 0;\n  }\n\n  set(channel) {\n    this.mask = (1 << channel) | 0;\n  }\n\n  enable(channel) {\n    this.mask |= (1 << channel) | 0;\n  }\n\n  enableAll() {\n    this.mask = 0xffffffff | 0;\n  }\n\n  toggle(channel) {\n    this.mask ^= (1 << channel) | 0;\n  }\n\n  disable(channel) {\n    this.mask &= ~((1 << channel) | 0);\n  }\n\n  disableAll() {\n    this.mask = 0;\n  }\n\n  test(layers) {\n    return (this.mask & layers.mask) !== 0;\n  }\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position$3 = /*@__PURE__*/ new Vector3();\nconst _scale$2 = /*@__PURE__*/ new Vector3();\nconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3(1, 0, 0);\nconst _yAxis = /*@__PURE__*/ new Vector3(0, 1, 0);\nconst _zAxis = /*@__PURE__*/ new Vector3(0, 0, 1);\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nclass Object3D extends EventDispatcher {\n  constructor() {\n    super();\n\n    Object.defineProperty(this, 'id', { value: _object3DId++ });\n\n    this.uuid = generateUUID();\n\n    this.name = '';\n    this.type = 'Object3D';\n\n    this.parent = null;\n    this.children = [];\n\n    this.up = Object3D.DefaultUp.clone();\n\n    const position = new Vector3();\n    const rotation = new Euler();\n    const quaternion = new Quaternion();\n    const scale = new Vector3(1, 1, 1);\n\n    function onRotationChange() {\n      quaternion.setFromEuler(rotation, false);\n    }\n\n    function onQuaternionChange() {\n      rotation.setFromQuaternion(quaternion, undefined, false);\n    }\n\n    rotation._onChange(onRotationChange);\n    quaternion._onChange(onQuaternionChange);\n\n    Object.defineProperties(this, {\n      position: {\n        configurable: true,\n        enumerable: true,\n        value: position,\n      },\n      rotation: {\n        configurable: true,\n        enumerable: true,\n        value: rotation,\n      },\n      quaternion: {\n        configurable: true,\n        enumerable: true,\n        value: quaternion,\n      },\n      scale: {\n        configurable: true,\n        enumerable: true,\n        value: scale,\n      },\n      modelViewMatrix: {\n        value: new Matrix4(),\n      },\n      normalMatrix: {\n        value: new Matrix3(),\n      },\n    });\n\n    this.matrix = new Matrix4();\n    this.matrixWorld = new Matrix4();\n\n    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = false;\n\n    this.layers = new Layers();\n    this.visible = true;\n\n    this.castShadow = false;\n    this.receiveShadow = false;\n\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n\n    this.animations = [];\n\n    this.userData = {};\n  }\n\n  onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}\n\n  onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}\n\n  applyMatrix4(matrix) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    this.matrix.premultiply(matrix);\n\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }\n\n  applyQuaternion(q) {\n    this.quaternion.premultiply(q);\n\n    return this;\n  }\n\n  setRotationFromAxisAngle(axis, angle) {\n    // assumes axis is normalized\n\n    this.quaternion.setFromAxisAngle(axis, angle);\n  }\n\n  setRotationFromEuler(euler) {\n    this.quaternion.setFromEuler(euler, true);\n  }\n\n  setRotationFromMatrix(m) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    this.quaternion.setFromRotationMatrix(m);\n  }\n\n  setRotationFromQuaternion(q) {\n    // assumes q is normalized\n\n    this.quaternion.copy(q);\n  }\n\n  rotateOnAxis(axis, angle) {\n    // rotate object on axis in object space\n    // axis is assumed to be normalized\n\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.multiply(_q1);\n\n    return this;\n  }\n\n  rotateOnWorldAxis(axis, angle) {\n    // rotate object on axis in world space\n    // axis is assumed to be normalized\n    // method assumes no rotated parent\n\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.premultiply(_q1);\n\n    return this;\n  }\n\n  rotateX(angle) {\n    return this.rotateOnAxis(_xAxis, angle);\n  }\n\n  rotateY(angle) {\n    return this.rotateOnAxis(_yAxis, angle);\n  }\n\n  rotateZ(angle) {\n    return this.rotateOnAxis(_zAxis, angle);\n  }\n\n  translateOnAxis(axis, distance) {\n    // translate object by distance along axis in object space\n    // axis is assumed to be normalized\n\n    _v1$4.copy(axis).applyQuaternion(this.quaternion);\n\n    this.position.add(_v1$4.multiplyScalar(distance));\n\n    return this;\n  }\n\n  translateX(distance) {\n    return this.translateOnAxis(_xAxis, distance);\n  }\n\n  translateY(distance) {\n    return this.translateOnAxis(_yAxis, distance);\n  }\n\n  translateZ(distance) {\n    return this.translateOnAxis(_zAxis, distance);\n  }\n\n  localToWorld(vector) {\n    return vector.applyMatrix4(this.matrixWorld);\n  }\n\n  worldToLocal(vector) {\n    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n  }\n\n  lookAt(x, y, z) {\n    // This method does not support objects having non-uniformly-scaled parent(s)\n\n    if (x.isVector3) {\n      _target.copy(x);\n    } else {\n      _target.set(x, y, z);\n    }\n\n    const parent = this.parent;\n\n    this.updateWorldMatrix(true, false);\n\n    _position$3.setFromMatrixPosition(this.matrixWorld);\n\n    if (this.isCamera || this.isLight) {\n      _m1$1.lookAt(_position$3, _target, this.up);\n    } else {\n      _m1$1.lookAt(_target, _position$3, this.up);\n    }\n\n    this.quaternion.setFromRotationMatrix(_m1$1);\n\n    if (parent) {\n      _m1$1.extractRotation(parent.matrixWorld);\n      _q1.setFromRotationMatrix(_m1$1);\n      this.quaternion.premultiply(_q1.invert());\n    }\n  }\n\n  add(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n\n      return this;\n    }\n\n    if (object === this) {\n      console.error(\n        \"THREE.Object3D.add: object can't be added as a child of itself.\",\n        object,\n      );\n      return this;\n    }\n\n    if (object && object.isObject3D) {\n      if (object.parent !== null) {\n        object.parent.remove(object);\n      }\n\n      object.parent = this;\n      this.children.push(object);\n\n      object.dispatchEvent(_addedEvent);\n    } else {\n      console.error(\n        'THREE.Object3D.add: object not an instance of THREE.Object3D.',\n        object,\n      );\n    }\n\n    return this;\n  }\n\n  remove(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n\n      return this;\n    }\n\n    const index = this.children.indexOf(object);\n\n    if (index !== -1) {\n      object.parent = null;\n      this.children.splice(index, 1);\n\n      object.dispatchEvent(_removedEvent);\n    }\n\n    return this;\n  }\n\n  removeFromParent() {\n    const parent = this.parent;\n\n    if (parent !== null) {\n      parent.remove(this);\n    }\n\n    return this;\n  }\n\n  clear() {\n    for (let i = 0; i < this.children.length; i++) {\n      const object = this.children[i];\n\n      object.parent = null;\n\n      object.dispatchEvent(_removedEvent);\n    }\n\n    this.children.length = 0;\n\n    return this;\n  }\n\n  attach(object) {\n    // adds object as a child of this, while maintaining the object's world transform\n\n    this.updateWorldMatrix(true, false);\n\n    _m1$1.copy(this.matrixWorld).invert();\n\n    if (object.parent !== null) {\n      object.parent.updateWorldMatrix(true, false);\n\n      _m1$1.multiply(object.parent.matrixWorld);\n    }\n\n    object.applyMatrix4(_m1$1);\n\n    this.add(object);\n\n    object.updateWorldMatrix(false, true);\n\n    return this;\n  }\n\n  getObjectById(id) {\n    return this.getObjectByProperty('id', id);\n  }\n\n  getObjectByName(name) {\n    return this.getObjectByProperty('name', name);\n  }\n\n  getObjectByProperty(name, value) {\n    if (this[name] === value) return this;\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      const child = this.children[i];\n      const object = child.getObjectByProperty(name, value);\n\n      if (object !== undefined) {\n        return object;\n      }\n    }\n\n    return undefined;\n  }\n\n  getWorldPosition(target) {\n    this.updateWorldMatrix(true, false);\n\n    return target.setFromMatrixPosition(this.matrixWorld);\n  }\n\n  getWorldQuaternion(target) {\n    this.updateWorldMatrix(true, false);\n\n    this.matrixWorld.decompose(_position$3, target, _scale$2);\n\n    return target;\n  }\n\n  getWorldScale(target) {\n    this.updateWorldMatrix(true, false);\n\n    this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n\n    return target;\n  }\n\n  getWorldDirection(target) {\n    this.updateWorldMatrix(true, false);\n\n    const e = this.matrixWorld.elements;\n\n    return target.set(e[8], e[9], e[10]).normalize();\n  }\n\n  raycast() {}\n\n  traverse(callback) {\n    callback(this);\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  }\n\n  traverseVisible(callback) {\n    if (this.visible === false) return;\n\n    callback(this);\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  }\n\n  traverseAncestors(callback) {\n    const parent = this.parent;\n\n    if (parent !== null) {\n      callback(parent);\n\n      parent.traverseAncestors(callback);\n    }\n  }\n\n  updateMatrix() {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n\n    this.matrixWorldNeedsUpdate = true;\n  }\n\n  updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n\n      force = true;\n    }\n\n    // update children\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].updateMatrixWorld(force);\n    }\n  }\n\n  updateWorldMatrix(updateParents, updateChildren) {\n    const parent = this.parent;\n\n    if (updateParents === true && parent !== null) {\n      parent.updateWorldMatrix(true, false);\n    }\n\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.parent === null) {\n      this.matrixWorld.copy(this.matrix);\n    } else {\n      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    }\n\n    // update children\n\n    if (updateChildren === true) {\n      const children = this.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateWorldMatrix(false, true);\n      }\n    }\n  }\n\n  toJSON(meta) {\n    // meta is a string when called from JSON.stringify\n    const isRootObject = meta === undefined || typeof meta === 'string';\n\n    const output = {};\n\n    // meta is a hash used to collect geometries, materials.\n    // not providing it implies that this is the root object\n    // being serialized.\n    if (isRootObject) {\n      // initialize meta obj\n      meta = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {},\n        shapes: {},\n        skeletons: {},\n        animations: {},\n      };\n\n      output.metadata = {\n        version: 4.5,\n        type: 'Object',\n        generator: 'Object3D.toJSON',\n      };\n    }\n\n    // standard Object3D serialization\n\n    const object = {};\n\n    object.uuid = this.uuid;\n    object.type = this.type;\n\n    if (this.name !== '') object.name = this.name;\n    if (this.castShadow === true) object.castShadow = true;\n    if (this.receiveShadow === true) object.receiveShadow = true;\n    if (this.visible === false) object.visible = false;\n    if (this.frustumCulled === false) object.frustumCulled = false;\n    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;\n\n    object.layers = this.layers.mask;\n    object.matrix = this.matrix.toArray();\n\n    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n\n    // object specific properties\n\n    if (this.isInstancedMesh) {\n      object.type = 'InstancedMesh';\n      object.count = this.count;\n      object.instanceMatrix = this.instanceMatrix.toJSON();\n      if (this.instanceColor !== null)\n        object.instanceColor = this.instanceColor.toJSON();\n    }\n\n    //\n\n    function serialize(library, element) {\n      if (library[element.uuid] === undefined) {\n        library[element.uuid] = element.toJSON(meta);\n      }\n\n      return element.uuid;\n    }\n\n    if (this.isScene) {\n      if (this.background) {\n        if (this.background.isColor) {\n          object.background = this.background.toJSON();\n        } else if (this.background.isTexture) {\n          object.background = this.background.toJSON(meta).uuid;\n        }\n      }\n\n      if (this.environment && this.environment.isTexture) {\n        object.environment = this.environment.toJSON(meta).uuid;\n      }\n    } else if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = serialize(meta.geometries, this.geometry);\n\n      const parameters = this.geometry.parameters;\n\n      if (parameters !== undefined && parameters.shapes !== undefined) {\n        const shapes = parameters.shapes;\n\n        if (Array.isArray(shapes)) {\n          for (let i = 0, l = shapes.length; i < l; i++) {\n            const shape = shapes[i];\n\n            serialize(meta.shapes, shape);\n          }\n        } else {\n          serialize(meta.shapes, shapes);\n        }\n      }\n    }\n\n    if (this.isSkinnedMesh) {\n      object.bindMode = this.bindMode;\n      object.bindMatrix = this.bindMatrix.toArray();\n\n      if (this.skeleton !== undefined) {\n        serialize(meta.skeletons, this.skeleton);\n\n        object.skeleton = this.skeleton.uuid;\n      }\n    }\n\n    if (this.material !== undefined) {\n      if (Array.isArray(this.material)) {\n        const uuids = [];\n\n        for (let i = 0, l = this.material.length; i < l; i++) {\n          uuids.push(serialize(meta.materials, this.material[i]));\n        }\n\n        object.material = uuids;\n      } else {\n        object.material = serialize(meta.materials, this.material);\n      }\n    }\n\n    //\n\n    if (this.children.length > 0) {\n      object.children = [];\n\n      for (let i = 0; i < this.children.length; i++) {\n        object.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n\n    //\n\n    if (this.animations.length > 0) {\n      object.animations = [];\n\n      for (let i = 0; i < this.animations.length; i++) {\n        const animation = this.animations[i];\n\n        object.animations.push(serialize(meta.animations, animation));\n      }\n    }\n\n    if (isRootObject) {\n      const geometries = extractFromCache(meta.geometries);\n      const materials = extractFromCache(meta.materials);\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const shapes = extractFromCache(meta.shapes);\n      const skeletons = extractFromCache(meta.skeletons);\n      const animations = extractFromCache(meta.animations);\n\n      if (geometries.length > 0) output.geometries = geometries;\n      if (materials.length > 0) output.materials = materials;\n      if (textures.length > 0) output.textures = textures;\n      if (images.length > 0) output.images = images;\n      if (shapes.length > 0) output.shapes = shapes;\n      if (skeletons.length > 0) output.skeletons = skeletons;\n      if (animations.length > 0) output.animations = animations;\n    }\n\n    output.object = object;\n\n    return output;\n\n    // extract data from the cache hash\n    // remove metadata on each item\n    // and return as array\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n  }\n\n  clone(recursive) {\n    return new this.constructor().copy(this, recursive);\n  }\n\n  copy(source, recursive = true) {\n    this.name = source.name;\n\n    this.up.copy(source.up);\n\n    this.position.copy(source.position);\n    this.rotation.order = source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n    this.layers.mask = source.layers.mask;\n    this.visible = source.visible;\n\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n\n    if (recursive === true) {\n      for (let i = 0; i < source.children.length; i++) {\n        const child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n\n    return this;\n  }\n}\n\nObject3D.DefaultUp = new Vector3(0, 1, 0);\nObject3D.DefaultMatrixAutoUpdate = true;\n\nObject3D.prototype.isObject3D = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$1 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nclass Triangle {\n  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n\n  static getNormal(a, b, c, target) {\n    target.subVectors(c, b);\n    _v0$1.subVectors(a, b);\n    target.cross(_v0$1);\n\n    const targetLengthSq = target.lengthSq();\n    if (targetLengthSq > 0) {\n      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n    }\n\n    return target.set(0, 0, 0);\n  }\n\n  // static/instance method to calculate barycentric coordinates\n  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n  static getBarycoord(point, a, b, c, target) {\n    _v0$1.subVectors(c, a);\n    _v1$3.subVectors(b, a);\n    _v2$2.subVectors(point, a);\n\n    const dot00 = _v0$1.dot(_v0$1);\n    const dot01 = _v0$1.dot(_v1$3);\n    const dot02 = _v0$1.dot(_v2$2);\n    const dot11 = _v1$3.dot(_v1$3);\n    const dot12 = _v1$3.dot(_v2$2);\n\n    const denom = dot00 * dot11 - dot01 * dot01;\n\n    // collinear or singular triangle\n    if (denom === 0) {\n      // arbitrary location outside of triangle?\n      // not sure if this is the best idea, maybe should be returning undefined\n      return target.set(-2, -1, -1);\n    }\n\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // barycentric coordinates must always sum to 1\n    return target.set(1 - u - v, v, u);\n  }\n\n  static containsPoint(point, a, b, c) {\n    this.getBarycoord(point, a, b, c, _v3$1);\n\n    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;\n  }\n\n  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\n    this.getBarycoord(point, p1, p2, p3, _v3$1);\n\n    target.set(0, 0);\n    target.addScaledVector(uv1, _v3$1.x);\n    target.addScaledVector(uv2, _v3$1.y);\n    target.addScaledVector(uv3, _v3$1.z);\n\n    return target;\n  }\n\n  static isFrontFacing(a, b, c, direction) {\n    _v0$1.subVectors(c, b);\n    _v1$3.subVectors(a, b);\n\n    // strictly front facing\n    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n  }\n\n  set(a, b, c) {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n\n    return this;\n  }\n\n  setFromPointsAndIndices(points, i0, i1, i2) {\n    this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    this.c.copy(points[i2]);\n\n    return this;\n  }\n\n  setFromAttributeAndIndices(attribute, i0, i1, i2) {\n    this.a.fromBufferAttribute(attribute, i0);\n    this.b.fromBufferAttribute(attribute, i1);\n    this.c.fromBufferAttribute(attribute, i2);\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(triangle) {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n\n    return this;\n  }\n\n  getArea() {\n    _v0$1.subVectors(this.c, this.b);\n    _v1$3.subVectors(this.a, this.b);\n\n    return _v0$1.cross(_v1$3).length() * 0.5;\n  }\n\n  getMidpoint(target) {\n    return target\n      .addVectors(this.a, this.b)\n      .add(this.c)\n      .multiplyScalar(1 / 3);\n  }\n\n  getNormal(target) {\n    return Triangle.getNormal(this.a, this.b, this.c, target);\n  }\n\n  getPlane(target) {\n    return target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n\n  getBarycoord(point, target) {\n    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n  }\n\n  getUV(point, uv1, uv2, uv3, target) {\n    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n  }\n\n  containsPoint(point) {\n    return Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n\n  isFrontFacing(direction) {\n    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n  }\n\n  intersectsBox(box) {\n    return box.intersectsTriangle(this);\n  }\n\n  closestPointToPoint(p, target) {\n    const a = this.a,\n      b = this.b,\n      c = this.c;\n    let v, w;\n\n    // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n    // under the accompanying license; see chapter 5.1.5 for detailed explanation.\n    // basically, we're distinguishing which of the voronoi regions of the triangle\n    // the point lies in with the minimum amount of redundant computation.\n\n    _vab.subVectors(b, a);\n    _vac.subVectors(c, a);\n    _vap.subVectors(p, a);\n    const d1 = _vab.dot(_vap);\n    const d2 = _vac.dot(_vap);\n    if (d1 <= 0 && d2 <= 0) {\n      // vertex region of A; barycentric coords (1, 0, 0)\n      return target.copy(a);\n    }\n\n    _vbp.subVectors(p, b);\n    const d3 = _vab.dot(_vbp);\n    const d4 = _vac.dot(_vbp);\n    if (d3 >= 0 && d4 <= d3) {\n      // vertex region of B; barycentric coords (0, 1, 0)\n      return target.copy(b);\n    }\n\n    const vc = d1 * d4 - d3 * d2;\n    if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3);\n      // edge region of AB; barycentric coords (1-v, v, 0)\n      return target.copy(a).addScaledVector(_vab, v);\n    }\n\n    _vcp.subVectors(p, c);\n    const d5 = _vab.dot(_vcp);\n    const d6 = _vac.dot(_vcp);\n    if (d6 >= 0 && d5 <= d6) {\n      // vertex region of C; barycentric coords (0, 0, 1)\n      return target.copy(c);\n    }\n\n    const vb = d5 * d2 - d1 * d6;\n    if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n      w = d2 / (d2 - d6);\n      // edge region of AC; barycentric coords (1-w, 0, w)\n      return target.copy(a).addScaledVector(_vac, w);\n    }\n\n    const va = d3 * d6 - d5 * d4;\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n      _vbc.subVectors(c, b);\n      w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n      // edge region of BC; barycentric coords (0, 1-w, w)\n      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n    }\n\n    // face region\n    const denom = 1 / (va + vb + vc);\n    // u = va * denom\n    v = vb * denom;\n    w = vc * denom;\n\n    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n  }\n\n  equals(triangle) {\n    return (\n      triangle.a.equals(this.a) &&\n      triangle.b.equals(this.b) &&\n      triangle.c.equals(this.c)\n    );\n  }\n}\n\nlet materialId = 0;\n\nclass Material$1 extends EventDispatcher {\n  constructor() {\n    super();\n\n    Object.defineProperty(this, 'id', { value: materialId++ });\n\n    this.uuid = generateUUID();\n\n    this.name = '';\n    this.type = 'Material';\n\n    this.fog = true;\n\n    this.blending = NormalBlending;\n    this.side = FrontSide;\n    this.vertexColors = false;\n\n    this.opacity = 1;\n    this.format = RGBAFormat;\n    this.transparent = false;\n\n    this.blendSrc = SrcAlphaFactor;\n    this.blendDst = OneMinusSrcAlphaFactor;\n    this.blendEquation = AddEquation;\n    this.blendSrcAlpha = null;\n    this.blendDstAlpha = null;\n    this.blendEquationAlpha = null;\n\n    this.depthFunc = LessEqualDepth;\n    this.depthTest = true;\n    this.depthWrite = true;\n\n    this.stencilWriteMask = 0xff;\n    this.stencilFunc = AlwaysStencilFunc;\n    this.stencilRef = 0;\n    this.stencilFuncMask = 0xff;\n    this.stencilFail = KeepStencilOp;\n    this.stencilZFail = KeepStencilOp;\n    this.stencilZPass = KeepStencilOp;\n    this.stencilWrite = false;\n\n    this.clippingPlanes = null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n\n    this.shadowSide = null;\n\n    this.colorWrite = true;\n\n    this.precision = null; // override the renderer's default precision for this material\n\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n    this.polygonOffsetUnits = 0;\n\n    this.dithering = false;\n\n    this.alphaToCoverage = false;\n    this.premultipliedAlpha = false;\n\n    this.visible = true;\n\n    this.toneMapped = true;\n\n    this.userData = {};\n\n    this.version = 0;\n\n    this._alphaTest = 0;\n  }\n\n  get alphaTest() {\n    return this._alphaTest;\n  }\n\n  set alphaTest(value) {\n    if (this._alphaTest > 0 !== value > 0) {\n      this.version++;\n    }\n\n    this._alphaTest = value;\n  }\n\n  onBuild(/* shaderobject, renderer */) {}\n\n  onBeforeRender(/* renderer, scene, camera, geometry, object, group */) {}\n\n  onBeforeCompile(/* shaderobject, renderer */) {}\n\n  customProgramCacheKey() {\n    return this.onBeforeCompile.toString();\n  }\n\n  setValues(values) {\n    if (values === undefined) return;\n\n    for (const key in values) {\n      const newValue = values[key];\n\n      if (newValue === undefined) {\n        console.warn(\"THREE.Material: '\" + key + \"' parameter is undefined.\");\n        continue;\n      }\n\n      // for backward compatability if shading is set in the constructor\n      if (key === 'shading') {\n        console.warn(\n          'THREE.' +\n            this.type +\n            ': .shading has been removed. Use the boolean .flatShading instead.',\n        );\n        this.flatShading = newValue === FlatShading ? true : false;\n        continue;\n      }\n\n      const currentValue = this[key];\n\n      if (currentValue === undefined) {\n        console.warn(\n          'THREE.' +\n            this.type +\n            \": '\" +\n            key +\n            \"' is not a property of this material.\",\n        );\n        continue;\n      }\n\n      if (currentValue && currentValue.isColor) {\n        currentValue.set(newValue);\n      } else if (\n        currentValue &&\n        currentValue.isVector3 &&\n        newValue &&\n        newValue.isVector3\n      ) {\n        currentValue.copy(newValue);\n      } else {\n        this[key] = newValue;\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n      };\n    }\n\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Material',\n        generator: 'Material.toJSON',\n      },\n    };\n\n    // standard Material serialization\n    data.uuid = this.uuid;\n    data.type = this.type;\n\n    if (this.name !== '') data.name = this.name;\n\n    if (this.color && this.color.isColor) data.color = this.color.getHex();\n\n    if (this.roughness !== undefined) data.roughness = this.roughness;\n    if (this.metalness !== undefined) data.metalness = this.metalness;\n\n    if (this.sheen !== undefined) data.sheen = this.sheen;\n    if (this.sheenTint && this.sheenTint.isColor)\n      data.sheenTint = this.sheenTint.getHex();\n    if (this.sheenRoughness !== undefined)\n      data.sheenRoughness = this.sheenRoughness;\n    if (this.emissive && this.emissive.isColor)\n      data.emissive = this.emissive.getHex();\n    if (this.emissiveIntensity && this.emissiveIntensity !== 1)\n      data.emissiveIntensity = this.emissiveIntensity;\n\n    if (this.specular && this.specular.isColor)\n      data.specular = this.specular.getHex();\n    if (this.specularIntensity !== undefined)\n      data.specularIntensity = this.specularIntensity;\n    if (this.specularTint && this.specularTint.isColor)\n      data.specularTint = this.specularTint.getHex();\n    if (this.shininess !== undefined) data.shininess = this.shininess;\n    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;\n    if (this.clearcoatRoughness !== undefined)\n      data.clearcoatRoughness = this.clearcoatRoughness;\n\n    if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n    }\n\n    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n    }\n\n    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n    }\n\n    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n    if (this.matcap && this.matcap.isTexture)\n      data.matcap = this.matcap.toJSON(meta).uuid;\n    if (this.alphaMap && this.alphaMap.isTexture)\n      data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n\n    if (this.lightMap && this.lightMap.isTexture) {\n      data.lightMap = this.lightMap.toJSON(meta).uuid;\n      data.lightMapIntensity = this.lightMapIntensity;\n    }\n\n    if (this.aoMap && this.aoMap.isTexture) {\n      data.aoMap = this.aoMap.toJSON(meta).uuid;\n      data.aoMapIntensity = this.aoMapIntensity;\n    }\n\n    if (this.bumpMap && this.bumpMap.isTexture) {\n      data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    }\n\n    if (this.normalMap && this.normalMap.isTexture) {\n      data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalMapType = this.normalMapType;\n      data.normalScale = this.normalScale.toArray();\n    }\n\n    if (this.displacementMap && this.displacementMap.isTexture) {\n      data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      data.displacementScale = this.displacementScale;\n      data.displacementBias = this.displacementBias;\n    }\n\n    if (this.roughnessMap && this.roughnessMap.isTexture)\n      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n    if (this.metalnessMap && this.metalnessMap.isTexture)\n      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n\n    if (this.emissiveMap && this.emissiveMap.isTexture)\n      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n    if (this.specularMap && this.specularMap.isTexture)\n      data.specularMap = this.specularMap.toJSON(meta).uuid;\n    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)\n      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n    if (this.specularTintMap && this.specularTintMap.isTexture)\n      data.specularTintMap = this.specularTintMap.toJSON(meta).uuid;\n\n    if (this.envMap && this.envMap.isTexture) {\n      data.envMap = this.envMap.toJSON(meta).uuid;\n\n      if (this.combine !== undefined) data.combine = this.combine;\n    }\n\n    if (this.envMapIntensity !== undefined)\n      data.envMapIntensity = this.envMapIntensity;\n    if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;\n    if (this.refractionRatio !== undefined)\n      data.refractionRatio = this.refractionRatio;\n\n    if (this.gradientMap && this.gradientMap.isTexture) {\n      data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n    }\n\n    if (this.transmission !== undefined) data.transmission = this.transmission;\n    if (this.transmissionMap && this.transmissionMap.isTexture)\n      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n    if (this.thickness !== undefined) data.thickness = this.thickness;\n    if (this.thicknessMap && this.thicknessMap.isTexture)\n      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n    if (this.attenuationDistance !== undefined)\n      data.attenuationDistance = this.attenuationDistance;\n    if (this.attenuationTint !== undefined)\n      data.attenuationTint = this.attenuationTint.getHex();\n\n    if (this.size !== undefined) data.size = this.size;\n    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n    if (this.sizeAttenuation !== undefined)\n      data.sizeAttenuation = this.sizeAttenuation;\n\n    if (this.blending !== NormalBlending) data.blending = this.blending;\n    if (this.side !== FrontSide) data.side = this.side;\n    if (this.vertexColors) data.vertexColors = true;\n\n    if (this.opacity < 1) data.opacity = this.opacity;\n    if (this.format !== RGBAFormat) data.format = this.format;\n    if (this.transparent === true) data.transparent = this.transparent;\n\n    data.depthFunc = this.depthFunc;\n    data.depthTest = this.depthTest;\n    data.depthWrite = this.depthWrite;\n    data.colorWrite = this.colorWrite;\n\n    data.stencilWrite = this.stencilWrite;\n    data.stencilWriteMask = this.stencilWriteMask;\n    data.stencilFunc = this.stencilFunc;\n    data.stencilRef = this.stencilRef;\n    data.stencilFuncMask = this.stencilFuncMask;\n    data.stencilFail = this.stencilFail;\n    data.stencilZFail = this.stencilZFail;\n    data.stencilZPass = this.stencilZPass;\n\n    // rotation (SpriteMaterial)\n    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;\n\n    if (this.polygonOffset === true) data.polygonOffset = true;\n    if (this.polygonOffsetFactor !== 0)\n      data.polygonOffsetFactor = this.polygonOffsetFactor;\n    if (this.polygonOffsetUnits !== 0)\n      data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;\n    if (this.dashSize !== undefined) data.dashSize = this.dashSize;\n    if (this.gapSize !== undefined) data.gapSize = this.gapSize;\n    if (this.scale !== undefined) data.scale = this.scale;\n\n    if (this.dithering === true) data.dithering = true;\n\n    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n    if (this.alphaToCoverage === true)\n      data.alphaToCoverage = this.alphaToCoverage;\n    if (this.premultipliedAlpha === true)\n      data.premultipliedAlpha = this.premultipliedAlpha;\n\n    if (this.wireframe === true) data.wireframe = this.wireframe;\n    if (this.wireframeLinewidth > 1)\n      data.wireframeLinewidth = this.wireframeLinewidth;\n    if (this.wireframeLinecap !== 'round')\n      data.wireframeLinecap = this.wireframeLinecap;\n    if (this.wireframeLinejoin !== 'round')\n      data.wireframeLinejoin = this.wireframeLinejoin;\n\n    if (this.flatShading === true) data.flatShading = this.flatShading;\n\n    if (this.visible === false) data.visible = false;\n\n    if (this.toneMapped === false) data.toneMapped = false;\n\n    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n    }\n\n    return data;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.name = source.name;\n\n    this.fog = source.fog;\n\n    this.blending = source.blending;\n    this.side = source.side;\n    this.vertexColors = source.vertexColors;\n\n    this.opacity = source.opacity;\n    this.format = source.format;\n    this.transparent = source.transparent;\n\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendEquationAlpha = source.blendEquationAlpha;\n\n    this.depthFunc = source.depthFunc;\n    this.depthTest = source.depthTest;\n    this.depthWrite = source.depthWrite;\n\n    this.stencilWriteMask = source.stencilWriteMask;\n    this.stencilFunc = source.stencilFunc;\n    this.stencilRef = source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    this.stencilFail = source.stencilFail;\n    this.stencilZFail = source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    this.stencilWrite = source.stencilWrite;\n\n    const srcPlanes = source.clippingPlanes;\n    let dstPlanes = null;\n\n    if (srcPlanes !== null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n\n      for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = srcPlanes[i].clone();\n      }\n    }\n\n    this.clippingPlanes = dstPlanes;\n    this.clipIntersection = source.clipIntersection;\n    this.clipShadows = source.clipShadows;\n\n    this.shadowSide = source.shadowSide;\n\n    this.colorWrite = source.colorWrite;\n\n    this.precision = source.precision;\n\n    this.polygonOffset = source.polygonOffset;\n    this.polygonOffsetFactor = source.polygonOffsetFactor;\n    this.polygonOffsetUnits = source.polygonOffsetUnits;\n\n    this.dithering = source.dithering;\n\n    this.alphaTest = source.alphaTest;\n    this.alphaToCoverage = source.alphaToCoverage;\n    this.premultipliedAlpha = source.premultipliedAlpha;\n\n    this.visible = source.visible;\n\n    this.toneMapped = source.toneMapped;\n\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n\n    return this;\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' });\n  }\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n}\n\nMaterial$1.prototype.isMaterial = true;\n\nconst _colorKeywords = {\n  aliceblue: 0xf0f8ff,\n  antiquewhite: 0xfaebd7,\n  aqua: 0x00ffff,\n  aquamarine: 0x7fffd4,\n  azure: 0xf0ffff,\n  beige: 0xf5f5dc,\n  bisque: 0xffe4c4,\n  black: 0x000000,\n  blanchedalmond: 0xffebcd,\n  blue: 0x0000ff,\n  blueviolet: 0x8a2be2,\n  brown: 0xa52a2a,\n  burlywood: 0xdeb887,\n  cadetblue: 0x5f9ea0,\n  chartreuse: 0x7fff00,\n  chocolate: 0xd2691e,\n  coral: 0xff7f50,\n  cornflowerblue: 0x6495ed,\n  cornsilk: 0xfff8dc,\n  crimson: 0xdc143c,\n  cyan: 0x00ffff,\n  darkblue: 0x00008b,\n  darkcyan: 0x008b8b,\n  darkgoldenrod: 0xb8860b,\n  darkgray: 0xa9a9a9,\n  darkgreen: 0x006400,\n  darkgrey: 0xa9a9a9,\n  darkkhaki: 0xbdb76b,\n  darkmagenta: 0x8b008b,\n  darkolivegreen: 0x556b2f,\n  darkorange: 0xff8c00,\n  darkorchid: 0x9932cc,\n  darkred: 0x8b0000,\n  darksalmon: 0xe9967a,\n  darkseagreen: 0x8fbc8f,\n  darkslateblue: 0x483d8b,\n  darkslategray: 0x2f4f4f,\n  darkslategrey: 0x2f4f4f,\n  darkturquoise: 0x00ced1,\n  darkviolet: 0x9400d3,\n  deeppink: 0xff1493,\n  deepskyblue: 0x00bfff,\n  dimgray: 0x696969,\n  dimgrey: 0x696969,\n  dodgerblue: 0x1e90ff,\n  firebrick: 0xb22222,\n  floralwhite: 0xfffaf0,\n  forestgreen: 0x228b22,\n  fuchsia: 0xff00ff,\n  gainsboro: 0xdcdcdc,\n  ghostwhite: 0xf8f8ff,\n  gold: 0xffd700,\n  goldenrod: 0xdaa520,\n  gray: 0x808080,\n  green: 0x008000,\n  greenyellow: 0xadff2f,\n  grey: 0x808080,\n  honeydew: 0xf0fff0,\n  hotpink: 0xff69b4,\n  indianred: 0xcd5c5c,\n  indigo: 0x4b0082,\n  ivory: 0xfffff0,\n  khaki: 0xf0e68c,\n  lavender: 0xe6e6fa,\n  lavenderblush: 0xfff0f5,\n  lawngreen: 0x7cfc00,\n  lemonchiffon: 0xfffacd,\n  lightblue: 0xadd8e6,\n  lightcoral: 0xf08080,\n  lightcyan: 0xe0ffff,\n  lightgoldenrodyellow: 0xfafad2,\n  lightgray: 0xd3d3d3,\n  lightgreen: 0x90ee90,\n  lightgrey: 0xd3d3d3,\n  lightpink: 0xffb6c1,\n  lightsalmon: 0xffa07a,\n  lightseagreen: 0x20b2aa,\n  lightskyblue: 0x87cefa,\n  lightslategray: 0x778899,\n  lightslategrey: 0x778899,\n  lightsteelblue: 0xb0c4de,\n  lightyellow: 0xffffe0,\n  lime: 0x00ff00,\n  limegreen: 0x32cd32,\n  linen: 0xfaf0e6,\n  magenta: 0xff00ff,\n  maroon: 0x800000,\n  mediumaquamarine: 0x66cdaa,\n  mediumblue: 0x0000cd,\n  mediumorchid: 0xba55d3,\n  mediumpurple: 0x9370db,\n  mediumseagreen: 0x3cb371,\n  mediumslateblue: 0x7b68ee,\n  mediumspringgreen: 0x00fa9a,\n  mediumturquoise: 0x48d1cc,\n  mediumvioletred: 0xc71585,\n  midnightblue: 0x191970,\n  mintcream: 0xf5fffa,\n  mistyrose: 0xffe4e1,\n  moccasin: 0xffe4b5,\n  navajowhite: 0xffdead,\n  navy: 0x000080,\n  oldlace: 0xfdf5e6,\n  olive: 0x808000,\n  olivedrab: 0x6b8e23,\n  orange: 0xffa500,\n  orangered: 0xff4500,\n  orchid: 0xda70d6,\n  palegoldenrod: 0xeee8aa,\n  palegreen: 0x98fb98,\n  paleturquoise: 0xafeeee,\n  palevioletred: 0xdb7093,\n  papayawhip: 0xffefd5,\n  peachpuff: 0xffdab9,\n  peru: 0xcd853f,\n  pink: 0xffc0cb,\n  plum: 0xdda0dd,\n  powderblue: 0xb0e0e6,\n  purple: 0x800080,\n  rebeccapurple: 0x663399,\n  red: 0xff0000,\n  rosybrown: 0xbc8f8f,\n  royalblue: 0x4169e1,\n  saddlebrown: 0x8b4513,\n  salmon: 0xfa8072,\n  sandybrown: 0xf4a460,\n  seagreen: 0x2e8b57,\n  seashell: 0xfff5ee,\n  sienna: 0xa0522d,\n  silver: 0xc0c0c0,\n  skyblue: 0x87ceeb,\n  slateblue: 0x6a5acd,\n  slategray: 0x708090,\n  slategrey: 0x708090,\n  snow: 0xfffafa,\n  springgreen: 0x00ff7f,\n  steelblue: 0x4682b4,\n  tan: 0xd2b48c,\n  teal: 0x008080,\n  thistle: 0xd8bfd8,\n  tomato: 0xff6347,\n  turquoise: 0x40e0d0,\n  violet: 0xee82ee,\n  wheat: 0xf5deb3,\n  white: 0xffffff,\n  whitesmoke: 0xf5f5f5,\n  yellow: 0xffff00,\n  yellowgreen: 0x9acd32,\n};\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n  return p;\n}\n\nfunction SRGBToLinear(c) {\n  return c < 0.04045\n    ? c * 0.0773993808\n    : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n}\n\nfunction LinearToSRGB(c) {\n  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n}\n\nclass Color {\n  constructor(r, g, b) {\n    if (g === undefined && b === undefined) {\n      // r is THREE.Color, hex or string\n      return this.set(r);\n    }\n\n    return this.setRGB(r, g, b);\n  }\n\n  set(value) {\n    if (value && value.isColor) {\n      this.copy(value);\n    } else if (typeof value === 'number') {\n      this.setHex(value);\n    } else if (typeof value === 'string') {\n      this.setStyle(value);\n    }\n\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.r = scalar;\n    this.g = scalar;\n    this.b = scalar;\n\n    return this;\n  }\n\n  setHex(hex) {\n    hex = Math.floor(hex);\n\n    this.r = ((hex >> 16) & 255) / 255;\n    this.g = ((hex >> 8) & 255) / 255;\n    this.b = (hex & 255) / 255;\n\n    return this;\n  }\n\n  setRGB(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n\n    return this;\n  }\n\n  setHSL(h, s, l) {\n    // h,s,l ranges are in 0.0 - 1.0\n    h = euclideanModulo(h, 1);\n    s = clamp$1(s, 0, 1);\n    l = clamp$1(l, 0, 1);\n\n    if (s === 0) {\n      this.r = this.g = this.b = l;\n    } else {\n      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n      const q = 2 * l - p;\n\n      this.r = hue2rgb(q, p, h + 1 / 3);\n      this.g = hue2rgb(q, p, h);\n      this.b = hue2rgb(q, p, h - 1 / 3);\n    }\n\n    return this;\n  }\n\n  setStyle(style) {\n    function handleAlpha(string) {\n      if (string === undefined) return;\n\n      if (parseFloat(string) < 1) {\n        console.warn(\n          'THREE.Color: Alpha component of ' + style + ' will be ignored.',\n        );\n      }\n    }\n\n    let m;\n\n    if ((m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(style))) {\n      // rgb / hsl\n\n      let color;\n      const name = m[1];\n      const components = m[2];\n\n      switch (name) {\n        case 'rgb':\n        case 'rgba':\n          if (\n            (color =\n              /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n                components,\n              ))\n          ) {\n            // rgb(255,0,0) rgba(255,0,0,0.5)\n            this.r = Math.min(255, parseInt(color[1], 10)) / 255;\n            this.g = Math.min(255, parseInt(color[2], 10)) / 255;\n            this.b = Math.min(255, parseInt(color[3], 10)) / 255;\n\n            handleAlpha(color[4]);\n\n            return this;\n          }\n\n          if (\n            (color =\n              /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n                components,\n              ))\n          ) {\n            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n            this.r = Math.min(100, parseInt(color[1], 10)) / 100;\n            this.g = Math.min(100, parseInt(color[2], 10)) / 100;\n            this.b = Math.min(100, parseInt(color[3], 10)) / 100;\n\n            handleAlpha(color[4]);\n\n            return this;\n          }\n\n          break;\n\n        case 'hsl':\n        case 'hsla':\n          if (\n            (color =\n              /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n                components,\n              ))\n          ) {\n            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n            const h = parseFloat(color[1]) / 360;\n            const s = parseInt(color[2], 10) / 100;\n            const l = parseInt(color[3], 10) / 100;\n\n            handleAlpha(color[4]);\n\n            return this.setHSL(h, s, l);\n          }\n\n          break;\n      }\n    } else if ((m = /^\\#([A-Fa-f\\d]+)$/.exec(style))) {\n      // hex color\n\n      const hex = m[1];\n      const size = hex.length;\n\n      if (size === 3) {\n        // #ff0\n        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n\n        return this;\n      } else if (size === 6) {\n        // #ff0000\n        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n\n        return this;\n      }\n    }\n\n    if (style && style.length > 0) {\n      return this.setColorName(style);\n    }\n\n    return this;\n  }\n\n  setColorName(style) {\n    // color keywords\n    const hex = _colorKeywords[style.toLowerCase()];\n\n    if (hex !== undefined) {\n      // red\n      this.setHex(hex);\n    } else {\n      // unknown color\n      console.warn('THREE.Color: Unknown color ' + style);\n    }\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this.r, this.g, this.b);\n  }\n\n  copy(color) {\n    this.r = color.r;\n    this.g = color.g;\n    this.b = color.b;\n\n    return this;\n  }\n\n  copyGammaToLinear(color, gammaFactor = 2.0) {\n    this.r = Math.pow(color.r, gammaFactor);\n    this.g = Math.pow(color.g, gammaFactor);\n    this.b = Math.pow(color.b, gammaFactor);\n\n    return this;\n  }\n\n  copyLinearToGamma(color, gammaFactor = 2.0) {\n    const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\n\n    this.r = Math.pow(color.r, safeInverse);\n    this.g = Math.pow(color.g, safeInverse);\n    this.b = Math.pow(color.b, safeInverse);\n\n    return this;\n  }\n\n  convertGammaToLinear(gammaFactor) {\n    this.copyGammaToLinear(this, gammaFactor);\n\n    return this;\n  }\n\n  convertLinearToGamma(gammaFactor) {\n    this.copyLinearToGamma(this, gammaFactor);\n\n    return this;\n  }\n\n  copySRGBToLinear(color) {\n    this.r = SRGBToLinear(color.r);\n    this.g = SRGBToLinear(color.g);\n    this.b = SRGBToLinear(color.b);\n\n    return this;\n  }\n\n  copyLinearToSRGB(color) {\n    this.r = LinearToSRGB(color.r);\n    this.g = LinearToSRGB(color.g);\n    this.b = LinearToSRGB(color.b);\n\n    return this;\n  }\n\n  convertSRGBToLinear() {\n    this.copySRGBToLinear(this);\n\n    return this;\n  }\n\n  convertLinearToSRGB() {\n    this.copyLinearToSRGB(this);\n\n    return this;\n  }\n\n  getHex() {\n    return (\n      ((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0)\n    );\n  }\n\n  getHexString() {\n    return ('000000' + this.getHex().toString(16)).slice(-6);\n  }\n\n  getHSL(target) {\n    // h,s,l ranges are in 0.0 - 1.0\n\n    const r = this.r,\n      g = this.g,\n      b = this.b;\n\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n\n    let hue, saturation;\n    const lightness = (min + max) / 2.0;\n\n    if (min === max) {\n      hue = 0;\n      saturation = 0;\n    } else {\n      const delta = max - min;\n\n      saturation =\n        lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n      switch (max) {\n        case r:\n          hue = (g - b) / delta + (g < b ? 6 : 0);\n          break;\n        case g:\n          hue = (b - r) / delta + 2;\n          break;\n        case b:\n          hue = (r - g) / delta + 4;\n          break;\n      }\n\n      hue /= 6;\n    }\n\n    target.h = hue;\n    target.s = saturation;\n    target.l = lightness;\n\n    return target;\n  }\n\n  getStyle() {\n    return (\n      'rgb(' +\n      ((this.r * 255) | 0) +\n      ',' +\n      ((this.g * 255) | 0) +\n      ',' +\n      ((this.b * 255) | 0) +\n      ')'\n    );\n  }\n\n  offsetHSL(h, s, l) {\n    this.getHSL(_hslA);\n\n    _hslA.h += h;\n    _hslA.s += s;\n    _hslA.l += l;\n\n    this.setHSL(_hslA.h, _hslA.s, _hslA.l);\n\n    return this;\n  }\n\n  add(color) {\n    this.r += color.r;\n    this.g += color.g;\n    this.b += color.b;\n\n    return this;\n  }\n\n  addColors(color1, color2) {\n    this.r = color1.r + color2.r;\n    this.g = color1.g + color2.g;\n    this.b = color1.b + color2.b;\n\n    return this;\n  }\n\n  addScalar(s) {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n\n    return this;\n  }\n\n  sub(color) {\n    this.r = Math.max(0, this.r - color.r);\n    this.g = Math.max(0, this.g - color.g);\n    this.b = Math.max(0, this.b - color.b);\n\n    return this;\n  }\n\n  multiply(color) {\n    this.r *= color.r;\n    this.g *= color.g;\n    this.b *= color.b;\n\n    return this;\n  }\n\n  multiplyScalar(s) {\n    this.r *= s;\n    this.g *= s;\n    this.b *= s;\n\n    return this;\n  }\n\n  lerp(color, alpha) {\n    this.r += (color.r - this.r) * alpha;\n    this.g += (color.g - this.g) * alpha;\n    this.b += (color.b - this.b) * alpha;\n\n    return this;\n  }\n\n  lerpColors(color1, color2, alpha) {\n    this.r = color1.r + (color2.r - color1.r) * alpha;\n    this.g = color1.g + (color2.g - color1.g) * alpha;\n    this.b = color1.b + (color2.b - color1.b) * alpha;\n\n    return this;\n  }\n\n  lerpHSL(color, alpha) {\n    this.getHSL(_hslA);\n    color.getHSL(_hslB);\n\n    const h = lerp(_hslA.h, _hslB.h, alpha);\n    const s = lerp(_hslA.s, _hslB.s, alpha);\n    const l = lerp(_hslA.l, _hslB.l, alpha);\n\n    this.setHSL(h, s, l);\n\n    return this;\n  }\n\n  equals(c) {\n    return c.r === this.r && c.g === this.g && c.b === this.b;\n  }\n\n  fromArray(array, offset = 0) {\n    this.r = array[offset];\n    this.g = array[offset + 1];\n    this.b = array[offset + 2];\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this.r;\n    array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index) {\n    this.r = attribute.getX(index);\n    this.g = attribute.getY(index);\n    this.b = attribute.getZ(index);\n\n    if (attribute.normalized === true) {\n      // assuming Uint8Array\n\n      this.r /= 255;\n      this.g /= 255;\n      this.b /= 255;\n    }\n\n    return this;\n  }\n\n  toJSON() {\n    return this.getHex();\n  }\n}\n\nColor.NAMES = _colorKeywords;\n\nColor.prototype.isColor = true;\nColor.prototype.r = 1;\nColor.prototype.g = 1;\nColor.prototype.b = 1;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n * }\n */\n\nclass MeshBasicMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'MeshBasicMaterial';\n\n    this.color = new Color(0xffffff); // emissive\n\n    this.map = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.specularMap = null;\n\n    this.alphaMap = null;\n\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n\n    this.map = source.map;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.specularMap = source.specularMap;\n\n    this.alphaMap = source.alphaMap;\n\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    return this;\n  }\n}\n\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\nconst _vector$9 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    if (Array.isArray(array)) {\n      throw new TypeError(\n        'THREE.BufferAttribute: array should be a Typed Array.',\n      );\n    }\n\n    this.name = '';\n\n    this.array = array;\n    this.itemSize = itemSize;\n    this.count = array !== undefined ? array.length / itemSize : 0;\n    this.normalized = normalized === true;\n\n    this.usage = StaticDrawUsage;\n    this.updateRange = { offset: 0, count: -1 };\n\n    this.version = 0;\n  }\n\n  onUploadCallback() {}\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n\n  setUsage(value) {\n    this.usage = value;\n\n    return this;\n  }\n\n  copy(source) {\n    this.name = source.name;\n    this.array = new source.array.constructor(source.array);\n    this.itemSize = source.itemSize;\n    this.count = source.count;\n    this.normalized = source.normalized;\n\n    this.usage = source.usage;\n\n    return this;\n  }\n\n  copyAt(index1, attribute, index2) {\n    index1 *= this.itemSize;\n    index2 *= attribute.itemSize;\n\n    for (let i = 0, l = this.itemSize; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n\n    return this;\n  }\n\n  copyArray(array) {\n    this.array.set(array);\n\n    return this;\n  }\n\n  copyColorsArray(colors) {\n    const array = this.array;\n    let offset = 0;\n\n    for (let i = 0, l = colors.length; i < l; i++) {\n      let color = colors[i];\n\n      if (color === undefined) {\n        console.warn(\n          'THREE.BufferAttribute.copyColorsArray(): color is undefined',\n          i,\n        );\n        color = new Color();\n      }\n\n      array[offset++] = color.r;\n      array[offset++] = color.g;\n      array[offset++] = color.b;\n    }\n\n    return this;\n  }\n\n  copyVector2sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn(\n          'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',\n          i,\n        );\n        vector = new Vector2();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n    }\n\n    return this;\n  }\n\n  copyVector3sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn(\n          'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',\n          i,\n        );\n        vector = new Vector3();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n    }\n\n    return this;\n  }\n\n  copyVector4sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn(\n          'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',\n          i,\n        );\n        vector = new Vector4();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n      array[offset++] = vector.w;\n    }\n\n    return this;\n  }\n\n  applyMatrix3(m) {\n    if (this.itemSize === 2) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector2$1.fromBufferAttribute(this, i);\n        _vector2$1.applyMatrix3(m);\n\n        this.setXY(i, _vector2$1.x, _vector2$1.y);\n      }\n    } else if (this.itemSize === 3) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector$9.fromBufferAttribute(this, i);\n        _vector$9.applyMatrix3(m);\n\n        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n    }\n\n    return this;\n  }\n\n  applyMatrix4(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n\n      _vector$9.applyMatrix4(m);\n\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n\n    return this;\n  }\n\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n\n      _vector$9.applyNormalMatrix(m);\n\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n\n    return this;\n  }\n\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n\n      _vector$9.transformDirection(m);\n\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n\n    return this;\n  }\n\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n\n    return this;\n  }\n\n  getX(index) {\n    return this.array[index * this.itemSize];\n  }\n\n  setX(index, x) {\n    this.array[index * this.itemSize] = x;\n\n    return this;\n  }\n\n  getY(index) {\n    return this.array[index * this.itemSize + 1];\n  }\n\n  setY(index, y) {\n    this.array[index * this.itemSize + 1] = y;\n\n    return this;\n  }\n\n  getZ(index) {\n    return this.array[index * this.itemSize + 2];\n  }\n\n  setZ(index, z) {\n    this.array[index * this.itemSize + 2] = z;\n\n    return this;\n  }\n\n  getW(index) {\n    return this.array[index * this.itemSize + 3];\n  }\n\n  setW(index, w) {\n    this.array[index * this.itemSize + 3] = w;\n\n    return this;\n  }\n\n  setXY(index, x, y) {\n    index *= this.itemSize;\n\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n\n    return this;\n  }\n\n  setXYZ(index, x, y, z) {\n    index *= this.itemSize;\n\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n\n    return this;\n  }\n\n  setXYZW(index, x, y, z, w) {\n    index *= this.itemSize;\n\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    this.array[index + 3] = w;\n\n    return this;\n  }\n\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this.array, this.itemSize).copy(this);\n  }\n\n  toJSON() {\n    const data = {\n      itemSize: this.itemSize,\n      type: this.array.constructor.name,\n      array: Array.prototype.slice.call(this.array),\n      normalized: this.normalized,\n    };\n\n    if (this.name !== '') data.name = this.name;\n    if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)\n      data.updateRange = this.updateRange;\n\n    return data;\n  }\n}\n\nBufferAttribute.prototype.isBufferAttribute = true;\n\nclass Uint16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n  }\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint32Array(array), itemSize, normalized);\n  }\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n  }\n}\n\nFloat16BufferAttribute.prototype.isFloat16BufferAttribute = true;\n\nclass Float32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Float32Array(array), itemSize, normalized);\n  }\n}\n\nlet _id = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box$1 = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector$8 = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n  constructor() {\n    super();\n\n    Object.defineProperty(this, 'id', { value: _id++ });\n\n    this.uuid = generateUUID();\n\n    this.name = '';\n    this.type = 'BufferGeometry';\n\n    this.index = null;\n    this.attributes = {};\n\n    this.morphAttributes = {};\n    this.morphTargetsRelative = false;\n\n    this.groups = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    this.drawRange = { start: 0, count: Infinity };\n\n    this.userData = {};\n  }\n\n  getIndex() {\n    return this.index;\n  }\n\n  setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (\n        arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute\n      )(index, 1);\n    } else {\n      this.index = index;\n    }\n\n    return this;\n  }\n\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n\n    return this;\n  }\n\n  deleteAttribute(name) {\n    delete this.attributes[name];\n\n    return this;\n  }\n\n  hasAttribute(name) {\n    return this.attributes[name] !== undefined;\n  }\n\n  addGroup(start, count, materialIndex = 0) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex,\n    });\n  }\n\n  clearGroups() {\n    this.groups = [];\n  }\n\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n\n  applyMatrix4(matrix) {\n    const position = this.attributes.position;\n\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n\n      position.needsUpdate = true;\n    }\n\n    const normal = this.attributes.normal;\n\n    if (normal !== undefined) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n      normal.applyNormalMatrix(normalMatrix);\n\n      normal.needsUpdate = true;\n    }\n\n    const tangent = this.attributes.tangent;\n\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n\n      tangent.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  applyQuaternion(q) {\n    _m1.makeRotationFromQuaternion(q);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n\n    this.boundingBox.getCenter(_offset).negate();\n\n    this.translate(_offset.x, _offset.y, _offset.z);\n\n    return this;\n  }\n\n  setFromPoints(points) {\n    const position = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n\n    this.setAttribute('position', new Float32BufferAttribute(position, 3));\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error(\n        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".',\n        this,\n      );\n\n      this.boundingBox.set(\n        new Vector3(-Infinity, -Infinity, -Infinity),\n        new Vector3(+Infinity, +Infinity, +Infinity),\n      );\n\n      return;\n    }\n\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _box$1.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(this.boundingBox.min, _box$1.min);\n            this.boundingBox.expandByPoint(_vector$8);\n\n            _vector$8.addVectors(this.boundingBox.max, _box$1.max);\n            this.boundingBox.expandByPoint(_vector$8);\n          } else {\n            this.boundingBox.expandByPoint(_box$1.min);\n            this.boundingBox.expandByPoint(_box$1.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n\n    if (\n      isNaN(this.boundingBox.min.x) ||\n      isNaN(this.boundingBox.min.y) ||\n      isNaN(this.boundingBox.min.z)\n    ) {\n      console.error(\n        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.',\n        this,\n      );\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error(\n        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".',\n        this,\n      );\n\n      this.boundingSphere.set(new Vector3(), Infinity);\n\n      return;\n    }\n\n    if (position) {\n      // first, find the center of the bounding sphere\n\n      const center = this.boundingSphere.center;\n\n      _box$1.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);\n            _box$1.expandByPoint(_vector$8);\n\n            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);\n            _box$1.expandByPoint(_vector$8);\n          } else {\n            _box$1.expandByPoint(_boxMorphTargets.min);\n            _box$1.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n\n      _box$1.getCenter(center);\n\n      // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector$8.fromBufferAttribute(position, i);\n\n        maxRadiusSq = Math.max(\n          maxRadiusSq,\n          center.distanceToSquared(_vector$8),\n        );\n      }\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector$8.fromBufferAttribute(morphAttribute, j);\n\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n              _vector$8.add(_offset);\n            }\n\n            maxRadiusSq = Math.max(\n              maxRadiusSq,\n              center.distanceToSquared(_vector$8),\n            );\n          }\n        }\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.',\n          this,\n        );\n      }\n    }\n  }\n\n  computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes;\n\n    // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (\n      index === null ||\n      attributes.position === undefined ||\n      attributes.normal === undefined ||\n      attributes.uv === undefined\n    ) {\n      console.error(\n        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',\n      );\n      return;\n    }\n\n    const indices = index.array;\n    const positions = attributes.position.array;\n    const normals = attributes.normal.array;\n    const uvs = attributes.uv.array;\n\n    const nVertices = positions.length / 3;\n\n    if (attributes.tangent === undefined) {\n      this.setAttribute(\n        'tangent',\n        new BufferAttribute(new Float32Array(4 * nVertices), 4),\n      );\n    }\n\n    const tangents = attributes.tangent.array;\n\n    const tan1 = [],\n      tan2 = [];\n\n    for (let i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n\n    const vA = new Vector3(),\n      vB = new Vector3(),\n      vC = new Vector3(),\n      uvA = new Vector2(),\n      uvB = new Vector2(),\n      uvC = new Vector2(),\n      sdir = new Vector3(),\n      tdir = new Vector3();\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n\n      vB.sub(vA);\n      vC.sub(vA);\n\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n\n      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);\n\n      // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n\n      sdir\n        .copy(vB)\n        .multiplyScalar(uvC.y)\n        .addScaledVector(vC, -uvB.y)\n        .multiplyScalar(r);\n      tdir\n        .copy(vC)\n        .multiplyScalar(uvB.x)\n        .addScaledVector(vB, -uvC.x)\n        .multiplyScalar(r);\n\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n\n    let groups = this.groups;\n\n    if (groups.length === 0) {\n      groups = [\n        {\n          start: 0,\n          count: indices.length,\n        },\n      ];\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n\n    const tmp = new Vector3(),\n      tmp2 = new Vector3();\n    const n = new Vector3(),\n      n2 = new Vector3();\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n\n      const t = tan1[v];\n\n      // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n      // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0.0 ? -1.0 : 1.0;\n\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  }\n\n  computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute('position');\n\n    if (positionAttribute !== undefined) {\n      let normalAttribute = this.getAttribute('normal');\n\n      if (normalAttribute === undefined) {\n        normalAttribute = new BufferAttribute(\n          new Float32Array(positionAttribute.count * 3),\n          3,\n        );\n        this.setAttribute('normal', normalAttribute);\n      } else {\n        // reset existing normals to zero\n\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n\n      const pA = new Vector3(),\n        pB = new Vector3(),\n        pC = new Vector3();\n      const nA = new Vector3(),\n        nB = new Vector3(),\n        nC = new Vector3();\n      const cb = new Vector3(),\n        ab = new Vector3();\n\n      // indexed elements\n\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n\n      this.normalizeNormals();\n\n      normalAttribute.needsUpdate = true;\n    }\n  }\n\n  merge(geometry, offset) {\n    if (!(geometry && geometry.isBufferGeometry)) {\n      console.error(\n        'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',\n        geometry,\n      );\n      return;\n    }\n\n    if (offset === undefined) {\n      offset = 0;\n\n      console.warn(\n        'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' +\n          'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',\n      );\n    }\n\n    const attributes = this.attributes;\n\n    for (const key in attributes) {\n      if (geometry.attributes[key] === undefined) continue;\n\n      const attribute1 = attributes[key];\n      const attributeArray1 = attribute1.array;\n\n      const attribute2 = geometry.attributes[key];\n      const attributeArray2 = attribute2.array;\n\n      const attributeOffset = attribute2.itemSize * offset;\n      const length = Math.min(\n        attributeArray2.length,\n        attributeArray1.length - attributeOffset,\n      );\n\n      for (let i = 0, j = attributeOffset; i < length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n\n    return this;\n  }\n\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector$8.fromBufferAttribute(normals, i);\n\n      _vector$8.normalize();\n\n      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n    }\n  }\n\n  toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n\n      const array2 = new array.constructor(indices.length * itemSize);\n\n      let index = 0,\n        index2 = 0;\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        if (attribute.isInterleavedBufferAttribute) {\n          index = indices[i] * attribute.data.stride + attribute.offset;\n        } else {\n          index = indices[i] * itemSize;\n        }\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new BufferAttribute(array2, itemSize, normalized);\n    }\n\n    //\n\n    if (this.index === null) {\n      console.warn(\n        'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.',\n      );\n      return this;\n    }\n\n    const geometry2 = new BufferGeometry();\n\n    const indices = this.index.array;\n    const attributes = this.attributes;\n\n    // attributes\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n\n      const newAttribute = convertBufferAttribute(attribute, indices);\n\n      geometry2.setAttribute(name, newAttribute);\n    }\n\n    // morph attributes\n\n    const morphAttributes = this.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n\n        const newAttribute = convertBufferAttribute(attribute, indices);\n\n        morphArray.push(newAttribute);\n      }\n\n      geometry2.morphAttributes[name] = morphArray;\n    }\n\n    geometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n    // groups\n\n    const groups = this.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    return geometry2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON',\n      },\n    };\n\n    // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (const key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n    data.data = { attributes: {} };\n\n    const index = this.index;\n\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array),\n      };\n    }\n\n    const attributes = this.attributes;\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n\n      const array = [];\n\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n\n        array.push(attribute.toJSON(data.data));\n      }\n\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n\n        hasMorphAttributes = true;\n      }\n    }\n\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n\n    const groups = this.groups;\n\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n\n    const boundingSphere = this.boundingSphere;\n\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius,\n      };\n    }\n\n    return data;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    // reset\n\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    // used for storing cloned, shared data\n\n    const data = {};\n\n    // name\n\n    this.name = source.name;\n\n    // index\n\n    const index = source.index;\n\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    }\n\n    // attributes\n\n    const attributes = source.attributes;\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    }\n\n    // morph attributes\n\n    const morphAttributes = source.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n\n      this.morphAttributes[name] = array;\n    }\n\n    this.morphTargetsRelative = source.morphTargetsRelative;\n\n    // groups\n\n    const groups = source.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n\n    // draw range\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count;\n\n    // user data\n\n    this.userData = source.userData;\n\n    // geometry generator parameters\n\n    if (source.parameters !== undefined)\n      this.parameters = Object.assign({}, source.parameters);\n\n    return this;\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' });\n  }\n}\n\nBufferGeometry.prototype.isBufferGeometry = true;\n\nconst _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _ray$2 = /*@__PURE__*/ new Ray();\nconst _sphere$3 = /*@__PURE__*/ new Sphere();\n\nconst _vA$1 = /*@__PURE__*/ new Vector3();\nconst _vB$1 = /*@__PURE__*/ new Vector3();\nconst _vC$1 = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _tempB = /*@__PURE__*/ new Vector3();\nconst _tempC = /*@__PURE__*/ new Vector3();\n\nconst _morphA = /*@__PURE__*/ new Vector3();\nconst _morphB = /*@__PURE__*/ new Vector3();\nconst _morphC = /*@__PURE__*/ new Vector3();\n\nconst _uvA$1 = /*@__PURE__*/ new Vector2();\nconst _uvB$1 = /*@__PURE__*/ new Vector2();\nconst _uvC$1 = /*@__PURE__*/ new Vector2();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n  constructor(\n    geometry = new BufferGeometry(),\n    material = new MeshBasicMaterial(),\n  ) {\n    super();\n\n    this.type = 'Mesh';\n\n    this.geometry = geometry;\n    this.material = material;\n\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    if (source.morphTargetInfluences !== undefined) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n\n    if (source.morphTargetDictionary !== undefined) {\n      this.morphTargetDictionary = Object.assign(\n        {},\n        source.morphTargetDictionary,\n      );\n    }\n\n    this.material = source.material;\n    this.geometry = source.geometry;\n\n    return this;\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error(\n          'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',\n        );\n      }\n    }\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n\n    if (material === undefined) return;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere$3.copy(geometry.boundingSphere);\n    _sphere$3.applyMatrix4(matrixWorld);\n\n    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;\n\n    //\n\n    _inverseMatrix$2.copy(matrixWorld).invert();\n    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);\n\n    // Check boundingBox before continuing\n\n    if (geometry.boundingBox !== null) {\n      if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;\n    }\n\n    let intersection;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      const uv = geometry.attributes.uv;\n      const uv2 = geometry.attributes.uv2;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n\n      if (index !== null) {\n        // indexed buffer geometry\n\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(\n              index.count,\n              Math.min(\n                group.start + group.count,\n                drawRange.start + drawRange.count,\n              ),\n            );\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n\n              intersection = checkBufferGeometryIntersection(\n                this,\n                groupMaterial,\n                raycaster,\n                _ray$2,\n                position,\n                morphPosition,\n                morphTargetsRelative,\n                uv,\n                uv2,\n                a,\n                b,\n                c,\n              );\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = index.getX(i);\n            const b = index.getX(i + 1);\n            const c = index.getX(i + 2);\n\n            intersection = checkBufferGeometryIntersection(\n              this,\n              material,\n              raycaster,\n              _ray$2,\n              position,\n              morphPosition,\n              morphTargetsRelative,\n              uv,\n              uv2,\n              a,\n              b,\n              c,\n            );\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== undefined) {\n        // non-indexed buffer geometry\n\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(\n              position.count,\n              Math.min(\n                group.start + group.count,\n                drawRange.start + drawRange.count,\n              ),\n            );\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n\n              intersection = checkBufferGeometryIntersection(\n                this,\n                groupMaterial,\n                raycaster,\n                _ray$2,\n                position,\n                morphPosition,\n                morphTargetsRelative,\n                uv,\n                uv2,\n                a,\n                b,\n                c,\n              );\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(\n            position.count,\n            drawRange.start + drawRange.count,\n          );\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = i;\n            const b = i + 1;\n            const c = i + 2;\n\n            intersection = checkBufferGeometryIntersection(\n              this,\n              material,\n              raycaster,\n              _ray$2,\n              position,\n              morphPosition,\n              morphTargetsRelative,\n              uv,\n              uv2,\n              a,\n              b,\n              c,\n            );\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error(\n        'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',\n      );\n    }\n  }\n}\n\nMesh.prototype.isMesh = true;\n\nfunction checkIntersection(\n  object,\n  material,\n  raycaster,\n  ray,\n  pA,\n  pB,\n  pC,\n  point,\n) {\n  let intersect;\n\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(\n      pA,\n      pB,\n      pC,\n      material.side !== DoubleSide,\n      point,\n    );\n  }\n\n  if (intersect === null) return null;\n\n  _intersectionPointWorld.copy(point);\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object,\n  };\n}\n\nfunction checkBufferGeometryIntersection(\n  object,\n  material,\n  raycaster,\n  ray,\n  position,\n  morphPosition,\n  morphTargetsRelative,\n  uv,\n  uv2,\n  a,\n  b,\n  c,\n) {\n  _vA$1.fromBufferAttribute(position, a);\n  _vB$1.fromBufferAttribute(position, b);\n  _vC$1.fromBufferAttribute(position, c);\n\n  const morphInfluences = object.morphTargetInfluences;\n\n  if (morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n    _morphB.set(0, 0, 0);\n    _morphC.set(0, 0, 0);\n\n    for (let i = 0, il = morphPosition.length; i < il; i++) {\n      const influence = morphInfluences[i];\n      const morphAttribute = morphPosition[i];\n\n      if (influence === 0) continue;\n\n      _tempA.fromBufferAttribute(morphAttribute, a);\n      _tempB.fromBufferAttribute(morphAttribute, b);\n      _tempC.fromBufferAttribute(morphAttribute, c);\n\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n        _morphB.addScaledVector(_tempB, influence);\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);\n        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);\n        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);\n      }\n    }\n\n    _vA$1.add(_morphA);\n    _vB$1.add(_morphB);\n    _vC$1.add(_morphC);\n  }\n\n  if (object.isSkinnedMesh) {\n    object.boneTransform(a, _vA$1);\n    object.boneTransform(b, _vB$1);\n    object.boneTransform(c, _vC$1);\n  }\n\n  const intersection = checkIntersection(\n    object,\n    material,\n    raycaster,\n    ray,\n    _vA$1,\n    _vB$1,\n    _vC$1,\n    _intersectionPoint,\n  );\n\n  if (intersection) {\n    if (uv) {\n      _uvA$1.fromBufferAttribute(uv, a);\n      _uvB$1.fromBufferAttribute(uv, b);\n      _uvC$1.fromBufferAttribute(uv, c);\n\n      intersection.uv = Triangle.getUV(\n        _intersectionPoint,\n        _vA$1,\n        _vB$1,\n        _vC$1,\n        _uvA$1,\n        _uvB$1,\n        _uvC$1,\n        new Vector2(),\n      );\n    }\n\n    if (uv2) {\n      _uvA$1.fromBufferAttribute(uv2, a);\n      _uvB$1.fromBufferAttribute(uv2, b);\n      _uvC$1.fromBufferAttribute(uv2, c);\n\n      intersection.uv2 = Triangle.getUV(\n        _intersectionPoint,\n        _vA$1,\n        _vB$1,\n        _vC$1,\n        _uvA$1,\n        _uvB$1,\n        _uvC$1,\n        new Vector2(),\n      );\n    }\n\n    const face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0,\n    };\n\n    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n\n    intersection.face = face;\n  }\n\n  return intersection;\n}\n\nclass BoxGeometry extends BufferGeometry {\n  constructor(\n    width = 1,\n    height = 1,\n    depth = 1,\n    widthSegments = 1,\n    heightSegments = 1,\n    depthSegments = 1,\n  ) {\n    super();\n\n    this.type = 'BoxGeometry';\n\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments,\n    };\n\n    const scope = this;\n\n    // segments\n\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments);\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    let numberOfVertices = 0;\n    let groupStart = 0;\n\n    // build each side of the box geometry\n\n    buildPlane(\n      'z',\n      'y',\n      'x',\n      -1,\n      -1,\n      depth,\n      height,\n      width,\n      depthSegments,\n      heightSegments,\n      0,\n    ); // px\n    buildPlane(\n      'z',\n      'y',\n      'x',\n      1,\n      -1,\n      depth,\n      height,\n      -width,\n      depthSegments,\n      heightSegments,\n      1,\n    ); // nx\n    buildPlane(\n      'x',\n      'z',\n      'y',\n      1,\n      1,\n      width,\n      depth,\n      height,\n      widthSegments,\n      depthSegments,\n      2,\n    ); // py\n    buildPlane(\n      'x',\n      'z',\n      'y',\n      1,\n      -1,\n      width,\n      depth,\n      -height,\n      widthSegments,\n      depthSegments,\n      3,\n    ); // ny\n    buildPlane(\n      'x',\n      'y',\n      'z',\n      1,\n      -1,\n      width,\n      height,\n      depth,\n      widthSegments,\n      heightSegments,\n      4,\n    ); // pz\n    buildPlane(\n      'x',\n      'y',\n      'z',\n      -1,\n      -1,\n      width,\n      height,\n      -depth,\n      widthSegments,\n      heightSegments,\n      5,\n    ); // nz\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function buildPlane(\n      u,\n      v,\n      w,\n      udir,\n      vdir,\n      width,\n      height,\n      depth,\n      gridX,\n      gridY,\n      materialIndex,\n    ) {\n      const segmentWidth = width / gridX;\n      const segmentHeight = height / gridY;\n\n      const widthHalf = width / 2;\n      const heightHalf = height / 2;\n      const depthHalf = depth / 2;\n\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n\n      let vertexCounter = 0;\n      let groupCount = 0;\n\n      const vector = new Vector3();\n\n      // generate vertices, normals and uvs\n\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segmentHeight - heightHalf;\n\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x = ix * segmentWidth - widthHalf;\n\n          // set values to correct vector component\n\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf;\n\n          // now apply vector to vertex buffer\n\n          vertices.push(vector.x, vector.y, vector.z);\n\n          // set values to correct vector component\n\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth > 0 ? 1 : -1;\n\n          // now apply vector to normal buffer\n\n          normals.push(vector.x, vector.y, vector.z);\n\n          // uvs\n\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n\n          // counters\n\n          vertexCounter += 1;\n        }\n      }\n\n      // indices\n\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + ix + gridX1 * (iy + 1);\n          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 * iy;\n\n          // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n\n          // increase counter\n\n          groupCount += 6;\n        }\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup(groupStart, groupCount, materialIndex);\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n\n      // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n    }\n  }\n\n  static fromJSON(data) {\n    return new BoxGeometry(\n      data.width,\n      data.height,\n      data.depth,\n      data.widthSegments,\n      data.heightSegments,\n      data.depthSegments,\n    );\n  }\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms(src) {\n  const dst = {};\n\n  for (const u in src) {\n    dst[u] = {};\n\n    for (const p in src[u]) {\n      const property = src[u][p];\n\n      if (\n        property &&\n        (property.isColor ||\n          property.isMatrix3 ||\n          property.isMatrix4 ||\n          property.isVector2 ||\n          property.isVector3 ||\n          property.isVector4 ||\n          property.isTexture ||\n          property.isQuaternion)\n      ) {\n        dst[u][p] = property.clone();\n      } else if (Array.isArray(property)) {\n        dst[u][p] = property.slice();\n      } else {\n        dst[u][p] = property;\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction mergeUniforms(uniforms) {\n  const merged = {};\n\n  for (let u = 0; u < uniforms.length; u++) {\n    const tmp = cloneUniforms(uniforms[u]);\n\n    for (const p in tmp) {\n      merged[p] = tmp[p];\n    }\n  }\n\n  return merged;\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex =\n  'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\nvar default_fragment =\n  'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n/**\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>\n * }\n */\n\nclass ShaderMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'ShaderMaterial';\n\n    this.defines = {};\n    this.uniforms = {};\n\n    this.vertexShader = default_vertex;\n    this.fragmentShader = default_fragment;\n\n    this.linewidth = 1;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n\n    this.fog = false; // set to use scene fog\n    this.lights = false; // set to use scene lights\n    this.clipping = false; // set to use user-defined clipping planes\n\n    this.extensions = {\n      derivatives: false, // set to use derivatives\n      fragDepth: false, // set to use fragment depth values\n      drawBuffers: false, // set to use draw buffers\n      shaderTextureLOD: false, // set to use shader texture LOD\n    };\n\n    // When rendered geometry doesn't include these attributes but the material does,\n    // use these default values in WebGL. This avoids errors when buffer data is missing.\n    this.defaultAttributeValues = {\n      color: [1, 1, 1],\n      uv: [0, 0],\n      uv2: [0, 0],\n    };\n\n    this.index0AttributeName = undefined;\n    this.uniformsNeedUpdate = false;\n\n    this.glslVersion = null;\n\n    if (parameters !== undefined) {\n      if (parameters.attributes !== undefined) {\n        console.error(\n          'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.',\n        );\n      }\n\n      this.setValues(parameters);\n    }\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.fragmentShader = source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n\n    this.uniforms = cloneUniforms(source.uniforms);\n\n    this.defines = Object.assign({}, source.defines);\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n\n    this.lights = source.lights;\n    this.clipping = source.clipping;\n\n    this.extensions = Object.assign({}, source.extensions);\n\n    this.glslVersion = source.glslVersion;\n\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n\n    data.glslVersion = this.glslVersion;\n    data.uniforms = {};\n\n    for (const name in this.uniforms) {\n      const uniform = this.uniforms[name];\n      const value = uniform.value;\n\n      if (value && value.isTexture) {\n        data.uniforms[name] = {\n          type: 't',\n          value: value.toJSON(meta).uuid,\n        };\n      } else if (value && value.isColor) {\n        data.uniforms[name] = {\n          type: 'c',\n          value: value.getHex(),\n        };\n      } else if (value && value.isVector2) {\n        data.uniforms[name] = {\n          type: 'v2',\n          value: value.toArray(),\n        };\n      } else if (value && value.isVector3) {\n        data.uniforms[name] = {\n          type: 'v3',\n          value: value.toArray(),\n        };\n      } else if (value && value.isVector4) {\n        data.uniforms[name] = {\n          type: 'v4',\n          value: value.toArray(),\n        };\n      } else if (value && value.isMatrix3) {\n        data.uniforms[name] = {\n          type: 'm3',\n          value: value.toArray(),\n        };\n      } else if (value && value.isMatrix4) {\n        data.uniforms[name] = {\n          type: 'm4',\n          value: value.toArray(),\n        };\n      } else {\n        data.uniforms[name] = {\n          value: value,\n        };\n\n        // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n      }\n    }\n\n    if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n\n    data.vertexShader = this.vertexShader;\n    data.fragmentShader = this.fragmentShader;\n\n    const extensions = {};\n\n    for (const key in this.extensions) {\n      if (this.extensions[key] === true) extensions[key] = true;\n    }\n\n    if (Object.keys(extensions).length > 0) data.extensions = extensions;\n\n    return data;\n  }\n}\n\nShaderMaterial.prototype.isShaderMaterial = true;\n\nclass Camera extends Object3D {\n  constructor() {\n    super();\n\n    this.type = 'Camera';\n\n    this.matrixWorldInverse = new Matrix4();\n\n    this.projectionMatrix = new Matrix4();\n    this.projectionMatrixInverse = new Matrix4();\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n\n    this.matrixWorldInverse.copy(source.matrixWorldInverse);\n\n    this.projectionMatrix.copy(source.projectionMatrix);\n    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n\n    return this;\n  }\n\n  getWorldDirection(target) {\n    this.updateWorldMatrix(true, false);\n\n    const e = this.matrixWorld.elements;\n\n    return target.set(-e[8], -e[9], -e[10]).normalize();\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n\n  updateWorldMatrix(updateParents, updateChildren) {\n    super.updateWorldMatrix(updateParents, updateChildren);\n\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\n\nCamera.prototype.isCamera = true;\n\nclass PerspectiveCamera extends Camera {\n  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n    super();\n\n    this.type = 'PerspectiveCamera';\n\n    this.fov = fov;\n    this.zoom = 1;\n\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n\n    this.aspect = aspect;\n    this.view = null;\n\n    this.filmGauge = 35; // width of the film (default in millimeters)\n    this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n    this.updateProjectionMatrix();\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n\n    return this;\n  }\n\n  /**\n   * Sets the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The default film gauge is 35, so that the focal length can be specified for\n   * a 35mm (full frame) camera.\n   *\n   * Values for focal length and film gauge must have the same unit.\n   */\n  setFocalLength(focalLength) {\n    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n    const vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength;\n\n    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n\n  /**\n   * Calculates the focal length from the current .fov and .filmGauge.\n   */\n  getFocalLength() {\n    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n\n    return (0.5 * this.getFilmHeight()) / vExtentSlope;\n  }\n\n  getEffectiveFOV() {\n    return (\n      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)\n    );\n  }\n\n  getFilmWidth() {\n    // film not completely covered in portrait format (aspect < 1)\n    return this.filmGauge * Math.min(this.aspect, 1);\n  }\n\n  getFilmHeight() {\n    // film not completely covered in landscape format (aspect > 1)\n    return this.filmGauge / Math.max(this.aspect, 1);\n  }\n\n  /**\n   * Sets an offset in a larger frustum. This is useful for multi-window or\n   * multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n   * the monitors are in grid like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   +---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then for each monitor you would call it like this\n   *\n   *   const w = 1920;\n   *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   --C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no reason monitors have to be the same size or in a grid.\n   */\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1,\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n\n    this.updateProjectionMatrix();\n  }\n\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  }\n\n  updateProjectionMatrix() {\n    const near = this.near;\n    let top = (near * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth,\n        fullHeight = view.fullHeight;\n\n      left += (view.offsetX * width) / fullWidth;\n      top -= (view.offsetY * height) / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n\n    const skew = this.filmOffset;\n    if (skew !== 0) left += (near * skew) / this.getFilmWidth();\n\n    this.projectionMatrix.makePerspective(\n      left,\n      left + width,\n      top,\n      top - height,\n      near,\n      this.far,\n    );\n\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n\n    data.object.aspect = this.aspect;\n\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n\n    return data;\n  }\n}\n\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\n\nconst fov = 90,\n  aspect = 1;\n\nclass CubeCamera extends Object3D {\n  constructor(near, far, renderTarget) {\n    super();\n\n    this.type = 'CubeCamera';\n\n    if (renderTarget.isWebGLCubeRenderTarget !== true) {\n      console.error(\n        'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.',\n      );\n      return;\n    }\n\n    this.renderTarget = renderTarget;\n\n    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPX.layers = this.layers;\n    cameraPX.up.set(0, -1, 0);\n    cameraPX.lookAt(new Vector3(1, 0, 0));\n    this.add(cameraPX);\n\n    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNX.layers = this.layers;\n    cameraNX.up.set(0, -1, 0);\n    cameraNX.lookAt(new Vector3(-1, 0, 0));\n    this.add(cameraNX);\n\n    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPY.layers = this.layers;\n    cameraPY.up.set(0, 0, 1);\n    cameraPY.lookAt(new Vector3(0, 1, 0));\n    this.add(cameraPY);\n\n    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNY.layers = this.layers;\n    cameraNY.up.set(0, 0, -1);\n    cameraNY.lookAt(new Vector3(0, -1, 0));\n    this.add(cameraNY);\n\n    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPZ.layers = this.layers;\n    cameraPZ.up.set(0, -1, 0);\n    cameraPZ.lookAt(new Vector3(0, 0, 1));\n    this.add(cameraPZ);\n\n    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNZ.layers = this.layers;\n    cameraNZ.up.set(0, -1, 0);\n    cameraNZ.lookAt(new Vector3(0, 0, -1));\n    this.add(cameraNZ);\n  }\n\n  update(renderer, scene) {\n    if (this.parent === null) this.updateMatrixWorld();\n\n    const renderTarget = this.renderTarget;\n\n    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] =\n      this.children;\n\n    const currentXrEnabled = renderer.xr.enabled;\n    const currentRenderTarget = renderer.getRenderTarget();\n\n    renderer.xr.enabled = false;\n\n    const generateMipmaps = renderTarget.texture.generateMipmaps;\n\n    renderTarget.texture.generateMipmaps = false;\n\n    renderer.setRenderTarget(renderTarget, 0);\n    renderer.render(scene, cameraPX);\n\n    renderer.setRenderTarget(renderTarget, 1);\n    renderer.render(scene, cameraNX);\n\n    renderer.setRenderTarget(renderTarget, 2);\n    renderer.render(scene, cameraPY);\n\n    renderer.setRenderTarget(renderTarget, 3);\n    renderer.render(scene, cameraNY);\n\n    renderer.setRenderTarget(renderTarget, 4);\n    renderer.render(scene, cameraPZ);\n\n    renderTarget.texture.generateMipmaps = generateMipmaps;\n\n    renderer.setRenderTarget(renderTarget, 5);\n    renderer.render(scene, cameraNZ);\n\n    renderer.setRenderTarget(currentRenderTarget);\n\n    renderer.xr.enabled = currentXrEnabled;\n  }\n}\n\nclass CubeTexture extends Texture$1 {\n  constructor(\n    images,\n    mapping,\n    wrapS,\n    wrapT,\n    magFilter,\n    minFilter,\n    format,\n    type,\n    anisotropy,\n    encoding,\n  ) {\n    images = images !== undefined ? images : [];\n    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n    super(\n      images,\n      mapping,\n      wrapS,\n      wrapT,\n      magFilter,\n      minFilter,\n      format,\n      type,\n      anisotropy,\n      encoding,\n    );\n\n    this.flipY = false;\n  }\n\n  get images() {\n    return this.image;\n  }\n\n  set images(value) {\n    this.image = value;\n  }\n}\n\nCubeTexture.prototype.isCubeTexture = true;\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n  constructor(size, options, dummy) {\n    if (Number.isInteger(options)) {\n      console.warn(\n        'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )',\n      );\n\n      options = dummy;\n    }\n\n    super(size, size, options);\n\n    options = options || {};\n\n    // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n    this.texture = new CubeTexture(\n      undefined,\n      options.mapping,\n      options.wrapS,\n      options.wrapT,\n      options.magFilter,\n      options.minFilter,\n      options.format,\n      options.type,\n      options.anisotropy,\n      options.encoding,\n    );\n    this.texture.isRenderTargetTexture = true;\n\n    this.texture.generateMipmaps =\n      options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    this.texture.minFilter =\n      options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n    this.texture._needsFlipEnvMap = false;\n  }\n\n  fromEquirectangularTexture(renderer, texture) {\n    this.texture.type = texture.type;\n    this.texture.format = RGBAFormat; // see #18859\n    this.texture.encoding = texture.encoding;\n\n    this.texture.generateMipmaps = texture.generateMipmaps;\n    this.texture.minFilter = texture.minFilter;\n    this.texture.magFilter = texture.magFilter;\n\n    const shader = {\n      uniforms: {\n        tEquirect: { value: null },\n      },\n\n      vertexShader: /* glsl */ `\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n      fragmentShader: /* glsl */ `\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`,\n    };\n\n    const geometry = new BoxGeometry(5, 5, 5);\n\n    const material = new ShaderMaterial({\n      name: 'CubemapFromEquirect',\n\n      uniforms: cloneUniforms(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      side: BackSide,\n      blending: NoBlending,\n    });\n\n    material.uniforms.tEquirect.value = texture;\n\n    const mesh = new Mesh(geometry, material);\n\n    const currentMinFilter = texture.minFilter;\n\n    // Avoid blurred poles\n    if (texture.minFilter === LinearMipmapLinearFilter)\n      texture.minFilter = LinearFilter;\n\n    const camera = new CubeCamera(1, 10, this);\n    camera.update(renderer, mesh);\n\n    texture.minFilter = currentMinFilter;\n\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n\n    return this;\n  }\n\n  clear(renderer, color, depth, stencil) {\n    const currentRenderTarget = renderer.getRenderTarget();\n\n    for (let i = 0; i < 6; i++) {\n      renderer.setRenderTarget(this, i);\n\n      renderer.clear(color, depth, stencil);\n    }\n\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n}\n\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n  constructor(normal = new Vector3(1, 0, 0), constant = 0) {\n    // normal is assumed to be normalized\n\n    this.normal = normal;\n    this.constant = constant;\n  }\n\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n\n    return this;\n  }\n\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n\n    return this;\n  }\n\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n\n    return this;\n  }\n\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1\n      .subVectors(c, b)\n      .cross(_vector2.subVectors(a, b))\n      .normalize();\n\n    // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n\n    return this;\n  }\n\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n\n    return this;\n  }\n\n  normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n\n    const inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n\n    return this;\n  }\n\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n\n  projectPoint(point, target) {\n    return target\n      .copy(this.normal)\n      .multiplyScalar(-this.distanceToPoint(point))\n      .add(point);\n  }\n\n  intersectLine(line, target) {\n    const direction = line.delta(_vector1);\n\n    const denominator = this.normal.dot(direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      }\n\n      // Unsure if this is the correct method to handle this case.\n      return null;\n    }\n\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n    if (t < 0 || t > 1) {\n      return null;\n    }\n\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n\n  intersectsLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n\n    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);\n  }\n\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n\n  coplanarPoint(target) {\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix =\n      optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n\n    this.constant = -referencePoint.dot(normal);\n\n    return this;\n  }\n\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n\n    return this;\n  }\n\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\n\nPlane.prototype.isPlane = true;\n\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n  constructor(\n    p0 = new Plane(),\n    p1 = new Plane(),\n    p2 = new Plane(),\n    p3 = new Plane(),\n    p4 = new Plane(),\n    p5 = new Plane(),\n  ) {\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n\n  set(p0, p1, p2, p3, p4, p5) {\n    const planes = this.planes;\n\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n\n    return this;\n  }\n\n  copy(frustum) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n\n    return this;\n  }\n\n  setFromProjectionMatrix(m) {\n    const planes = this.planes;\n    const me = m.elements;\n    const me0 = me[0],\n      me1 = me[1],\n      me2 = me[2],\n      me3 = me[3];\n    const me4 = me[4],\n      me5 = me[5],\n      me6 = me[6],\n      me7 = me[7];\n    const me8 = me[8],\n      me9 = me[9],\n      me10 = me[10],\n      me11 = me[11];\n    const me12 = me[12],\n      me13 = me[13],\n      me14 = me[14],\n      me15 = me[15];\n\n    planes[0]\n      .setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12)\n      .normalize();\n    planes[1]\n      .setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12)\n      .normalize();\n    planes[2]\n      .setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13)\n      .normalize();\n    planes[3]\n      .setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13)\n      .normalize();\n    planes[4]\n      .setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14)\n      .normalize();\n    planes[5]\n      .setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14)\n      .normalize();\n\n    return this;\n  }\n\n  intersectsObject(object) {\n    const geometry = object.geometry;\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n\n    return this.intersectsSphere(_sphere$2);\n  }\n\n  intersectsSprite(sprite) {\n    _sphere$2.center.set(0, 0, 0);\n    _sphere$2.radius = 0.7071067811865476;\n    _sphere$2.applyMatrix4(sprite.matrixWorld);\n\n    return this.intersectsSphere(_sphere$2);\n  }\n\n  intersectsSphere(sphere) {\n    const planes = this.planes;\n    const center = sphere.center;\n    const negRadius = -sphere.radius;\n\n    for (let i = 0; i < 6; i++) {\n      const distance = planes[i].distanceToPoint(center);\n\n      if (distance < negRadius) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  intersectsBox(box) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = planes[i];\n\n      // corner at max distance\n\n      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n      if (plane.distanceToPoint(_vector$7) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  containsPoint(point) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      if (planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\n\nfunction WebGLAnimation() {\n  let context = null;\n  let isAnimating = false;\n  let animationLoop = null;\n  let requestId = null;\n\n  function onAnimationFrame(time, frame) {\n    animationLoop(time, frame);\n\n    requestId = context.requestAnimationFrame(onAnimationFrame);\n  }\n\n  return {\n    start: function () {\n      if (isAnimating === true) return;\n      if (animationLoop === null) return;\n\n      requestId = context.requestAnimationFrame(onAnimationFrame);\n\n      isAnimating = true;\n    },\n\n    stop: function () {\n      context.cancelAnimationFrame(requestId);\n\n      isAnimating = false;\n    },\n\n    setAnimationLoop: function (callback) {\n      animationLoop = callback;\n    },\n\n    setContext: function (value) {\n      context = value;\n    },\n  };\n}\n\nfunction WebGLAttributes(gl, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n\n  const buffers = new WeakMap();\n\n  function createBuffer(attribute, bufferType) {\n    const array = attribute.array;\n    const usage = attribute.usage;\n\n    const buffer = gl.createBuffer();\n\n    gl.bindBuffer(bufferType, buffer);\n    gl.bufferData(bufferType, array, usage);\n\n    attribute.onUploadCallback();\n\n    let type = 5126;\n\n    if (array instanceof Float32Array) {\n      type = 5126;\n    } else if (array instanceof Float64Array) {\n      console.warn(\n        'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.',\n      );\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        if (isWebGL2) {\n          type = 5131;\n        } else {\n          console.warn(\n            'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.',\n          );\n        }\n      } else {\n        type = 5123;\n      }\n    } else if (array instanceof Int16Array) {\n      type = 5122;\n    } else if (array instanceof Uint32Array) {\n      type = 5125;\n    } else if (array instanceof Int32Array) {\n      type = 5124;\n    } else if (array instanceof Int8Array) {\n      type = 5120;\n    } else if (array instanceof Uint8Array) {\n      type = 5121;\n    } else if (array instanceof Uint8ClampedArray) {\n      type = 5121;\n    }\n\n    return {\n      buffer: buffer,\n      type: type,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version,\n    };\n  }\n\n  function updateBuffer(buffer, attribute, bufferType) {\n    const array = attribute.array;\n    const updateRange = attribute.updateRange;\n\n    gl.bindBuffer(bufferType, buffer);\n\n    if (updateRange.count === -1) {\n      // Not using update ranges\n\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      if (isWebGL2) {\n        gl.bufferSubData(\n          bufferType,\n          updateRange.offset * array.BYTES_PER_ELEMENT,\n          array,\n          updateRange.offset,\n          updateRange.count,\n        );\n      } else {\n        gl.bufferSubData(\n          bufferType,\n          updateRange.offset * array.BYTES_PER_ELEMENT,\n          array.subarray(\n            updateRange.offset,\n            updateRange.offset + updateRange.count,\n          ),\n        );\n      }\n\n      updateRange.count = -1; // reset range\n    }\n  }\n\n  //\n\n  function get(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\n    return buffers.get(attribute);\n  }\n\n  function remove(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\n    const data = buffers.get(attribute);\n\n    if (data) {\n      gl.deleteBuffer(data.buffer);\n\n      buffers.delete(attribute);\n    }\n  }\n\n  function update(attribute, bufferType) {\n    if (attribute.isGLBufferAttribute) {\n      const cached = buffers.get(attribute);\n\n      if (!cached || cached.version < attribute.version) {\n        buffers.set(attribute, {\n          buffer: attribute.buffer,\n          type: attribute.type,\n          bytesPerElement: attribute.elementSize,\n          version: attribute.version,\n        });\n      }\n\n      return;\n    }\n\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\n    const data = buffers.get(attribute);\n\n    if (data === undefined) {\n      buffers.set(attribute, createBuffer(attribute, bufferType));\n    } else if (data.version < attribute.version) {\n      updateBuffer(data.buffer, attribute, bufferType);\n\n      data.version = attribute.version;\n    }\n  }\n\n  return {\n    get: get,\n    remove: remove,\n    update: update,\n  };\n}\n\nclass PlaneGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n    super();\n    this.type = 'PlaneGeometry';\n\n    this.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n    };\n\n    const width_half = width / 2;\n    const height_half = height / 2;\n\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n\n    const segment_width = width / gridX;\n    const segment_height = height / gridY;\n\n    //\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    for (let iy = 0; iy < gridY1; iy++) {\n      const y = iy * segment_height - height_half;\n\n      for (let ix = 0; ix < gridX1; ix++) {\n        const x = ix * segment_width - width_half;\n\n        vertices.push(x, -y, 0);\n\n        normals.push(0, 0, 1);\n\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      }\n    }\n\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix < gridX; ix++) {\n        const a = ix + gridX1 * iy;\n        const b = ix + gridX1 * (iy + 1);\n        const c = ix + 1 + gridX1 * (iy + 1);\n        const d = ix + 1 + gridX1 * iy;\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n  static fromJSON(data) {\n    return new PlaneGeometry(\n      data.width,\n      data.height,\n      data.widthSegments,\n      data.heightSegments,\n    );\n  }\n}\n\nvar alphamap_fragment =\n  '#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif';\n\nvar alphamap_pars_fragment =\n  '#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif';\n\nvar alphatest_fragment =\n  '#ifdef USE_ALPHATEST\\n\\tif ( diffuseColor.a < alphaTest ) discard;\\n#endif';\n\nvar alphatest_pars_fragment =\n  '#ifdef USE_ALPHATEST\\n\\tuniform float alphaTest;\\n#endif';\n\nvar aomap_fragment =\n  '#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\\n\\t#endif\\n#endif';\n\nvar aomap_pars_fragment =\n  '#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif';\n\nvar begin_vertex = 'vec3 transformed = vec3( position );';\n\nvar beginnormal_vertex =\n  'vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif';\n\nvar bsdfs =\n  'vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( V * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float dotNH ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tfloat invAlpha = 1.0 / alpha;\\n\\tfloat cos2h = dotNH * dotNH;\\n\\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\\n\\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat D = D_Charlie( sheenRoughness, dotNH );\\n\\tfloat V = V_Neubelt( dotNV, dotNL );\\n\\treturn sheenTint * ( D * V );\\n}\\n#endif';\n\nvar bumpmap_pars_fragment =\n  '#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif';\n\nvar clipping_planes_fragment =\n  '#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif';\n\nvar clipping_planes_pars_fragment =\n  '#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif';\n\nvar clipping_planes_pars_vertex =\n  '#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif';\n\nvar clipping_planes_vertex =\n  '#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif';\n\nvar color_fragment =\n  '#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif';\n\nvar color_pars_fragment =\n  '#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif';\n\nvar color_pars_vertex =\n  '#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif';\n\nvar color_vertex =\n  '#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif';\n\nvar common =\n  '#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract( sin( sn ) * c );\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}';\n\nvar cube_uv_reflection_fragment =\n  '#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_maxMipLevel 8.0\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_maxTileSize 256.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\\t\\tvec2 f = fract( uv );\\n\\t\\tuv += 0.5 - f;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t}\\n\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\\t\\tuv *= texelSize;\\n\\t\\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x += texelSize;\\n\\t\\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.y += texelSize;\\n\\t\\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x -= texelSize;\\n\\t\\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\treturn mix( tm, bm, f.y );\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif';\n\nvar defaultnormal_vertex =\n  'vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif';\n\nvar displacementmap_pars_vertex =\n  '#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif';\n\nvar displacementmap_vertex =\n  '#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif';\n\nvar emissivemap_fragment =\n  '#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif';\n\nvar emissivemap_pars_fragment =\n  '#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif';\n\nvar encodings_fragment = 'gl_FragColor = linearToOutputTexel( gl_FragColor );';\n\nvar encodings_pars_fragment =\n  '\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}';\n\nvar envmap_fragment =\n  '#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif';\n\nvar envmap_common_pars_fragment =\n  '#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif';\n\nvar envmap_pars_fragment =\n  '#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif';\n\nvar envmap_pars_vertex =\n  '#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif';\n\nvar envmap_vertex =\n  '#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif';\n\nvar fog_vertex = '#ifdef USE_FOG\\n\\tvFogDepth = - mvPosition.z;\\n#endif';\n\nvar fog_pars_vertex = '#ifdef USE_FOG\\n\\tvarying float vFogDepth;\\n#endif';\n\nvar fog_fragment =\n  '#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif';\n\nvar fog_pars_fragment =\n  '#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float vFogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif';\n\nvar gradientmap_pars_fragment =\n  '#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}';\n\nvar lightmap_fragment =\n  '#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\\n\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tlightMapIrradiance *= PI;\\n\\t#endif\\n\\treflectedLight.indirectDiffuse += lightMapIrradiance;\\n#endif';\n\nvar lightmap_pars_fragment =\n  '#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif';\n\nvar lights_lambert_vertex =\n  'vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif';\n\nvar lights_pars_begin =\n  'uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\\n\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tif ( cutoffDistance > 0.0 ) {\\n\\t\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t}\\n\\t\\treturn distanceFalloff;\\n\\t#else\\n\\t\\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\t\\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t#endif\\n}\\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\\n\\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tlight.color = directionalLight.color;\\n\\t\\tlight.direction = directionalLight.direction;\\n\\t\\tlight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tlight.color = pointLight.color;\\n\\t\\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat angleCos = dot( light.direction, spotLight.direction );\\n\\t\\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\tif ( spotAttenuation > 0.0 ) {\\n\\t\\t\\tfloat lightDistance = length( lVector );\\n\\t\\t\\tlight.color = spotLight.color * spotAttenuation;\\n\\t\\t\\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t\\t} else {\\n\\t\\t\\tlight.color = vec3( 0.0 );\\n\\t\\t\\tlight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\\n\\t\\tfloat dotNL = dot( normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\treturn irradiance;\\n\\t}\\n#endif';\n\nvar envmap_physical_pars_fragment =\n  '#if defined( USE_ENVMAP )\\n\\t#ifdef ENVMAP_MODE_REFRACTION\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n\\tvec3 getIBLIrradiance( const in vec3 normal ) {\\n\\t\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\\n\\t\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 reflectVec;\\n\\t\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\t\\treflectVec = reflect( - viewDir, normal );\\n\\t\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\treflectVec = refract( - viewDir, normal, refractionRatio );\\n\\t\\t\\t#endif\\n\\t\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n#endif';\n\nvar lights_toon_fragment =\n  'ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;';\n\nvar lights_toon_pars_fragment =\n  'varying vec3 vViewPosition;\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)';\n\nvar lights_phong_fragment =\n  'BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;';\n\nvar lights_phong_pars_fragment =\n  'varying vec3 vViewPosition;\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)';\n\nvar lights_physical_fragment =\n  'PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\\nmaterial.roughness = min( material.roughness, 1.0 );\\n#ifdef IOR\\n\\t#ifdef SPECULAR\\n\\t\\tfloat specularIntensityFactor = specularIntensity;\\n\\t\\tvec3 specularTintFactor = specularTint;\\n\\t\\t#ifdef USE_SPECULARINTENSITYMAP\\n\\t\\t\\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\\n\\t\\t#endif\\n\\t\\t#ifdef USE_SPECULARTINTMAP\\n\\t\\t\\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\\n\\t\\t#endif\\n\\t\\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\\n\\t#else\\n\\t\\tfloat specularIntensityFactor = 1.0;\\n\\t\\tvec3 specularTintFactor = vec3( 1.0 );\\n\\t\\tmaterial.specularF90 = 1.0;\\n\\t#endif\\n\\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\tmaterial.clearcoatF0 = vec3( 0.04 );\\n\\tmaterial.clearcoatF90 = 1.0;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenTint = sheenTint;\\n\\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\\n#endif';\n\nvar lights_physical_pars_fragment =\n  'struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat roughness;\\n\\tvec3 specularColor;\\n\\tfloat specularF90;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat clearcoat;\\n\\t\\tfloat clearcoatRoughness;\\n\\t\\tvec3 clearcoatF0;\\n\\t\\tfloat clearcoatF90;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tvec3 sheenTint;\\n\\t\\tfloat sheenRoughness;\\n\\t#endif\\n};\\nvec3 clearcoatSpecular = vec3( 0.0 );\\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\\n\\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\treturn specularColor * fab.x + specularF90 * fab.y;\\n}\\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\\n\\tfloat Ess = fab.x + fab.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.roughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = dotNLcc * directLight.color;\\n\\t\\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\\n\\t#endif\\n\\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\treflectedLight.indirectSpecular += radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}';\n\nvar lights_fragment_begin =\n  '\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef USE_CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointLightInfo( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotLightInfo( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif';\n\nvar lights_fragment_maps =\n  '#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getIBLIrradiance( geometry.normal );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\\n\\t#endif\\n#endif';\n\nvar lights_fragment_end =\n  '#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif';\n\nvar logdepthbuf_fragment =\n  '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif';\n\nvar logdepthbuf_pars_fragment =\n  '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif';\n\nvar logdepthbuf_pars_vertex =\n  '#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif';\n\nvar logdepthbuf_vertex =\n  '#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif';\n\nvar map_fragment =\n  '#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif';\n\nvar map_pars_fragment = '#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif';\n\nvar map_particle_fragment =\n  '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif';\n\nvar map_particle_pars_fragment =\n  '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif';\n\nvar metalnessmap_fragment =\n  'float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif';\n\nvar metalnessmap_pars_fragment =\n  '#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif';\n\nvar morphnormal_vertex =\n  '#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t}\\n\\t#else\\n\\t\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\t\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\t\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\t\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n\\t#endif\\n#endif';\n\nvar morphtarget_pars_vertex =\n  '#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\t\\tuniform sampler2DArray morphTargetsTexture;\\n\\t\\tuniform vec2 morphTargetsTextureSize;\\n\\t\\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\\n\\t\\t\\tfloat texelIndex = float( vertexIndex * stride + offset );\\n\\t\\t\\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\\n\\t\\t\\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\\n\\t\\t\\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\\n\\t\\t\\treturn texture( morphTargetsTexture, morphUV ).xyz;\\n\\t\\t}\\n\\t#else\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t\\t#else\\n\\t\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif';\n\nvar morphtarget_vertex =\n  '#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\t\\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\\n\\t\\t\\t#else\\n\\t\\t\\t\\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#else\\n\\t\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\t\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\t\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\t\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif';\n\nvar normal_fragment_begin =\n  'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;';\n\nvar normal_fragment_maps =\n  '#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif';\n\nvar normal_pars_fragment =\n  '#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif';\n\nvar normal_pars_vertex =\n  '#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif';\n\nvar normal_vertex =\n  '#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif';\n\nvar normalmap_pars_fragment =\n  '#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif';\n\nvar clearcoat_normal_fragment_begin =\n  '#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif';\n\nvar clearcoat_normal_fragment_maps =\n  '#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif';\n\nvar clearcoat_pars_fragment =\n  '#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif';\n\nvar output_fragment =\n  '#ifdef OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef USE_TRANSMISSION\\ndiffuseColor.a *= transmissionAlpha + 0.1;\\n#endif\\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );';\n\nvar packing =\n  'vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}';\n\nvar premultiplied_alpha_fragment =\n  '#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif';\n\nvar project_vertex =\n  'vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;';\n\nvar dithering_fragment =\n  '#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif';\n\nvar dithering_pars_fragment =\n  '#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif';\n\nvar roughnessmap_fragment =\n  'float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif';\n\nvar roughnessmap_pars_fragment =\n  '#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif';\n\nvar shadowmap_pars_fragment =\n  '#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif';\n\nvar shadowmap_pars_vertex =\n  '#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif';\n\nvar shadowmap_vertex =\n  '#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif';\n\nvar shadowmask_pars_fragment =\n  'float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}';\n\nvar skinbase_vertex =\n  '#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif';\n\nvar skinning_pars_vertex =\n  '#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif';\n\nvar skinning_vertex =\n  '#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif';\n\nvar skinnormal_vertex =\n  '#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif';\n\nvar specularmap_fragment =\n  'float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif';\n\nvar specularmap_pars_fragment =\n  '#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif';\n\nvar tonemapping_fragment =\n  '#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif';\n\nvar tonemapping_pars_fragment =\n  '#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }';\n\nvar transmission_fragment =\n  '#ifdef USE_TRANSMISSION\\n\\tfloat transmissionAlpha = 1.0;\\n\\tfloat transmissionFactor = transmission;\\n\\tfloat thicknessFactor = thickness;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\\tvec4 transmission = getIBLVolumeRefraction(\\n\\t\\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\\n\\t\\tattenuationTint, attenuationDistance );\\n\\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\\n\\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\\n#endif';\n\nvar transmission_pars_fragment =\n  '#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform float attenuationDistance;\\n\\tuniform vec3 attenuationTint;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec3 vWorldPosition;\\n\\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\\n\\t\\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n\\t\\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n\\t\\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n\\t\\treturn normalize( refractionVector ) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness( float roughness, float ior ) {\\n\\t\\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n\\t}\\n\\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\\n\\t\\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\\n\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\\n\\t\\t#else\\n\\t\\t\\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\\n\\t\\tif ( attenuationDistance == 0.0 ) {\\n\\t\\t\\treturn radiance;\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\\t\\t\\treturn transmittance * radiance;\\n\\t\\t}\\n\\t}\\n\\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\\n\\t\\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\\n\\t\\tvec3 attenuationColor, float attenuationDistance ) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n\\t\\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\\n\\t\\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n\\t\\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\\n\\t}\\n#endif';\n\nvar uv_pars_fragment =\n  '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif';\n\nvar uv_pars_vertex =\n  '#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif';\n\nvar uv_vertex =\n  '#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif';\n\nvar uv2_pars_fragment =\n  '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif';\n\nvar uv2_pars_vertex =\n  '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif';\n\nvar uv2_vertex =\n  '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif';\n\nvar worldpos_vertex =\n  '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif';\n\nconst vertex$g =\n  'varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}';\n\nconst fragment$g =\n  'uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}';\n\nconst vertex$f =\n  'varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}';\n\nconst fragment$f =\n  '#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}';\n\nconst vertex$e =\n  '#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}';\n\nconst fragment$e =\n  '#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}';\n\nconst vertex$d =\n  '#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}';\n\nconst fragment$d =\n  '#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}';\n\nconst vertex$c =\n  'varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}';\n\nconst fragment$c =\n  'uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}';\n\nconst vertex$b =\n  'uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}';\n\nconst fragment$b =\n  'uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}';\n\nconst vertex$a =\n  '#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinbase_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}';\n\nconst fragment$a =\n  'uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}';\n\nconst vertex$9 =\n  '#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}';\n\nconst fragment$9 =\n  'uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}';\n\nconst vertex$8 =\n  '#define MATCAP\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}';\n\nconst fragment$8 =\n  '#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}';\n\nconst vertex$7 =\n  '#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}';\n\nconst fragment$7 =\n  '#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}';\n\nconst vertex$6 =\n  '#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}';\n\nconst fragment$6 =\n  '#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}';\n\nconst vertex$5 =\n  '#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec3 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}';\n\nconst fragment$5 =\n  '#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define IOR\\n\\t#define SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef IOR\\n\\tuniform float ior;\\n#endif\\n#ifdef SPECULAR\\n\\tuniform float specularIntensity;\\n\\tuniform vec3 specularTint;\\n\\t#ifdef USE_SPECULARINTENSITYMAP\\n\\t\\tuniform sampler2D specularIntensityMap;\\n\\t#endif\\n\\t#ifdef USE_SPECULARTINTMAP\\n\\t\\tuniform sampler2D specularTintMap;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheenTint;\\n\\tuniform float sheenRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\\n\\t\\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\\n\\t#endif\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}';\n\nconst vertex$4 =\n  '#define TOON\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}';\n\nconst fragment$4 =\n  '#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}';\n\nconst vertex$3 =\n  'uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}';\n\nconst fragment$3 =\n  'uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}';\n\nconst vertex$2 =\n  '#include <common>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}';\n\nconst fragment$2 =\n  'uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}';\n\nconst vertex$1 =\n  'uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}';\n\nconst fragment$1 =\n  'uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}';\n\nconst ShaderChunk = {\n  alphamap_fragment: alphamap_fragment,\n  alphamap_pars_fragment: alphamap_pars_fragment,\n  alphatest_fragment: alphatest_fragment,\n  alphatest_pars_fragment: alphatest_pars_fragment,\n  aomap_fragment: aomap_fragment,\n  aomap_pars_fragment: aomap_pars_fragment,\n  begin_vertex: begin_vertex,\n  beginnormal_vertex: beginnormal_vertex,\n  bsdfs: bsdfs,\n  bumpmap_pars_fragment: bumpmap_pars_fragment,\n  clipping_planes_fragment: clipping_planes_fragment,\n  clipping_planes_pars_fragment: clipping_planes_pars_fragment,\n  clipping_planes_pars_vertex: clipping_planes_pars_vertex,\n  clipping_planes_vertex: clipping_planes_vertex,\n  color_fragment: color_fragment,\n  color_pars_fragment: color_pars_fragment,\n  color_pars_vertex: color_pars_vertex,\n  color_vertex: color_vertex,\n  common: common,\n  cube_uv_reflection_fragment: cube_uv_reflection_fragment,\n  defaultnormal_vertex: defaultnormal_vertex,\n  displacementmap_pars_vertex: displacementmap_pars_vertex,\n  displacementmap_vertex: displacementmap_vertex,\n  emissivemap_fragment: emissivemap_fragment,\n  emissivemap_pars_fragment: emissivemap_pars_fragment,\n  encodings_fragment: encodings_fragment,\n  encodings_pars_fragment: encodings_pars_fragment,\n  envmap_fragment: envmap_fragment,\n  envmap_common_pars_fragment: envmap_common_pars_fragment,\n  envmap_pars_fragment: envmap_pars_fragment,\n  envmap_pars_vertex: envmap_pars_vertex,\n  envmap_physical_pars_fragment: envmap_physical_pars_fragment,\n  envmap_vertex: envmap_vertex,\n  fog_vertex: fog_vertex,\n  fog_pars_vertex: fog_pars_vertex,\n  fog_fragment: fog_fragment,\n  fog_pars_fragment: fog_pars_fragment,\n  gradientmap_pars_fragment: gradientmap_pars_fragment,\n  lightmap_fragment: lightmap_fragment,\n  lightmap_pars_fragment: lightmap_pars_fragment,\n  lights_lambert_vertex: lights_lambert_vertex,\n  lights_pars_begin: lights_pars_begin,\n  lights_toon_fragment: lights_toon_fragment,\n  lights_toon_pars_fragment: lights_toon_pars_fragment,\n  lights_phong_fragment: lights_phong_fragment,\n  lights_phong_pars_fragment: lights_phong_pars_fragment,\n  lights_physical_fragment: lights_physical_fragment,\n  lights_physical_pars_fragment: lights_physical_pars_fragment,\n  lights_fragment_begin: lights_fragment_begin,\n  lights_fragment_maps: lights_fragment_maps,\n  lights_fragment_end: lights_fragment_end,\n  logdepthbuf_fragment: logdepthbuf_fragment,\n  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n  logdepthbuf_vertex: logdepthbuf_vertex,\n  map_fragment: map_fragment,\n  map_pars_fragment: map_pars_fragment,\n  map_particle_fragment: map_particle_fragment,\n  map_particle_pars_fragment: map_particle_pars_fragment,\n  metalnessmap_fragment: metalnessmap_fragment,\n  metalnessmap_pars_fragment: metalnessmap_pars_fragment,\n  morphnormal_vertex: morphnormal_vertex,\n  morphtarget_pars_vertex: morphtarget_pars_vertex,\n  morphtarget_vertex: morphtarget_vertex,\n  normal_fragment_begin: normal_fragment_begin,\n  normal_fragment_maps: normal_fragment_maps,\n  normal_pars_fragment: normal_pars_fragment,\n  normal_pars_vertex: normal_pars_vertex,\n  normal_vertex: normal_vertex,\n  normalmap_pars_fragment: normalmap_pars_fragment,\n  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n  clearcoat_pars_fragment: clearcoat_pars_fragment,\n  output_fragment: output_fragment,\n  packing: packing,\n  premultiplied_alpha_fragment: premultiplied_alpha_fragment,\n  project_vertex: project_vertex,\n  dithering_fragment: dithering_fragment,\n  dithering_pars_fragment: dithering_pars_fragment,\n  roughnessmap_fragment: roughnessmap_fragment,\n  roughnessmap_pars_fragment: roughnessmap_pars_fragment,\n  shadowmap_pars_fragment: shadowmap_pars_fragment,\n  shadowmap_pars_vertex: shadowmap_pars_vertex,\n  shadowmap_vertex: shadowmap_vertex,\n  shadowmask_pars_fragment: shadowmask_pars_fragment,\n  skinbase_vertex: skinbase_vertex,\n  skinning_pars_vertex: skinning_pars_vertex,\n  skinning_vertex: skinning_vertex,\n  skinnormal_vertex: skinnormal_vertex,\n  specularmap_fragment: specularmap_fragment,\n  specularmap_pars_fragment: specularmap_pars_fragment,\n  tonemapping_fragment: tonemapping_fragment,\n  tonemapping_pars_fragment: tonemapping_pars_fragment,\n  transmission_fragment: transmission_fragment,\n  transmission_pars_fragment: transmission_pars_fragment,\n  uv_pars_fragment: uv_pars_fragment,\n  uv_pars_vertex: uv_pars_vertex,\n  uv_vertex: uv_vertex,\n  uv2_pars_fragment: uv2_pars_fragment,\n  uv2_pars_vertex: uv2_pars_vertex,\n  uv2_vertex: uv2_vertex,\n  worldpos_vertex: worldpos_vertex,\n\n  background_vert: vertex$g,\n  background_frag: fragment$g,\n  cube_vert: vertex$f,\n  cube_frag: fragment$f,\n  depth_vert: vertex$e,\n  depth_frag: fragment$e,\n  distanceRGBA_vert: vertex$d,\n  distanceRGBA_frag: fragment$d,\n  equirect_vert: vertex$c,\n  equirect_frag: fragment$c,\n  linedashed_vert: vertex$b,\n  linedashed_frag: fragment$b,\n  meshbasic_vert: vertex$a,\n  meshbasic_frag: fragment$a,\n  meshlambert_vert: vertex$9,\n  meshlambert_frag: fragment$9,\n  meshmatcap_vert: vertex$8,\n  meshmatcap_frag: fragment$8,\n  meshnormal_vert: vertex$7,\n  meshnormal_frag: fragment$7,\n  meshphong_vert: vertex$6,\n  meshphong_frag: fragment$6,\n  meshphysical_vert: vertex$5,\n  meshphysical_frag: fragment$5,\n  meshtoon_vert: vertex$4,\n  meshtoon_frag: fragment$4,\n  points_vert: vertex$3,\n  points_frag: fragment$3,\n  shadow_vert: vertex$2,\n  shadow_frag: fragment$2,\n  sprite_vert: vertex$1,\n  sprite_frag: fragment$1,\n};\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nconst UniformsLib = {\n  common: {\n    diffuse: { value: new Color(0xffffff) },\n    opacity: { value: 1.0 },\n\n    map: { value: null },\n    uvTransform: { value: new Matrix3() },\n    uv2Transform: { value: new Matrix3() },\n\n    alphaMap: { value: null },\n    alphaTest: { value: 0 },\n  },\n\n  specularmap: {\n    specularMap: { value: null },\n  },\n\n  envmap: {\n    envMap: { value: null },\n    flipEnvMap: { value: -1 },\n    reflectivity: { value: 1.0 }, // basic, lambert, phong\n    ior: { value: 1.5 }, // standard, physical\n    refractionRatio: { value: 0.98 },\n    maxMipLevel: { value: 0 },\n  },\n\n  aomap: {\n    aoMap: { value: null },\n    aoMapIntensity: { value: 1 },\n  },\n\n  lightmap: {\n    lightMap: { value: null },\n    lightMapIntensity: { value: 1 },\n  },\n\n  emissivemap: {\n    emissiveMap: { value: null },\n  },\n\n  bumpmap: {\n    bumpMap: { value: null },\n    bumpScale: { value: 1 },\n  },\n\n  normalmap: {\n    normalMap: { value: null },\n    normalScale: { value: new Vector2(1, 1) },\n  },\n\n  displacementmap: {\n    displacementMap: { value: null },\n    displacementScale: { value: 1 },\n    displacementBias: { value: 0 },\n  },\n\n  roughnessmap: {\n    roughnessMap: { value: null },\n  },\n\n  metalnessmap: {\n    metalnessMap: { value: null },\n  },\n\n  gradientmap: {\n    gradientMap: { value: null },\n  },\n\n  fog: {\n    fogDensity: { value: 0.00025 },\n    fogNear: { value: 1 },\n    fogFar: { value: 2000 },\n    fogColor: { value: new Color(0xffffff) },\n  },\n\n  lights: {\n    ambientLightColor: { value: [] },\n\n    lightProbe: { value: [] },\n\n    directionalLights: {\n      value: [],\n      properties: {\n        direction: {},\n        color: {},\n      },\n    },\n\n    directionalLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {},\n      },\n    },\n\n    directionalShadowMap: { value: [] },\n    directionalShadowMatrix: { value: [] },\n\n    spotLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        direction: {},\n        distance: {},\n        coneCos: {},\n        penumbraCos: {},\n        decay: {},\n      },\n    },\n\n    spotLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {},\n      },\n    },\n\n    spotShadowMap: { value: [] },\n    spotShadowMatrix: { value: [] },\n\n    pointLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        decay: {},\n        distance: {},\n      },\n    },\n\n    pointLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {},\n        shadowCameraNear: {},\n        shadowCameraFar: {},\n      },\n    },\n\n    pointShadowMap: { value: [] },\n    pointShadowMatrix: { value: [] },\n\n    hemisphereLights: {\n      value: [],\n      properties: {\n        direction: {},\n        skyColor: {},\n        groundColor: {},\n      },\n    },\n\n    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n    rectAreaLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        width: {},\n        height: {},\n      },\n    },\n\n    ltc_1: { value: null },\n    ltc_2: { value: null },\n  },\n\n  points: {\n    diffuse: { value: new Color(0xffffff) },\n    opacity: { value: 1.0 },\n    size: { value: 1.0 },\n    scale: { value: 1.0 },\n    map: { value: null },\n    alphaMap: { value: null },\n    alphaTest: { value: 0 },\n    uvTransform: { value: new Matrix3() },\n  },\n\n  sprite: {\n    diffuse: { value: new Color(0xffffff) },\n    opacity: { value: 1.0 },\n    center: { value: new Vector2(0.5, 0.5) },\n    rotation: { value: 0.0 },\n    map: { value: null },\n    alphaMap: { value: null },\n    alphaTest: { value: 0 },\n    uvTransform: { value: new Matrix3() },\n  },\n};\n\nconst ShaderLib = {\n  basic: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.fog,\n    ]),\n\n    vertexShader: ShaderChunk.meshbasic_vert,\n    fragmentShader: ShaderChunk.meshbasic_frag,\n  },\n\n  lambert: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: new Color(0x000000) },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.meshlambert_vert,\n    fragmentShader: ShaderChunk.meshlambert_frag,\n  },\n\n  phong: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: new Color(0x000000) },\n        specular: { value: new Color(0x111111) },\n        shininess: { value: 30 },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.meshphong_vert,\n    fragmentShader: ShaderChunk.meshphong_frag,\n  },\n\n  standard: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.roughnessmap,\n      UniformsLib.metalnessmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: new Color(0x000000) },\n        roughness: { value: 1.0 },\n        metalness: { value: 0.0 },\n        envMapIntensity: { value: 1 }, // temporary\n      },\n    ]),\n\n    vertexShader: ShaderChunk.meshphysical_vert,\n    fragmentShader: ShaderChunk.meshphysical_frag,\n  },\n\n  toon: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.gradientmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: new Color(0x000000) },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.meshtoon_vert,\n    fragmentShader: ShaderChunk.meshtoon_frag,\n  },\n\n  matcap: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.fog,\n      {\n        matcap: { value: null },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.meshmatcap_vert,\n    fragmentShader: ShaderChunk.meshmatcap_frag,\n  },\n\n  points: {\n    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),\n\n    vertexShader: ShaderChunk.points_vert,\n    fragmentShader: ShaderChunk.points_frag,\n  },\n\n  dashed: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.fog,\n      {\n        scale: { value: 1 },\n        dashSize: { value: 1 },\n        totalSize: { value: 2 },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.linedashed_vert,\n    fragmentShader: ShaderChunk.linedashed_frag,\n  },\n\n  depth: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),\n\n    vertexShader: ShaderChunk.depth_vert,\n    fragmentShader: ShaderChunk.depth_frag,\n  },\n\n  normal: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      {\n        opacity: { value: 1.0 },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.meshnormal_vert,\n    fragmentShader: ShaderChunk.meshnormal_frag,\n  },\n\n  sprite: {\n    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),\n\n    vertexShader: ShaderChunk.sprite_vert,\n    fragmentShader: ShaderChunk.sprite_frag,\n  },\n\n  background: {\n    uniforms: {\n      uvTransform: { value: new Matrix3() },\n      t2D: { value: null },\n    },\n\n    vertexShader: ShaderChunk.background_vert,\n    fragmentShader: ShaderChunk.background_frag,\n  },\n  /* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n  cube: {\n    uniforms: mergeUniforms([\n      UniformsLib.envmap,\n      {\n        opacity: { value: 1.0 },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.cube_vert,\n    fragmentShader: ShaderChunk.cube_frag,\n  },\n\n  equirect: {\n    uniforms: {\n      tEquirect: { value: null },\n    },\n\n    vertexShader: ShaderChunk.equirect_vert,\n    fragmentShader: ShaderChunk.equirect_frag,\n  },\n\n  distanceRGBA: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.displacementmap,\n      {\n        referencePosition: { value: new Vector3() },\n        nearDistance: { value: 1 },\n        farDistance: { value: 1000 },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.distanceRGBA_vert,\n    fragmentShader: ShaderChunk.distanceRGBA_frag,\n  },\n\n  shadow: {\n    uniforms: mergeUniforms([\n      UniformsLib.lights,\n      UniformsLib.fog,\n      {\n        color: { value: new Color(0x00000) },\n        opacity: { value: 1.0 },\n      },\n    ]),\n\n    vertexShader: ShaderChunk.shadow_vert,\n    fragmentShader: ShaderChunk.shadow_frag,\n  },\n};\n\nShaderLib.physical = {\n  uniforms: mergeUniforms([\n    ShaderLib.standard.uniforms,\n    {\n      clearcoat: { value: 0 },\n      clearcoatMap: { value: null },\n      clearcoatRoughness: { value: 0 },\n      clearcoatRoughnessMap: { value: null },\n      clearcoatNormalScale: { value: new Vector2(1, 1) },\n      clearcoatNormalMap: { value: null },\n      sheen: { value: 0 },\n      sheenTint: { value: new Color(0x000000) },\n      sheenRoughness: { value: 0 },\n      transmission: { value: 0 },\n      transmissionMap: { value: null },\n      transmissionSamplerSize: { value: new Vector2() },\n      transmissionSamplerMap: { value: null },\n      thickness: { value: 0 },\n      thicknessMap: { value: null },\n      attenuationDistance: { value: 0 },\n      attenuationTint: { value: new Color(0x000000) },\n      specularIntensity: { value: 0 },\n      specularIntensityMap: { value: null },\n      specularTint: { value: new Color(1, 1, 1) },\n      specularTintMap: { value: null },\n    },\n  ]),\n\n  vertexShader: ShaderChunk.meshphysical_vert,\n  fragmentShader: ShaderChunk.meshphysical_frag,\n};\n\nfunction WebGLBackground(\n  renderer,\n  cubemaps,\n  state,\n  objects,\n  premultipliedAlpha,\n) {\n  const clearColor = new Color(0x000000);\n  let clearAlpha = 0;\n\n  let planeMesh;\n  let boxMesh;\n\n  let currentBackground = null;\n  let currentBackgroundVersion = 0;\n  let currentTonemapping = null;\n\n  function render(renderList, scene) {\n    let forceClear = false;\n    let background = scene.isScene === true ? scene.background : null;\n\n    if (background && background.isTexture) {\n      background = cubemaps.get(background);\n    }\n\n    // Ignore background in AR\n    // TODO: Reconsider this.\n\n    const xr = renderer.xr;\n    const session = xr.getSession && xr.getSession();\n\n    if (session && session.environmentBlendMode === 'additive') {\n      background = null;\n    }\n\n    if (background === null) {\n      setClear(clearColor, clearAlpha);\n    } else if (background && background.isColor) {\n      setClear(background, 1);\n      forceClear = true;\n    }\n\n    if (renderer.autoClear || forceClear) {\n      renderer.clear(\n        renderer.autoClearColor,\n        renderer.autoClearDepth,\n        renderer.autoClearStencil,\n      );\n    }\n\n    if (\n      background &&\n      (background.isCubeTexture ||\n        background.mapping === CubeUVReflectionMapping)\n    ) {\n      if (boxMesh === undefined) {\n        boxMesh = new Mesh(\n          new BoxGeometry(1, 1, 1),\n          new ShaderMaterial({\n            name: 'BackgroundCubeMaterial',\n            uniforms: cloneUniforms(ShaderLib.cube.uniforms),\n            vertexShader: ShaderLib.cube.vertexShader,\n            fragmentShader: ShaderLib.cube.fragmentShader,\n            side: BackSide,\n            depthTest: false,\n            depthWrite: false,\n            fog: false,\n          }),\n        );\n\n        boxMesh.geometry.deleteAttribute('normal');\n        boxMesh.geometry.deleteAttribute('uv');\n\n        boxMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        };\n\n        // enable code injection for non-built-in material\n        Object.defineProperty(boxMesh.material, 'envMap', {\n          get: function () {\n            return this.uniforms.envMap.value;\n          },\n        });\n\n        objects.update(boxMesh);\n      }\n\n      boxMesh.material.uniforms.envMap.value = background;\n      boxMesh.material.uniforms.flipEnvMap.value =\n        background.isCubeTexture && background.isRenderTargetTexture === false\n          ? -1\n          : 1;\n\n      if (\n        currentBackground !== background ||\n        currentBackgroundVersion !== background.version ||\n        currentTonemapping !== renderer.toneMapping\n      ) {\n        boxMesh.material.needsUpdate = true;\n\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n\n      // push to the pre-sorted opaque render list\n      renderList.unshift(\n        boxMesh,\n        boxMesh.geometry,\n        boxMesh.material,\n        0,\n        0,\n        null,\n      );\n    } else if (background && background.isTexture) {\n      if (planeMesh === undefined) {\n        planeMesh = new Mesh(\n          new PlaneGeometry(2, 2),\n          new ShaderMaterial({\n            name: 'BackgroundMaterial',\n            uniforms: cloneUniforms(ShaderLib.background.uniforms),\n            vertexShader: ShaderLib.background.vertexShader,\n            fragmentShader: ShaderLib.background.fragmentShader,\n            side: FrontSide,\n            depthTest: false,\n            depthWrite: false,\n            fog: false,\n          }),\n        );\n\n        planeMesh.geometry.deleteAttribute('normal');\n\n        // enable code injection for non-built-in material\n        Object.defineProperty(planeMesh.material, 'map', {\n          get: function () {\n            return this.uniforms.t2D.value;\n          },\n        });\n\n        objects.update(planeMesh);\n      }\n\n      planeMesh.material.uniforms.t2D.value = background;\n\n      if (background.matrixAutoUpdate === true) {\n        background.updateMatrix();\n      }\n\n      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n\n      if (\n        currentBackground !== background ||\n        currentBackgroundVersion !== background.version ||\n        currentTonemapping !== renderer.toneMapping\n      ) {\n        planeMesh.material.needsUpdate = true;\n\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n\n      // push to the pre-sorted opaque render list\n      renderList.unshift(\n        planeMesh,\n        planeMesh.geometry,\n        planeMesh.material,\n        0,\n        0,\n        null,\n      );\n    }\n  }\n\n  function setClear(color, alpha) {\n    state.buffers.color.setClear(\n      color.r,\n      color.g,\n      color.b,\n      alpha,\n      premultipliedAlpha,\n    );\n  }\n\n  return {\n    getClearColor: function () {\n      return clearColor;\n    },\n    setClearColor: function (color, alpha = 1) {\n      clearColor.set(color);\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    getClearAlpha: function () {\n      return clearAlpha;\n    },\n    setClearAlpha: function (alpha) {\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    render: render,\n  };\n}\n\nfunction WebGLBindingStates(gl, extensions, attributes, capabilities) {\n  const maxVertexAttributes = gl.getParameter(34921);\n\n  const extension = capabilities.isWebGL2\n    ? null\n    : extensions.get('OES_vertex_array_object');\n  const vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\n  const bindingStates = {};\n\n  const defaultState = createBindingState(null);\n  let currentState = defaultState;\n\n  function setup(object, material, program, geometry, index) {\n    let updateBuffers = false;\n\n    if (vaoAvailable) {\n      const state = getBindingState(geometry, program, material);\n\n      if (currentState !== state) {\n        currentState = state;\n        bindVertexArrayObject(currentState.object);\n      }\n\n      updateBuffers = needsUpdate(geometry, index);\n\n      if (updateBuffers) saveCache(geometry, index);\n    } else {\n      const wireframe = material.wireframe === true;\n\n      if (\n        currentState.geometry !== geometry.id ||\n        currentState.program !== program.id ||\n        currentState.wireframe !== wireframe\n      ) {\n        currentState.geometry = geometry.id;\n        currentState.program = program.id;\n        currentState.wireframe = wireframe;\n\n        updateBuffers = true;\n      }\n    }\n\n    if (object.isInstancedMesh === true) {\n      updateBuffers = true;\n    }\n\n    if (index !== null) {\n      attributes.update(index, 34963);\n    }\n\n    if (updateBuffers) {\n      setupVertexAttributes(object, material, program, geometry);\n\n      if (index !== null) {\n        gl.bindBuffer(34963, attributes.get(index).buffer);\n      }\n    }\n  }\n\n  function createVertexArrayObject() {\n    if (capabilities.isWebGL2) return gl.createVertexArray();\n\n    return extension.createVertexArrayOES();\n  }\n\n  function bindVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n\n    return extension.bindVertexArrayOES(vao);\n  }\n\n  function deleteVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n\n    return extension.deleteVertexArrayOES(vao);\n  }\n\n  function getBindingState(geometry, program, material) {\n    const wireframe = material.wireframe === true;\n\n    let programMap = bindingStates[geometry.id];\n\n    if (programMap === undefined) {\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n    }\n\n    let stateMap = programMap[program.id];\n\n    if (stateMap === undefined) {\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n\n    let state = stateMap[wireframe];\n\n    if (state === undefined) {\n      state = createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = state;\n    }\n\n    return state;\n  }\n\n  function createBindingState(vao) {\n    const newAttributes = [];\n    const enabledAttributes = [];\n    const attributeDivisors = [];\n\n    for (let i = 0; i < maxVertexAttributes; i++) {\n      newAttributes[i] = 0;\n      enabledAttributes[i] = 0;\n      attributeDivisors[i] = 0;\n    }\n\n    return {\n      // for backward compatibility on non-VAO support browser\n      geometry: null,\n      program: null,\n      wireframe: false,\n\n      newAttributes: newAttributes,\n      enabledAttributes: enabledAttributes,\n      attributeDivisors: attributeDivisors,\n      object: vao,\n      attributes: {},\n      index: null,\n    };\n  }\n\n  function needsUpdate(geometry, index) {\n    const cachedAttributes = currentState.attributes;\n    const geometryAttributes = geometry.attributes;\n\n    let attributesNum = 0;\n\n    for (const key in geometryAttributes) {\n      const cachedAttribute = cachedAttributes[key];\n      const geometryAttribute = geometryAttributes[key];\n\n      if (cachedAttribute === undefined) return true;\n\n      if (cachedAttribute.attribute !== geometryAttribute) return true;\n\n      if (cachedAttribute.data !== geometryAttribute.data) return true;\n\n      attributesNum++;\n    }\n\n    if (currentState.attributesNum !== attributesNum) return true;\n\n    if (currentState.index !== index) return true;\n\n    return false;\n  }\n\n  function saveCache(geometry, index) {\n    const cache = {};\n    const attributes = geometry.attributes;\n    let attributesNum = 0;\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n\n      const data = {};\n      data.attribute = attribute;\n\n      if (attribute.data) {\n        data.data = attribute.data;\n      }\n\n      cache[key] = data;\n\n      attributesNum++;\n    }\n\n    currentState.attributes = cache;\n    currentState.attributesNum = attributesNum;\n\n    currentState.index = index;\n  }\n\n  function initAttributes() {\n    const newAttributes = currentState.newAttributes;\n\n    for (let i = 0, il = newAttributes.length; i < il; i++) {\n      newAttributes[i] = 0;\n    }\n  }\n\n  function enableAttribute(attribute) {\n    enableAttributeAndDivisor(attribute, 0);\n  }\n\n  function enableAttributeAndDivisor(attribute, meshPerAttribute) {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    const attributeDivisors = currentState.attributeDivisors;\n\n    newAttributes[attribute] = 1;\n\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n\n    if (attributeDivisors[attribute] !== meshPerAttribute) {\n      const extension = capabilities.isWebGL2\n        ? gl\n        : extensions.get('ANGLE_instanced_arrays');\n\n      extension[\n        capabilities.isWebGL2\n          ? 'vertexAttribDivisor'\n          : 'vertexAttribDivisorANGLE'\n      ](attribute, meshPerAttribute);\n      attributeDivisors[attribute] = meshPerAttribute;\n    }\n  }\n\n  function disableUnusedAttributes() {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n\n    for (let i = 0, il = enabledAttributes.length; i < il; i++) {\n      if (enabledAttributes[i] !== newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n  }\n\n  function vertexAttribPointer(index, size, type, normalized, stride, offset) {\n    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {\n      gl.vertexAttribIPointer(index, size, type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n    }\n  }\n\n  function setupVertexAttributes(object, material, program, geometry) {\n    if (\n      capabilities.isWebGL2 === false &&\n      (object.isInstancedMesh || geometry.isInstancedBufferGeometry)\n    ) {\n      if (extensions.get('ANGLE_instanced_arrays') === null) return;\n    }\n\n    initAttributes();\n\n    const geometryAttributes = geometry.attributes;\n\n    const programAttributes = program.getAttributes();\n\n    const materialDefaultAttributeValues = material.defaultAttributeValues;\n\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n\n      if (programAttribute.location >= 0) {\n        let geometryAttribute = geometryAttributes[name];\n\n        if (geometryAttribute === undefined) {\n          if (name === 'instanceMatrix' && object.instanceMatrix)\n            geometryAttribute = object.instanceMatrix;\n          if (name === 'instanceColor' && object.instanceColor)\n            geometryAttribute = object.instanceColor;\n        }\n\n        if (geometryAttribute !== undefined) {\n          const normalized = geometryAttribute.normalized;\n          const size = geometryAttribute.itemSize;\n\n          const attribute = attributes.get(geometryAttribute);\n\n          // TODO Attribute may not be available on context restore\n\n          if (attribute === undefined) continue;\n\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          const bytesPerElement = attribute.bytesPerElement;\n\n          if (geometryAttribute.isInterleavedBufferAttribute) {\n            const data = geometryAttribute.data;\n            const stride = data.stride;\n            const offset = geometryAttribute.offset;\n\n            if (data && data.isInstancedInterleavedBuffer) {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttributeAndDivisor(\n                  programAttribute.location + i,\n                  data.meshPerAttribute,\n                );\n              }\n\n              if (\n                object.isInstancedMesh !== true &&\n                geometry._maxInstanceCount === undefined\n              ) {\n                geometry._maxInstanceCount = data.meshPerAttribute * data.count;\n              }\n            } else {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttribute(programAttribute.location + i);\n              }\n            }\n\n            gl.bindBuffer(34962, buffer);\n\n            for (let i = 0; i < programAttribute.locationSize; i++) {\n              vertexAttribPointer(\n                programAttribute.location + i,\n                size / programAttribute.locationSize,\n                type,\n                normalized,\n                stride * bytesPerElement,\n                (offset + (size / programAttribute.locationSize) * i) *\n                  bytesPerElement,\n              );\n            }\n          } else {\n            if (geometryAttribute.isInstancedBufferAttribute) {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttributeAndDivisor(\n                  programAttribute.location + i,\n                  geometryAttribute.meshPerAttribute,\n                );\n              }\n\n              if (\n                object.isInstancedMesh !== true &&\n                geometry._maxInstanceCount === undefined\n              ) {\n                geometry._maxInstanceCount =\n                  geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            } else {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttribute(programAttribute.location + i);\n              }\n            }\n\n            gl.bindBuffer(34962, buffer);\n\n            for (let i = 0; i < programAttribute.locationSize; i++) {\n              vertexAttribPointer(\n                programAttribute.location + i,\n                size / programAttribute.locationSize,\n                type,\n                normalized,\n                size * bytesPerElement,\n                (size / programAttribute.locationSize) * i * bytesPerElement,\n              );\n            }\n          }\n        } else if (materialDefaultAttributeValues !== undefined) {\n          const value = materialDefaultAttributeValues[name];\n\n          if (value !== undefined) {\n            switch (value.length) {\n              case 2:\n                gl.vertexAttrib2fv(programAttribute.location, value);\n                break;\n\n              case 3:\n                gl.vertexAttrib3fv(programAttribute.location, value);\n                break;\n\n              case 4:\n                gl.vertexAttrib4fv(programAttribute.location, value);\n                break;\n\n              default:\n                gl.vertexAttrib1fv(programAttribute.location, value);\n            }\n          }\n        }\n      }\n    }\n\n    disableUnusedAttributes();\n  }\n\n  function dispose() {\n    reset();\n\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n\n      for (const programId in programMap) {\n        const stateMap = programMap[programId];\n\n        for (const wireframe in stateMap) {\n          deleteVertexArrayObject(stateMap[wireframe].object);\n\n          delete stateMap[wireframe];\n        }\n\n        delete programMap[programId];\n      }\n\n      delete bindingStates[geometryId];\n    }\n  }\n\n  function releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === undefined) return;\n\n    const programMap = bindingStates[geometry.id];\n\n    for (const programId in programMap) {\n      const stateMap = programMap[programId];\n\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[programId];\n    }\n\n    delete bindingStates[geometry.id];\n  }\n\n  function releaseStatesOfProgram(program) {\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n\n      if (programMap[program.id] === undefined) continue;\n\n      const stateMap = programMap[program.id];\n\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[program.id];\n    }\n  }\n\n  function reset() {\n    resetDefaultState();\n\n    if (currentState === defaultState) return;\n\n    currentState = defaultState;\n    bindVertexArrayObject(currentState.object);\n  }\n\n  // for backward-compatilibity\n\n  function resetDefaultState() {\n    defaultState.geometry = null;\n    defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n\n  return {\n    setup: setup,\n    reset: reset,\n    resetDefaultState: resetDefaultState,\n    dispose: dispose,\n    releaseStatesOfGeometry: releaseStatesOfGeometry,\n    releaseStatesOfProgram: releaseStatesOfProgram,\n\n    initAttributes: initAttributes,\n    enableAttribute: enableAttribute,\n    disableUnusedAttributes: disableUnusedAttributes,\n  };\n}\n\nfunction WebGLBufferRenderer(gl, extensions, info, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n\n  let mode;\n\n  function setMode(value) {\n    mode = value;\n  }\n\n  function render(start, count) {\n    gl.drawArrays(mode, start, count);\n\n    info.update(count, mode, 1);\n  }\n\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0) return;\n\n    let extension, methodName;\n\n    if (isWebGL2) {\n      extension = gl;\n      methodName = 'drawArraysInstanced';\n    } else {\n      extension = extensions.get('ANGLE_instanced_arrays');\n      methodName = 'drawArraysInstancedANGLE';\n\n      if (extension === null) {\n        console.error(\n          'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',\n        );\n        return;\n      }\n    }\n\n    extension[methodName](mode, start, count, primcount);\n\n    info.update(count, mode, primcount);\n  }\n\n  //\n\n  this.setMode = setMode;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}\n\nfunction WebGLCapabilities(gl, extensions, parameters) {\n  let maxAnisotropy;\n\n  function getMaxAnisotropy() {\n    if (maxAnisotropy !== undefined) return maxAnisotropy;\n\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n\n      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      maxAnisotropy = 0;\n    }\n\n    return maxAnisotropy;\n  }\n\n  function getMaxPrecision(precision) {\n    if (precision === 'highp') {\n      if (\n        gl.getShaderPrecisionFormat(35633, 36338).precision > 0 &&\n        gl.getShaderPrecisionFormat(35632, 36338).precision > 0\n      ) {\n        return 'highp';\n      }\n\n      precision = 'mediump';\n    }\n\n    if (precision === 'mediump') {\n      if (\n        gl.getShaderPrecisionFormat(35633, 36337).precision > 0 &&\n        gl.getShaderPrecisionFormat(35632, 36337).precision > 0\n      ) {\n        return 'mediump';\n      }\n    }\n\n    return 'lowp';\n  }\n\n  /* eslint-disable no-undef */\n  const isWebGL2 =\n    (typeof WebGL2RenderingContext !== 'undefined' &&\n      gl instanceof WebGL2RenderingContext) ||\n    (typeof WebGL2ComputeRenderingContext !== 'undefined' &&\n      gl instanceof WebGL2ComputeRenderingContext);\n  /* eslint-enable no-undef */\n\n  let precision =\n    parameters.precision !== undefined ? parameters.precision : 'highp';\n  const maxPrecision = getMaxPrecision(precision);\n\n  if (maxPrecision !== precision) {\n    console.warn(\n      'THREE.WebGLRenderer:',\n      precision,\n      'not supported, using',\n      maxPrecision,\n      'instead.',\n    );\n    precision = maxPrecision;\n  }\n\n  const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');\n\n  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n  const maxTextures = gl.getParameter(34930);\n  const maxVertexTextures = gl.getParameter(35660);\n  const maxTextureSize = gl.getParameter(3379);\n  const maxCubemapSize = gl.getParameter(34076);\n\n  const maxAttributes = gl.getParameter(34921);\n  const maxVertexUniforms = gl.getParameter(36347);\n  const maxVaryings = gl.getParameter(36348);\n  const maxFragmentUniforms = gl.getParameter(36349);\n\n  const vertexTextures = maxVertexTextures > 0;\n  const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');\n  const floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;\n\n  return {\n    isWebGL2: isWebGL2,\n\n    drawBuffers: drawBuffers,\n\n    getMaxAnisotropy: getMaxAnisotropy,\n    getMaxPrecision: getMaxPrecision,\n\n    precision: precision,\n    logarithmicDepthBuffer: logarithmicDepthBuffer,\n\n    maxTextures: maxTextures,\n    maxVertexTextures: maxVertexTextures,\n    maxTextureSize: maxTextureSize,\n    maxCubemapSize: maxCubemapSize,\n\n    maxAttributes: maxAttributes,\n    maxVertexUniforms: maxVertexUniforms,\n    maxVaryings: maxVaryings,\n    maxFragmentUniforms: maxFragmentUniforms,\n\n    vertexTextures: vertexTextures,\n    floatFragmentTextures: floatFragmentTextures,\n    floatVertexTextures: floatVertexTextures,\n\n    maxSamples: maxSamples,\n  };\n}\n\nfunction WebGLClipping(properties) {\n  const scope = this;\n\n  let globalState = null,\n    numGlobalPlanes = 0,\n    localClippingEnabled = false,\n    renderingShadows = false;\n\n  const plane = new Plane(),\n    viewNormalMatrix = new Matrix3(),\n    uniform = { value: null, needsUpdate: false };\n\n  this.uniform = uniform;\n  this.numPlanes = 0;\n  this.numIntersection = 0;\n\n  this.init = function (planes, enableLocalClipping, camera) {\n    const enabled =\n      planes.length !== 0 ||\n      enableLocalClipping ||\n      // enable state of previous frame - the clipping code has to\n      // run another frame in order to reset the state:\n      numGlobalPlanes !== 0 ||\n      localClippingEnabled;\n\n    localClippingEnabled = enableLocalClipping;\n\n    globalState = projectPlanes(planes, camera, 0);\n    numGlobalPlanes = planes.length;\n\n    return enabled;\n  };\n\n  this.beginShadows = function () {\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n\n  this.endShadows = function () {\n    renderingShadows = false;\n    resetGlobalState();\n  };\n\n  this.setState = function (material, camera, useCache) {\n    const planes = material.clippingPlanes,\n      clipIntersection = material.clipIntersection,\n      clipShadows = material.clipShadows;\n\n    const materialProperties = properties.get(material);\n\n    if (\n      !localClippingEnabled ||\n      planes === null ||\n      planes.length === 0 ||\n      (renderingShadows && !clipShadows)\n    ) {\n      // there's no local clipping\n\n      if (renderingShadows) {\n        // there's no global clipping\n\n        projectPlanes(null);\n      } else {\n        resetGlobalState();\n      }\n    } else {\n      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n        lGlobal = nGlobal * 4;\n\n      let dstArray = materialProperties.clippingState || null;\n\n      uniform.value = dstArray; // ensure unique state\n\n      dstArray = projectPlanes(planes, camera, lGlobal, useCache);\n\n      for (let i = 0; i !== lGlobal; ++i) {\n        dstArray[i] = globalState[i];\n      }\n\n      materialProperties.clippingState = dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : 0;\n      this.numPlanes += nGlobal;\n    }\n  };\n\n  function resetGlobalState() {\n    if (uniform.value !== globalState) {\n      uniform.value = globalState;\n      uniform.needsUpdate = numGlobalPlanes > 0;\n    }\n\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection = 0;\n  }\n\n  function projectPlanes(planes, camera, dstOffset, skipTransform) {\n    const nPlanes = planes !== null ? planes.length : 0;\n    let dstArray = null;\n\n    if (nPlanes !== 0) {\n      dstArray = uniform.value;\n\n      if (skipTransform !== true || dstArray === null) {\n        const flatSize = dstOffset + nPlanes * 4,\n          viewMatrix = camera.matrixWorldInverse;\n\n        viewNormalMatrix.getNormalMatrix(viewMatrix);\n\n        if (dstArray === null || dstArray.length < flatSize) {\n          dstArray = new Float32Array(flatSize);\n        }\n\n        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n\n          plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = plane.constant;\n        }\n      }\n\n      uniform.value = dstArray;\n      uniform.needsUpdate = true;\n    }\n\n    scope.numPlanes = nPlanes;\n    scope.numIntersection = 0;\n\n    return dstArray;\n  }\n}\n\nfunction WebGLCubeMaps(renderer) {\n  let cubemaps = new WeakMap();\n\n  function mapTextureMapping(texture, mapping) {\n    if (mapping === EquirectangularReflectionMapping) {\n      texture.mapping = CubeReflectionMapping;\n    } else if (mapping === EquirectangularRefractionMapping) {\n      texture.mapping = CubeRefractionMapping;\n    }\n\n    return texture;\n  }\n\n  function get(texture) {\n    if (\n      texture &&\n      texture.isTexture &&\n      texture.isRenderTargetTexture === false\n    ) {\n      const mapping = texture.mapping;\n\n      if (\n        mapping === EquirectangularReflectionMapping ||\n        mapping === EquirectangularRefractionMapping\n      ) {\n        if (cubemaps.has(texture)) {\n          const cubemap = cubemaps.get(texture).texture;\n          return mapTextureMapping(cubemap, texture.mapping);\n        } else {\n          const image = texture.image;\n\n          if (image && image.height > 0) {\n            const currentRenderTarget = renderer.getRenderTarget();\n\n            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);\n            renderTarget.fromEquirectangularTexture(renderer, texture);\n            cubemaps.set(texture, renderTarget);\n\n            renderer.setRenderTarget(currentRenderTarget);\n\n            texture.addEventListener('dispose', onTextureDispose);\n\n            return mapTextureMapping(renderTarget.texture, texture.mapping);\n          } else {\n            // image not yet ready. try the conversion next frame\n\n            return null;\n          }\n        }\n      }\n    }\n\n    return texture;\n  }\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n\n    texture.removeEventListener('dispose', onTextureDispose);\n\n    const cubemap = cubemaps.get(texture);\n\n    if (cubemap !== undefined) {\n      cubemaps.delete(texture);\n      cubemap.dispose();\n    }\n  }\n\n  function dispose() {\n    cubemaps = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose,\n  };\n}\n\nclass OrthographicCamera extends Camera {\n  constructor(\n    left = -1,\n    right = 1,\n    top = 1,\n    bottom = -1,\n    near = 0.1,\n    far = 2000,\n  ) {\n    super();\n\n    this.type = 'OrthographicCamera';\n\n    this.zoom = 1;\n    this.view = null;\n\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n\n    this.near = near;\n    this.far = far;\n\n    this.updateProjectionMatrix();\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n\n    this.left = source.left;\n    this.right = source.right;\n    this.top = source.top;\n    this.bottom = source.bottom;\n    this.near = source.near;\n    this.far = source.far;\n\n    this.zoom = source.zoom;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n\n    return this;\n  }\n\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1,\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n\n    this.updateProjectionMatrix();\n  }\n\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  }\n\n  updateProjectionMatrix() {\n    const dx = (this.right - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.right + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n\n    if (this.view !== null && this.view.enabled) {\n      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n      const scaleH =\n        (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n\n      left += scaleW * this.view.offsetX;\n      right = left + scaleW * this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = top - scaleH * this.view.height;\n    }\n\n    this.projectionMatrix.makeOrthographic(\n      left,\n      right,\n      top,\n      bottom,\n      this.near,\n      this.far,\n    );\n\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n\n    data.object.zoom = this.zoom;\n    data.object.left = this.left;\n    data.object.right = this.right;\n    data.object.top = this.top;\n    data.object.bottom = this.bottom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n\n    return data;\n  }\n}\n\nOrthographicCamera.prototype.isOrthographicCamera = true;\n\nclass RawShaderMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super(parameters);\n\n    this.type = 'RawShaderMaterial';\n  }\n}\n\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow(2, LOD_MAX);\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES$1 = 20;\n\nconst ENCODINGS = {\n  [LinearEncoding]: 0,\n  [sRGBEncoding]: 1,\n  [RGBEEncoding]: 2,\n  [RGBM7Encoding]: 3,\n  [RGBM16Encoding]: 4,\n  [RGBDEncoding]: 5,\n  [GammaEncoding]: 6,\n};\n\nconst _flatCamera$1 = /*@__PURE__*/ new OrthographicCamera();\nconst { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\n\n// Golden Ratio\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n  /*@__PURE__*/ new Vector3(1, 1, 1),\n  /*@__PURE__*/ new Vector3(-1, 1, 1),\n  /*@__PURE__*/ new Vector3(1, 1, -1),\n  /*@__PURE__*/ new Vector3(-1, 1, -1),\n  /*@__PURE__*/ new Vector3(0, PHI, INV_PHI),\n  /*@__PURE__*/ new Vector3(0, PHI, -INV_PHI),\n  /*@__PURE__*/ new Vector3(INV_PHI, 0, PHI),\n  /*@__PURE__*/ new Vector3(-INV_PHI, 0, PHI),\n  /*@__PURE__*/ new Vector3(PHI, INV_PHI, 0),\n  /*@__PURE__*/ new Vector3(-PHI, INV_PHI, 0),\n];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n */\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n\n    this._blurMaterial = _getBlurShader(MAX_SAMPLES$1);\n    this._equirectShader = null;\n    this._cubemapShader = null;\n\n    this._compileMaterial(this._blurMaterial);\n  }\n\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n    const cubeUVRenderTarget = this._allocateTargets();\n\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromEquirectangular(equirectangular) {\n    return this._fromTexture(equirectangular);\n  }\n\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromCubemap(cubemap) {\n    return this._fromTexture(cubemap);\n  }\n\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileCubemapShader() {\n    if (this._cubemapShader === null) {\n      this._cubemapShader = _getCubemapShader();\n      this._compileMaterial(this._cubemapShader);\n    }\n  }\n\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileEquirectangularShader() {\n    if (this._equirectShader === null) {\n      this._equirectShader = _getEquirectShader();\n      this._compileMaterial(this._equirectShader);\n    }\n  }\n\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose() {\n    this._blurMaterial.dispose();\n\n    if (this._cubemapShader !== null) this._cubemapShader.dispose();\n    if (this._equirectShader !== null) this._equirectShader.dispose();\n\n    for (let i = 0; i < _lodPlanes.length; i++) {\n      _lodPlanes[i].dispose();\n    }\n  }\n\n  // private interface\n\n  _cleanup(outputTarget) {\n    this._pingPongRenderTarget.dispose();\n    this._renderer.setRenderTarget(_oldTarget);\n    outputTarget.scissorTest = false;\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n\n  _fromTexture(texture) {\n    _oldTarget = this._renderer.getRenderTarget();\n    const cubeUVRenderTarget = this._allocateTargets(texture);\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n\n  _allocateTargets(texture) {\n    // warning: null texture is valid\n\n    const params = {\n      magFilter: NearestFilter,\n      minFilter: NearestFilter,\n      generateMipmaps: false,\n      type: UnsignedByteType,\n      format: RGBEFormat,\n      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,\n      depthBuffer: false,\n    };\n\n    const cubeUVRenderTarget = _createRenderTarget(params);\n    cubeUVRenderTarget.depthBuffer = texture ? false : true;\n    this._pingPongRenderTarget = _createRenderTarget(params);\n    return cubeUVRenderTarget;\n  }\n\n  _compileMaterial(material) {\n    const tmpMesh = new Mesh(_lodPlanes[0], material);\n    this._renderer.compile(tmpMesh, _flatCamera$1);\n  }\n\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov = 90;\n    const aspect = 1;\n    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n\n    const originalAutoClear = renderer.autoClear;\n    const outputEncoding = renderer.outputEncoding;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n    renderer.autoClear = false;\n\n    const backgroundMaterial = new MeshBasicMaterial({\n      name: 'PMREM.Background',\n      side: BackSide,\n      depthWrite: false,\n      depthTest: false,\n    });\n\n    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n\n    let useSolidColor = false;\n    const background = scene.background;\n\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col == 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col == 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n\n      _setViewport(\n        cubeUVRenderTarget,\n        col * SIZE_MAX,\n        i > 2 ? SIZE_MAX : 0,\n        SIZE_MAX,\n        SIZE_MAX,\n      );\n      renderer.setRenderTarget(cubeUVRenderTarget);\n\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n\n      renderer.render(scene, cubeCamera);\n    }\n\n    backgroundBox.geometry.dispose();\n    backgroundBox.material.dispose();\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n\n  _setEncoding(uniform, texture) {\n    if (\n      this._renderer.capabilities.isWebGL2 === true &&\n      texture.format === RGBAFormat &&\n      texture.type === UnsignedByteType &&\n      texture.encoding === sRGBEncoding\n    ) {\n      uniform.value = ENCODINGS[LinearEncoding];\n    } else {\n      uniform.value = ENCODINGS[texture.encoding];\n    }\n  }\n\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n\n    if (texture.isCubeTexture) {\n      if (this._cubemapShader == null) {\n        this._cubemapShader = _getCubemapShader();\n      }\n    } else {\n      if (this._equirectShader == null) {\n        this._equirectShader = _getEquirectShader();\n      }\n    }\n\n    const material = texture.isCubeTexture\n      ? this._cubemapShader\n      : this._equirectShader;\n    const mesh = new Mesh(_lodPlanes[0], material);\n\n    const uniforms = material.uniforms;\n\n    uniforms['envMap'].value = texture;\n\n    if (!texture.isCubeTexture) {\n      uniforms['texelSize'].value.set(\n        1.0 / texture.image.width,\n        1.0 / texture.image.height,\n      );\n    }\n\n    this._setEncoding(uniforms['inputEncoding'], texture);\n    this._setEncoding(uniforms['outputEncoding'], cubeUVRenderTarget.texture);\n\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera$1);\n  }\n\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n\n    for (let i = 1; i < TOTAL_LODS; i++) {\n      const sigma = Math.sqrt(\n        _sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1],\n      );\n\n      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n\n    this._halfBlur(\n      cubeUVRenderTarget,\n      pingPongRenderTarget,\n      lodIn,\n      lodOut,\n      sigma,\n      'latitudinal',\n      poleAxis,\n    );\n\n    this._halfBlur(\n      pingPongRenderTarget,\n      cubeUVRenderTarget,\n      lodOut,\n      lodOut,\n      sigma,\n      'longitudinal',\n      poleAxis,\n    );\n  }\n\n  _halfBlur(\n    targetIn,\n    targetOut,\n    lodIn,\n    lodOut,\n    sigmaRadians,\n    direction,\n    poleAxis,\n  ) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error(\n        'blur direction must be either latitudinal or longitudinal!',\n      );\n    }\n\n    // Number of standard deviations at which to cut off the discrete approximation.\n    const STANDARD_DEVIATIONS = 3;\n\n    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n\n    const pixels = _sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians)\n      ? Math.PI / (2 * pixels)\n      : (2 * Math.PI) / (2 * MAX_SAMPLES$1 - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians)\n      ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels)\n      : MAX_SAMPLES$1;\n\n    if (samples > MAX_SAMPLES$1) {\n      console.warn(\n        `sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES$1}`,\n      );\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES$1; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp((-x * x) / 2);\n      weights.push(weight);\n\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n    if (poleAxis) {\n      blurUniforms['poleAxis'].value = poleAxis;\n    }\n\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    blurUniforms['mipInt'].value = LOD_MAX - lodIn;\n\n    this._setEncoding(blurUniforms['inputEncoding'], targetIn.texture);\n    this._setEncoding(blurUniforms['outputEncoding'], targetIn.texture);\n\n    const outputSize = _sizeLods[lodOut];\n    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n    const y =\n      (lodOut === 0 ? 0 : 2 * SIZE_MAX) +\n      2 *\n        outputSize *\n        (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera$1);\n  }\n}\n\nfunction _isLDR(texture) {\n  if (texture === undefined || texture.type !== UnsignedByteType) return false;\n\n  return (\n    texture.encoding === LinearEncoding ||\n    texture.encoding === sRGBEncoding ||\n    texture.encoding === GammaEncoding\n  );\n}\n\nfunction _createPlanes() {\n  const _lodPlanes = [];\n  const _sizeLods = [];\n  const _sigmas = [];\n\n  let lod = LOD_MAX;\n\n  for (let i = 0; i < TOTAL_LODS; i++) {\n    const sizeLod = Math.pow(2, lod);\n    _sizeLods.push(sizeLod);\n    let sigma = 1.0 / sizeLod;\n\n    if (i > LOD_MAX - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n    } else if (i == 0) {\n      sigma = 0;\n    }\n\n    _sigmas.push(sigma);\n\n    const texelSize = 1.0 / (sizeLod - 1);\n    const min = -texelSize / 2;\n    const max = 1 + texelSize / 2;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = ((face % 3) * 2) / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [\n        x,\n        y,\n        0,\n        x + 2 / 3,\n        y,\n        0,\n        x + 2 / 3,\n        y + 1,\n        0,\n        x,\n        y,\n        0,\n        x + 2 / 3,\n        y + 1,\n        0,\n        x,\n        y + 1,\n        0,\n      ];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    const planes = new BufferGeometry();\n    planes.setAttribute(\n      'position',\n      new BufferAttribute(position, positionSize),\n    );\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute(\n      'faceIndex',\n      new BufferAttribute(faceIndex, faceIndexSize),\n    );\n    _lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return { _lodPlanes, _sizeLods, _sigmas };\n}\n\nfunction _createRenderTarget(params) {\n  const cubeUVRenderTarget = new WebGLRenderTarget(\n    3 * SIZE_MAX,\n    3 * SIZE_MAX,\n    params,\n  );\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _getBlurShader(maxSamples) {\n  const weights = new Float32Array(maxSamples);\n  const poleAxis = new Vector3(0, 1, 0);\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'SphericalGaussianBlur',\n\n    defines: { n: maxSamples },\n\n    uniforms: {\n      envMap: { value: null },\n      samples: { value: 1 },\n      weights: { value: weights },\n      latitudinal: { value: false },\n      dTheta: { value: 0 },\n      mipInt: { value: 0 },\n      poleAxis: { value: poleAxis },\n      inputEncoding: { value: ENCODINGS[LinearEncoding] },\n      outputEncoding: { value: ENCODINGS[LinearEncoding] },\n    },\n\n    vertexShader: _getCommonVertexShader(),\n\n    fragmentShader: /* glsl */ `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n  });\n\n  return shaderMaterial;\n}\n\nfunction _getEquirectShader() {\n  const texelSize = new Vector2(1, 1);\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'EquirectangularToCubeUV',\n\n    uniforms: {\n      envMap: { value: null },\n      texelSize: { value: texelSize },\n      inputEncoding: { value: ENCODINGS[LinearEncoding] },\n      outputEncoding: { value: ENCODINGS[LinearEncoding] },\n    },\n\n    vertexShader: _getCommonVertexShader(),\n\n    fragmentShader: /* glsl */ `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n  });\n\n  return shaderMaterial;\n}\n\nfunction _getCubemapShader() {\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'CubemapToCubeUV',\n\n    uniforms: {\n      envMap: { value: null },\n      inputEncoding: { value: ENCODINGS[LinearEncoding] },\n      outputEncoding: { value: ENCODINGS[LinearEncoding] },\n    },\n\n    vertexShader: _getCommonVertexShader(),\n\n    fragmentShader: /* glsl */ `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n  });\n\n  return shaderMaterial;\n}\n\nfunction _getCommonVertexShader() {\n  return /* glsl */ `\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n}\n\nfunction _getEncodings() {\n  return /* glsl */ `\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`;\n}\n\nfunction WebGLCubeUVMaps(renderer) {\n  let cubeUVmaps = new WeakMap();\n\n  let pmremGenerator = null;\n\n  function get(texture) {\n    if (\n      texture &&\n      texture.isTexture &&\n      texture.isRenderTargetTexture === false\n    ) {\n      const mapping = texture.mapping;\n\n      const isEquirectMap =\n        mapping === EquirectangularReflectionMapping ||\n        mapping === EquirectangularRefractionMapping;\n      const isCubeMap =\n        mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n\n      if (isEquirectMap || isCubeMap) {\n        // equirect/cube map to cubeUV conversion\n\n        if (cubeUVmaps.has(texture)) {\n          return cubeUVmaps.get(texture).texture;\n        } else {\n          const image = texture.image;\n\n          if (\n            (isEquirectMap && image && image.height > 0) ||\n            (isCubeMap && image && isCubeTextureComplete(image))\n          ) {\n            const currentRenderTarget = renderer.getRenderTarget();\n\n            if (pmremGenerator === null)\n              pmremGenerator = new PMREMGenerator(renderer);\n\n            const renderTarget = isEquirectMap\n              ? pmremGenerator.fromEquirectangular(texture)\n              : pmremGenerator.fromCubemap(texture);\n            cubeUVmaps.set(texture, renderTarget);\n\n            renderer.setRenderTarget(currentRenderTarget);\n\n            texture.addEventListener('dispose', onTextureDispose);\n\n            return renderTarget.texture;\n          } else {\n            // image not yet ready. try the conversion next frame\n\n            return null;\n          }\n        }\n      }\n    }\n\n    return texture;\n  }\n\n  function isCubeTextureComplete(image) {\n    let count = 0;\n    const length = 6;\n\n    for (let i = 0; i < length; i++) {\n      if (image[i] !== undefined) count++;\n    }\n\n    return count === length;\n  }\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n\n    texture.removeEventListener('dispose', onTextureDispose);\n\n    const cubemapUV = cubeUVmaps.get(texture);\n\n    if (cubemapUV !== undefined) {\n      cubeUVmaps.delete(texture);\n      cubemapUV.dispose();\n    }\n  }\n\n  function dispose() {\n    cubeUVmaps = new WeakMap();\n\n    if (pmremGenerator !== null) {\n      pmremGenerator.dispose();\n      pmremGenerator = null;\n    }\n  }\n\n  return {\n    get: get,\n    dispose: dispose,\n  };\n}\n\nfunction WebGLExtensions(gl) {\n  const extensions = {};\n\n  function getExtension(name) {\n    if (extensions[name] !== undefined) {\n      return extensions[name];\n    }\n\n    let extension;\n\n    switch (name) {\n      case 'WEBGL_depth_texture':\n        extension =\n          gl.getExtension('WEBGL_depth_texture') ||\n          gl.getExtension('MOZ_WEBGL_depth_texture') ||\n          gl.getExtension('WEBKIT_WEBGL_depth_texture');\n        break;\n\n      case 'EXT_texture_filter_anisotropic':\n        extension =\n          gl.getExtension('EXT_texture_filter_anisotropic') ||\n          gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||\n          gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\n        break;\n\n      case 'WEBGL_compressed_texture_s3tc':\n        extension =\n          gl.getExtension('WEBGL_compressed_texture_s3tc') ||\n          gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||\n          gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n        break;\n\n      case 'WEBGL_compressed_texture_pvrtc':\n        extension =\n          gl.getExtension('WEBGL_compressed_texture_pvrtc') ||\n          gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n        break;\n\n      default:\n        extension = gl.getExtension(name);\n    }\n\n    extensions[name] = extension;\n\n    return extension;\n  }\n\n  return {\n    has: function (name) {\n      return getExtension(name) !== null;\n    },\n\n    init: function (capabilities) {\n      if (capabilities.isWebGL2) {\n        getExtension('EXT_color_buffer_float');\n      } else {\n        getExtension('WEBGL_depth_texture');\n        getExtension('OES_texture_float');\n        getExtension('OES_texture_half_float');\n        getExtension('OES_texture_half_float_linear');\n        getExtension('OES_standard_derivatives');\n        getExtension('OES_element_index_uint');\n        getExtension('OES_vertex_array_object');\n        getExtension('ANGLE_instanced_arrays');\n      }\n\n      getExtension('OES_texture_float_linear');\n      getExtension('EXT_color_buffer_half_float');\n    },\n\n    get: function (name) {\n      const extension = getExtension(name);\n\n      if (extension === null) {\n        console.warn(\n          'THREE.WebGLRenderer: ' + name + ' extension not supported.',\n        );\n      }\n\n      return extension;\n    },\n  };\n}\n\nfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n  const geometries = {};\n  const wireframeAttributes = new WeakMap();\n\n  function onGeometryDispose(event) {\n    const geometry = event.target;\n\n    if (geometry.index !== null) {\n      attributes.remove(geometry.index);\n    }\n\n    for (const name in geometry.attributes) {\n      attributes.remove(geometry.attributes[name]);\n    }\n\n    geometry.removeEventListener('dispose', onGeometryDispose);\n\n    delete geometries[geometry.id];\n\n    const attribute = wireframeAttributes.get(geometry);\n\n    if (attribute) {\n      attributes.remove(attribute);\n      wireframeAttributes.delete(geometry);\n    }\n\n    bindingStates.releaseStatesOfGeometry(geometry);\n\n    if (geometry.isInstancedBufferGeometry === true) {\n      delete geometry._maxInstanceCount;\n    }\n\n    //\n\n    info.memory.geometries--;\n  }\n\n  function get(object, geometry) {\n    if (geometries[geometry.id] === true) return geometry;\n\n    geometry.addEventListener('dispose', onGeometryDispose);\n\n    geometries[geometry.id] = true;\n\n    info.memory.geometries++;\n\n    return geometry;\n  }\n\n  function update(geometry) {\n    const geometryAttributes = geometry.attributes;\n\n    // Updating index buffer in VAO now. See WebGLBindingStates.\n\n    for (const name in geometryAttributes) {\n      attributes.update(geometryAttributes[name], 34962);\n    }\n\n    // morph targets\n\n    const morphAttributes = geometry.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const array = morphAttributes[name];\n\n      for (let i = 0, l = array.length; i < l; i++) {\n        attributes.update(array[i], 34962);\n      }\n    }\n  }\n\n  function updateWireframeAttribute(geometry) {\n    const indices = [];\n\n    const geometryIndex = geometry.index;\n    const geometryPosition = geometry.attributes.position;\n    let version = 0;\n\n    if (geometryIndex !== null) {\n      const array = geometryIndex.array;\n      version = geometryIndex.version;\n\n      for (let i = 0, l = array.length; i < l; i += 3) {\n        const a = array[i + 0];\n        const b = array[i + 1];\n        const c = array[i + 2];\n\n        indices.push(a, b, b, c, c, a);\n      }\n    } else {\n      const array = geometryPosition.array;\n      version = geometryPosition.version;\n\n      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n        const a = i + 0;\n        const b = i + 1;\n        const c = i + 2;\n\n        indices.push(a, b, b, c, c, a);\n      }\n    }\n\n    const attribute = new (\n      arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute\n    )(indices, 1);\n    attribute.version = version;\n\n    // Updating index buffer in VAO now. See WebGLBindingStates\n\n    //\n\n    const previousAttribute = wireframeAttributes.get(geometry);\n\n    if (previousAttribute) attributes.remove(previousAttribute);\n\n    //\n\n    wireframeAttributes.set(geometry, attribute);\n  }\n\n  function getWireframeAttribute(geometry) {\n    const currentAttribute = wireframeAttributes.get(geometry);\n\n    if (currentAttribute) {\n      const geometryIndex = geometry.index;\n\n      if (geometryIndex !== null) {\n        // if the attribute is obsolete, create a new one\n\n        if (currentAttribute.version < geometryIndex.version) {\n          updateWireframeAttribute(geometry);\n        }\n      }\n    } else {\n      updateWireframeAttribute(geometry);\n    }\n\n    return wireframeAttributes.get(geometry);\n  }\n\n  return {\n    get: get,\n    update: update,\n\n    getWireframeAttribute: getWireframeAttribute,\n  };\n}\n\nfunction WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n\n  let mode;\n\n  function setMode(value) {\n    mode = value;\n  }\n\n  let type, bytesPerElement;\n\n  function setIndex(value) {\n    type = value.type;\n    bytesPerElement = value.bytesPerElement;\n  }\n\n  function render(start, count) {\n    gl.drawElements(mode, count, type, start * bytesPerElement);\n\n    info.update(count, mode, 1);\n  }\n\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0) return;\n\n    let extension, methodName;\n\n    if (isWebGL2) {\n      extension = gl;\n      methodName = 'drawElementsInstanced';\n    } else {\n      extension = extensions.get('ANGLE_instanced_arrays');\n      methodName = 'drawElementsInstancedANGLE';\n\n      if (extension === null) {\n        console.error(\n          'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',\n        );\n        return;\n      }\n    }\n\n    extension[methodName](\n      mode,\n      count,\n      type,\n      start * bytesPerElement,\n      primcount,\n    );\n\n    info.update(count, mode, primcount);\n  }\n\n  //\n\n  this.setMode = setMode;\n  this.setIndex = setIndex;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}\n\nfunction WebGLInfo(gl) {\n  const memory = {\n    geometries: 0,\n    textures: 0,\n  };\n\n  const render = {\n    frame: 0,\n    calls: 0,\n    triangles: 0,\n    points: 0,\n    lines: 0,\n  };\n\n  function update(count, mode, instanceCount) {\n    render.calls++;\n\n    switch (mode) {\n      case 4:\n        render.triangles += instanceCount * (count / 3);\n        break;\n\n      case 1:\n        render.lines += instanceCount * (count / 2);\n        break;\n\n      case 3:\n        render.lines += instanceCount * (count - 1);\n        break;\n\n      case 2:\n        render.lines += instanceCount * count;\n        break;\n\n      case 0:\n        render.points += instanceCount * count;\n        break;\n\n      default:\n        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);\n        break;\n    }\n  }\n\n  function reset() {\n    render.frame++;\n    render.calls = 0;\n    render.triangles = 0;\n    render.points = 0;\n    render.lines = 0;\n  }\n\n  return {\n    memory: memory,\n    render: render,\n    programs: null,\n    autoReset: true,\n    reset: reset,\n    update: update,\n  };\n}\n\nclass DataTexture2DArray extends Texture$1 {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null);\n\n    this.image = { data, width, height, depth };\n\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n\n    this.wrapR = ClampToEdgeWrapping;\n\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n\n    this.needsUpdate = true;\n  }\n}\n\nDataTexture2DArray.prototype.isDataTexture2DArray = true;\n\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction denormalize(morph, attribute) {\n  let denominator = 1;\n  const array = attribute.isInterleavedBufferAttribute\n    ? attribute.data.array\n    : attribute.array;\n\n  if (array instanceof Int8Array) denominator = 127;\n  else if (array instanceof Int16Array) denominator = 32767;\n  else if (array instanceof Int32Array) denominator = 2147483647;\n  else\n    console.error(\n      'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ',\n      array,\n    );\n\n  morph.divideScalar(denominator);\n}\n\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  const influencesList = {};\n  const morphInfluences = new Float32Array(8);\n  const morphTextures = new WeakMap();\n  const morph = new Vector3();\n\n  const workInfluences = [];\n\n  for (let i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    const objectInfluences = object.morphTargetInfluences;\n\n    if (capabilities.isWebGL2 === true) {\n      // instead of using attributes, the WebGL 2 code path encodes morph targets\n      // into an array of data textures. Each layer represents a single morph target.\n\n      const numberOfMorphTargets = geometry.morphAttributes.position.length;\n\n      let entry = morphTextures.get(geometry);\n\n      if (entry === undefined || entry.count !== numberOfMorphTargets) {\n        if (entry !== undefined) entry.texture.dispose();\n\n        const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\n        const morphTargets = geometry.morphAttributes.position;\n        const morphNormals = geometry.morphAttributes.normal || [];\n\n        const numberOfVertices = geometry.attributes.position.count;\n        const numberOfVertexData = hasMorphNormals === true ? 2 : 1; // (v,n) vs. (v)\n\n        let width = numberOfVertices * numberOfVertexData;\n        let height = 1;\n\n        if (width > capabilities.maxTextureSize) {\n          height = Math.ceil(width / capabilities.maxTextureSize);\n          width = capabilities.maxTextureSize;\n        }\n\n        const buffer = new Float32Array(\n          width * height * 4 * numberOfMorphTargets,\n        );\n\n        const texture = new DataTexture2DArray(\n          buffer,\n          width,\n          height,\n          numberOfMorphTargets,\n        );\n        texture.format = RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)\n        texture.type = FloatType;\n\n        // fill buffer\n\n        const vertexDataStride = numberOfVertexData * 4;\n\n        for (let i = 0; i < numberOfMorphTargets; i++) {\n          const morphTarget = morphTargets[i];\n          const morphNormal = morphNormals[i];\n\n          const offset = width * height * 4 * i;\n\n          for (let j = 0; j < morphTarget.count; j++) {\n            morph.fromBufferAttribute(morphTarget, j);\n\n            if (morphTarget.normalized === true)\n              denormalize(morph, morphTarget);\n\n            const stride = j * vertexDataStride;\n\n            buffer[offset + stride + 0] = morph.x;\n            buffer[offset + stride + 1] = morph.y;\n            buffer[offset + stride + 2] = morph.z;\n            buffer[offset + stride + 3] = 0;\n\n            if (hasMorphNormals === true) {\n              morph.fromBufferAttribute(morphNormal, j);\n\n              if (morphNormal.normalized === true)\n                denormalize(morph, morphNormal);\n\n              buffer[offset + stride + 4] = morph.x;\n              buffer[offset + stride + 5] = morph.y;\n              buffer[offset + stride + 6] = morph.z;\n              buffer[offset + stride + 7] = 0;\n            }\n          }\n        }\n\n        entry = {\n          count: numberOfMorphTargets,\n          texture: texture,\n          size: new Vector2(width, height),\n        };\n\n        morphTextures.set(geometry, entry);\n      }\n\n      //\n\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < objectInfluences.length; i++) {\n        morphInfluencesSum += objectInfluences[i];\n      }\n\n      const morphBaseInfluence = geometry.morphTargetsRelative\n        ? 1\n        : 1 - morphInfluencesSum;\n\n      program\n        .getUniforms()\n        .setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program\n        .getUniforms()\n        .setValue(gl, 'morphTargetInfluences', objectInfluences);\n\n      program\n        .getUniforms()\n        .setValue(gl, 'morphTargetsTexture', entry.texture, textures);\n      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);\n    } else {\n      // When object doesn't have morph target influences defined, we treat it as a 0-length array\n      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n      const length =\n        objectInfluences === undefined ? 0 : objectInfluences.length;\n\n      let influences = influencesList[geometry.id];\n\n      if (influences === undefined || influences.length !== length) {\n        // initialise list\n\n        influences = [];\n\n        for (let i = 0; i < length; i++) {\n          influences[i] = [i, 0];\n        }\n\n        influencesList[geometry.id] = influences;\n      }\n\n      // Collect influences\n\n      for (let i = 0; i < length; i++) {\n        const influence = influences[i];\n\n        influence[0] = i;\n        influence[1] = objectInfluences[i];\n      }\n\n      influences.sort(absNumericalSort);\n\n      for (let i = 0; i < 8; i++) {\n        if (i < length && influences[i][1]) {\n          workInfluences[i][0] = influences[i][0];\n          workInfluences[i][1] = influences[i][1];\n        } else {\n          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n          workInfluences[i][1] = 0;\n        }\n      }\n\n      workInfluences.sort(numericalSort);\n\n      const morphTargets = geometry.morphAttributes.position;\n      const morphNormals = geometry.morphAttributes.normal;\n\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < 8; i++) {\n        const influence = workInfluences[i];\n        const index = influence[0];\n        const value = influence[1];\n\n        if (index !== Number.MAX_SAFE_INTEGER && value) {\n          if (\n            morphTargets &&\n            geometry.getAttribute('morphTarget' + i) !== morphTargets[index]\n          ) {\n            geometry.setAttribute('morphTarget' + i, morphTargets[index]);\n          }\n\n          if (\n            morphNormals &&\n            geometry.getAttribute('morphNormal' + i) !== morphNormals[index]\n          ) {\n            geometry.setAttribute('morphNormal' + i, morphNormals[index]);\n          }\n\n          morphInfluences[i] = value;\n          morphInfluencesSum += value;\n        } else {\n          if (\n            morphTargets &&\n            geometry.hasAttribute('morphTarget' + i) === true\n          ) {\n            geometry.deleteAttribute('morphTarget' + i);\n          }\n\n          if (\n            morphNormals &&\n            geometry.hasAttribute('morphNormal' + i) === true\n          ) {\n            geometry.deleteAttribute('morphNormal' + i);\n          }\n\n          morphInfluences[i] = 0;\n        }\n      }\n\n      // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n      // This allows us to switch between absolute morphs and relative morphs without changing shader code\n      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n      const morphBaseInfluence = geometry.morphTargetsRelative\n        ? 1\n        : 1 - morphInfluencesSum;\n\n      program\n        .getUniforms()\n        .setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program\n        .getUniforms()\n        .setValue(gl, 'morphTargetInfluences', morphInfluences);\n    }\n  }\n\n  return {\n    update: update,\n  };\n}\n\nfunction WebGLObjects(gl, geometries, attributes, info) {\n  let updateMap = new WeakMap();\n\n  function update(object) {\n    const frame = info.render.frame;\n\n    const geometry = object.geometry;\n    const buffergeometry = geometries.get(object, geometry);\n\n    // Update once per frame\n\n    if (updateMap.get(buffergeometry) !== frame) {\n      geometries.update(buffergeometry);\n\n      updateMap.set(buffergeometry, frame);\n    }\n\n    if (object.isInstancedMesh) {\n      if (\n        object.hasEventListener('dispose', onInstancedMeshDispose) === false\n      ) {\n        object.addEventListener('dispose', onInstancedMeshDispose);\n      }\n\n      attributes.update(object.instanceMatrix, 34962);\n\n      if (object.instanceColor !== null) {\n        attributes.update(object.instanceColor, 34962);\n      }\n    }\n\n    return buffergeometry;\n  }\n\n  function dispose() {\n    updateMap = new WeakMap();\n  }\n\n  function onInstancedMeshDispose(event) {\n    const instancedMesh = event.target;\n\n    instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);\n\n    attributes.remove(instancedMesh.instanceMatrix);\n\n    if (instancedMesh.instanceColor !== null)\n      attributes.remove(instancedMesh.instanceColor);\n  }\n\n  return {\n    update: update,\n    dispose: dispose,\n  };\n}\n\nclass DataTexture3D extends Texture$1 {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    // We're going to add .setXXX() methods for setting properties later.\n    // Users can still set in DataTexture3D directly.\n    //\n    //\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n    // \ttexture.anisotropy = 16;\n    //\n    // See #14839\n\n    super(null);\n\n    this.image = { data, width, height, depth };\n\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n\n    this.wrapR = ClampToEdgeWrapping;\n\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n\n    this.needsUpdate = true;\n  }\n}\n\nDataTexture3D.prototype.isDataTexture3D = true;\n\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\nconst emptyTexture = new Texture$1();\nconst emptyTexture2dArray = new DataTexture2DArray();\nconst emptyTexture3d = new DataTexture3D();\nconst emptyCubeTexture = new CubeTexture();\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nconst mat4array = new Float32Array(16);\nconst mat3array = new Float32Array(9);\nconst mat2array = new Float32Array(4);\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten(array, nBlocks, blockSize) {\n  const firstElem = array[0];\n\n  if (firstElem <= 0 || firstElem > 0) return array;\n  // unoptimized: ! isNaN( firstElem )\n  // see http://jacksondunstan.com/articles/983\n\n  const n = nBlocks * blockSize;\n  let r = arrayCacheF32[n];\n\n  if (r === undefined) {\n    r = new Float32Array(n);\n    arrayCacheF32[n] = r;\n  }\n\n  if (nBlocks !== 0) {\n    firstElem.toArray(r, 0);\n\n    for (let i = 1, offset = 0; i !== nBlocks; ++i) {\n      offset += blockSize;\n      array[i].toArray(r, offset);\n    }\n  }\n\n  return r;\n}\n\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nfunction copyArray(a, b) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    a[i] = b[i];\n  }\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits(textures, n) {\n  let r = arrayCacheI32[n];\n\n  if (r === undefined) {\n    r = new Int32Array(n);\n    arrayCacheI32[n] = r;\n  }\n\n  for (let i = 0; i !== n; ++i) {\n    r[i] = textures.allocateTextureUnit();\n  }\n\n  return r;\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValueV1f(gl, v) {\n  const cache = this.cache;\n\n  if (cache[0] === v) return;\n\n  gl.uniform1f(this.addr, v);\n\n  cache[0] = v;\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValueV2f(gl, v) {\n  const cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (cache[0] !== v.x || cache[1] !== v.y) {\n      gl.uniform2f(this.addr, v.x, v.y);\n\n      cache[0] = v.x;\n      cache[1] = v.y;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n\n    gl.uniform2fv(this.addr, v);\n\n    copyArray(cache, v);\n  }\n}\n\nfunction setValueV3f(gl, v) {\n  const cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {\n      gl.uniform3f(this.addr, v.x, v.y, v.z);\n\n      cache[0] = v.x;\n      cache[1] = v.y;\n      cache[2] = v.z;\n    }\n  } else if (v.r !== undefined) {\n    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {\n      gl.uniform3f(this.addr, v.r, v.g, v.b);\n\n      cache[0] = v.r;\n      cache[1] = v.g;\n      cache[2] = v.b;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n\n    gl.uniform3fv(this.addr, v);\n\n    copyArray(cache, v);\n  }\n}\n\nfunction setValueV4f(gl, v) {\n  const cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (\n      cache[0] !== v.x ||\n      cache[1] !== v.y ||\n      cache[2] !== v.z ||\n      cache[3] !== v.w\n    ) {\n      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n\n      cache[0] = v.x;\n      cache[1] = v.y;\n      cache[2] = v.z;\n      cache[3] = v.w;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n\n    gl.uniform4fv(this.addr, v);\n\n    copyArray(cache, v);\n  }\n}\n\n// Single matrix (from flat array or THREE.MatrixN)\n\nfunction setValueM2(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n\n    gl.uniformMatrix2fv(this.addr, false, v);\n\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n\n    mat2array.set(elements);\n\n    gl.uniformMatrix2fv(this.addr, false, mat2array);\n\n    copyArray(cache, elements);\n  }\n}\n\nfunction setValueM3(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n\n    gl.uniformMatrix3fv(this.addr, false, v);\n\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n\n    mat3array.set(elements);\n\n    gl.uniformMatrix3fv(this.addr, false, mat3array);\n\n    copyArray(cache, elements);\n  }\n}\n\nfunction setValueM4(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n\n    gl.uniformMatrix4fv(this.addr, false, v);\n\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n\n    mat4array.set(elements);\n\n    gl.uniformMatrix4fv(this.addr, false, mat4array);\n\n    copyArray(cache, elements);\n  }\n}\n\n// Single integer / boolean\n\nfunction setValueV1i(gl, v) {\n  const cache = this.cache;\n\n  if (cache[0] === v) return;\n\n  gl.uniform1i(this.addr, v);\n\n  cache[0] = v;\n}\n\n// Single integer / boolean vector (from flat array)\n\nfunction setValueV2i(gl, v) {\n  const cache = this.cache;\n\n  if (arraysEqual(cache, v)) return;\n\n  gl.uniform2iv(this.addr, v);\n\n  copyArray(cache, v);\n}\n\nfunction setValueV3i(gl, v) {\n  const cache = this.cache;\n\n  if (arraysEqual(cache, v)) return;\n\n  gl.uniform3iv(this.addr, v);\n\n  copyArray(cache, v);\n}\n\nfunction setValueV4i(gl, v) {\n  const cache = this.cache;\n\n  if (arraysEqual(cache, v)) return;\n\n  gl.uniform4iv(this.addr, v);\n\n  copyArray(cache, v);\n}\n\n// Single unsigned integer\n\nfunction setValueV1ui(gl, v) {\n  const cache = this.cache;\n\n  if (cache[0] === v) return;\n\n  gl.uniform1ui(this.addr, v);\n\n  cache[0] = v;\n}\n\n// Single unsigned integer vector (from flat array)\n\nfunction setValueV2ui(gl, v) {\n  const cache = this.cache;\n\n  if (arraysEqual(cache, v)) return;\n\n  gl.uniform2uiv(this.addr, v);\n\n  copyArray(cache, v);\n}\n\nfunction setValueV3ui(gl, v) {\n  const cache = this.cache;\n\n  if (arraysEqual(cache, v)) return;\n\n  gl.uniform3uiv(this.addr, v);\n\n  copyArray(cache, v);\n}\n\nfunction setValueV4ui(gl, v) {\n  const cache = this.cache;\n\n  if (arraysEqual(cache, v)) return;\n\n  gl.uniform4uiv(this.addr, v);\n\n  copyArray(cache, v);\n}\n\n// Single texture (2D / Cube)\n\nfunction setValueT1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.safeSetTexture2D(v || emptyTexture, unit);\n}\n\nfunction setValueT3D1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.setTexture3D(v || emptyTexture3d, unit);\n}\n\nfunction setValueT6(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.safeSetTextureCube(v || emptyCubeTexture, unit);\n}\n\nfunction setValueT2DArray1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.setTexture2DArray(v || emptyTexture2dArray, unit);\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter(type) {\n  switch (type) {\n    case 0x1406:\n      return setValueV1f; // FLOAT\n    case 0x8b50:\n      return setValueV2f; // _VEC2\n    case 0x8b51:\n      return setValueV3f; // _VEC3\n    case 0x8b52:\n      return setValueV4f; // _VEC4\n\n    case 0x8b5a:\n      return setValueM2; // _MAT2\n    case 0x8b5b:\n      return setValueM3; // _MAT3\n    case 0x8b5c:\n      return setValueM4; // _MAT4\n\n    case 0x1404:\n    case 0x8b56:\n      return setValueV1i; // INT, BOOL\n    case 0x8b53:\n    case 0x8b57:\n      return setValueV2i; // _VEC2\n    case 0x8b54:\n    case 0x8b58:\n      return setValueV3i; // _VEC3\n    case 0x8b55:\n    case 0x8b59:\n      return setValueV4i; // _VEC4\n\n    case 0x1405:\n      return setValueV1ui; // UINT\n    case 0x8dc6:\n      return setValueV2ui; // _VEC2\n    case 0x8dc7:\n      return setValueV3ui; // _VEC3\n    case 0x8dc8:\n      return setValueV4ui; // _VEC4\n\n    case 0x8b5e: // SAMPLER_2D\n    case 0x8d66: // SAMPLER_EXTERNAL_OES\n    case 0x8dca: // INT_SAMPLER_2D\n    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n    case 0x8b62: // SAMPLER_2D_SHADOW\n      return setValueT1;\n\n    case 0x8b5f: // SAMPLER_3D\n    case 0x8dcb: // INT_SAMPLER_3D\n    case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n      return setValueT3D1;\n\n    case 0x8b60: // SAMPLER_CUBE\n    case 0x8dcc: // INT_SAMPLER_CUBE\n    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n    case 0x8dc5: // SAMPLER_CUBE_SHADOW\n      return setValueT6;\n\n    case 0x8dc1: // SAMPLER_2D_ARRAY\n    case 0x8dcf: // INT_SAMPLER_2D_ARRAY\n    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n    case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n      return setValueT2DArray1;\n  }\n}\n\n// Array of scalars\n\nfunction setValueV1fArray(gl, v) {\n  gl.uniform1fv(this.addr, v);\n}\n\n// Array of vectors (from flat array or array of THREE.VectorN)\n\nfunction setValueV2fArray(gl, v) {\n  const data = flatten(v, this.size, 2);\n\n  gl.uniform2fv(this.addr, data);\n}\n\nfunction setValueV3fArray(gl, v) {\n  const data = flatten(v, this.size, 3);\n\n  gl.uniform3fv(this.addr, data);\n}\n\nfunction setValueV4fArray(gl, v) {\n  const data = flatten(v, this.size, 4);\n\n  gl.uniform4fv(this.addr, data);\n}\n\n// Array of matrices (from flat array or array of THREE.MatrixN)\n\nfunction setValueM2Array(gl, v) {\n  const data = flatten(v, this.size, 4);\n\n  gl.uniformMatrix2fv(this.addr, false, data);\n}\n\nfunction setValueM3Array(gl, v) {\n  const data = flatten(v, this.size, 9);\n\n  gl.uniformMatrix3fv(this.addr, false, data);\n}\n\nfunction setValueM4Array(gl, v) {\n  const data = flatten(v, this.size, 16);\n\n  gl.uniformMatrix4fv(this.addr, false, data);\n}\n\n// Array of integer / boolean\n\nfunction setValueV1iArray(gl, v) {\n  gl.uniform1iv(this.addr, v);\n}\n\n// Array of integer / boolean vectors (from flat array)\n\nfunction setValueV2iArray(gl, v) {\n  gl.uniform2iv(this.addr, v);\n}\n\nfunction setValueV3iArray(gl, v) {\n  gl.uniform3iv(this.addr, v);\n}\n\nfunction setValueV4iArray(gl, v) {\n  gl.uniform4iv(this.addr, v);\n}\n\n// Array of unsigned integer\n\nfunction setValueV1uiArray(gl, v) {\n  gl.uniform1uiv(this.addr, v);\n}\n\n// Array of unsigned integer vectors (from flat array)\n\nfunction setValueV2uiArray(gl, v) {\n  gl.uniform2uiv(this.addr, v);\n}\n\nfunction setValueV3uiArray(gl, v) {\n  gl.uniform3uiv(this.addr, v);\n}\n\nfunction setValueV4uiArray(gl, v) {\n  gl.uniform4uiv(this.addr, v);\n}\n\n// Array of textures (2D / Cube)\n\nfunction setValueT1Array(gl, v, textures) {\n  const n = v.length;\n\n  const units = allocTexUnits(textures, n);\n\n  gl.uniform1iv(this.addr, units);\n\n  for (let i = 0; i !== n; ++i) {\n    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);\n  }\n}\n\nfunction setValueT6Array(gl, v, textures) {\n  const n = v.length;\n\n  const units = allocTexUnits(textures, n);\n\n  gl.uniform1iv(this.addr, units);\n\n  for (let i = 0; i !== n; ++i) {\n    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);\n  }\n}\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter(type) {\n  switch (type) {\n    case 0x1406:\n      return setValueV1fArray; // FLOAT\n    case 0x8b50:\n      return setValueV2fArray; // _VEC2\n    case 0x8b51:\n      return setValueV3fArray; // _VEC3\n    case 0x8b52:\n      return setValueV4fArray; // _VEC4\n\n    case 0x8b5a:\n      return setValueM2Array; // _MAT2\n    case 0x8b5b:\n      return setValueM3Array; // _MAT3\n    case 0x8b5c:\n      return setValueM4Array; // _MAT4\n\n    case 0x1404:\n    case 0x8b56:\n      return setValueV1iArray; // INT, BOOL\n    case 0x8b53:\n    case 0x8b57:\n      return setValueV2iArray; // _VEC2\n    case 0x8b54:\n    case 0x8b58:\n      return setValueV3iArray; // _VEC3\n    case 0x8b55:\n    case 0x8b59:\n      return setValueV4iArray; // _VEC4\n\n    case 0x1405:\n      return setValueV1uiArray; // UINT\n    case 0x8dc6:\n      return setValueV2uiArray; // _VEC2\n    case 0x8dc7:\n      return setValueV3uiArray; // _VEC3\n    case 0x8dc8:\n      return setValueV4uiArray; // _VEC4\n\n    case 0x8b5e: // SAMPLER_2D\n    case 0x8d66: // SAMPLER_EXTERNAL_OES\n    case 0x8dca: // INT_SAMPLER_2D\n    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n    case 0x8b62: // SAMPLER_2D_SHADOW\n      return setValueT1Array;\n\n    case 0x8b60: // SAMPLER_CUBE\n    case 0x8dcc: // INT_SAMPLER_CUBE\n    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n    case 0x8dc5: // SAMPLER_CUBE_SHADOW\n      return setValueT6Array;\n  }\n}\n\n// --- Uniform Classes ---\n\nfunction SingleUniform(id, activeInfo, addr) {\n  this.id = id;\n  this.addr = addr;\n  this.cache = [];\n  this.setValue = getSingularSetter(activeInfo.type);\n\n  // this.path = activeInfo.name; // DEBUG\n}\n\nfunction PureArrayUniform(id, activeInfo, addr) {\n  this.id = id;\n  this.addr = addr;\n  this.cache = [];\n  this.size = activeInfo.size;\n  this.setValue = getPureArraySetter(activeInfo.type);\n\n  // this.path = activeInfo.name; // DEBUG\n}\n\nPureArrayUniform.prototype.updateCache = function (data) {\n  const cache = this.cache;\n\n  if (data instanceof Float32Array && cache.length !== data.length) {\n    this.cache = new Float32Array(data.length);\n  }\n\n  copyArray(cache, data);\n};\n\nfunction StructuredUniform(id) {\n  this.id = id;\n\n  this.seq = [];\n  this.map = {};\n}\n\nStructuredUniform.prototype.setValue = function (gl, value, textures) {\n  const seq = this.seq;\n\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i];\n    u.setValue(gl, value[u.id], textures);\n  }\n};\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform(container, uniformObject) {\n  container.seq.push(uniformObject);\n  container.map[uniformObject.id] = uniformObject;\n}\n\nfunction parseUniform(activeInfo, addr, container) {\n  const path = activeInfo.name,\n    pathLength = path.length;\n\n  // reset RegExp object, because of the early exit of a previous run\n  RePathPart.lastIndex = 0;\n\n  while (true) {\n    const match = RePathPart.exec(path),\n      matchEnd = RePathPart.lastIndex;\n\n    let id = match[1];\n    const idIsIndex = match[2] === ']',\n      subscript = match[3];\n\n    if (idIsIndex) id = id | 0; // convert to integer\n\n    if (\n      subscript === undefined ||\n      (subscript === '[' && matchEnd + 2 === pathLength)\n    ) {\n      // bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n      addUniform(\n        container,\n        subscript === undefined\n          ? new SingleUniform(id, activeInfo, addr)\n          : new PureArrayUniform(id, activeInfo, addr),\n      );\n\n      break;\n    } else {\n      // step into inner node / create it in case it doesn't exist\n\n      const map = container.map;\n      let next = map[id];\n\n      if (next === undefined) {\n        next = new StructuredUniform(id);\n        addUniform(container, next);\n      }\n\n      container = next;\n    }\n  }\n}\n\n// Root Container\n\nfunction WebGLUniforms(gl, program) {\n  this.seq = [];\n  this.map = {};\n\n  const n = gl.getProgramParameter(program, 35718);\n\n  for (let i = 0; i < n; ++i) {\n    const info = gl.getActiveUniform(program, i),\n      addr = gl.getUniformLocation(program, info.name);\n\n    parseUniform(info, addr, this);\n  }\n}\n\nWebGLUniforms.prototype.setValue = function (gl, name, value, textures) {\n  const u = this.map[name];\n\n  if (u !== undefined) u.setValue(gl, value, textures);\n};\n\nWebGLUniforms.prototype.setOptional = function (gl, object, name) {\n  const v = object[name];\n\n  if (v !== undefined) this.setValue(gl, name, v);\n};\n\n// Static interface\n\nWebGLUniforms.upload = function (gl, seq, values, textures) {\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i],\n      v = values[u.id];\n\n    if (v.needsUpdate !== false) {\n      // note: always updating when .needsUpdate is undefined\n      u.setValue(gl, v.value, textures);\n    }\n  }\n};\n\nWebGLUniforms.seqWithValue = function (seq, values) {\n  const r = [];\n\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i];\n    if (u.id in values) r.push(u);\n  }\n\n  return r;\n};\n\nfunction WebGLShader(gl, type, string) {\n  const shader = gl.createShader(type);\n\n  gl.shaderSource(shader, string);\n  gl.compileShader(shader);\n\n  return shader;\n}\n\nlet programIdCount = 0;\n\nfunction addLineNumbers(string) {\n  const lines = string.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = i + 1 + ': ' + lines[i];\n  }\n\n  return lines.join('\\n');\n}\n\nfunction getEncodingComponents(encoding) {\n  switch (encoding) {\n    case LinearEncoding:\n      return ['Linear', '( value )'];\n    case sRGBEncoding:\n      return ['sRGB', '( value )'];\n    case RGBEEncoding:\n      return ['RGBE', '( value )'];\n    case RGBM7Encoding:\n      return ['RGBM', '( value, 7.0 )'];\n    case RGBM16Encoding:\n      return ['RGBM', '( value, 16.0 )'];\n    case RGBDEncoding:\n      return ['RGBD', '( value, 256.0 )'];\n    case GammaEncoding:\n      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n    case LogLuvEncoding:\n      return ['LogLuv', '( value )'];\n    default:\n      console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);\n      return ['Linear', '( value )'];\n  }\n}\n\nfunction getShaderErrors(gl, shader, type) {\n  const status = gl.getShaderParameter(shader, 35713);\n  const errors = gl.getShaderInfoLog(shader).trim();\n\n  if (status && errors === '') return '';\n\n  // --enable-privileged-webgl-extension\n  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n  return (\n    type.toUpperCase() +\n    '\\n\\n' +\n    errors +\n    '\\n\\n' +\n    addLineNumbers(gl.getShaderSource(shader))\n  );\n}\n\nfunction getTexelDecodingFunction(functionName, encoding) {\n  const components = getEncodingComponents(encoding);\n  return (\n    'vec4 ' +\n    functionName +\n    '( vec4 value ) { return ' +\n    components[0] +\n    'ToLinear' +\n    components[1] +\n    '; }'\n  );\n}\n\nfunction getTexelEncodingFunction(functionName, encoding) {\n  const components = getEncodingComponents(encoding);\n  return (\n    'vec4 ' +\n    functionName +\n    '( vec4 value ) { return LinearTo' +\n    components[0] +\n    components[1] +\n    '; }'\n  );\n}\n\nfunction getToneMappingFunction(functionName, toneMapping) {\n  let toneMappingName;\n\n  switch (toneMapping) {\n    case LinearToneMapping:\n      toneMappingName = 'Linear';\n      break;\n\n    case ReinhardToneMapping:\n      toneMappingName = 'Reinhard';\n      break;\n\n    case CineonToneMapping:\n      toneMappingName = 'OptimizedCineon';\n      break;\n\n    case ACESFilmicToneMapping:\n      toneMappingName = 'ACESFilmic';\n      break;\n\n    case CustomToneMapping:\n      toneMappingName = 'Custom';\n      break;\n\n    default:\n      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);\n      toneMappingName = 'Linear';\n  }\n\n  return (\n    'vec3 ' +\n    functionName +\n    '( vec3 color ) { return ' +\n    toneMappingName +\n    'ToneMapping( color ); }'\n  );\n}\n\nfunction generateExtensions(parameters) {\n  const chunks = [\n    parameters.extensionDerivatives ||\n    parameters.envMapCubeUV ||\n    parameters.bumpMap ||\n    parameters.tangentSpaceNormalMap ||\n    parameters.clearcoatNormalMap ||\n    parameters.flatShading ||\n    parameters.shaderID === 'physical'\n      ? '#extension GL_OES_standard_derivatives : enable'\n      : '',\n    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) &&\n    parameters.rendererExtensionFragDepth\n      ? '#extension GL_EXT_frag_depth : enable'\n      : '',\n    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers\n      ? '#extension GL_EXT_draw_buffers : require'\n      : '',\n    (parameters.extensionShaderTextureLOD ||\n      parameters.envMap ||\n      parameters.transmission) &&\n    parameters.rendererExtensionShaderTextureLod\n      ? '#extension GL_EXT_shader_texture_lod : enable'\n      : '',\n  ];\n\n  return chunks.filter(filterEmptyLine).join('\\n');\n}\n\nfunction generateDefines(defines) {\n  const chunks = [];\n\n  for (const name in defines) {\n    const value = defines[name];\n\n    if (value === false) continue;\n\n    chunks.push('#define ' + name + ' ' + value);\n  }\n\n  return chunks.join('\\n');\n}\n\nfunction fetchAttributeLocations(gl, program) {\n  const attributes = {};\n\n  const n = gl.getProgramParameter(program, 35721);\n\n  for (let i = 0; i < n; i++) {\n    const info = gl.getActiveAttrib(program, i);\n    const name = info.name;\n\n    let locationSize = 1;\n    if (info.type === 35674) locationSize = 2;\n    if (info.type === 35675) locationSize = 3;\n    if (info.type === 35676) locationSize = 4;\n\n    // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n    attributes[name] = {\n      type: info.type,\n      location: gl.getAttribLocation(program, name),\n      locationSize: locationSize,\n    };\n  }\n\n  return attributes;\n}\n\nfunction filterEmptyLine(string) {\n  return string !== '';\n}\n\nfunction replaceLightNums(string, parameters) {\n  return string\n    .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)\n    .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)\n    .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)\n    .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)\n    .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)\n    .replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)\n    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)\n    .replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);\n}\n\nfunction replaceClippingPlaneNums(string, parameters) {\n  return string\n    .replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)\n    .replace(\n      /UNION_CLIPPING_PLANES/g,\n      parameters.numClippingPlanes - parameters.numClipIntersection,\n    );\n}\n\n// Resolve Includes\n\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes(string) {\n  return string.replace(includePattern, includeReplacer);\n}\n\nfunction includeReplacer(match, include) {\n  const string = ShaderChunk[include];\n\n  if (string === undefined) {\n    throw new Error('Can not resolve #include <' + include + '>');\n  }\n\n  return resolveIncludes(string);\n}\n\n// Unroll Loops\n\nconst deprecatedUnrollLoopPattern =\n  /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\nconst unrollLoopPattern =\n  /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops(string) {\n  return string\n    .replace(unrollLoopPattern, loopReplacer)\n    .replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);\n}\n\nfunction deprecatedLoopReplacer(match, start, end, snippet) {\n  console.warn(\n    'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.',\n  );\n  return loopReplacer(match, start, end, snippet);\n}\n\nfunction loopReplacer(match, start, end, snippet) {\n  let string = '';\n\n  for (let i = parseInt(start); i < parseInt(end); i++) {\n    string += snippet\n      .replace(/\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]')\n      .replace(/UNROLLED_LOOP_INDEX/g, i);\n  }\n\n  return string;\n}\n\n//\n\nfunction generatePrecision(parameters) {\n  let precisionstring =\n    'precision ' +\n    parameters.precision +\n    ' float;\\nprecision ' +\n    parameters.precision +\n    ' int;';\n\n  if (parameters.precision === 'highp') {\n    precisionstring += '\\n#define HIGH_PRECISION';\n  } else if (parameters.precision === 'mediump') {\n    precisionstring += '\\n#define MEDIUM_PRECISION';\n  } else if (parameters.precision === 'lowp') {\n    precisionstring += '\\n#define LOW_PRECISION';\n  }\n\n  return precisionstring;\n}\n\nfunction generateShadowMapTypeDefine(parameters) {\n  let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n  if (parameters.shadowMapType === PCFShadowMap) {\n    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n  } else if (parameters.shadowMapType === PCFSoftShadowMap) {\n    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n  } else if (parameters.shadowMapType === VSMShadowMap) {\n    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n  }\n\n  return shadowMapTypeDefine;\n}\n\nfunction generateEnvMapTypeDefine(parameters) {\n  let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeReflectionMapping:\n      case CubeRefractionMapping:\n        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n        break;\n\n      case CubeUVReflectionMapping:\n      case CubeUVRefractionMapping:\n        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n        break;\n    }\n  }\n\n  return envMapTypeDefine;\n}\n\nfunction generateEnvMapModeDefine(parameters) {\n  let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeRefractionMapping:\n      case CubeUVRefractionMapping:\n        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n        break;\n    }\n  }\n\n  return envMapModeDefine;\n}\n\nfunction generateEnvMapBlendingDefine(parameters) {\n  let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n  if (parameters.envMap) {\n    switch (parameters.combine) {\n      case MultiplyOperation:\n        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n        break;\n\n      case MixOperation:\n        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n        break;\n\n      case AddOperation:\n        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n        break;\n    }\n  }\n\n  return envMapBlendingDefine;\n}\n\nfunction WebGLProgram(renderer, cacheKey, parameters, bindingStates) {\n  // TODO Send this event to Three.js DevTools\n  // console.log( 'WebGLProgram', cacheKey );\n\n  const gl = renderer.getContext();\n\n  const defines = parameters.defines;\n\n  let vertexShader = parameters.vertexShader;\n  let fragmentShader = parameters.fragmentShader;\n\n  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);\n  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);\n  const envMapModeDefine = generateEnvMapModeDefine(parameters);\n  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);\n\n  const gammaFactorDefine =\n    renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;\n\n  const customExtensions = parameters.isWebGL2\n    ? ''\n    : generateExtensions(parameters);\n\n  const customDefines = generateDefines(defines);\n\n  const program = gl.createProgram();\n\n  let prefixVertex, prefixFragment;\n  let versionString = parameters.glslVersion\n    ? '#version ' + parameters.glslVersion + '\\n'\n    : '';\n\n  if (parameters.isRawShaderMaterial) {\n    prefixVertex = [customDefines].filter(filterEmptyLine).join('\\n');\n\n    if (prefixVertex.length > 0) {\n      prefixVertex += '\\n';\n    }\n\n    prefixFragment = [customExtensions, customDefines]\n      .filter(filterEmptyLine)\n      .join('\\n');\n\n    if (prefixFragment.length > 0) {\n      prefixFragment += '\\n';\n    }\n  } else {\n    prefixVertex = [\n      generatePrecision(parameters),\n\n      '#define SHADER_NAME ' + parameters.shaderName,\n\n      customDefines,\n\n      parameters.instancing ? '#define USE_INSTANCING' : '',\n      parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',\n\n      parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n      '#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n      '#define MAX_BONES ' + parameters.maxBones,\n      parameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n      parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n      parameters.map ? '#define USE_MAP' : '',\n      parameters.envMap ? '#define USE_ENVMAP' : '',\n      parameters.envMap ? '#define ' + envMapModeDefine : '',\n      parameters.lightMap ? '#define USE_LIGHTMAP' : '',\n      parameters.aoMap ? '#define USE_AOMAP' : '',\n      parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n      parameters.bumpMap ? '#define USE_BUMPMAP' : '',\n      parameters.normalMap ? '#define USE_NORMALMAP' : '',\n      parameters.normalMap && parameters.objectSpaceNormalMap\n        ? '#define OBJECTSPACE_NORMALMAP'\n        : '',\n      parameters.normalMap && parameters.tangentSpaceNormalMap\n        ? '#define TANGENTSPACE_NORMALMAP'\n        : '',\n\n      parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n      parameters.clearcoatRoughnessMap\n        ? '#define USE_CLEARCOAT_ROUGHNESSMAP'\n        : '',\n      parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n      parameters.displacementMap && parameters.supportsVertexTextures\n        ? '#define USE_DISPLACEMENTMAP'\n        : '',\n\n      parameters.specularMap ? '#define USE_SPECULARMAP' : '',\n      parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',\n      parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',\n\n      parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n      parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n      parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\n      parameters.transmission ? '#define USE_TRANSMISSION' : '',\n      parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n      parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n      parameters.vertexTangents ? '#define USE_TANGENT' : '',\n      parameters.vertexColors ? '#define USE_COLOR' : '',\n      parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n      parameters.vertexUvs ? '#define USE_UV' : '',\n      parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',\n\n      parameters.flatShading ? '#define FLAT_SHADED' : '',\n\n      parameters.skinning ? '#define USE_SKINNING' : '',\n      parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n      parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n      parameters.morphNormals && parameters.flatShading === false\n        ? '#define USE_MORPHNORMALS'\n        : '',\n      parameters.morphTargets && parameters.isWebGL2\n        ? '#define MORPHTARGETS_TEXTURE'\n        : '',\n      parameters.morphTargets && parameters.isWebGL2\n        ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount\n        : '',\n      parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n      parameters.flipSided ? '#define FLIP_SIDED' : '',\n\n      parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n      parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n      parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n      parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth\n        ? '#define USE_LOGDEPTHBUF_EXT'\n        : '',\n\n      'uniform mat4 modelMatrix;',\n      'uniform mat4 modelViewMatrix;',\n      'uniform mat4 projectionMatrix;',\n      'uniform mat4 viewMatrix;',\n      'uniform mat3 normalMatrix;',\n      'uniform vec3 cameraPosition;',\n      'uniform bool isOrthographic;',\n\n      '#ifdef USE_INSTANCING',\n\n      '\tattribute mat4 instanceMatrix;',\n\n      '#endif',\n\n      '#ifdef USE_INSTANCING_COLOR',\n\n      '\tattribute vec3 instanceColor;',\n\n      '#endif',\n\n      'attribute vec3 position;',\n      'attribute vec3 normal;',\n      'attribute vec2 uv;',\n\n      '#ifdef USE_TANGENT',\n\n      '\tattribute vec4 tangent;',\n\n      '#endif',\n\n      '#if defined( USE_COLOR_ALPHA )',\n\n      '\tattribute vec4 color;',\n\n      '#elif defined( USE_COLOR )',\n\n      '\tattribute vec3 color;',\n\n      '#endif',\n\n      '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',\n\n      '\tattribute vec3 morphTarget0;',\n      '\tattribute vec3 morphTarget1;',\n      '\tattribute vec3 morphTarget2;',\n      '\tattribute vec3 morphTarget3;',\n\n      '\t#ifdef USE_MORPHNORMALS',\n\n      '\t\tattribute vec3 morphNormal0;',\n      '\t\tattribute vec3 morphNormal1;',\n      '\t\tattribute vec3 morphNormal2;',\n      '\t\tattribute vec3 morphNormal3;',\n\n      '\t#else',\n\n      '\t\tattribute vec3 morphTarget4;',\n      '\t\tattribute vec3 morphTarget5;',\n      '\t\tattribute vec3 morphTarget6;',\n      '\t\tattribute vec3 morphTarget7;',\n\n      '\t#endif',\n\n      '#endif',\n\n      '#ifdef USE_SKINNING',\n\n      '\tattribute vec4 skinIndex;',\n      '\tattribute vec4 skinWeight;',\n\n      '#endif',\n\n      '\\n',\n    ]\n      .filter(filterEmptyLine)\n      .join('\\n');\n\n    prefixFragment = [\n      customExtensions,\n\n      generatePrecision(parameters),\n\n      '#define SHADER_NAME ' + parameters.shaderName,\n\n      customDefines,\n\n      '#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n      parameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n      parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n      parameters.map ? '#define USE_MAP' : '',\n      parameters.matcap ? '#define USE_MATCAP' : '',\n      parameters.envMap ? '#define USE_ENVMAP' : '',\n      parameters.envMap ? '#define ' + envMapTypeDefine : '',\n      parameters.envMap ? '#define ' + envMapModeDefine : '',\n      parameters.envMap ? '#define ' + envMapBlendingDefine : '',\n      parameters.lightMap ? '#define USE_LIGHTMAP' : '',\n      parameters.aoMap ? '#define USE_AOMAP' : '',\n      parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n      parameters.bumpMap ? '#define USE_BUMPMAP' : '',\n      parameters.normalMap ? '#define USE_NORMALMAP' : '',\n      parameters.normalMap && parameters.objectSpaceNormalMap\n        ? '#define OBJECTSPACE_NORMALMAP'\n        : '',\n      parameters.normalMap && parameters.tangentSpaceNormalMap\n        ? '#define TANGENTSPACE_NORMALMAP'\n        : '',\n\n      parameters.clearcoat ? '#define USE_CLEARCOAT' : '',\n      parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n      parameters.clearcoatRoughnessMap\n        ? '#define USE_CLEARCOAT_ROUGHNESSMAP'\n        : '',\n      parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n      parameters.specularMap ? '#define USE_SPECULARMAP' : '',\n      parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',\n      parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',\n      parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n      parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\n      parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n      parameters.alphaTest ? '#define USE_ALPHATEST' : '',\n\n      parameters.sheen ? '#define USE_SHEEN' : '',\n\n      parameters.transmission ? '#define USE_TRANSMISSION' : '',\n      parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n      parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n      parameters.vertexTangents ? '#define USE_TANGENT' : '',\n      parameters.vertexColors || parameters.instancingColor\n        ? '#define USE_COLOR'\n        : '',\n      parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n      parameters.vertexUvs ? '#define USE_UV' : '',\n      parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',\n\n      parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n      parameters.flatShading ? '#define FLAT_SHADED' : '',\n\n      parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n      parameters.flipSided ? '#define FLIP_SIDED' : '',\n\n      parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n      parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n      parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n      parameters.physicallyCorrectLights\n        ? '#define PHYSICALLY_CORRECT_LIGHTS'\n        : '',\n\n      parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth\n        ? '#define USE_LOGDEPTHBUF_EXT'\n        : '',\n\n      (parameters.extensionShaderTextureLOD || parameters.envMap) &&\n      parameters.rendererExtensionShaderTextureLod\n        ? '#define TEXTURE_LOD_EXT'\n        : '',\n\n      'uniform mat4 viewMatrix;',\n      'uniform vec3 cameraPosition;',\n      'uniform bool isOrthographic;',\n\n      parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',\n      parameters.toneMapping !== NoToneMapping\n        ? ShaderChunk['tonemapping_pars_fragment']\n        : '', // this code is required here because it is used by the toneMapping() function defined below\n      parameters.toneMapping !== NoToneMapping\n        ? getToneMappingFunction('toneMapping', parameters.toneMapping)\n        : '',\n\n      parameters.dithering ? '#define DITHERING' : '',\n      parameters.format === RGBFormat ? '#define OPAQUE' : '',\n\n      ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below\n      parameters.map\n        ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding)\n        : '',\n      parameters.matcap\n        ? getTexelDecodingFunction(\n            'matcapTexelToLinear',\n            parameters.matcapEncoding,\n          )\n        : '',\n      parameters.envMap\n        ? getTexelDecodingFunction(\n            'envMapTexelToLinear',\n            parameters.envMapEncoding,\n          )\n        : '',\n      parameters.emissiveMap\n        ? getTexelDecodingFunction(\n            'emissiveMapTexelToLinear',\n            parameters.emissiveMapEncoding,\n          )\n        : '',\n      parameters.specularTintMap\n        ? getTexelDecodingFunction(\n            'specularTintMapTexelToLinear',\n            parameters.specularTintMapEncoding,\n          )\n        : '',\n      parameters.lightMap\n        ? getTexelDecodingFunction(\n            'lightMapTexelToLinear',\n            parameters.lightMapEncoding,\n          )\n        : '',\n      getTexelEncodingFunction(\n        'linearToOutputTexel',\n        parameters.outputEncoding,\n      ),\n\n      parameters.depthPacking\n        ? '#define DEPTH_PACKING ' + parameters.depthPacking\n        : '',\n\n      '\\n',\n    ]\n      .filter(filterEmptyLine)\n      .join('\\n');\n  }\n\n  vertexShader = resolveIncludes(vertexShader);\n  vertexShader = replaceLightNums(vertexShader, parameters);\n  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);\n\n  fragmentShader = resolveIncludes(fragmentShader);\n  fragmentShader = replaceLightNums(fragmentShader, parameters);\n  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\n\n  vertexShader = unrollLoops(vertexShader);\n  fragmentShader = unrollLoops(fragmentShader);\n\n  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {\n    // GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\n    versionString = '#version 300 es\\n';\n\n    prefixVertex =\n      [\n        'precision mediump sampler2DArray;',\n        '#define attribute in',\n        '#define varying out',\n        '#define texture2D texture',\n      ].join('\\n') +\n      '\\n' +\n      prefixVertex;\n\n    prefixFragment =\n      [\n        '#define varying in',\n        parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;',\n        parameters.glslVersion === GLSL3\n          ? ''\n          : '#define gl_FragColor pc_fragColor',\n        '#define gl_FragDepthEXT gl_FragDepth',\n        '#define texture2D texture',\n        '#define textureCube texture',\n        '#define texture2DProj textureProj',\n        '#define texture2DLodEXT textureLod',\n        '#define texture2DProjLodEXT textureProjLod',\n        '#define textureCubeLodEXT textureLod',\n        '#define texture2DGradEXT textureGrad',\n        '#define texture2DProjGradEXT textureProjGrad',\n        '#define textureCubeGradEXT textureGrad',\n      ].join('\\n') +\n      '\\n' +\n      prefixFragment;\n  }\n\n  const vertexGlsl = versionString + prefixVertex + vertexShader;\n  const fragmentGlsl = versionString + prefixFragment + fragmentShader;\n\n  // console.log( '*VERTEX*', vertexGlsl );\n  // console.log( '*FRAGMENT*', fragmentGlsl );\n\n  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);\n  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);\n\n  gl.attachShader(program, glVertexShader);\n  gl.attachShader(program, glFragmentShader);\n\n  // Force a particular attribute to index 0.\n\n  if (parameters.index0AttributeName !== undefined) {\n    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n  } else if (parameters.morphTargets === true) {\n    // programs with morphTargets displace position out of attribute 0\n    gl.bindAttribLocation(program, 0, 'position');\n  }\n\n  gl.linkProgram(program);\n\n  // check for link errors\n  if (renderer.debug.checkShaderErrors) {\n    const programLog = gl.getProgramInfoLog(program).trim();\n    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n\n    let runnable = true;\n    let haveDiagnostics = true;\n\n    if (gl.getProgramParameter(program, 35714) === false) {\n      runnable = false;\n\n      const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');\n      const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');\n\n      console.error(\n        'THREE.WebGLProgram: Shader Error ' +\n          gl.getError() +\n          ' - ' +\n          'VALIDATE_STATUS ' +\n          gl.getProgramParameter(program, 35715) +\n          '\\n\\n' +\n          'Program Info Log: ' +\n          programLog +\n          '\\n' +\n          vertexErrors +\n          '\\n' +\n          fragmentErrors,\n      );\n    } else if (programLog !== '') {\n      console.warn('THREE.WebGLProgram: Program Info Log:', programLog);\n    } else if (vertexLog === '' || fragmentLog === '') {\n      haveDiagnostics = false;\n    }\n\n    if (haveDiagnostics) {\n      this.diagnostics = {\n        runnable: runnable,\n\n        programLog: programLog,\n\n        vertexShader: {\n          log: vertexLog,\n          prefix: prefixVertex,\n        },\n\n        fragmentShader: {\n          log: fragmentLog,\n          prefix: prefixFragment,\n        },\n      };\n    }\n  }\n\n  // Clean up\n\n  // Crashes in iOS9 and iOS10. #18402\n  // gl.detachShader( program, glVertexShader );\n  // gl.detachShader( program, glFragmentShader );\n\n  gl.deleteShader(glVertexShader);\n  gl.deleteShader(glFragmentShader);\n\n  // set up caching for uniform locations\n\n  let cachedUniforms;\n\n  this.getUniforms = function () {\n    if (cachedUniforms === undefined) {\n      cachedUniforms = new WebGLUniforms(gl, program);\n    }\n\n    return cachedUniforms;\n  };\n\n  // set up caching for attribute locations\n\n  let cachedAttributes;\n\n  this.getAttributes = function () {\n    if (cachedAttributes === undefined) {\n      cachedAttributes = fetchAttributeLocations(gl, program);\n    }\n\n    return cachedAttributes;\n  };\n\n  // free resource\n\n  this.destroy = function () {\n    bindingStates.releaseStatesOfProgram(this);\n\n    gl.deleteProgram(program);\n    this.program = undefined;\n  };\n\n  //\n\n  this.name = parameters.shaderName;\n  this.id = programIdCount++;\n  this.cacheKey = cacheKey;\n  this.usedTimes = 1;\n  this.program = program;\n  this.vertexShader = glVertexShader;\n  this.fragmentShader = glFragmentShader;\n\n  return this;\n}\n\nfunction WebGLPrograms(\n  renderer,\n  cubemaps,\n  cubeuvmaps,\n  extensions,\n  capabilities,\n  bindingStates,\n  clipping,\n) {\n  const programs = [];\n\n  const isWebGL2 = capabilities.isWebGL2;\n  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n  const floatVertexTextures = capabilities.floatVertexTextures;\n  const maxVertexUniforms = capabilities.maxVertexUniforms;\n  const vertexTextures = capabilities.vertexTextures;\n\n  let precision = capabilities.precision;\n\n  const shaderIDs = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'toon',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite',\n  };\n\n  const parameterNames = [\n    'precision',\n    'isWebGL2',\n    'supportsVertexTextures',\n    'outputEncoding',\n    'instancing',\n    'instancingColor',\n    'map',\n    'mapEncoding',\n    'matcap',\n    'matcapEncoding',\n    'envMap',\n    'envMapMode',\n    'envMapEncoding',\n    'envMapCubeUV',\n    'lightMap',\n    'lightMapEncoding',\n    'aoMap',\n    'emissiveMap',\n    'emissiveMapEncoding',\n    'bumpMap',\n    'normalMap',\n    'objectSpaceNormalMap',\n    'tangentSpaceNormalMap',\n    'clearcoat',\n    'clearcoatMap',\n    'clearcoatRoughnessMap',\n    'clearcoatNormalMap',\n    'displacementMap',\n    'specularMap',\n    'specularIntensityMap',\n    'specularTintMap',\n    'specularTintMapEncoding',\n    'roughnessMap',\n    'metalnessMap',\n    'gradientMap',\n    'alphaMap',\n    'alphaTest',\n    'combine',\n    'vertexColors',\n    'vertexAlphas',\n    'vertexTangents',\n    'vertexUvs',\n    'uvsVertexOnly',\n    'fog',\n    'useFog',\n    'fogExp2',\n    'flatShading',\n    'sizeAttenuation',\n    'logarithmicDepthBuffer',\n    'skinning',\n    'maxBones',\n    'useVertexTexture',\n    'morphTargets',\n    'morphNormals',\n    'morphTargetsCount',\n    'premultipliedAlpha',\n    'numDirLights',\n    'numPointLights',\n    'numSpotLights',\n    'numHemiLights',\n    'numRectAreaLights',\n    'numDirLightShadows',\n    'numPointLightShadows',\n    'numSpotLightShadows',\n    'shadowMapEnabled',\n    'shadowMapType',\n    'toneMapping',\n    'physicallyCorrectLights',\n    'doubleSided',\n    'flipSided',\n    'numClippingPlanes',\n    'numClipIntersection',\n    'depthPacking',\n    'dithering',\n    'format',\n    'sheen',\n    'transmission',\n    'transmissionMap',\n    'thicknessMap',\n  ];\n\n  function getMaxBones(object) {\n    const skeleton = object.skeleton;\n    const bones = skeleton.bones;\n\n    if (floatVertexTextures) {\n      return 1024;\n    } else {\n      // default for when object is not specified\n      // ( for example when prebuilding shader to be used with multiple objects )\n      //\n      //  - leave some extra space for other uniforms\n      //  - limit here is ANGLE's 254 max uniform vectors\n      //    (up to 54 should be safe)\n\n      const nVertexUniforms = maxVertexUniforms;\n      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n\n      const maxBones = Math.min(nVertexMatrices, bones.length);\n\n      if (maxBones < bones.length) {\n        console.warn(\n          'THREE.WebGLRenderer: Skeleton has ' +\n            bones.length +\n            ' bones. This GPU supports ' +\n            maxBones +\n            '.',\n        );\n        return 0;\n      }\n\n      return maxBones;\n    }\n  }\n\n  function getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      console.warn(\n        \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\",\n      );\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    if (\n      isWebGL2 &&\n      map &&\n      map.isTexture &&\n      map.format === RGBAFormat &&\n      map.type === UnsignedByteType &&\n      map.encoding === sRGBEncoding\n    ) {\n      encoding = LinearEncoding; // disable inline decode for sRGB textures in WebGL 2\n    }\n\n    return encoding;\n  }\n\n  function getParameters(material, lights, shadows, scene, object) {\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial\n      ? scene.environment\n      : null;\n\n    const envMap = (\n      material.isMeshStandardMaterial ? cubeuvmaps : cubemaps\n    ).get(material.envMap || environment);\n\n    const shaderID = shaderIDs[material.type];\n\n    // heuristics to create shader parameters according to lights in the scene\n    // (not to blow over maxLights budget)\n\n    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;\n\n    if (material.precision !== null) {\n      precision = capabilities.getMaxPrecision(material.precision);\n\n      if (precision !== material.precision) {\n        console.warn(\n          'THREE.WebGLProgram.getParameters:',\n          material.precision,\n          'not supported, using',\n          precision,\n          'instead.',\n        );\n      }\n    }\n\n    let vertexShader, fragmentShader;\n\n    if (shaderID) {\n      const shader = ShaderLib[shaderID];\n\n      vertexShader = shader.vertexShader;\n      fragmentShader = shader.fragmentShader;\n    } else {\n      vertexShader = material.vertexShader;\n      fragmentShader = material.fragmentShader;\n    }\n\n    const currentRenderTarget = renderer.getRenderTarget();\n\n    const useAlphaTest = material.alphaTest > 0;\n    const useClearcoat = material.clearcoat > 0;\n\n    const parameters = {\n      isWebGL2: isWebGL2,\n\n      shaderID: shaderID,\n      shaderName: material.type,\n\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      defines: material.defines,\n\n      isRawShaderMaterial: material.isRawShaderMaterial === true,\n      glslVersion: material.glslVersion,\n\n      precision: precision,\n\n      instancing: object.isInstancedMesh === true,\n      instancingColor:\n        object.isInstancedMesh === true && object.instanceColor !== null,\n\n      supportsVertexTextures: vertexTextures,\n      outputEncoding:\n        currentRenderTarget !== null\n          ? getTextureEncodingFromMap(currentRenderTarget.texture)\n          : renderer.outputEncoding,\n      map: !!material.map,\n      mapEncoding: getTextureEncodingFromMap(material.map),\n      matcap: !!material.matcap,\n      matcapEncoding: getTextureEncodingFromMap(material.matcap),\n      envMap: !!envMap,\n      envMapMode: envMap && envMap.mapping,\n      envMapEncoding: getTextureEncodingFromMap(envMap),\n      envMapCubeUV:\n        !!envMap &&\n        (envMap.mapping === CubeUVReflectionMapping ||\n          envMap.mapping === CubeUVRefractionMapping),\n      lightMap: !!material.lightMap,\n      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),\n      aoMap: !!material.aoMap,\n      emissiveMap: !!material.emissiveMap,\n      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),\n      bumpMap: !!material.bumpMap,\n      normalMap: !!material.normalMap,\n      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n\n      clearcoat: useClearcoat,\n      clearcoatMap: useClearcoat && !!material.clearcoatMap,\n      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,\n      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,\n\n      displacementMap: !!material.displacementMap,\n      roughnessMap: !!material.roughnessMap,\n      metalnessMap: !!material.metalnessMap,\n      specularMap: !!material.specularMap,\n      specularIntensityMap: !!material.specularIntensityMap,\n      specularTintMap: !!material.specularTintMap,\n      specularTintMapEncoding: getTextureEncodingFromMap(\n        material.specularTintMap,\n      ),\n\n      alphaMap: !!material.alphaMap,\n      alphaTest: useAlphaTest,\n\n      gradientMap: !!material.gradientMap,\n\n      sheen: material.sheen > 0,\n\n      transmission: material.transmission > 0,\n      transmissionMap: !!material.transmissionMap,\n      thicknessMap: !!material.thicknessMap,\n\n      combine: material.combine,\n\n      vertexTangents:\n        !!material.normalMap &&\n        !!object.geometry &&\n        !!object.geometry.attributes.tangent,\n      vertexColors: material.vertexColors,\n      vertexAlphas:\n        material.vertexColors === true &&\n        !!object.geometry &&\n        !!object.geometry.attributes.color &&\n        object.geometry.attributes.color.itemSize === 4,\n      vertexUvs:\n        !!material.map ||\n        !!material.bumpMap ||\n        !!material.normalMap ||\n        !!material.specularMap ||\n        !!material.alphaMap ||\n        !!material.emissiveMap ||\n        !!material.roughnessMap ||\n        !!material.metalnessMap ||\n        !!material.clearcoatMap ||\n        !!material.clearcoatRoughnessMap ||\n        !!material.clearcoatNormalMap ||\n        !!material.displacementMap ||\n        !!material.transmissionMap ||\n        !!material.thicknessMap ||\n        !!material.specularIntensityMap ||\n        !!material.specularTintMap,\n      uvsVertexOnly:\n        !(\n          !!material.map ||\n          !!material.bumpMap ||\n          !!material.normalMap ||\n          !!material.specularMap ||\n          !!material.alphaMap ||\n          !!material.emissiveMap ||\n          !!material.roughnessMap ||\n          !!material.metalnessMap ||\n          !!material.clearcoatNormalMap ||\n          material.transmission > 0 ||\n          !!material.transmissionMap ||\n          !!material.thicknessMap ||\n          !!material.specularIntensityMap ||\n          !!material.specularTintMap\n        ) && !!material.displacementMap,\n\n      fog: !!fog,\n      useFog: material.fog,\n      fogExp2: fog && fog.isFogExp2,\n\n      flatShading: !!material.flatShading,\n\n      sizeAttenuation: material.sizeAttenuation,\n      logarithmicDepthBuffer: logarithmicDepthBuffer,\n\n      skinning: object.isSkinnedMesh === true && maxBones > 0,\n      maxBones: maxBones,\n      useVertexTexture: floatVertexTextures,\n\n      morphTargets:\n        !!object.geometry && !!object.geometry.morphAttributes.position,\n      morphNormals:\n        !!object.geometry && !!object.geometry.morphAttributes.normal,\n      morphTargetsCount:\n        !!object.geometry && !!object.geometry.morphAttributes.position\n          ? object.geometry.morphAttributes.position.length\n          : 0,\n\n      numDirLights: lights.directional.length,\n      numPointLights: lights.point.length,\n      numSpotLights: lights.spot.length,\n      numRectAreaLights: lights.rectArea.length,\n      numHemiLights: lights.hemi.length,\n\n      numDirLightShadows: lights.directionalShadowMap.length,\n      numPointLightShadows: lights.pointShadowMap.length,\n      numSpotLightShadows: lights.spotShadowMap.length,\n\n      numClippingPlanes: clipping.numPlanes,\n      numClipIntersection: clipping.numIntersection,\n\n      format: material.format,\n      dithering: material.dithering,\n\n      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n      shadowMapType: renderer.shadowMap.type,\n\n      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n      physicallyCorrectLights: renderer.physicallyCorrectLights,\n\n      premultipliedAlpha: material.premultipliedAlpha,\n\n      doubleSided: material.side === DoubleSide,\n      flipSided: material.side === BackSide,\n\n      depthPacking:\n        material.depthPacking !== undefined ? material.depthPacking : false,\n\n      index0AttributeName: material.index0AttributeName,\n\n      extensionDerivatives:\n        material.extensions && material.extensions.derivatives,\n      extensionFragDepth: material.extensions && material.extensions.fragDepth,\n      extensionDrawBuffers:\n        material.extensions && material.extensions.drawBuffers,\n      extensionShaderTextureLOD:\n        material.extensions && material.extensions.shaderTextureLOD,\n\n      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),\n      rendererExtensionDrawBuffers:\n        isWebGL2 || extensions.has('WEBGL_draw_buffers'),\n      rendererExtensionShaderTextureLod:\n        isWebGL2 || extensions.has('EXT_shader_texture_lod'),\n\n      customProgramCacheKey: material.customProgramCacheKey(),\n    };\n\n    return parameters;\n  }\n\n  function getProgramCacheKey(parameters) {\n    const array = [];\n\n    if (parameters.shaderID) {\n      array.push(parameters.shaderID);\n    } else {\n      array.push(parameters.fragmentShader);\n      array.push(parameters.vertexShader);\n    }\n\n    if (parameters.defines !== undefined) {\n      for (const name in parameters.defines) {\n        array.push(name);\n        array.push(parameters.defines[name]);\n      }\n    }\n\n    if (parameters.isRawShaderMaterial === false) {\n      for (let i = 0; i < parameterNames.length; i++) {\n        array.push(parameters[parameterNames[i]]);\n      }\n\n      array.push(renderer.outputEncoding);\n      array.push(renderer.gammaFactor);\n    }\n\n    array.push(parameters.customProgramCacheKey);\n\n    return array.join();\n  }\n\n  function getUniforms(material) {\n    const shaderID = shaderIDs[material.type];\n    let uniforms;\n\n    if (shaderID) {\n      const shader = ShaderLib[shaderID];\n      uniforms = UniformsUtils.clone(shader.uniforms);\n    } else {\n      uniforms = material.uniforms;\n    }\n\n    return uniforms;\n  }\n\n  function acquireProgram(parameters, cacheKey) {\n    let program;\n\n    // Check if code has been already compiled\n    for (let p = 0, pl = programs.length; p < pl; p++) {\n      const preexistingProgram = programs[p];\n\n      if (preexistingProgram.cacheKey === cacheKey) {\n        program = preexistingProgram;\n        ++program.usedTimes;\n\n        break;\n      }\n    }\n\n    if (program === undefined) {\n      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n      programs.push(program);\n    }\n\n    return program;\n  }\n\n  function releaseProgram(program) {\n    if (--program.usedTimes === 0) {\n      // Remove from unordered set\n      const i = programs.indexOf(program);\n      programs[i] = programs[programs.length - 1];\n      programs.pop();\n\n      // Free WebGL resources\n      program.destroy();\n    }\n  }\n\n  return {\n    getParameters: getParameters,\n    getProgramCacheKey: getProgramCacheKey,\n    getUniforms: getUniforms,\n    acquireProgram: acquireProgram,\n    releaseProgram: releaseProgram,\n    // Exposed for resource monitoring & error feedback via renderer.info:\n    programs: programs,\n  };\n}\n\nfunction WebGLProperties() {\n  let properties = new WeakMap();\n\n  function get(object) {\n    let map = properties.get(object);\n\n    if (map === undefined) {\n      map = {};\n      properties.set(object, map);\n    }\n\n    return map;\n  }\n\n  function remove(object) {\n    properties.delete(object);\n  }\n\n  function update(object, key, value) {\n    properties.get(object)[key] = value;\n  }\n\n  function dispose() {\n    properties = new WeakMap();\n  }\n\n  return {\n    get: get,\n    remove: remove,\n    update: update,\n    dispose: dispose,\n  };\n}\n\nfunction painterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.program !== b.program) {\n    return a.program.id - b.program.id;\n  } else if (a.material.id !== b.material.id) {\n    return a.material.id - b.material.id;\n  } else if (a.z !== b.z) {\n    return a.z - b.z;\n  } else {\n    return a.id - b.id;\n  }\n}\n\nfunction reversePainterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return a.id - b.id;\n  }\n}\n\nfunction WebGLRenderList(properties) {\n  const renderItems = [];\n  let renderItemsIndex = 0;\n\n  const opaque = [];\n  const transmissive = [];\n  const transparent = [];\n\n  const defaultProgram = { id: -1 };\n\n  function init() {\n    renderItemsIndex = 0;\n\n    opaque.length = 0;\n    transmissive.length = 0;\n    transparent.length = 0;\n  }\n\n  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {\n    let renderItem = renderItems[renderItemsIndex];\n    const materialProperties = properties.get(material);\n\n    if (renderItem === undefined) {\n      renderItem = {\n        id: object.id,\n        object: object,\n        geometry: geometry,\n        material: material,\n        program: materialProperties.program || defaultProgram,\n        groupOrder: groupOrder,\n        renderOrder: object.renderOrder,\n        z: z,\n        group: group,\n      };\n\n      renderItems[renderItemsIndex] = renderItem;\n    } else {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.program = materialProperties.program || defaultProgram;\n      renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = object.renderOrder;\n      renderItem.z = z;\n      renderItem.group = group;\n    }\n\n    renderItemsIndex++;\n\n    return renderItem;\n  }\n\n  function push(object, geometry, material, groupOrder, z, group) {\n    const renderItem = getNextRenderItem(\n      object,\n      geometry,\n      material,\n      groupOrder,\n      z,\n      group,\n    );\n\n    if (material.transmission > 0.0) {\n      transmissive.push(renderItem);\n    } else if (material.transparent === true) {\n      transparent.push(renderItem);\n    } else {\n      opaque.push(renderItem);\n    }\n  }\n\n  function unshift(object, geometry, material, groupOrder, z, group) {\n    const renderItem = getNextRenderItem(\n      object,\n      geometry,\n      material,\n      groupOrder,\n      z,\n      group,\n    );\n\n    if (material.transmission > 0.0) {\n      transmissive.unshift(renderItem);\n    } else if (material.transparent === true) {\n      transparent.unshift(renderItem);\n    } else {\n      opaque.unshift(renderItem);\n    }\n  }\n\n  function sort(customOpaqueSort, customTransparentSort) {\n    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);\n    if (transmissive.length > 1)\n      transmissive.sort(customTransparentSort || reversePainterSortStable);\n    if (transparent.length > 1)\n      transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n\n  function finish() {\n    // Clear references from inactive renderItems in the list\n\n    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {\n      const renderItem = renderItems[i];\n\n      if (renderItem.id === null) break;\n\n      renderItem.id = null;\n      renderItem.object = null;\n      renderItem.geometry = null;\n      renderItem.material = null;\n      renderItem.program = null;\n      renderItem.group = null;\n    }\n  }\n\n  return {\n    opaque: opaque,\n    transmissive: transmissive,\n    transparent: transparent,\n\n    init: init,\n    push: push,\n    unshift: unshift,\n    finish: finish,\n\n    sort: sort,\n  };\n}\n\nfunction WebGLRenderLists(properties) {\n  let lists = new WeakMap();\n\n  function get(scene, renderCallDepth) {\n    let list;\n\n    if (lists.has(scene) === false) {\n      list = new WebGLRenderList(properties);\n      lists.set(scene, [list]);\n    } else {\n      if (renderCallDepth >= lists.get(scene).length) {\n        list = new WebGLRenderList(properties);\n        lists.get(scene).push(list);\n      } else {\n        list = lists.get(scene)[renderCallDepth];\n      }\n    }\n\n    return list;\n  }\n\n  function dispose() {\n    lists = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose,\n  };\n}\n\nfunction UniformsCache() {\n  const lights = {};\n\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      let uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            direction: new Vector3(),\n            color: new Color(),\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0,\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0,\n          };\n          break;\n\n        case 'HemisphereLight':\n          uniforms = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color(),\n          };\n          break;\n\n        case 'RectAreaLight':\n          uniforms = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3(),\n          };\n          break;\n      }\n\n      lights[light.id] = uniforms;\n\n      return uniforms;\n    },\n  };\n}\n\nfunction ShadowUniformsCache() {\n  const lights = {};\n\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      let uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1000,\n          };\n          break;\n\n        // TODO (abelnation): set RectAreaLight shadow uniforms\n      }\n\n      lights[light.id] = uniforms;\n\n      return uniforms;\n    },\n  };\n}\n\nlet nextVersion = 0;\n\nfunction shadowCastingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n}\n\nfunction WebGLLights(extensions, capabilities) {\n  const cache = new UniformsCache();\n\n  const shadowCache = ShadowUniformsCache();\n\n  const state = {\n    version: 0,\n\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1,\n    },\n\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotShadow: [],\n    spotShadowMap: [],\n    spotShadowMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n    rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: [],\n  };\n\n  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());\n\n  const vector3 = new Vector3();\n  const matrix4 = new Matrix4();\n  const matrix42 = new Matrix4();\n\n  function setup(lights, physicallyCorrectLights) {\n    let r = 0,\n      g = 0,\n      b = 0;\n\n    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n\n    let numDirectionalShadows = 0;\n    let numPointShadows = 0;\n    let numSpotShadows = 0;\n\n    lights.sort(shadowCastingLightsFirst);\n\n    // artist-friendly light intensity scaling factor\n    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;\n\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n\n      const color = light.color;\n      const intensity = light.intensity;\n      const distance = light.distance;\n\n      const shadowMap =\n        light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n      if (light.isAmbientLight) {\n        r += color.r * intensity * scaleFactor;\n        g += color.g * intensity * scaleFactor;\n        b += color.b * intensity * scaleFactor;\n      } else if (light.isLightProbe) {\n        for (let j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n      } else if (light.isDirectionalLight) {\n        const uniforms = cache.get(light);\n\n        uniforms.color\n          .copy(light.color)\n          .multiplyScalar(light.intensity * scaleFactor);\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n\n          const shadowUniforms = shadowCache.get(light);\n\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n\n          state.directionalShadow[directionalLength] = shadowUniforms;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] =\n            light.shadow.matrix;\n\n          numDirectionalShadows++;\n        }\n\n        state.directional[directionalLength] = uniforms;\n\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = cache.get(light);\n\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n\n        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);\n        uniforms.distance = distance;\n\n        uniforms.coneCos = Math.cos(light.angle);\n        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        uniforms.decay = light.decay;\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n\n          const shadowUniforms = shadowCache.get(light);\n\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n\n          state.spotShadow[spotLength] = shadowUniforms;\n          state.spotShadowMap[spotLength] = shadowMap;\n          state.spotShadowMatrix[spotLength] = light.shadow.matrix;\n\n          numSpotShadows++;\n        }\n\n        state.spot[spotLength] = uniforms;\n\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = cache.get(light);\n\n        // (a) intensity is the total visible light emitted\n        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\n        // (b) intensity is the brightness of the light\n        uniforms.color.copy(color).multiplyScalar(intensity);\n\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\n        state.rectArea[rectAreaLength] = uniforms;\n\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = cache.get(light);\n\n        uniforms.color\n          .copy(light.color)\n          .multiplyScalar(light.intensity * scaleFactor);\n        uniforms.distance = light.distance;\n        uniforms.decay = light.decay;\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n\n          const shadowUniforms = shadowCache.get(light);\n\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          shadowUniforms.shadowCameraNear = shadow.camera.near;\n          shadowUniforms.shadowCameraFar = shadow.camera.far;\n\n          state.pointShadow[pointLength] = shadowUniforms;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n\n          numPointShadows++;\n        }\n\n        state.point[pointLength] = uniforms;\n\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = cache.get(light);\n\n        uniforms.skyColor\n          .copy(light.color)\n          .multiplyScalar(intensity * scaleFactor);\n        uniforms.groundColor\n          .copy(light.groundColor)\n          .multiplyScalar(intensity * scaleFactor);\n\n        state.hemi[hemiLength] = uniforms;\n\n        hemiLength++;\n      }\n    }\n\n    if (rectAreaLength > 0) {\n      if (capabilities.isWebGL2) {\n        // WebGL 2\n\n        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n      } else {\n        // WebGL 1\n\n        if (extensions.has('OES_texture_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n        } else if (extensions.has('OES_texture_half_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n        } else {\n          console.error(\n            'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.',\n          );\n        }\n      }\n    }\n\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n\n    const hash = state.hash;\n\n    if (\n      hash.directionalLength !== directionalLength ||\n      hash.pointLength !== pointLength ||\n      hash.spotLength !== spotLength ||\n      hash.rectAreaLength !== rectAreaLength ||\n      hash.hemiLength !== hemiLength ||\n      hash.numDirectionalShadows !== numDirectionalShadows ||\n      hash.numPointShadows !== numPointShadows ||\n      hash.numSpotShadows !== numSpotShadows\n    ) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n\n      state.directionalShadow.length = numDirectionalShadows;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotShadowMatrix.length = numSpotShadows;\n\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n\n      state.version = nextVersion++;\n    }\n  }\n\n  function setupView(lights, camera) {\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n\n    const viewMatrix = camera.matrixWorldInverse;\n\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n\n      if (light.isDirectionalLight) {\n        const uniforms = state.directional[directionalLength];\n\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = state.spot[spotLength];\n\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = state.rectArea[rectAreaLength];\n\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n\n        // extract local rotation of light to derive width/height half vectors\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\n        uniforms.halfWidth.applyMatrix4(matrix42);\n        uniforms.halfHeight.applyMatrix4(matrix42);\n\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = state.point[pointLength];\n\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = state.hemi[hemiLength];\n\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        uniforms.direction.transformDirection(viewMatrix);\n        uniforms.direction.normalize();\n\n        hemiLength++;\n      }\n    }\n  }\n\n  return {\n    setup: setup,\n    setupView: setupView,\n    state: state,\n  };\n}\n\nfunction WebGLRenderState(extensions, capabilities) {\n  const lights = new WebGLLights(extensions, capabilities);\n\n  const lightsArray = [];\n  const shadowsArray = [];\n\n  function init() {\n    lightsArray.length = 0;\n    shadowsArray.length = 0;\n  }\n\n  function pushLight(light) {\n    lightsArray.push(light);\n  }\n\n  function pushShadow(shadowLight) {\n    shadowsArray.push(shadowLight);\n  }\n\n  function setupLights(physicallyCorrectLights) {\n    lights.setup(lightsArray, physicallyCorrectLights);\n  }\n\n  function setupLightsView(camera) {\n    lights.setupView(lightsArray, camera);\n  }\n\n  const state = {\n    lightsArray: lightsArray,\n    shadowsArray: shadowsArray,\n\n    lights: lights,\n  };\n\n  return {\n    init: init,\n    state: state,\n    setupLights: setupLights,\n    setupLightsView: setupLightsView,\n\n    pushLight: pushLight,\n    pushShadow: pushShadow,\n  };\n}\n\nfunction WebGLRenderStates(extensions, capabilities) {\n  let renderStates = new WeakMap();\n\n  function get(scene, renderCallDepth = 0) {\n    let renderState;\n\n    if (renderStates.has(scene) === false) {\n      renderState = new WebGLRenderState(extensions, capabilities);\n      renderStates.set(scene, [renderState]);\n    } else {\n      if (renderCallDepth >= renderStates.get(scene).length) {\n        renderState = new WebGLRenderState(extensions, capabilities);\n        renderStates.get(scene).push(renderState);\n      } else {\n        renderState = renderStates.get(scene)[renderCallDepth];\n      }\n    }\n\n    return renderState;\n  }\n\n  function dispose() {\n    renderStates = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose,\n  };\n}\n\n/**\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nclass MeshDepthMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'MeshDepthMaterial';\n\n    this.depthPacking = BasicDepthPacking;\n\n    this.map = null;\n\n    this.alphaMap = null;\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n\n    this.fog = false;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.depthPacking = source.depthPacking;\n\n    this.map = source.map;\n\n    this.alphaMap = source.alphaMap;\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n\n    return this;\n  }\n}\n\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n/**\n * parameters = {\n *\n *  referencePosition: <float>,\n *  nearDistance: <float>,\n *  farDistance: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>\n *\n * }\n */\n\nclass MeshDistanceMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'MeshDistanceMaterial';\n\n    this.referencePosition = new Vector3();\n    this.nearDistance = 1;\n    this.farDistance = 1000;\n\n    this.map = null;\n\n    this.alphaMap = null;\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.fog = false;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.referencePosition.copy(source.referencePosition);\n    this.nearDistance = source.nearDistance;\n    this.farDistance = source.farDistance;\n\n    this.map = source.map;\n\n    this.alphaMap = source.alphaMap;\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    return this;\n  }\n}\n\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\nconst vertex = 'void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}';\n\nconst fragment =\n  'uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\nuniform float samples;\\n#include <packing>\\nvoid main() {\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\\n\\tfor ( float i = 0.0; i < samples; i ++ ) {\\n\\t\\tfloat uvOffset = uvStart + i * uvStride;\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean / samples;\\n\\tsquared_mean = squared_mean / samples;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}';\n\nfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n  let _frustum = new Frustum();\n\n  const _shadowMapSize = new Vector2(),\n    _viewportSize = new Vector2(),\n    _viewport = new Vector4(),\n    _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),\n    _distanceMaterial = new MeshDistanceMaterial(),\n    _materialCache = {},\n    _maxTextureSize = _capabilities.maxTextureSize;\n\n  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\n  const shadowMaterialVertical = new ShaderMaterial({\n    uniforms: {\n      shadow_pass: { value: null },\n      resolution: { value: new Vector2() },\n      radius: { value: 4.0 },\n      samples: { value: 8.0 },\n    },\n\n    vertexShader: vertex,\n    fragmentShader: fragment,\n  });\n\n  const shadowMaterialHorizontal = shadowMaterialVertical.clone();\n  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n  const fullScreenTri = new BufferGeometry();\n  fullScreenTri.setAttribute(\n    'position',\n    new BufferAttribute(\n      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),\n      3,\n    ),\n  );\n\n  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n\n  const scope = this;\n\n  this.enabled = false;\n\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n\n  this.type = PCFShadowMap;\n\n  this.render = function (lights, scene, camera) {\n    if (scope.enabled === false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false) return;\n\n    if (lights.length === 0) return;\n\n    const currentRenderTarget = _renderer.getRenderTarget();\n    const activeCubeFace = _renderer.getActiveCubeFace();\n    const activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n    const _state = _renderer.state;\n\n    // Set GL state for depth map.\n    _state.setBlending(NoBlending);\n    _state.buffers.color.setClear(1, 1, 1, 1);\n    _state.buffers.depth.setTest(true);\n    _state.setScissorTest(false);\n\n    // render depth map\n\n    for (let i = 0, il = lights.length; i < il; i++) {\n      const light = lights[i];\n      const shadow = light.shadow;\n\n      if (shadow === undefined) {\n        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\n        continue;\n      }\n\n      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n\n      _shadowMapSize.copy(shadow.mapSize);\n\n      const shadowFrameExtents = shadow.getFrameExtents();\n\n      _shadowMapSize.multiply(shadowFrameExtents);\n\n      _viewportSize.copy(shadow.mapSize);\n\n      if (\n        _shadowMapSize.x > _maxTextureSize ||\n        _shadowMapSize.y > _maxTextureSize\n      ) {\n        if (_shadowMapSize.x > _maxTextureSize) {\n          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          shadow.mapSize.x = _viewportSize.x;\n        }\n\n        if (_shadowMapSize.y > _maxTextureSize) {\n          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n          shadow.mapSize.y = _viewportSize.y;\n        }\n      }\n\n      if (\n        shadow.map === null &&\n        !shadow.isPointLightShadow &&\n        this.type === VSMShadowMap\n      ) {\n        const pars = {\n          minFilter: LinearFilter,\n          magFilter: LinearFilter,\n          format: RGBAFormat,\n        };\n\n        shadow.map = new WebGLRenderTarget(\n          _shadowMapSize.x,\n          _shadowMapSize.y,\n          pars,\n        );\n        shadow.map.texture.name = light.name + '.shadowMap';\n\n        shadow.mapPass = new WebGLRenderTarget(\n          _shadowMapSize.x,\n          _shadowMapSize.y,\n          pars,\n        );\n\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      if (shadow.map === null) {\n        const pars = {\n          minFilter: NearestFilter,\n          magFilter: NearestFilter,\n          format: RGBAFormat,\n        };\n\n        shadow.map = new WebGLRenderTarget(\n          _shadowMapSize.x,\n          _shadowMapSize.y,\n          pars,\n        );\n        shadow.map.texture.name = light.name + '.shadowMap';\n\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      _renderer.setRenderTarget(shadow.map);\n      _renderer.clear();\n\n      const viewportCount = shadow.getViewportCount();\n\n      for (let vp = 0; vp < viewportCount; vp++) {\n        const viewport = shadow.getViewport(vp);\n\n        _viewport.set(\n          _viewportSize.x * viewport.x,\n          _viewportSize.y * viewport.y,\n          _viewportSize.x * viewport.z,\n          _viewportSize.y * viewport.w,\n        );\n\n        _state.viewport(_viewport);\n\n        shadow.updateMatrices(light, vp);\n\n        _frustum = shadow.getFrustum();\n\n        renderObject(scene, camera, shadow.camera, light, this.type);\n      }\n\n      // do blur pass for VSM\n\n      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        VSMPass(shadow, camera);\n      }\n\n      shadow.needsUpdate = false;\n    }\n\n    scope.needsUpdate = false;\n\n    _renderer.setRenderTarget(\n      currentRenderTarget,\n      activeCubeFace,\n      activeMipmapLevel,\n    );\n  };\n\n  function VSMPass(shadow, camera) {\n    const geometry = _objects.update(fullScreenMesh);\n\n    // vertical pass\n\n    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialVertical.uniforms.radius.value = shadow.radius;\n    shadowMaterialVertical.uniforms.samples.value = shadow.blurSamples;\n    _renderer.setRenderTarget(shadow.mapPass);\n    _renderer.clear();\n    _renderer.renderBufferDirect(\n      camera,\n      null,\n      geometry,\n      shadowMaterialVertical,\n      fullScreenMesh,\n      null,\n    );\n\n    // horizontal pass\n\n    shadowMaterialHorizontal.uniforms.shadow_pass.value =\n      shadow.mapPass.texture;\n    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n    shadowMaterialHorizontal.uniforms.samples.value = shadow.blurSamples;\n    _renderer.setRenderTarget(shadow.map);\n    _renderer.clear();\n    _renderer.renderBufferDirect(\n      camera,\n      null,\n      geometry,\n      shadowMaterialHorizontal,\n      fullScreenMesh,\n      null,\n    );\n  }\n\n  function getDepthMaterial(\n    object,\n    geometry,\n    material,\n    light,\n    shadowCameraNear,\n    shadowCameraFar,\n    type,\n  ) {\n    let result = null;\n\n    const customMaterial =\n      light.isPointLight === true\n        ? object.customDistanceMaterial\n        : object.customDepthMaterial;\n\n    if (customMaterial !== undefined) {\n      result = customMaterial;\n    } else {\n      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;\n    }\n\n    if (\n      (_renderer.localClippingEnabled &&\n        material.clipShadows === true &&\n        material.clippingPlanes.length !== 0) ||\n      (material.displacementMap && material.displacementScale !== 0) ||\n      (material.alphaMap && material.alphaTest > 0)\n    ) {\n      // in this case we need a unique material instance reflecting the\n      // appropriate state\n\n      const keyA = result.uuid,\n        keyB = material.uuid;\n\n      let materialsForVariant = _materialCache[keyA];\n\n      if (materialsForVariant === undefined) {\n        materialsForVariant = {};\n        _materialCache[keyA] = materialsForVariant;\n      }\n\n      let cachedMaterial = materialsForVariant[keyB];\n\n      if (cachedMaterial === undefined) {\n        cachedMaterial = result.clone();\n        materialsForVariant[keyB] = cachedMaterial;\n      }\n\n      result = cachedMaterial;\n    }\n\n    result.visible = material.visible;\n    result.wireframe = material.wireframe;\n\n    if (type === VSMShadowMap) {\n      result.side =\n        material.shadowSide !== null ? material.shadowSide : material.side;\n    } else {\n      result.side =\n        material.shadowSide !== null\n          ? material.shadowSide\n          : shadowSide[material.side];\n    }\n\n    result.alphaMap = material.alphaMap;\n    result.alphaTest = material.alphaTest;\n\n    result.clipShadows = material.clipShadows;\n    result.clippingPlanes = material.clippingPlanes;\n    result.clipIntersection = material.clipIntersection;\n\n    result.displacementMap = material.displacementMap;\n    result.displacementScale = material.displacementScale;\n    result.displacementBias = material.displacementBias;\n\n    result.wireframeLinewidth = material.wireframeLinewidth;\n    result.linewidth = material.linewidth;\n\n    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n      result.referencePosition.setFromMatrixPosition(light.matrixWorld);\n      result.nearDistance = shadowCameraNear;\n      result.farDistance = shadowCameraFar;\n    }\n\n    return result;\n  }\n\n  function renderObject(object, camera, shadowCamera, light, type) {\n    if (object.visible === false) return;\n\n    const visible = object.layers.test(camera.layers);\n\n    if (visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if (\n        (object.castShadow ||\n          (object.receiveShadow && type === VSMShadowMap)) &&\n        (!object.frustumCulled || _frustum.intersectsObject(object))\n      ) {\n        object.modelViewMatrix.multiplyMatrices(\n          shadowCamera.matrixWorldInverse,\n          object.matrixWorld,\n        );\n\n        const geometry = _objects.update(object);\n        const material = object.material;\n\n        if (Array.isArray(material)) {\n          const groups = geometry.groups;\n\n          for (let k = 0, kl = groups.length; k < kl; k++) {\n            const group = groups[k];\n            const groupMaterial = material[group.materialIndex];\n\n            if (groupMaterial && groupMaterial.visible) {\n              const depthMaterial = getDepthMaterial(\n                object,\n                geometry,\n                groupMaterial,\n                light,\n                shadowCamera.near,\n                shadowCamera.far,\n                type,\n              );\n\n              _renderer.renderBufferDirect(\n                shadowCamera,\n                null,\n                geometry,\n                depthMaterial,\n                object,\n                group,\n              );\n            }\n          }\n        } else if (material.visible) {\n          const depthMaterial = getDepthMaterial(\n            object,\n            geometry,\n            material,\n            light,\n            shadowCamera.near,\n            shadowCamera.far,\n            type,\n          );\n\n          _renderer.renderBufferDirect(\n            shadowCamera,\n            null,\n            geometry,\n            depthMaterial,\n            object,\n            null,\n          );\n        }\n      }\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      renderObject(children[i], camera, shadowCamera, light, type);\n    }\n  }\n}\n\nfunction WebGLState(gl, extensions, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n\n  function ColorBuffer() {\n    let locked = false;\n\n    const color = new Vector4();\n    let currentColorMask = null;\n    const currentColorClear = new Vector4(0, 0, 0, 0);\n\n    return {\n      setMask: function (colorMask) {\n        if (currentColorMask !== colorMask && !locked) {\n          gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n          currentColorMask = colorMask;\n        }\n      },\n\n      setLocked: function (lock) {\n        locked = lock;\n      },\n\n      setClear: function (r, g, b, a, premultipliedAlpha) {\n        if (premultipliedAlpha === true) {\n          r *= a;\n          g *= a;\n          b *= a;\n        }\n\n        color.set(r, g, b, a);\n\n        if (currentColorClear.equals(color) === false) {\n          gl.clearColor(r, g, b, a);\n          currentColorClear.copy(color);\n        }\n      },\n\n      reset: function () {\n        locked = false;\n\n        currentColorMask = null;\n        currentColorClear.set(-1, 0, 0, 0); // set to invalid state\n      },\n    };\n  }\n\n  function DepthBuffer() {\n    let locked = false;\n\n    let currentDepthMask = null;\n    let currentDepthFunc = null;\n    let currentDepthClear = null;\n\n    return {\n      setTest: function (depthTest) {\n        if (depthTest) {\n          enable(2929);\n        } else {\n          disable(2929);\n        }\n      },\n\n      setMask: function (depthMask) {\n        if (currentDepthMask !== depthMask && !locked) {\n          gl.depthMask(depthMask);\n          currentDepthMask = depthMask;\n        }\n      },\n\n      setFunc: function (depthFunc) {\n        if (currentDepthFunc !== depthFunc) {\n          if (depthFunc) {\n            switch (depthFunc) {\n              case NeverDepth:\n                gl.depthFunc(512);\n                break;\n\n              case AlwaysDepth:\n                gl.depthFunc(519);\n                break;\n\n              case LessDepth:\n                gl.depthFunc(513);\n                break;\n\n              case LessEqualDepth:\n                gl.depthFunc(515);\n                break;\n\n              case EqualDepth:\n                gl.depthFunc(514);\n                break;\n\n              case GreaterEqualDepth:\n                gl.depthFunc(518);\n                break;\n\n              case GreaterDepth:\n                gl.depthFunc(516);\n                break;\n\n              case NotEqualDepth:\n                gl.depthFunc(517);\n                break;\n\n              default:\n                gl.depthFunc(515);\n            }\n          } else {\n            gl.depthFunc(515);\n          }\n\n          currentDepthFunc = depthFunc;\n        }\n      },\n\n      setLocked: function (lock) {\n        locked = lock;\n      },\n\n      setClear: function (depth) {\n        if (currentDepthClear !== depth) {\n          gl.clearDepth(depth);\n          currentDepthClear = depth;\n        }\n      },\n\n      reset: function () {\n        locked = false;\n\n        currentDepthMask = null;\n        currentDepthFunc = null;\n        currentDepthClear = null;\n      },\n    };\n  }\n\n  function StencilBuffer() {\n    let locked = false;\n\n    let currentStencilMask = null;\n    let currentStencilFunc = null;\n    let currentStencilRef = null;\n    let currentStencilFuncMask = null;\n    let currentStencilFail = null;\n    let currentStencilZFail = null;\n    let currentStencilZPass = null;\n    let currentStencilClear = null;\n\n    return {\n      setTest: function (stencilTest) {\n        if (!locked) {\n          if (stencilTest) {\n            enable(2960);\n          } else {\n            disable(2960);\n          }\n        }\n      },\n\n      setMask: function (stencilMask) {\n        if (currentStencilMask !== stencilMask && !locked) {\n          gl.stencilMask(stencilMask);\n          currentStencilMask = stencilMask;\n        }\n      },\n\n      setFunc: function (stencilFunc, stencilRef, stencilMask) {\n        if (\n          currentStencilFunc !== stencilFunc ||\n          currentStencilRef !== stencilRef ||\n          currentStencilFuncMask !== stencilMask\n        ) {\n          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n\n          currentStencilFunc = stencilFunc;\n          currentStencilRef = stencilRef;\n          currentStencilFuncMask = stencilMask;\n        }\n      },\n\n      setOp: function (stencilFail, stencilZFail, stencilZPass) {\n        if (\n          currentStencilFail !== stencilFail ||\n          currentStencilZFail !== stencilZFail ||\n          currentStencilZPass !== stencilZPass\n        ) {\n          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n\n          currentStencilFail = stencilFail;\n          currentStencilZFail = stencilZFail;\n          currentStencilZPass = stencilZPass;\n        }\n      },\n\n      setLocked: function (lock) {\n        locked = lock;\n      },\n\n      setClear: function (stencil) {\n        if (currentStencilClear !== stencil) {\n          gl.clearStencil(stencil);\n          currentStencilClear = stencil;\n        }\n      },\n\n      reset: function () {\n        locked = false;\n\n        currentStencilMask = null;\n        currentStencilFunc = null;\n        currentStencilRef = null;\n        currentStencilFuncMask = null;\n        currentStencilFail = null;\n        currentStencilZFail = null;\n        currentStencilZPass = null;\n        currentStencilClear = null;\n      },\n    };\n  }\n\n  //\n\n  const colorBuffer = new ColorBuffer();\n  const depthBuffer = new DepthBuffer();\n  const stencilBuffer = new StencilBuffer();\n\n  let enabledCapabilities = {};\n\n  let xrFramebuffer = null;\n  let currentBoundFramebuffers = {};\n\n  let currentProgram = null;\n\n  let currentBlendingEnabled = false;\n  let currentBlending = null;\n  let currentBlendEquation = null;\n  let currentBlendSrc = null;\n  let currentBlendDst = null;\n  let currentBlendEquationAlpha = null;\n  let currentBlendSrcAlpha = null;\n  let currentBlendDstAlpha = null;\n  let currentPremultipledAlpha = false;\n\n  let currentFlipSided = null;\n  let currentCullFace = null;\n\n  let currentLineWidth = null;\n\n  let currentPolygonOffsetFactor = null;\n  let currentPolygonOffsetUnits = null;\n\n  const maxTextures = gl.getParameter(35661);\n\n  let lineWidthAvailable = false;\n  let version = 0;\n  const glVersion = gl.getParameter(7938);\n\n  if (glVersion.indexOf('WebGL') !== -1) {\n    version = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 1.0;\n  } else if (glVersion.indexOf('OpenGL ES') !== -1) {\n    version = parseFloat(/^OpenGL ES (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 2.0;\n  }\n\n  let currentTextureSlot = null;\n  let currentBoundTextures = {};\n\n  const scissorParam = gl.getParameter(3088);\n  const viewportParam = gl.getParameter(2978);\n\n  const currentScissor = new Vector4().fromArray(scissorParam);\n  const currentViewport = new Vector4().fromArray(viewportParam);\n\n  function createTexture(type, target, count) {\n    const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.\n    const texture = gl.createTexture();\n\n    gl.bindTexture(type, texture);\n    gl.texParameteri(type, 10241, 9728);\n    gl.texParameteri(type, 10240, 9728);\n\n    for (let i = 0; i < count; i++) {\n      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);\n    }\n\n    return texture;\n  }\n\n  const emptyTextures = {};\n  emptyTextures[3553] = createTexture(3553, 3553, 1);\n  emptyTextures[34067] = createTexture(34067, 34069, 6);\n\n  // init\n\n  colorBuffer.setClear(0, 0, 0, 1);\n  depthBuffer.setClear(1);\n  stencilBuffer.setClear(0);\n\n  enable(2929);\n  depthBuffer.setFunc(LessEqualDepth);\n\n  setFlipSided(false);\n  setCullFace(CullFaceBack);\n  enable(2884);\n\n  setBlending(NoBlending);\n\n  //\n\n  function enable(id) {\n    if (enabledCapabilities[id] !== true) {\n      gl.enable(id);\n      enabledCapabilities[id] = true;\n    }\n  }\n\n  function disable(id) {\n    if (enabledCapabilities[id] !== false) {\n      gl.disable(id);\n      enabledCapabilities[id] = false;\n    }\n  }\n\n  function bindXRFramebuffer(framebuffer) {\n    if (framebuffer !== xrFramebuffer) {\n      gl.bindFramebuffer(36160, framebuffer);\n\n      xrFramebuffer = framebuffer;\n    }\n  }\n\n  function bindFramebuffer(target, framebuffer) {\n    if (framebuffer === null && xrFramebuffer !== null)\n      framebuffer = xrFramebuffer; // use active XR framebuffer if available\n\n    if (currentBoundFramebuffers[target] !== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n\n      currentBoundFramebuffers[target] = framebuffer;\n\n      if (isWebGL2) {\n        // 36009 is equivalent to 36160\n\n        if (target === 36009) {\n          currentBoundFramebuffers[36160] = framebuffer;\n        }\n\n        if (target === 36160) {\n          currentBoundFramebuffers[36009] = framebuffer;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function useProgram(program) {\n    if (currentProgram !== program) {\n      gl.useProgram(program);\n\n      currentProgram = program;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  const equationToGL = {\n    [AddEquation]: 32774,\n    [SubtractEquation]: 32778,\n    [ReverseSubtractEquation]: 32779,\n  };\n\n  if (isWebGL2) {\n    equationToGL[MinEquation] = 32775;\n    equationToGL[MaxEquation] = 32776;\n  } else {\n    const extension = extensions.get('EXT_blend_minmax');\n\n    if (extension !== null) {\n      equationToGL[MinEquation] = extension.MIN_EXT;\n      equationToGL[MaxEquation] = extension.MAX_EXT;\n    }\n  }\n\n  const factorToGL = {\n    [ZeroFactor]: 0,\n    [OneFactor]: 1,\n    [SrcColorFactor]: 768,\n    [SrcAlphaFactor]: 770,\n    [SrcAlphaSaturateFactor]: 776,\n    [DstColorFactor]: 774,\n    [DstAlphaFactor]: 772,\n    [OneMinusSrcColorFactor]: 769,\n    [OneMinusSrcAlphaFactor]: 771,\n    [OneMinusDstColorFactor]: 775,\n    [OneMinusDstAlphaFactor]: 773,\n  };\n\n  function setBlending(\n    blending,\n    blendEquation,\n    blendSrc,\n    blendDst,\n    blendEquationAlpha,\n    blendSrcAlpha,\n    blendDstAlpha,\n    premultipliedAlpha,\n  ) {\n    if (blending === NoBlending) {\n      if (currentBlendingEnabled === true) {\n        disable(3042);\n        currentBlendingEnabled = false;\n      }\n\n      return;\n    }\n\n    if (currentBlendingEnabled === false) {\n      enable(3042);\n      currentBlendingEnabled = true;\n    }\n\n    if (blending !== CustomBlending) {\n      if (\n        blending !== currentBlending ||\n        premultipliedAlpha !== currentPremultipledAlpha\n      ) {\n        if (\n          currentBlendEquation !== AddEquation ||\n          currentBlendEquationAlpha !== AddEquation\n        ) {\n          gl.blendEquation(32774);\n\n          currentBlendEquation = AddEquation;\n          currentBlendEquationAlpha = AddEquation;\n        }\n\n        if (premultipliedAlpha) {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(1, 771, 1, 771);\n              break;\n\n            case AdditiveBlending:\n              gl.blendFunc(1, 1);\n              break;\n\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(0, 0, 769, 771);\n              break;\n\n            case MultiplyBlending:\n              gl.blendFuncSeparate(0, 768, 0, 770);\n              break;\n\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        } else {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(770, 771, 1, 771);\n              break;\n\n            case AdditiveBlending:\n              gl.blendFunc(770, 1);\n              break;\n\n            case SubtractiveBlending:\n              gl.blendFunc(0, 769);\n              break;\n\n            case MultiplyBlending:\n              gl.blendFunc(0, 768);\n              break;\n\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        }\n\n        currentBlendSrc = null;\n        currentBlendDst = null;\n        currentBlendSrcAlpha = null;\n        currentBlendDstAlpha = null;\n\n        currentBlending = blending;\n        currentPremultipledAlpha = premultipliedAlpha;\n      }\n\n      return;\n    }\n\n    // custom blending\n\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n\n    if (\n      blendEquation !== currentBlendEquation ||\n      blendEquationAlpha !== currentBlendEquationAlpha\n    ) {\n      gl.blendEquationSeparate(\n        equationToGL[blendEquation],\n        equationToGL[blendEquationAlpha],\n      );\n\n      currentBlendEquation = blendEquation;\n      currentBlendEquationAlpha = blendEquationAlpha;\n    }\n\n    if (\n      blendSrc !== currentBlendSrc ||\n      blendDst !== currentBlendDst ||\n      blendSrcAlpha !== currentBlendSrcAlpha ||\n      blendDstAlpha !== currentBlendDstAlpha\n    ) {\n      gl.blendFuncSeparate(\n        factorToGL[blendSrc],\n        factorToGL[blendDst],\n        factorToGL[blendSrcAlpha],\n        factorToGL[blendDstAlpha],\n      );\n\n      currentBlendSrc = blendSrc;\n      currentBlendDst = blendDst;\n      currentBlendSrcAlpha = blendSrcAlpha;\n      currentBlendDstAlpha = blendDstAlpha;\n    }\n\n    currentBlending = blending;\n    currentPremultipledAlpha = null;\n  }\n\n  function setMaterial(material, frontFaceCW) {\n    material.side === DoubleSide ? disable(2884) : enable(2884);\n\n    let flipSided = material.side === BackSide;\n    if (frontFaceCW) flipSided = !flipSided;\n\n    setFlipSided(flipSided);\n\n    material.blending === NormalBlending && material.transparent === false\n      ? setBlending(NoBlending)\n      : setBlending(\n          material.blending,\n          material.blendEquation,\n          material.blendSrc,\n          material.blendDst,\n          material.blendEquationAlpha,\n          material.blendSrcAlpha,\n          material.blendDstAlpha,\n          material.premultipliedAlpha,\n        );\n\n    depthBuffer.setFunc(material.depthFunc);\n    depthBuffer.setTest(material.depthTest);\n    depthBuffer.setMask(material.depthWrite);\n    colorBuffer.setMask(material.colorWrite);\n\n    const stencilWrite = material.stencilWrite;\n    stencilBuffer.setTest(stencilWrite);\n    if (stencilWrite) {\n      stencilBuffer.setMask(material.stencilWriteMask);\n      stencilBuffer.setFunc(\n        material.stencilFunc,\n        material.stencilRef,\n        material.stencilFuncMask,\n      );\n      stencilBuffer.setOp(\n        material.stencilFail,\n        material.stencilZFail,\n        material.stencilZPass,\n      );\n    }\n\n    setPolygonOffset(\n      material.polygonOffset,\n      material.polygonOffsetFactor,\n      material.polygonOffsetUnits,\n    );\n\n    material.alphaToCoverage === true ? enable(32926) : disable(32926);\n  }\n\n  //\n\n  function setFlipSided(flipSided) {\n    if (currentFlipSided !== flipSided) {\n      if (flipSided) {\n        gl.frontFace(2304);\n      } else {\n        gl.frontFace(2305);\n      }\n\n      currentFlipSided = flipSided;\n    }\n  }\n\n  function setCullFace(cullFace) {\n    if (cullFace !== CullFaceNone) {\n      enable(2884);\n\n      if (cullFace !== currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          gl.cullFace(1029);\n        } else if (cullFace === CullFaceFront) {\n          gl.cullFace(1028);\n        } else {\n          gl.cullFace(1032);\n        }\n      }\n    } else {\n      disable(2884);\n    }\n\n    currentCullFace = cullFace;\n  }\n\n  function setLineWidth(width) {\n    if (width !== currentLineWidth) {\n      if (lineWidthAvailable) gl.lineWidth(width);\n\n      currentLineWidth = width;\n    }\n  }\n\n  function setPolygonOffset(polygonOffset, factor, units) {\n    if (polygonOffset) {\n      enable(32823);\n\n      if (\n        currentPolygonOffsetFactor !== factor ||\n        currentPolygonOffsetUnits !== units\n      ) {\n        gl.polygonOffset(factor, units);\n\n        currentPolygonOffsetFactor = factor;\n        currentPolygonOffsetUnits = units;\n      }\n    } else {\n      disable(32823);\n    }\n  }\n\n  function setScissorTest(scissorTest) {\n    if (scissorTest) {\n      enable(3089);\n    } else {\n      disable(3089);\n    }\n  }\n\n  // texture\n\n  function activeTexture(webglSlot) {\n    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;\n\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      currentTextureSlot = webglSlot;\n    }\n  }\n\n  function bindTexture(webglType, webglTexture) {\n    if (currentTextureSlot === null) {\n      activeTexture();\n    }\n\n    let boundTexture = currentBoundTextures[currentTextureSlot];\n\n    if (boundTexture === undefined) {\n      boundTexture = { type: undefined, texture: undefined };\n      currentBoundTextures[currentTextureSlot] = boundTexture;\n    }\n\n    if (\n      boundTexture.type !== webglType ||\n      boundTexture.texture !== webglTexture\n    ) {\n      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\n\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  }\n\n  function unbindTexture() {\n    const boundTexture = currentBoundTextures[currentTextureSlot];\n\n    if (boundTexture !== undefined && boundTexture.type !== undefined) {\n      gl.bindTexture(boundTexture.type, null);\n\n      boundTexture.type = undefined;\n      boundTexture.texture = undefined;\n    }\n  }\n\n  function compressedTexImage2D() {\n    try {\n      gl.compressedTexImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error('THREE.WebGLState:', error);\n    }\n  }\n\n  function texImage2D() {\n    try {\n      gl.texImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error('THREE.WebGLState:', error);\n    }\n  }\n\n  function texImage3D() {\n    try {\n      gl.texImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error('THREE.WebGLState:', error);\n    }\n  }\n\n  //\n\n  function scissor(scissor) {\n    if (currentScissor.equals(scissor) === false) {\n      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);\n      currentScissor.copy(scissor);\n    }\n  }\n\n  function viewport(viewport) {\n    if (currentViewport.equals(viewport) === false) {\n      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);\n      currentViewport.copy(viewport);\n    }\n  }\n\n  //\n\n  function reset() {\n    // reset state\n\n    gl.disable(3042);\n    gl.disable(2884);\n    gl.disable(2929);\n    gl.disable(32823);\n    gl.disable(3089);\n    gl.disable(2960);\n    gl.disable(32926);\n\n    gl.blendEquation(32774);\n    gl.blendFunc(1, 0);\n    gl.blendFuncSeparate(1, 0, 1, 0);\n\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0, 0, 0, 0);\n\n    gl.depthMask(true);\n    gl.depthFunc(513);\n    gl.clearDepth(1);\n\n    gl.stencilMask(0xffffffff);\n    gl.stencilFunc(519, 0, 0xffffffff);\n    gl.stencilOp(7680, 7680, 7680);\n    gl.clearStencil(0);\n\n    gl.cullFace(1029);\n    gl.frontFace(2305);\n\n    gl.polygonOffset(0, 0);\n\n    gl.activeTexture(33984);\n\n    gl.bindFramebuffer(36160, null);\n\n    if (isWebGL2 === true) {\n      gl.bindFramebuffer(36009, null);\n      gl.bindFramebuffer(36008, null);\n    }\n\n    gl.useProgram(null);\n\n    gl.lineWidth(1);\n\n    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // reset internals\n\n    enabledCapabilities = {};\n\n    currentTextureSlot = null;\n    currentBoundTextures = {};\n\n    xrFramebuffer = null;\n    currentBoundFramebuffers = {};\n\n    currentProgram = null;\n\n    currentBlendingEnabled = false;\n    currentBlending = null;\n    currentBlendEquation = null;\n    currentBlendSrc = null;\n    currentBlendDst = null;\n    currentBlendEquationAlpha = null;\n    currentBlendSrcAlpha = null;\n    currentBlendDstAlpha = null;\n    currentPremultipledAlpha = false;\n\n    currentFlipSided = null;\n    currentCullFace = null;\n\n    currentLineWidth = null;\n\n    currentPolygonOffsetFactor = null;\n    currentPolygonOffsetUnits = null;\n\n    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n\n    colorBuffer.reset();\n    depthBuffer.reset();\n    stencilBuffer.reset();\n  }\n\n  return {\n    buffers: {\n      color: colorBuffer,\n      depth: depthBuffer,\n      stencil: stencilBuffer,\n    },\n\n    enable: enable,\n    disable: disable,\n\n    bindFramebuffer: bindFramebuffer,\n    bindXRFramebuffer: bindXRFramebuffer,\n\n    useProgram: useProgram,\n\n    setBlending: setBlending,\n    setMaterial: setMaterial,\n\n    setFlipSided: setFlipSided,\n    setCullFace: setCullFace,\n\n    setLineWidth: setLineWidth,\n    setPolygonOffset: setPolygonOffset,\n\n    setScissorTest: setScissorTest,\n\n    activeTexture: activeTexture,\n    bindTexture: bindTexture,\n    unbindTexture: unbindTexture,\n    compressedTexImage2D: compressedTexImage2D,\n    texImage2D: texImage2D,\n    texImage3D: texImage3D,\n\n    scissor: scissor,\n    viewport: viewport,\n\n    reset: reset,\n  };\n}\n\nfunction WebGLTextures(\n  _gl,\n  extensions,\n  state,\n  properties,\n  capabilities,\n  utils,\n  info,\n) {\n  const isWebGL2 = capabilities.isWebGL2;\n  const maxTextures = capabilities.maxTextures;\n  const maxCubemapSize = capabilities.maxCubemapSize;\n  const maxTextureSize = capabilities.maxTextureSize;\n  const maxSamples = capabilities.maxSamples;\n\n  const _videoTextures = new WeakMap();\n  let _canvas;\n\n  // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n  // also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n  let useOffscreenCanvas = false;\n\n  try {\n    useOffscreenCanvas =\n      typeof OffscreenCanvas !== 'undefined' &&\n      new OffscreenCanvas(1, 1).getContext('2d') !== null;\n  } catch (err) {\n    // Ignore any errors\n  }\n\n  function createCanvas(width, height) {\n    // Use OffscreenCanvas when available. Specially needed in web workers\n\n    return useOffscreenCanvas\n      ? new OffscreenCanvas(width, height)\n      : createElementNS('canvas');\n  }\n\n  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\n    let scale = 1;\n\n    // handle case if texture exceeds max size\n\n    if (image.width > maxSize || image.height > maxSize) {\n      scale = maxSize / Math.max(image.width, image.height);\n    }\n\n    // only perform resize if necessary\n\n    if (scale < 1 || needsPowerOfTwo === true) {\n      // only perform resize for certain image types\n\n      if (\n        (typeof HTMLImageElement !== 'undefined' &&\n          image instanceof HTMLImageElement) ||\n        (typeof HTMLCanvasElement !== 'undefined' &&\n          image instanceof HTMLCanvasElement) ||\n        (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)\n      ) {\n        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n\n        const width = floor(scale * image.width);\n        const height = floor(scale * image.height);\n\n        if (_canvas === undefined) _canvas = createCanvas(width, height);\n\n        // cube textures can't reuse the same canvas\n\n        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0, width, height);\n\n        console.warn(\n          'THREE.WebGLRenderer: Texture has been resized from (' +\n            image.width +\n            'x' +\n            image.height +\n            ') to (' +\n            width +\n            'x' +\n            height +\n            ').',\n        );\n\n        return canvas;\n      } else {\n        if ('data' in image) {\n          console.warn(\n            'THREE.WebGLRenderer: Image in DataTexture is too big (' +\n              image.width +\n              'x' +\n              image.height +\n              ').',\n          );\n        }\n\n        return image;\n      }\n    }\n\n    return image;\n  }\n\n  function isPowerOfTwo$1(image) {\n    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);\n  }\n\n  function textureNeedsPowerOfTwo(texture) {\n    if (isWebGL2) return false;\n\n    return (\n      texture.wrapS !== ClampToEdgeWrapping ||\n      texture.wrapT !== ClampToEdgeWrapping ||\n      (texture.minFilter !== NearestFilter &&\n        texture.minFilter !== LinearFilter)\n    );\n  }\n\n  function textureNeedsGenerateMipmaps(texture, supportsMips) {\n    return (\n      texture.generateMipmaps &&\n      supportsMips &&\n      texture.minFilter !== NearestFilter &&\n      texture.minFilter !== LinearFilter\n    );\n  }\n\n  function generateMipmap(target, texture, width, height, depth = 1) {\n    _gl.generateMipmap(target);\n\n    const textureProperties = properties.get(texture);\n\n    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));\n  }\n\n  function getInternalFormat(internalFormatName, glFormat, glType, encoding) {\n    if (isWebGL2 === false) return glFormat;\n\n    if (internalFormatName !== null) {\n      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];\n\n      console.warn(\n        \"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '\" +\n          internalFormatName +\n          \"'\",\n      );\n    }\n\n    let internalFormat = glFormat;\n\n    if (glFormat === 6403) {\n      if (glType === 5126) internalFormat = 33326;\n      if (glType === 5131) internalFormat = 33325;\n      if (glType === 5121) internalFormat = 33321;\n    }\n\n    if (glFormat === 6407) {\n      if (glType === 5126) internalFormat = 34837;\n      if (glType === 5131) internalFormat = 34843;\n      if (glType === 5121) internalFormat = 32849;\n    }\n\n    if (glFormat === 6408) {\n      if (glType === 5126) internalFormat = 34836;\n      if (glType === 5131) internalFormat = 34842;\n      if (glType === 5121)\n        internalFormat = encoding === sRGBEncoding ? 35907 : 32856;\n    }\n\n    if (\n      internalFormat === 33325 ||\n      internalFormat === 33326 ||\n      internalFormat === 34842 ||\n      internalFormat === 34836\n    ) {\n      extensions.get('EXT_color_buffer_float');\n    }\n\n    return internalFormat;\n  }\n\n  // Fallback filters for non-power-of-2 textures\n\n  function filterFallback(f) {\n    if (\n      f === NearestFilter ||\n      f === NearestMipmapNearestFilter ||\n      f === NearestMipmapLinearFilter\n    ) {\n      return 9728;\n    }\n\n    return 9729;\n  }\n\n  //\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n\n    texture.removeEventListener('dispose', onTextureDispose);\n\n    deallocateTexture(texture);\n\n    if (texture.isVideoTexture) {\n      _videoTextures.delete(texture);\n    }\n\n    info.memory.textures--;\n  }\n\n  function onRenderTargetDispose(event) {\n    const renderTarget = event.target;\n\n    renderTarget.removeEventListener('dispose', onRenderTargetDispose);\n\n    deallocateRenderTarget(renderTarget);\n  }\n\n  //\n\n  function deallocateTexture(texture) {\n    const textureProperties = properties.get(texture);\n\n    if (textureProperties.__webglInit === undefined) return;\n\n    _gl.deleteTexture(textureProperties.__webglTexture);\n\n    properties.remove(texture);\n  }\n\n  function deallocateRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n\n    if (!renderTarget) return;\n\n    if (textureProperties.__webglTexture !== undefined) {\n      _gl.deleteTexture(textureProperties.__webglTexture);\n\n      info.memory.textures--;\n    }\n\n    if (renderTarget.depthTexture) {\n      renderTarget.depthTexture.dispose();\n    }\n\n    if (renderTarget.isWebGLCubeRenderTarget) {\n      for (let i = 0; i < 6; i++) {\n        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n        if (renderTargetProperties.__webglDepthbuffer)\n          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n      }\n    } else {\n      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n      if (renderTargetProperties.__webglDepthbuffer)\n        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n      if (renderTargetProperties.__webglMultisampledFramebuffer)\n        _gl.deleteFramebuffer(\n          renderTargetProperties.__webglMultisampledFramebuffer,\n        );\n      if (renderTargetProperties.__webglColorRenderbuffer)\n        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);\n      if (renderTargetProperties.__webglDepthRenderbuffer)\n        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n    }\n\n    if (renderTarget.isWebGLMultipleRenderTargets) {\n      for (let i = 0, il = texture.length; i < il; i++) {\n        const attachmentProperties = properties.get(texture[i]);\n\n        if (attachmentProperties.__webglTexture) {\n          _gl.deleteTexture(attachmentProperties.__webglTexture);\n\n          info.memory.textures--;\n        }\n\n        properties.remove(texture[i]);\n      }\n    }\n\n    properties.remove(texture);\n    properties.remove(renderTarget);\n  }\n\n  //\n\n  let textureUnits = 0;\n\n  function resetTextureUnits() {\n    textureUnits = 0;\n  }\n\n  function allocateTextureUnit() {\n    const textureUnit = textureUnits;\n\n    if (textureUnit >= maxTextures) {\n      console.warn(\n        'THREE.WebGLTextures: Trying to use ' +\n          textureUnit +\n          ' texture units while this GPU supports only ' +\n          maxTextures,\n      );\n    }\n\n    textureUnits += 1;\n\n    return textureUnit;\n  }\n\n  //\n\n  function setTexture2D(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (texture.isVideoTexture) updateVideoTexture(texture);\n\n    if (\n      texture.version > 0 &&\n      textureProperties.__version !== texture.version\n    ) {\n      const image = texture.image;\n\n      if (image === undefined) {\n        console.warn(\n          'THREE.WebGLRenderer: Texture marked for update but image is undefined',\n        );\n      } else if (image.complete === false) {\n        console.warn(\n          'THREE.WebGLRenderer: Texture marked for update but image is incomplete',\n        );\n      } else {\n        uploadTexture(textureProperties, texture, slot);\n        return;\n      }\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(3553, textureProperties.__webglTexture);\n  }\n\n  function setTexture2DArray(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (\n      texture.version > 0 &&\n      textureProperties.__version !== texture.version\n    ) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(35866, textureProperties.__webglTexture);\n  }\n\n  function setTexture3D(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (\n      texture.version > 0 &&\n      textureProperties.__version !== texture.version\n    ) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(32879, textureProperties.__webglTexture);\n  }\n\n  function setTextureCube(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (\n      texture.version > 0 &&\n      textureProperties.__version !== texture.version\n    ) {\n      uploadCubeTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(34067, textureProperties.__webglTexture);\n  }\n\n  const wrappingToGL = {\n    [RepeatWrapping]: 10497,\n    [ClampToEdgeWrapping]: 33071,\n    [MirroredRepeatWrapping]: 33648,\n  };\n\n  const filterToGL = {\n    [NearestFilter]: 9728,\n    [NearestMipmapNearestFilter]: 9984,\n    [NearestMipmapLinearFilter]: 9986,\n\n    [LinearFilter]: 9729,\n    [LinearMipmapNearestFilter]: 9985,\n    [LinearMipmapLinearFilter]: 9987,\n  };\n\n  function setTextureParameters(textureType, texture, supportsMips) {\n    if (supportsMips) {\n      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);\n      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);\n\n      if (textureType === 32879 || textureType === 35866) {\n        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);\n      }\n\n      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);\n      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);\n    } else {\n      _gl.texParameteri(textureType, 10242, 33071);\n      _gl.texParameteri(textureType, 10243, 33071);\n\n      if (textureType === 32879 || textureType === 35866) {\n        _gl.texParameteri(textureType, 32882, 33071);\n      }\n\n      if (\n        texture.wrapS !== ClampToEdgeWrapping ||\n        texture.wrapT !== ClampToEdgeWrapping\n      ) {\n        console.warn(\n          'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',\n        );\n      }\n\n      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));\n      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));\n\n      if (\n        texture.minFilter !== NearestFilter &&\n        texture.minFilter !== LinearFilter\n      ) {\n        console.warn(\n          'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',\n        );\n      }\n    }\n\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n\n      if (\n        texture.type === FloatType &&\n        extensions.has('OES_texture_float_linear') === false\n      )\n        return; // verify extension for WebGL 1 and WebGL 2\n      if (\n        isWebGL2 === false &&\n        texture.type === HalfFloatType &&\n        extensions.has('OES_texture_half_float_linear') === false\n      )\n        return; // verify extension for WebGL 1 only\n\n      if (\n        texture.anisotropy > 1 ||\n        properties.get(texture).__currentAnisotropy\n      ) {\n        _gl.texParameterf(\n          textureType,\n          extension.TEXTURE_MAX_ANISOTROPY_EXT,\n          Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()),\n        );\n        properties.get(texture).__currentAnisotropy = texture.anisotropy;\n      }\n    }\n  }\n\n  function initTexture(textureProperties, texture) {\n    if (textureProperties.__webglInit === undefined) {\n      textureProperties.__webglInit = true;\n\n      texture.addEventListener('dispose', onTextureDispose);\n\n      textureProperties.__webglTexture = _gl.createTexture();\n\n      info.memory.textures++;\n    }\n  }\n\n  function uploadTexture(textureProperties, texture, slot) {\n    let textureType = 3553;\n\n    if (texture.isDataTexture2DArray) textureType = 35866;\n    if (texture.isDataTexture3D) textureType = 32879;\n\n    initTexture(textureProperties, texture);\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(textureType, textureProperties.__webglTexture);\n\n    _gl.pixelStorei(37440, texture.flipY);\n    _gl.pixelStorei(37441, texture.premultiplyAlpha);\n    _gl.pixelStorei(3317, texture.unpackAlignment);\n    _gl.pixelStorei(37443, 0);\n\n    const needsPowerOfTwo =\n      textureNeedsPowerOfTwo(texture) &&\n      isPowerOfTwo$1(texture.image) === false;\n    const image = resizeImage(\n      texture.image,\n      needsPowerOfTwo,\n      false,\n      maxTextureSize,\n    );\n\n    const supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n      glFormat = utils.convert(texture.format);\n\n    let glType = utils.convert(texture.type),\n      glInternalFormat = getInternalFormat(\n        texture.internalFormat,\n        glFormat,\n        glType,\n        texture.encoding,\n      );\n\n    setTextureParameters(textureType, texture, supportsMips);\n\n    let mipmap;\n    const mipmaps = texture.mipmaps;\n\n    if (texture.isDepthTexture) {\n      // populate depth texture with dummy data\n\n      glInternalFormat = 6402;\n\n      if (isWebGL2) {\n        if (texture.type === FloatType) {\n          glInternalFormat = 36012;\n        } else if (texture.type === UnsignedIntType) {\n          glInternalFormat = 33190;\n        } else if (texture.type === UnsignedInt248Type) {\n          glInternalFormat = 35056;\n        } else {\n          glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D\n        }\n      } else {\n        if (texture.type === FloatType) {\n          console.error(\n            'WebGLRenderer: Floating point depth texture requires WebGL2.',\n          );\n        }\n      }\n\n      // validation checks for WebGL 1\n\n      if (texture.format === DepthFormat && glInternalFormat === 6402) {\n        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n        if (\n          texture.type !== UnsignedShortType &&\n          texture.type !== UnsignedIntType\n        ) {\n          console.warn(\n            'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.',\n          );\n\n          texture.type = UnsignedShortType;\n          glType = utils.convert(texture.type);\n        }\n      }\n\n      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {\n        // Depth stencil textures need the DEPTH_STENCIL internal format\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n        glInternalFormat = 34041;\n\n        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n        if (texture.type !== UnsignedInt248Type) {\n          console.warn(\n            'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.',\n          );\n\n          texture.type = UnsignedInt248Type;\n          glType = utils.convert(texture.type);\n        }\n      }\n\n      //\n\n      state.texImage2D(\n        3553,\n        0,\n        glInternalFormat,\n        image.width,\n        image.height,\n        0,\n        glFormat,\n        glType,\n        null,\n      );\n    } else if (texture.isDataTexture) {\n      // use manually created mipmaps if available\n      // if there are no manual mipmaps\n      // set 0 level mipmap and then use GL to generate other mipmap levels\n\n      if (mipmaps.length > 0 && supportsMips) {\n        for (let i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n          state.texImage2D(\n            3553,\n            i,\n            glInternalFormat,\n            mipmap.width,\n            mipmap.height,\n            0,\n            glFormat,\n            glType,\n            mipmap.data,\n          );\n        }\n\n        texture.generateMipmaps = false;\n        textureProperties.__maxMipLevel = mipmaps.length - 1;\n      } else {\n        state.texImage2D(\n          3553,\n          0,\n          glInternalFormat,\n          image.width,\n          image.height,\n          0,\n          glFormat,\n          glType,\n          image.data,\n        );\n        textureProperties.__maxMipLevel = 0;\n      }\n    } else if (texture.isCompressedTexture) {\n      for (let i = 0, il = mipmaps.length; i < il; i++) {\n        mipmap = mipmaps[i];\n\n        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n          if (glFormat !== null) {\n            state.compressedTexImage2D(\n              3553,\n              i,\n              glInternalFormat,\n              mipmap.width,\n              mipmap.height,\n              0,\n              mipmap.data,\n            );\n          } else {\n            console.warn(\n              'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',\n            );\n          }\n        } else {\n          state.texImage2D(\n            3553,\n            i,\n            glInternalFormat,\n            mipmap.width,\n            mipmap.height,\n            0,\n            glFormat,\n            glType,\n            mipmap.data,\n          );\n        }\n      }\n\n      textureProperties.__maxMipLevel = mipmaps.length - 1;\n    } else if (texture.isDataTexture2DArray) {\n      state.texImage3D(\n        35866,\n        0,\n        glInternalFormat,\n        image.width,\n        image.height,\n        image.depth,\n        0,\n        glFormat,\n        glType,\n        image.data,\n      );\n      textureProperties.__maxMipLevel = 0;\n    } else if (texture.isDataTexture3D) {\n      state.texImage3D(\n        32879,\n        0,\n        glInternalFormat,\n        image.width,\n        image.height,\n        image.depth,\n        0,\n        glFormat,\n        glType,\n        image.data,\n      );\n      textureProperties.__maxMipLevel = 0;\n    } else {\n      // regular Texture (image, video, canvas)\n\n      // use manually created mipmaps if available\n      // if there are no manual mipmaps\n      // set 0 level mipmap and then use GL to generate other mipmap levels\n\n      if (mipmaps.length > 0 && supportsMips) {\n        for (let i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);\n        }\n\n        texture.generateMipmaps = false;\n        textureProperties.__maxMipLevel = mipmaps.length - 1;\n      } else {\n        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);\n        textureProperties.__maxMipLevel = 0;\n      }\n    }\n\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      generateMipmap(textureType, texture, image.width, image.height);\n    }\n\n    textureProperties.__version = texture.version;\n\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n\n  function uploadCubeTexture(textureProperties, texture, slot) {\n    if (texture.image.length !== 6) return;\n\n    initTexture(textureProperties, texture);\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(34067, textureProperties.__webglTexture);\n\n    _gl.pixelStorei(37440, texture.flipY);\n    _gl.pixelStorei(37441, texture.premultiplyAlpha);\n    _gl.pixelStorei(3317, texture.unpackAlignment);\n    _gl.pixelStorei(37443, 0);\n\n    const isCompressed =\n      texture &&\n      (texture.isCompressedTexture || texture.image[0].isCompressedTexture);\n    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n\n    const cubeImage = [];\n\n    for (let i = 0; i < 6; i++) {\n      if (!isCompressed && !isDataTexture) {\n        cubeImage[i] = resizeImage(\n          texture.image[i],\n          false,\n          true,\n          maxCubemapSize,\n        );\n      } else {\n        cubeImage[i] = isDataTexture\n          ? texture.image[i].image\n          : texture.image[i];\n      }\n    }\n\n    const image = cubeImage[0],\n      supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n      glFormat = utils.convert(texture.format),\n      glType = utils.convert(texture.type),\n      glInternalFormat = getInternalFormat(\n        texture.internalFormat,\n        glFormat,\n        glType,\n        texture.encoding,\n      );\n\n    setTextureParameters(34067, texture, supportsMips);\n\n    let mipmaps;\n\n    if (isCompressed) {\n      for (let i = 0; i < 6; i++) {\n        mipmaps = cubeImage[i].mipmaps;\n\n        for (let j = 0; j < mipmaps.length; j++) {\n          const mipmap = mipmaps[j];\n\n          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n            if (glFormat !== null) {\n              state.compressedTexImage2D(\n                34069 + i,\n                j,\n                glInternalFormat,\n                mipmap.width,\n                mipmap.height,\n                0,\n                mipmap.data,\n              );\n            } else {\n              console.warn(\n                'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',\n              );\n            }\n          } else {\n            state.texImage2D(\n              34069 + i,\n              j,\n              glInternalFormat,\n              mipmap.width,\n              mipmap.height,\n              0,\n              glFormat,\n              glType,\n              mipmap.data,\n            );\n          }\n        }\n      }\n\n      textureProperties.__maxMipLevel = mipmaps.length - 1;\n    } else {\n      mipmaps = texture.mipmaps;\n\n      for (let i = 0; i < 6; i++) {\n        if (isDataTexture) {\n          state.texImage2D(\n            34069 + i,\n            0,\n            glInternalFormat,\n            cubeImage[i].width,\n            cubeImage[i].height,\n            0,\n            glFormat,\n            glType,\n            cubeImage[i].data,\n          );\n\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n            const mipmapImage = mipmap.image[i].image;\n\n            state.texImage2D(\n              34069 + i,\n              j + 1,\n              glInternalFormat,\n              mipmapImage.width,\n              mipmapImage.height,\n              0,\n              glFormat,\n              glType,\n              mipmapImage.data,\n            );\n          }\n        } else {\n          state.texImage2D(\n            34069 + i,\n            0,\n            glInternalFormat,\n            glFormat,\n            glType,\n            cubeImage[i],\n          );\n\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n\n            state.texImage2D(\n              34069 + i,\n              j + 1,\n              glInternalFormat,\n              glFormat,\n              glType,\n              mipmap.image[i],\n            );\n          }\n        }\n      }\n\n      textureProperties.__maxMipLevel = mipmaps.length;\n    }\n\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      // We assume images for cube map have the same size.\n      generateMipmap(34067, texture, image.width, image.height);\n    }\n\n    textureProperties.__version = texture.version;\n\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n\n  // Render targets\n\n  // Setup storage for target texture and bind it to correct framebuffer\n  function setupFrameBufferTexture(\n    framebuffer,\n    renderTarget,\n    texture,\n    attachment,\n    textureTarget,\n  ) {\n    const glFormat = utils.convert(texture.format);\n    const glType = utils.convert(texture.type);\n    const glInternalFormat = getInternalFormat(\n      texture.internalFormat,\n      glFormat,\n      glType,\n      texture.encoding,\n    );\n\n    if (textureTarget === 32879 || textureTarget === 35866) {\n      state.texImage3D(\n        textureTarget,\n        0,\n        glInternalFormat,\n        renderTarget.width,\n        renderTarget.height,\n        renderTarget.depth,\n        0,\n        glFormat,\n        glType,\n        null,\n      );\n    } else {\n      state.texImage2D(\n        textureTarget,\n        0,\n        glInternalFormat,\n        renderTarget.width,\n        renderTarget.height,\n        0,\n        glFormat,\n        glType,\n        null,\n      );\n    }\n\n    state.bindFramebuffer(36160, framebuffer);\n    _gl.framebufferTexture2D(\n      36160,\n      attachment,\n      textureTarget,\n      properties.get(texture).__webglTexture,\n      0,\n    );\n    state.bindFramebuffer(36160, null);\n  }\n\n  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n    _gl.bindRenderbuffer(36161, renderbuffer);\n\n    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n      let glInternalFormat = 33189;\n\n      if (isMultisample) {\n        const depthTexture = renderTarget.depthTexture;\n\n        if (depthTexture && depthTexture.isDepthTexture) {\n          if (depthTexture.type === FloatType) {\n            glInternalFormat = 36012;\n          } else if (depthTexture.type === UnsignedIntType) {\n            glInternalFormat = 33190;\n          }\n        }\n\n        const samples = getRenderTargetSamples(renderTarget);\n\n        _gl.renderbufferStorageMultisample(\n          36161,\n          samples,\n          glInternalFormat,\n          renderTarget.width,\n          renderTarget.height,\n        );\n      } else {\n        _gl.renderbufferStorage(\n          36161,\n          glInternalFormat,\n          renderTarget.width,\n          renderTarget.height,\n        );\n      }\n\n      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);\n    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n      if (isMultisample) {\n        const samples = getRenderTargetSamples(renderTarget);\n\n        _gl.renderbufferStorageMultisample(\n          36161,\n          samples,\n          35056,\n          renderTarget.width,\n          renderTarget.height,\n        );\n      } else {\n        _gl.renderbufferStorage(\n          36161,\n          34041,\n          renderTarget.width,\n          renderTarget.height,\n        );\n      }\n\n      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);\n    } else {\n      // Use the first texture for MRT so far\n      const texture =\n        renderTarget.isWebGLMultipleRenderTargets === true\n          ? renderTarget.texture[0]\n          : renderTarget.texture;\n\n      const glFormat = utils.convert(texture.format);\n      const glType = utils.convert(texture.type);\n      const glInternalFormat = getInternalFormat(\n        texture.internalFormat,\n        glFormat,\n        glType,\n        texture.encoding,\n      );\n\n      if (isMultisample) {\n        const samples = getRenderTargetSamples(renderTarget);\n\n        _gl.renderbufferStorageMultisample(\n          36161,\n          samples,\n          glInternalFormat,\n          renderTarget.width,\n          renderTarget.height,\n        );\n      } else {\n        _gl.renderbufferStorage(\n          36161,\n          glInternalFormat,\n          renderTarget.width,\n          renderTarget.height,\n        );\n      }\n    }\n\n    _gl.bindRenderbuffer(36161, null);\n  }\n\n  // Setup resources for a Depth Texture for a FBO (needs an extension)\n  function setupDepthTexture(framebuffer, renderTarget) {\n    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n    if (isCube)\n      throw new Error(\n        'Depth Texture with cube render targets is not supported',\n      );\n\n    state.bindFramebuffer(36160, framebuffer);\n\n    if (\n      !(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)\n    ) {\n      throw new Error(\n        'renderTarget.depthTexture must be an instance of THREE.DepthTexture',\n      );\n    }\n\n    // upload an empty depth texture with framebuffer size\n    if (\n      !properties.get(renderTarget.depthTexture).__webglTexture ||\n      renderTarget.depthTexture.image.width !== renderTarget.width ||\n      renderTarget.depthTexture.image.height !== renderTarget.height\n    ) {\n      renderTarget.depthTexture.image.width = renderTarget.width;\n      renderTarget.depthTexture.image.height = renderTarget.height;\n      renderTarget.depthTexture.needsUpdate = true;\n    }\n\n    setTexture2D(renderTarget.depthTexture, 0);\n\n    const webglDepthTexture = properties.get(\n      renderTarget.depthTexture,\n    ).__webglTexture;\n\n    if (renderTarget.depthTexture.format === DepthFormat) {\n      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);\n    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);\n    } else {\n      throw new Error('Unknown depthTexture format');\n    }\n  }\n\n  // Setup GL resources for a non-texture depth buffer\n  function setupDepthRenderbuffer(renderTarget) {\n    const renderTargetProperties = properties.get(renderTarget);\n\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n    if (renderTarget.depthTexture) {\n      if (isCube)\n        throw new Error(\n          'target.depthTexture not supported in Cube render targets',\n        );\n\n      setupDepthTexture(\n        renderTargetProperties.__webglFramebuffer,\n        renderTarget,\n      );\n    } else {\n      if (isCube) {\n        renderTargetProperties.__webglDepthbuffer = [];\n\n        for (let i = 0; i < 6; i++) {\n          state.bindFramebuffer(\n            36160,\n            renderTargetProperties.__webglFramebuffer[i],\n          );\n          renderTargetProperties.__webglDepthbuffer[i] =\n            _gl.createRenderbuffer();\n          setupRenderBufferStorage(\n            renderTargetProperties.__webglDepthbuffer[i],\n            renderTarget,\n            false,\n          );\n        }\n      } else {\n        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);\n        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n        setupRenderBufferStorage(\n          renderTargetProperties.__webglDepthbuffer,\n          renderTarget,\n          false,\n        );\n      }\n    }\n\n    state.bindFramebuffer(36160, null);\n  }\n\n  // Set up GL resources for the render target\n  function setupRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n\n    renderTarget.addEventListener('dispose', onRenderTargetDispose);\n\n    if (renderTarget.isWebGLMultipleRenderTargets !== true) {\n      textureProperties.__webglTexture = _gl.createTexture();\n      textureProperties.__version = texture.version;\n      info.memory.textures++;\n    }\n\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    const isMultipleRenderTargets =\n      renderTarget.isWebGLMultipleRenderTargets === true;\n    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;\n    const isRenderTarget3D =\n      texture.isDataTexture3D || texture.isDataTexture2DArray;\n    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n\n    // Handles WebGL2 RGBFormat fallback - #18858\n\n    if (\n      isWebGL2 &&\n      texture.format === RGBFormat &&\n      (texture.type === FloatType || texture.type === HalfFloatType)\n    ) {\n      texture.format = RGBAFormat;\n\n      console.warn(\n        'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.',\n      );\n    }\n\n    // Setup framebuffer\n\n    if (isCube) {\n      renderTargetProperties.__webglFramebuffer = [];\n\n      for (let i = 0; i < 6; i++) {\n        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n      }\n    } else {\n      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n      if (isMultipleRenderTargets) {\n        if (capabilities.drawBuffers) {\n          const textures = renderTarget.texture;\n\n          for (let i = 0, il = textures.length; i < il; i++) {\n            const attachmentProperties = properties.get(textures[i]);\n\n            if (attachmentProperties.__webglTexture === undefined) {\n              attachmentProperties.__webglTexture = _gl.createTexture();\n\n              info.memory.textures++;\n            }\n          }\n        } else {\n          console.warn(\n            'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.',\n          );\n        }\n      } else if (isMultisample) {\n        if (isWebGL2) {\n          renderTargetProperties.__webglMultisampledFramebuffer =\n            _gl.createFramebuffer();\n          renderTargetProperties.__webglColorRenderbuffer =\n            _gl.createRenderbuffer();\n\n          _gl.bindRenderbuffer(\n            36161,\n            renderTargetProperties.__webglColorRenderbuffer,\n          );\n\n          const glFormat = utils.convert(texture.format);\n          const glType = utils.convert(texture.type);\n          const glInternalFormat = getInternalFormat(\n            texture.internalFormat,\n            glFormat,\n            glType,\n            texture.encoding,\n          );\n          const samples = getRenderTargetSamples(renderTarget);\n          _gl.renderbufferStorageMultisample(\n            36161,\n            samples,\n            glInternalFormat,\n            renderTarget.width,\n            renderTarget.height,\n          );\n\n          state.bindFramebuffer(\n            36160,\n            renderTargetProperties.__webglMultisampledFramebuffer,\n          );\n          _gl.framebufferRenderbuffer(\n            36160,\n            36064,\n            36161,\n            renderTargetProperties.__webglColorRenderbuffer,\n          );\n          _gl.bindRenderbuffer(36161, null);\n\n          if (renderTarget.depthBuffer) {\n            renderTargetProperties.__webglDepthRenderbuffer =\n              _gl.createRenderbuffer();\n            setupRenderBufferStorage(\n              renderTargetProperties.__webglDepthRenderbuffer,\n              renderTarget,\n              true,\n            );\n          }\n\n          state.bindFramebuffer(36160, null);\n        } else {\n          console.warn(\n            'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',\n          );\n        }\n      }\n    }\n\n    // Setup color buffer\n\n    if (isCube) {\n      state.bindTexture(34067, textureProperties.__webglTexture);\n      setTextureParameters(34067, texture, supportsMips);\n\n      for (let i = 0; i < 6; i++) {\n        setupFrameBufferTexture(\n          renderTargetProperties.__webglFramebuffer[i],\n          renderTarget,\n          texture,\n          36064,\n          34069 + i,\n        );\n      }\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);\n      }\n\n      state.unbindTexture();\n    } else if (isMultipleRenderTargets) {\n      const textures = renderTarget.texture;\n\n      for (let i = 0, il = textures.length; i < il; i++) {\n        const attachment = textures[i];\n        const attachmentProperties = properties.get(attachment);\n\n        state.bindTexture(3553, attachmentProperties.__webglTexture);\n        setTextureParameters(3553, attachment, supportsMips);\n        setupFrameBufferTexture(\n          renderTargetProperties.__webglFramebuffer,\n          renderTarget,\n          attachment,\n          36064 + i,\n          3553,\n        );\n\n        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {\n          generateMipmap(\n            3553,\n            attachment,\n            renderTarget.width,\n            renderTarget.height,\n          );\n        }\n      }\n\n      state.unbindTexture();\n    } else {\n      let glTextureType = 3553;\n\n      if (isRenderTarget3D) {\n        // Render targets containing layers, i.e: Texture 3D and 2d arrays\n\n        if (isWebGL2) {\n          const isTexture3D = texture.isDataTexture3D;\n          glTextureType = isTexture3D ? 32879 : 35866;\n        } else {\n          console.warn(\n            'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.',\n          );\n        }\n      }\n\n      state.bindTexture(glTextureType, textureProperties.__webglTexture);\n      setTextureParameters(glTextureType, texture, supportsMips);\n      setupFrameBufferTexture(\n        renderTargetProperties.__webglFramebuffer,\n        renderTarget,\n        texture,\n        36064,\n        glTextureType,\n      );\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(\n          glTextureType,\n          texture,\n          renderTarget.width,\n          renderTarget.height,\n          renderTarget.depth,\n        );\n      }\n\n      state.unbindTexture();\n    }\n\n    // Setup depth and stencil buffers\n\n    if (renderTarget.depthBuffer) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  }\n\n  function updateRenderTargetMipmap(renderTarget) {\n    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n\n    const textures =\n      renderTarget.isWebGLMultipleRenderTargets === true\n        ? renderTarget.texture\n        : [renderTarget.texture];\n\n    for (let i = 0, il = textures.length; i < il; i++) {\n      const texture = textures[i];\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;\n        const webglTexture = properties.get(texture).__webglTexture;\n\n        state.bindTexture(target, webglTexture);\n        generateMipmap(\n          target,\n          texture,\n          renderTarget.width,\n          renderTarget.height,\n        );\n        state.unbindTexture();\n      }\n    }\n  }\n\n  function updateMultisampleRenderTarget(renderTarget) {\n    if (renderTarget.isWebGLMultisampleRenderTarget) {\n      if (isWebGL2) {\n        const width = renderTarget.width;\n        const height = renderTarget.height;\n        let mask = 16384;\n\n        if (renderTarget.depthBuffer) mask |= 256;\n        if (renderTarget.stencilBuffer) mask |= 1024;\n\n        const renderTargetProperties = properties.get(renderTarget);\n\n        state.bindFramebuffer(\n          36008,\n          renderTargetProperties.__webglMultisampledFramebuffer,\n        );\n        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);\n\n        _gl.blitFramebuffer(\n          0,\n          0,\n          width,\n          height,\n          0,\n          0,\n          width,\n          height,\n          mask,\n          9728,\n        );\n\n        state.bindFramebuffer(36008, null);\n        state.bindFramebuffer(\n          36009,\n          renderTargetProperties.__webglMultisampledFramebuffer,\n        );\n      } else {\n        console.warn(\n          'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',\n        );\n      }\n    }\n  }\n\n  function getRenderTargetSamples(renderTarget) {\n    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget\n      ? Math.min(maxSamples, renderTarget.samples)\n      : 0;\n  }\n\n  function updateVideoTexture(texture) {\n    const frame = info.render.frame;\n\n    // Check the last frame we updated the VideoTexture\n\n    if (_videoTextures.get(texture) !== frame) {\n      _videoTextures.set(texture, frame);\n      texture.update();\n    }\n  }\n\n  // backwards compatibility\n\n  let warnedTexture2D = false;\n  let warnedTextureCube = false;\n\n  function safeSetTexture2D(texture, slot) {\n    if (texture && texture.isWebGLRenderTarget) {\n      if (warnedTexture2D === false) {\n        console.warn(\n          \"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.\",\n        );\n        warnedTexture2D = true;\n      }\n\n      texture = texture.texture;\n    }\n\n    setTexture2D(texture, slot);\n  }\n\n  function safeSetTextureCube(texture, slot) {\n    if (texture && texture.isWebGLCubeRenderTarget) {\n      if (warnedTextureCube === false) {\n        console.warn(\n          \"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.\",\n        );\n        warnedTextureCube = true;\n      }\n\n      texture = texture.texture;\n    }\n\n    setTextureCube(texture, slot);\n  }\n\n  //\n\n  this.allocateTextureUnit = allocateTextureUnit;\n  this.resetTextureUnits = resetTextureUnits;\n\n  this.setTexture2D = setTexture2D;\n  this.setTexture2DArray = setTexture2DArray;\n  this.setTexture3D = setTexture3D;\n  this.setTextureCube = setTextureCube;\n  this.setupRenderTarget = setupRenderTarget;\n  this.updateRenderTargetMipmap = updateRenderTargetMipmap;\n  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\n  this.safeSetTexture2D = safeSetTexture2D;\n  this.safeSetTextureCube = safeSetTextureCube;\n}\n\nfunction WebGLUtils(gl, extensions, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n\n  function convert(p) {\n    let extension;\n\n    if (p === UnsignedByteType) return 5121;\n    if (p === UnsignedShort4444Type) return 32819;\n    if (p === UnsignedShort5551Type) return 32820;\n    if (p === UnsignedShort565Type) return 33635;\n\n    if (p === ByteType) return 5120;\n    if (p === ShortType) return 5122;\n    if (p === UnsignedShortType) return 5123;\n    if (p === IntType) return 5124;\n    if (p === UnsignedIntType) return 5125;\n    if (p === FloatType) return 5126;\n\n    if (p === HalfFloatType) {\n      if (isWebGL2) return 5131;\n\n      extension = extensions.get('OES_texture_half_float');\n\n      if (extension !== null) {\n        return extension.HALF_FLOAT_OES;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === AlphaFormat) return 6406;\n    if (p === RGBFormat) return 6407;\n    if (p === RGBAFormat) return 6408;\n    if (p === LuminanceFormat) return 6409;\n    if (p === LuminanceAlphaFormat) return 6410;\n    if (p === DepthFormat) return 6402;\n    if (p === DepthStencilFormat) return 34041;\n    if (p === RedFormat) return 6403;\n\n    // WebGL2 formats.\n\n    if (p === RedIntegerFormat) return 36244;\n    if (p === RGFormat) return 33319;\n    if (p === RGIntegerFormat) return 33320;\n    if (p === RGBIntegerFormat) return 36248;\n    if (p === RGBAIntegerFormat) return 36249;\n\n    if (\n      p === RGB_S3TC_DXT1_Format ||\n      p === RGBA_S3TC_DXT1_Format ||\n      p === RGBA_S3TC_DXT3_Format ||\n      p === RGBA_S3TC_DXT5_Format\n    ) {\n      extension = extensions.get('WEBGL_compressed_texture_s3tc');\n\n      if (extension !== null) {\n        if (p === RGB_S3TC_DXT1_Format)\n          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n        if (p === RGBA_S3TC_DXT1_Format)\n          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n        if (p === RGBA_S3TC_DXT3_Format)\n          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n        if (p === RGBA_S3TC_DXT5_Format)\n          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n      } else {\n        return null;\n      }\n    }\n\n    if (\n      p === RGB_PVRTC_4BPPV1_Format ||\n      p === RGB_PVRTC_2BPPV1_Format ||\n      p === RGBA_PVRTC_4BPPV1_Format ||\n      p === RGBA_PVRTC_2BPPV1_Format\n    ) {\n      extension = extensions.get('WEBGL_compressed_texture_pvrtc');\n\n      if (extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format)\n          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === RGB_PVRTC_2BPPV1_Format)\n          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (p === RGBA_PVRTC_4BPPV1_Format)\n          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === RGBA_PVRTC_2BPPV1_Format)\n          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === RGB_ETC1_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_etc1');\n\n      if (extension !== null) {\n        return extension.COMPRESSED_RGB_ETC1_WEBGL;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_etc');\n\n      if (extension !== null) {\n        if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format)\n          return extension.COMPRESSED_RGBA8_ETC2_EAC;\n      }\n    }\n\n    if (\n      p === RGBA_ASTC_4x4_Format ||\n      p === RGBA_ASTC_5x4_Format ||\n      p === RGBA_ASTC_5x5_Format ||\n      p === RGBA_ASTC_6x5_Format ||\n      p === RGBA_ASTC_6x6_Format ||\n      p === RGBA_ASTC_8x5_Format ||\n      p === RGBA_ASTC_8x6_Format ||\n      p === RGBA_ASTC_8x8_Format ||\n      p === RGBA_ASTC_10x5_Format ||\n      p === RGBA_ASTC_10x6_Format ||\n      p === RGBA_ASTC_10x8_Format ||\n      p === RGBA_ASTC_10x10_Format ||\n      p === RGBA_ASTC_12x10_Format ||\n      p === RGBA_ASTC_12x12_Format ||\n      p === SRGB8_ALPHA8_ASTC_4x4_Format ||\n      p === SRGB8_ALPHA8_ASTC_5x4_Format ||\n      p === SRGB8_ALPHA8_ASTC_5x5_Format ||\n      p === SRGB8_ALPHA8_ASTC_6x5_Format ||\n      p === SRGB8_ALPHA8_ASTC_6x6_Format ||\n      p === SRGB8_ALPHA8_ASTC_8x5_Format ||\n      p === SRGB8_ALPHA8_ASTC_8x6_Format ||\n      p === SRGB8_ALPHA8_ASTC_8x8_Format ||\n      p === SRGB8_ALPHA8_ASTC_10x5_Format ||\n      p === SRGB8_ALPHA8_ASTC_10x6_Format ||\n      p === SRGB8_ALPHA8_ASTC_10x8_Format ||\n      p === SRGB8_ALPHA8_ASTC_10x10_Format ||\n      p === SRGB8_ALPHA8_ASTC_12x10_Format ||\n      p === SRGB8_ALPHA8_ASTC_12x12_Format\n    ) {\n      extension = extensions.get('WEBGL_compressed_texture_astc');\n\n      if (extension !== null) {\n        // TODO Complete?\n\n        return p;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === RGBA_BPTC_Format) {\n      extension = extensions.get('EXT_texture_compression_bptc');\n\n      if (extension !== null) {\n        // TODO Complete?\n\n        return p;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === UnsignedInt248Type) {\n      if (isWebGL2) return 34042;\n\n      extension = extensions.get('WEBGL_depth_texture');\n\n      if (extension !== null) {\n        return extension.UNSIGNED_INT_24_8_WEBGL;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return { convert: convert };\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n  constructor(array = []) {\n    super();\n\n    this.cameras = array;\n  }\n}\n\nArrayCamera.prototype.isArrayCamera = true;\n\nclass Group extends Object3D {\n  constructor() {\n    super();\n\n    this.type = 'Group';\n  }\n}\n\nGroup.prototype.isGroup = true;\n\nconst _moveEvent = { type: 'move' };\n\nclass WebXRController {\n  constructor() {\n    this._targetRay = null;\n    this._grip = null;\n    this._hand = null;\n  }\n\n  getHandSpace() {\n    if (this._hand === null) {\n      this._hand = new Group();\n      this._hand.matrixAutoUpdate = false;\n      this._hand.visible = false;\n\n      this._hand.joints = {};\n      this._hand.inputState = { pinching: false };\n    }\n\n    return this._hand;\n  }\n\n  getTargetRaySpace() {\n    if (this._targetRay === null) {\n      this._targetRay = new Group();\n      this._targetRay.matrixAutoUpdate = false;\n      this._targetRay.visible = false;\n      this._targetRay.hasLinearVelocity = false;\n      this._targetRay.linearVelocity = new Vector3();\n      this._targetRay.hasAngularVelocity = false;\n      this._targetRay.angularVelocity = new Vector3();\n    }\n\n    return this._targetRay;\n  }\n\n  getGripSpace() {\n    if (this._grip === null) {\n      this._grip = new Group();\n      this._grip.matrixAutoUpdate = false;\n      this._grip.visible = false;\n      this._grip.hasLinearVelocity = false;\n      this._grip.linearVelocity = new Vector3();\n      this._grip.hasAngularVelocity = false;\n      this._grip.angularVelocity = new Vector3();\n    }\n\n    return this._grip;\n  }\n\n  dispatchEvent(event) {\n    if (this._targetRay !== null) {\n      this._targetRay.dispatchEvent(event);\n    }\n\n    if (this._grip !== null) {\n      this._grip.dispatchEvent(event);\n    }\n\n    if (this._hand !== null) {\n      this._hand.dispatchEvent(event);\n    }\n\n    return this;\n  }\n\n  disconnect(inputSource) {\n    this.dispatchEvent({ type: 'disconnected', data: inputSource });\n\n    if (this._targetRay !== null) {\n      this._targetRay.visible = false;\n    }\n\n    if (this._grip !== null) {\n      this._grip.visible = false;\n    }\n\n    if (this._hand !== null) {\n      this._hand.visible = false;\n    }\n\n    return this;\n  }\n\n  update(inputSource, frame, referenceSpace) {\n    let inputPose = null;\n    let gripPose = null;\n    let handPose = null;\n\n    const targetRay = this._targetRay;\n    const grip = this._grip;\n    const hand = this._hand;\n\n    if (inputSource && frame.session.visibilityState !== 'visible-blurred') {\n      if (targetRay !== null) {\n        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n\n        if (inputPose !== null) {\n          targetRay.matrix.fromArray(inputPose.transform.matrix);\n          targetRay.matrix.decompose(\n            targetRay.position,\n            targetRay.rotation,\n            targetRay.scale,\n          );\n\n          if (inputPose.linearVelocity) {\n            targetRay.hasLinearVelocity = true;\n            targetRay.linearVelocity.copy(inputPose.linearVelocity);\n          } else {\n            targetRay.hasLinearVelocity = false;\n          }\n\n          if (inputPose.angularVelocity) {\n            targetRay.hasAngularVelocity = true;\n            targetRay.angularVelocity.copy(inputPose.angularVelocity);\n          } else {\n            targetRay.hasAngularVelocity = false;\n          }\n\n          this.dispatchEvent(_moveEvent);\n        }\n      }\n\n      if (hand && inputSource.hand) {\n        handPose = true;\n\n        for (const inputjoint of inputSource.hand.values()) {\n          // Update the joints groups with the XRJoint poses\n          const jointPose = frame.getJointPose(inputjoint, referenceSpace);\n\n          if (hand.joints[inputjoint.jointName] === undefined) {\n            // The transform of this joint will be updated with the joint pose on each frame\n            const joint = new Group();\n            joint.matrixAutoUpdate = false;\n            joint.visible = false;\n            hand.joints[inputjoint.jointName] = joint;\n            // ??\n            hand.add(joint);\n          }\n\n          const joint = hand.joints[inputjoint.jointName];\n\n          if (jointPose !== null) {\n            joint.matrix.fromArray(jointPose.transform.matrix);\n            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n            joint.jointRadius = jointPose.radius;\n          }\n\n          joint.visible = jointPose !== null;\n        }\n\n        // Custom events\n\n        // Check pinchz\n        const indexTip = hand.joints['index-finger-tip'];\n        const thumbTip = hand.joints['thumb-tip'];\n        const distance = indexTip.position.distanceTo(thumbTip.position);\n\n        const distanceToPinch = 0.02;\n        const threshold = 0.005;\n\n        if (\n          hand.inputState.pinching &&\n          distance > distanceToPinch + threshold\n        ) {\n          hand.inputState.pinching = false;\n          this.dispatchEvent({\n            type: 'pinchend',\n            handedness: inputSource.handedness,\n            target: this,\n          });\n        } else if (\n          !hand.inputState.pinching &&\n          distance <= distanceToPinch - threshold\n        ) {\n          hand.inputState.pinching = true;\n          this.dispatchEvent({\n            type: 'pinchstart',\n            handedness: inputSource.handedness,\n            target: this,\n          });\n        }\n      } else {\n        if (grip !== null && inputSource.gripSpace) {\n          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n\n          if (gripPose !== null) {\n            grip.matrix.fromArray(gripPose.transform.matrix);\n            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n\n            if (gripPose.linearVelocity) {\n              grip.hasLinearVelocity = true;\n              grip.linearVelocity.copy(gripPose.linearVelocity);\n            } else {\n              grip.hasLinearVelocity = false;\n            }\n\n            if (gripPose.angularVelocity) {\n              grip.hasAngularVelocity = true;\n              grip.angularVelocity.copy(gripPose.angularVelocity);\n            } else {\n              grip.hasAngularVelocity = false;\n            }\n          }\n        }\n      }\n    }\n\n    if (targetRay !== null) {\n      targetRay.visible = inputPose !== null;\n    }\n\n    if (grip !== null) {\n      grip.visible = gripPose !== null;\n    }\n\n    if (hand !== null) {\n      hand.visible = handPose !== null;\n    }\n\n    return this;\n  }\n}\n\nclass WebXRManager extends EventDispatcher {\n  constructor(renderer, gl) {\n    super();\n\n    const scope = this;\n    const state = renderer.state;\n\n    let session = null;\n    let framebufferScaleFactor = 1.0;\n\n    let referenceSpace = null;\n    let referenceSpaceType = 'local-floor';\n\n    let pose = null;\n    let glBinding = null;\n    let glFramebuffer = null;\n    let glProjLayer = null;\n    let glBaseLayer = null;\n    let isMultisample = false;\n    let glMultisampledFramebuffer = null;\n    let glColorRenderbuffer = null;\n    let glDepthRenderbuffer = null;\n    let xrFrame = null;\n    let depthStyle = null;\n    let clearStyle = null;\n\n    const controllers = [];\n    const inputSourcesMap = new Map();\n\n    //\n\n    const cameraL = new PerspectiveCamera();\n    cameraL.layers.enable(1);\n    cameraL.viewport = new Vector4();\n\n    const cameraR = new PerspectiveCamera();\n    cameraR.layers.enable(2);\n    cameraR.viewport = new Vector4();\n\n    const cameras = [cameraL, cameraR];\n\n    const cameraVR = new ArrayCamera();\n    cameraVR.layers.enable(1);\n    cameraVR.layers.enable(2);\n\n    let _currentDepthNear = null;\n    let _currentDepthFar = null;\n\n    //\n\n    this.cameraAutoUpdate = true;\n    this.enabled = false;\n\n    this.isPresenting = false;\n\n    this.getController = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getTargetRaySpace();\n    };\n\n    this.getControllerGrip = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getGripSpace();\n    };\n\n    this.getHand = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getHandSpace();\n    };\n\n    //\n\n    function onSessionEvent(event) {\n      const controller = inputSourcesMap.get(event.inputSource);\n\n      if (controller) {\n        controller.dispatchEvent({ type: event.type, data: event.inputSource });\n      }\n    }\n\n    function onSessionEnd() {\n      inputSourcesMap.forEach(function (controller, inputSource) {\n        controller.disconnect(inputSource);\n      });\n\n      inputSourcesMap.clear();\n\n      _currentDepthNear = null;\n      _currentDepthFar = null;\n\n      // restore framebuffer/rendering state\n\n      state.bindXRFramebuffer(null);\n      renderer.setRenderTarget(renderer.getRenderTarget());\n\n      if (glFramebuffer) gl.deleteFramebuffer(glFramebuffer);\n      if (glMultisampledFramebuffer)\n        gl.deleteFramebuffer(glMultisampledFramebuffer);\n      if (glColorRenderbuffer) gl.deleteRenderbuffer(glColorRenderbuffer);\n      if (glDepthRenderbuffer) gl.deleteRenderbuffer(glDepthRenderbuffer);\n      glFramebuffer = null;\n      glMultisampledFramebuffer = null;\n      glColorRenderbuffer = null;\n      glDepthRenderbuffer = null;\n      glBaseLayer = null;\n      glProjLayer = null;\n      glBinding = null;\n      session = null;\n\n      //\n\n      animation.stop();\n\n      scope.isPresenting = false;\n\n      scope.dispatchEvent({ type: 'sessionend' });\n    }\n\n    this.setFramebufferScaleFactor = function (value) {\n      framebufferScaleFactor = value;\n\n      if (scope.isPresenting === true) {\n        console.warn(\n          'THREE.WebXRManager: Cannot change framebuffer scale while presenting.',\n        );\n      }\n    };\n\n    this.setReferenceSpaceType = function (value) {\n      referenceSpaceType = value;\n\n      if (scope.isPresenting === true) {\n        console.warn(\n          'THREE.WebXRManager: Cannot change reference space type while presenting.',\n        );\n      }\n    };\n\n    this.getReferenceSpace = function () {\n      return referenceSpace;\n    };\n\n    this.getBaseLayer = function () {\n      return glProjLayer !== null ? glProjLayer : glBaseLayer;\n    };\n\n    this.getBinding = function () {\n      return glBinding;\n    };\n\n    this.getFrame = function () {\n      return xrFrame;\n    };\n\n    this.getSession = function () {\n      return session;\n    };\n\n    this.setSession = async function (value) {\n      session = value;\n\n      if (session !== null) {\n        session.addEventListener('select', onSessionEvent);\n        session.addEventListener('selectstart', onSessionEvent);\n        session.addEventListener('selectend', onSessionEvent);\n        session.addEventListener('squeeze', onSessionEvent);\n        session.addEventListener('squeezestart', onSessionEvent);\n        session.addEventListener('squeezeend', onSessionEvent);\n        session.addEventListener('end', onSessionEnd);\n        session.addEventListener('inputsourceschange', onInputSourcesChange);\n\n        const attributes = gl.getContextAttributes();\n\n        if (attributes.xrCompatible !== true) {\n          await gl.makeXRCompatible();\n        }\n\n        if (session.renderState.layers === undefined) {\n          const layerInit = {\n            antialias: attributes.antialias,\n            alpha: attributes.alpha,\n            depth: attributes.depth,\n            stencil: attributes.stencil,\n            framebufferScaleFactor: framebufferScaleFactor,\n          };\n\n          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n\n          session.updateRenderState({ baseLayer: glBaseLayer });\n        } else if (gl instanceof WebGLRenderingContext) {\n          // Use old style webgl layer because we can't use MSAA\n          // WebGL2 support.\n\n          const layerInit = {\n            antialias: true,\n            alpha: attributes.alpha,\n            depth: attributes.depth,\n            stencil: attributes.stencil,\n            framebufferScaleFactor: framebufferScaleFactor,\n          };\n\n          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n\n          session.updateRenderState({ layers: [glBaseLayer] });\n        } else {\n          isMultisample = attributes.antialias;\n          let depthFormat = null;\n\n          if (attributes.depth) {\n            clearStyle = 256;\n\n            if (attributes.stencil) clearStyle |= 1024;\n\n            depthStyle = attributes.stencil ? 33306 : 36096;\n            depthFormat = attributes.stencil ? 35056 : 33190;\n          }\n\n          const projectionlayerInit = {\n            colorFormat: attributes.alpha ? 32856 : 32849,\n            depthFormat: depthFormat,\n            scaleFactor: framebufferScaleFactor,\n          };\n\n          glBinding = new XRWebGLBinding(session, gl);\n\n          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);\n\n          glFramebuffer = gl.createFramebuffer();\n\n          session.updateRenderState({ layers: [glProjLayer] });\n\n          if (isMultisample) {\n            glMultisampledFramebuffer = gl.createFramebuffer();\n            glColorRenderbuffer = gl.createRenderbuffer();\n            gl.bindRenderbuffer(36161, glColorRenderbuffer);\n            gl.renderbufferStorageMultisample(\n              36161,\n              4,\n              32856,\n              glProjLayer.textureWidth,\n              glProjLayer.textureHeight,\n            );\n            state.bindFramebuffer(36160, glMultisampledFramebuffer);\n            gl.framebufferRenderbuffer(\n              36160,\n              36064,\n              36161,\n              glColorRenderbuffer,\n            );\n            gl.bindRenderbuffer(36161, null);\n\n            if (depthFormat !== null) {\n              glDepthRenderbuffer = gl.createRenderbuffer();\n              gl.bindRenderbuffer(36161, glDepthRenderbuffer);\n              gl.renderbufferStorageMultisample(\n                36161,\n                4,\n                depthFormat,\n                glProjLayer.textureWidth,\n                glProjLayer.textureHeight,\n              );\n              gl.framebufferRenderbuffer(\n                36160,\n                depthStyle,\n                36161,\n                glDepthRenderbuffer,\n              );\n              gl.bindRenderbuffer(36161, null);\n            }\n\n            state.bindFramebuffer(36160, null);\n          }\n        }\n\n        referenceSpace = await session.requestReferenceSpace(\n          referenceSpaceType,\n        );\n\n        animation.setContext(session);\n        animation.start();\n\n        scope.isPresenting = true;\n\n        scope.dispatchEvent({ type: 'sessionstart' });\n      }\n    };\n\n    function onInputSourcesChange(event) {\n      const inputSources = session.inputSources;\n\n      // Assign inputSources to available controllers\n\n      for (let i = 0; i < controllers.length; i++) {\n        inputSourcesMap.set(inputSources[i], controllers[i]);\n      }\n\n      // Notify disconnected\n\n      for (let i = 0; i < event.removed.length; i++) {\n        const inputSource = event.removed[i];\n        const controller = inputSourcesMap.get(inputSource);\n\n        if (controller) {\n          controller.dispatchEvent({ type: 'disconnected', data: inputSource });\n          inputSourcesMap.delete(inputSource);\n        }\n      }\n\n      // Notify connected\n\n      for (let i = 0; i < event.added.length; i++) {\n        const inputSource = event.added[i];\n        const controller = inputSourcesMap.get(inputSource);\n\n        if (controller) {\n          controller.dispatchEvent({ type: 'connected', data: inputSource });\n        }\n      }\n    }\n\n    //\n\n    const cameraLPos = new Vector3();\n    const cameraRPos = new Vector3();\n\n    /**\n     * Assumes 2 cameras that are parallel and share an X-axis, and that\n     * the cameras' projection and world matrices have already been set.\n     * And that near and far planes are identical for both cameras.\n     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n     */\n    function setProjectionFromUnion(camera, cameraL, cameraR) {\n      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n\n      const ipd = cameraLPos.distanceTo(cameraRPos);\n\n      const projL = cameraL.projectionMatrix.elements;\n      const projR = cameraR.projectionMatrix.elements;\n\n      // VR systems will have identical far and near planes, and\n      // most likely identical top and bottom frustum extents.\n      // Use the left camera for these values.\n      const near = projL[14] / (projL[10] - 1);\n      const far = projL[14] / (projL[10] + 1);\n      const topFov = (projL[9] + 1) / projL[5];\n      const bottomFov = (projL[9] - 1) / projL[5];\n\n      const leftFov = (projL[8] - 1) / projL[0];\n      const rightFov = (projR[8] + 1) / projR[0];\n      const left = near * leftFov;\n      const right = near * rightFov;\n\n      // Calculate the new camera's position offset from the\n      // left camera. xOffset should be roughly half `ipd`.\n      const zOffset = ipd / (-leftFov + rightFov);\n      const xOffset = zOffset * -leftFov;\n\n      // TODO: Better way to apply this offset?\n      cameraL.matrixWorld.decompose(\n        camera.position,\n        camera.quaternion,\n        camera.scale,\n      );\n      camera.translateX(xOffset);\n      camera.translateZ(zOffset);\n      camera.matrixWorld.compose(\n        camera.position,\n        camera.quaternion,\n        camera.scale,\n      );\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n\n      // Find the union of the frustum values of the cameras and scale\n      // the values so that the near plane's position does not change in world space,\n      // although must now be relative to the new union camera.\n      const near2 = near + zOffset;\n      const far2 = far + zOffset;\n      const left2 = left - xOffset;\n      const right2 = right + (ipd - xOffset);\n      const top2 = ((topFov * far) / far2) * near2;\n      const bottom2 = ((bottomFov * far) / far2) * near2;\n\n      camera.projectionMatrix.makePerspective(\n        left2,\n        right2,\n        top2,\n        bottom2,\n        near2,\n        far2,\n      );\n    }\n\n    function updateCamera(camera, parent) {\n      if (parent === null) {\n        camera.matrixWorld.copy(camera.matrix);\n      } else {\n        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n      }\n\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    }\n\n    this.updateCamera = function (camera) {\n      if (session === null) return;\n\n      cameraVR.near = cameraR.near = cameraL.near = camera.near;\n      cameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n      if (\n        _currentDepthNear !== cameraVR.near ||\n        _currentDepthFar !== cameraVR.far\n      ) {\n        // Note that the new renderState won't apply until the next frame. See #18320\n\n        session.updateRenderState({\n          depthNear: cameraVR.near,\n          depthFar: cameraVR.far,\n        });\n\n        _currentDepthNear = cameraVR.near;\n        _currentDepthFar = cameraVR.far;\n      }\n\n      const parent = camera.parent;\n      const cameras = cameraVR.cameras;\n\n      updateCamera(cameraVR, parent);\n\n      for (let i = 0; i < cameras.length; i++) {\n        updateCamera(cameras[i], parent);\n      }\n\n      cameraVR.matrixWorld.decompose(\n        cameraVR.position,\n        cameraVR.quaternion,\n        cameraVR.scale,\n      );\n\n      // update user camera and its children\n\n      camera.position.copy(cameraVR.position);\n      camera.quaternion.copy(cameraVR.quaternion);\n      camera.scale.copy(cameraVR.scale);\n      camera.matrix.copy(cameraVR.matrix);\n      camera.matrixWorld.copy(cameraVR.matrixWorld);\n\n      const children = camera.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateMatrixWorld(true);\n      }\n\n      // update projection matrix for proper view frustum culling\n\n      if (cameras.length === 2) {\n        setProjectionFromUnion(cameraVR, cameraL, cameraR);\n      } else {\n        // assume single camera setup (AR)\n\n        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n      }\n    };\n\n    this.getCamera = function () {\n      return cameraVR;\n    };\n\n    this.getFoveation = function () {\n      if (glProjLayer !== null) {\n        return glProjLayer.fixedFoveation;\n      }\n\n      if (glBaseLayer !== null) {\n        return glBaseLayer.fixedFoveation;\n      }\n\n      return undefined;\n    };\n\n    this.setFoveation = function (foveation) {\n      // 0 = no foveation = full resolution\n      // 1 = maximum foveation = the edges render at lower resolution\n\n      if (glProjLayer !== null) {\n        glProjLayer.fixedFoveation = foveation;\n      }\n\n      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {\n        glBaseLayer.fixedFoveation = foveation;\n      }\n    };\n\n    // Animation Loop\n\n    let onAnimationFrameCallback = null;\n\n    function onAnimationFrame(time, frame) {\n      pose = frame.getViewerPose(referenceSpace);\n      xrFrame = frame;\n\n      if (pose !== null) {\n        const views = pose.views;\n\n        if (glBaseLayer !== null) {\n          state.bindXRFramebuffer(glBaseLayer.framebuffer);\n        }\n\n        let cameraVRNeedsUpdate = false;\n\n        // check if it's necessary to rebuild cameraVR's camera list\n\n        if (views.length !== cameraVR.cameras.length) {\n          cameraVR.cameras.length = 0;\n\n          cameraVRNeedsUpdate = true;\n        }\n\n        for (let i = 0; i < views.length; i++) {\n          const view = views[i];\n\n          let viewport = null;\n\n          if (glBaseLayer !== null) {\n            viewport = glBaseLayer.getViewport(view);\n          } else {\n            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);\n\n            state.bindXRFramebuffer(glFramebuffer);\n\n            if (glSubImage.depthStencilTexture !== undefined) {\n              gl.framebufferTexture2D(\n                36160,\n                depthStyle,\n                3553,\n                glSubImage.depthStencilTexture,\n                0,\n              );\n            }\n\n            gl.framebufferTexture2D(\n              36160,\n              36064,\n              3553,\n              glSubImage.colorTexture,\n              0,\n            );\n\n            viewport = glSubImage.viewport;\n          }\n\n          const camera = cameras[i];\n\n          camera.matrix.fromArray(view.transform.matrix);\n          camera.projectionMatrix.fromArray(view.projectionMatrix);\n          camera.viewport.set(\n            viewport.x,\n            viewport.y,\n            viewport.width,\n            viewport.height,\n          );\n\n          if (i === 0) {\n            cameraVR.matrix.copy(camera.matrix);\n          }\n\n          if (cameraVRNeedsUpdate === true) {\n            cameraVR.cameras.push(camera);\n          }\n        }\n\n        if (isMultisample) {\n          state.bindXRFramebuffer(glMultisampledFramebuffer);\n\n          if (clearStyle !== null) gl.clear(clearStyle);\n        }\n      }\n\n      //\n\n      const inputSources = session.inputSources;\n\n      for (let i = 0; i < controllers.length; i++) {\n        const controller = controllers[i];\n        const inputSource = inputSources[i];\n\n        controller.update(inputSource, frame, referenceSpace);\n      }\n\n      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n\n      if (isMultisample) {\n        const width = glProjLayer.textureWidth;\n        const height = glProjLayer.textureHeight;\n\n        state.bindFramebuffer(36008, glMultisampledFramebuffer);\n        state.bindFramebuffer(36009, glFramebuffer);\n        // Invalidate the depth here to avoid flush of the depth data to main memory.\n        gl.invalidateFramebuffer(36008, [depthStyle]);\n        gl.invalidateFramebuffer(36009, [depthStyle]);\n        gl.blitFramebuffer(\n          0,\n          0,\n          width,\n          height,\n          0,\n          0,\n          width,\n          height,\n          16384,\n          9728,\n        );\n        // Invalidate the MSAA buffer because it's not needed anymore.\n        gl.invalidateFramebuffer(36008, [36064]);\n        state.bindFramebuffer(36008, null);\n        state.bindFramebuffer(36009, null);\n\n        state.bindFramebuffer(36160, glMultisampledFramebuffer);\n      }\n\n      xrFrame = null;\n    }\n\n    const animation = new WebGLAnimation();\n\n    animation.setAnimationLoop(onAnimationFrame);\n\n    this.setAnimationLoop = function (callback) {\n      onAnimationFrameCallback = callback;\n    };\n\n    this.dispose = function () {};\n  }\n}\n\nfunction WebGLMaterials(properties) {\n  function refreshFogUniforms(uniforms, fog) {\n    uniforms.fogColor.value.copy(fog.color);\n\n    if (fog.isFog) {\n      uniforms.fogNear.value = fog.near;\n      uniforms.fogFar.value = fog.far;\n    } else if (fog.isFogExp2) {\n      uniforms.fogDensity.value = fog.density;\n    }\n  }\n\n  function refreshMaterialUniforms(\n    uniforms,\n    material,\n    pixelRatio,\n    height,\n    transmissionRenderTarget,\n  ) {\n    if (material.isMeshBasicMaterial) {\n      refreshUniformsCommon(uniforms, material);\n    } else if (material.isMeshLambertMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsLambert(uniforms, material);\n    } else if (material.isMeshToonMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsToon(uniforms, material);\n    } else if (material.isMeshPhongMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsPhong(uniforms, material);\n    } else if (material.isMeshStandardMaterial) {\n      refreshUniformsCommon(uniforms, material);\n\n      if (material.isMeshPhysicalMaterial) {\n        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);\n      } else {\n        refreshUniformsStandard(uniforms, material);\n      }\n    } else if (material.isMeshMatcapMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsMatcap(uniforms, material);\n    } else if (material.isMeshDepthMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsDepth(uniforms, material);\n    } else if (material.isMeshDistanceMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsDistance(uniforms, material);\n    } else if (material.isMeshNormalMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsNormal(uniforms, material);\n    } else if (material.isLineBasicMaterial) {\n      refreshUniformsLine(uniforms, material);\n\n      if (material.isLineDashedMaterial) {\n        refreshUniformsDash(uniforms, material);\n      }\n    } else if (material.isPointsMaterial) {\n      refreshUniformsPoints(uniforms, material, pixelRatio, height);\n    } else if (material.isSpriteMaterial) {\n      refreshUniformsSprites(uniforms, material);\n    } else if (material.isShadowMaterial) {\n      uniforms.color.value.copy(material.color);\n      uniforms.opacity.value = material.opacity;\n    } else if (material.isShaderMaterial) {\n      material.uniformsNeedUpdate = false; // #15581\n    }\n  }\n\n  function refreshUniformsCommon(uniforms, material) {\n    uniforms.opacity.value = material.opacity;\n\n    if (material.color) {\n      uniforms.diffuse.value.copy(material.color);\n    }\n\n    if (material.emissive) {\n      uniforms.emissive.value\n        .copy(material.emissive)\n        .multiplyScalar(material.emissiveIntensity);\n    }\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n\n    if (material.specularMap) {\n      uniforms.specularMap.value = material.specularMap;\n    }\n\n    if (material.alphaTest > 0) {\n      uniforms.alphaTest.value = material.alphaTest;\n    }\n\n    const envMap = properties.get(material).envMap;\n\n    if (envMap) {\n      uniforms.envMap.value = envMap;\n\n      uniforms.flipEnvMap.value =\n        envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;\n\n      uniforms.reflectivity.value = material.reflectivity;\n      uniforms.ior.value = material.ior;\n      uniforms.refractionRatio.value = material.refractionRatio;\n\n      const maxMipLevel = properties.get(envMap).__maxMipLevel;\n\n      if (maxMipLevel !== undefined) {\n        uniforms.maxMipLevel.value = maxMipLevel;\n      }\n    }\n\n    if (material.lightMap) {\n      uniforms.lightMap.value = material.lightMap;\n      uniforms.lightMapIntensity.value = material.lightMapIntensity;\n    }\n\n    if (material.aoMap) {\n      uniforms.aoMap.value = material.aoMap;\n      uniforms.aoMapIntensity.value = material.aoMapIntensity;\n    }\n\n    // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. specular map\n    // 3. displacementMap map\n    // 4. normal map\n    // 5. bump map\n    // 6. roughnessMap map\n    // 7. metalnessMap map\n    // 8. alphaMap map\n    // 9. emissiveMap map\n    // 10. clearcoat map\n    // 11. clearcoat normal map\n    // 12. clearcoat roughnessMap map\n    // 13. specular intensity map\n    // 14. specular tint map\n    // 15. transmission map\n    // 16. thickness map\n\n    let uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.specularMap) {\n      uvScaleMap = material.specularMap;\n    } else if (material.displacementMap) {\n      uvScaleMap = material.displacementMap;\n    } else if (material.normalMap) {\n      uvScaleMap = material.normalMap;\n    } else if (material.bumpMap) {\n      uvScaleMap = material.bumpMap;\n    } else if (material.roughnessMap) {\n      uvScaleMap = material.roughnessMap;\n    } else if (material.metalnessMap) {\n      uvScaleMap = material.metalnessMap;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    } else if (material.emissiveMap) {\n      uvScaleMap = material.emissiveMap;\n    } else if (material.clearcoatMap) {\n      uvScaleMap = material.clearcoatMap;\n    } else if (material.clearcoatNormalMap) {\n      uvScaleMap = material.clearcoatNormalMap;\n    } else if (material.clearcoatRoughnessMap) {\n      uvScaleMap = material.clearcoatRoughnessMap;\n    } else if (material.specularIntensityMap) {\n      uvScaleMap = material.specularIntensityMap;\n    } else if (material.specularTintMap) {\n      uvScaleMap = material.specularTintMap;\n    } else if (material.transmissionMap) {\n      uvScaleMap = material.transmissionMap;\n    } else if (material.thicknessMap) {\n      uvScaleMap = material.thicknessMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      // backwards compatibility\n      if (uvScaleMap.isWebGLRenderTarget) {\n        uvScaleMap = uvScaleMap.texture;\n      }\n\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n\n    // uv repeat and offset setting priorities for uv2\n    // 1. ao map\n    // 2. light map\n\n    let uv2ScaleMap;\n\n    if (material.aoMap) {\n      uv2ScaleMap = material.aoMap;\n    } else if (material.lightMap) {\n      uv2ScaleMap = material.lightMap;\n    }\n\n    if (uv2ScaleMap !== undefined) {\n      // backwards compatibility\n      if (uv2ScaleMap.isWebGLRenderTarget) {\n        uv2ScaleMap = uv2ScaleMap.texture;\n      }\n\n      if (uv2ScaleMap.matrixAutoUpdate === true) {\n        uv2ScaleMap.updateMatrix();\n      }\n\n      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsLine(uniforms, material) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n  }\n\n  function refreshUniformsDash(uniforms, material) {\n    uniforms.dashSize.value = material.dashSize;\n    uniforms.totalSize.value = material.dashSize + material.gapSize;\n    uniforms.scale.value = material.scale;\n  }\n\n  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n    uniforms.size.value = material.size * pixelRatio;\n    uniforms.scale.value = height * 0.5;\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n\n    if (material.alphaTest > 0) {\n      uniforms.alphaTest.value = material.alphaTest;\n    }\n\n    // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. alpha map\n\n    let uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsSprites(uniforms, material) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n    uniforms.rotation.value = material.rotation;\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n\n    if (material.alphaTest > 0) {\n      uniforms.alphaTest.value = material.alphaTest;\n    }\n\n    // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. alpha map\n\n    let uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsLambert(uniforms, material) {\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n  }\n\n  function refreshUniformsPhong(uniforms, material) {\n    uniforms.specular.value.copy(material.specular);\n    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\n\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsToon(uniforms, material) {\n    if (material.gradientMap) {\n      uniforms.gradientMap.value = material.gradientMap;\n    }\n\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsStandard(uniforms, material) {\n    uniforms.roughness.value = material.roughness;\n    uniforms.metalness.value = material.metalness;\n\n    if (material.roughnessMap) {\n      uniforms.roughnessMap.value = material.roughnessMap;\n    }\n\n    if (material.metalnessMap) {\n      uniforms.metalnessMap.value = material.metalnessMap;\n    }\n\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n\n    const envMap = properties.get(material).envMap;\n\n    if (envMap) {\n      //uniforms.envMap.value = material.envMap; // part of uniforms common\n      uniforms.envMapIntensity.value = material.envMapIntensity;\n    }\n  }\n\n  function refreshUniformsPhysical(\n    uniforms,\n    material,\n    transmissionRenderTarget,\n  ) {\n    refreshUniformsStandard(uniforms, material);\n\n    uniforms.ior.value = material.ior; // also part of uniforms common\n\n    if (material.sheen > 0) {\n      uniforms.sheenTint.value\n        .copy(material.sheenTint)\n        .multiplyScalar(material.sheen);\n\n      uniforms.sheenRoughness.value = material.sheenRoughness;\n    }\n\n    if (material.clearcoat > 0) {\n      uniforms.clearcoat.value = material.clearcoat;\n      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\n      if (material.clearcoatMap) {\n        uniforms.clearcoatMap.value = material.clearcoatMap;\n      }\n\n      if (material.clearcoatRoughnessMap) {\n        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n      }\n\n      if (material.clearcoatNormalMap) {\n        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n        if (material.side === BackSide) {\n          uniforms.clearcoatNormalScale.value.negate();\n        }\n      }\n    }\n\n    if (material.transmission > 0) {\n      uniforms.transmission.value = material.transmission;\n      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n      uniforms.transmissionSamplerSize.value.set(\n        transmissionRenderTarget.width,\n        transmissionRenderTarget.height,\n      );\n\n      if (material.transmissionMap) {\n        uniforms.transmissionMap.value = material.transmissionMap;\n      }\n\n      uniforms.thickness.value = material.thickness;\n\n      if (material.thicknessMap) {\n        uniforms.thicknessMap.value = material.thicknessMap;\n      }\n\n      uniforms.attenuationDistance.value = material.attenuationDistance;\n      uniforms.attenuationTint.value.copy(material.attenuationTint);\n    }\n\n    uniforms.specularIntensity.value = material.specularIntensity;\n    uniforms.specularTint.value.copy(material.specularTint);\n\n    if (material.specularIntensityMap) {\n      uniforms.specularIntensityMap.value = material.specularIntensityMap;\n    }\n\n    if (material.specularTintMap) {\n      uniforms.specularTintMap.value = material.specularTintMap;\n    }\n  }\n\n  function refreshUniformsMatcap(uniforms, material) {\n    if (material.matcap) {\n      uniforms.matcap.value = material.matcap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsDepth(uniforms, material) {\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsDistance(uniforms, material) {\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n\n    uniforms.referencePosition.value.copy(material.referencePosition);\n    uniforms.nearDistance.value = material.nearDistance;\n    uniforms.farDistance.value = material.farDistance;\n  }\n\n  function refreshUniformsNormal(uniforms, material) {\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  return {\n    refreshFogUniforms: refreshFogUniforms,\n    refreshMaterialUniforms: refreshMaterialUniforms,\n  };\n}\n\nfunction createCanvasElement() {\n  const canvas = createElementNS('canvas');\n  canvas.style.display = 'block';\n  return canvas;\n}\n\nfunction WebGLRenderer(parameters = {}) {\n  const _canvas =\n      parameters.canvas !== undefined\n        ? parameters.canvas\n        : createCanvasElement(),\n    _context = parameters.context !== undefined ? parameters.context : null,\n    _alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n    _depth = parameters.depth !== undefined ? parameters.depth : true,\n    _stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n    _antialias =\n      parameters.antialias !== undefined ? parameters.antialias : false,\n    _premultipliedAlpha =\n      parameters.premultipliedAlpha !== undefined\n        ? parameters.premultipliedAlpha\n        : true,\n    _preserveDrawingBuffer =\n      parameters.preserveDrawingBuffer !== undefined\n        ? parameters.preserveDrawingBuffer\n        : false,\n    _powerPreference =\n      parameters.powerPreference !== undefined\n        ? parameters.powerPreference\n        : 'default',\n    _failIfMajorPerformanceCaveat =\n      parameters.failIfMajorPerformanceCaveat !== undefined\n        ? parameters.failIfMajorPerformanceCaveat\n        : false;\n\n  let currentRenderList = null;\n  let currentRenderState = null;\n\n  // render() can be called from within a callback triggered by another render.\n  // We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n  const renderListStack = [];\n  const renderStateStack = [];\n\n  // public properties\n\n  this.domElement = _canvas;\n\n  // Debug configuration container\n  this.debug = {\n    /**\n     * Enables error checking and reporting when shader programs are being compiled\n     * @type {boolean}\n     */\n    checkShaderErrors: true,\n  };\n\n  // clearing\n\n  this.autoClear = true;\n  this.autoClearColor = true;\n  this.autoClearDepth = true;\n  this.autoClearStencil = true;\n\n  // scene graph\n\n  this.sortObjects = true;\n\n  // user-defined clipping\n\n  this.clippingPlanes = [];\n  this.localClippingEnabled = false;\n\n  // physically based shading\n\n  this.gammaFactor = 2.0; // for backwards compatibility\n  this.outputEncoding = LinearEncoding;\n\n  // physical lights\n\n  this.physicallyCorrectLights = false;\n\n  // tone mapping\n\n  this.toneMapping = NoToneMapping;\n  this.toneMappingExposure = 1.0;\n\n  // internal properties\n\n  const _this = this;\n\n  let _isContextLost = false;\n\n  // internal state cache\n\n  let _currentActiveCubeFace = 0;\n  let _currentActiveMipmapLevel = 0;\n  let _currentRenderTarget = null;\n  let _currentMaterialId = -1;\n\n  let _currentCamera = null;\n\n  const _currentViewport = new Vector4();\n  const _currentScissor = new Vector4();\n  let _currentScissorTest = null;\n\n  //\n\n  let _width = _canvas.width;\n  let _height = _canvas.height;\n\n  let _pixelRatio = 1;\n  let _opaqueSort = null;\n  let _transparentSort = null;\n\n  const _viewport = new Vector4(0, 0, _width, _height);\n  const _scissor = new Vector4(0, 0, _width, _height);\n  let _scissorTest = false;\n\n  //\n\n  const _currentDrawBuffers = [];\n\n  // frustum\n\n  const _frustum = new Frustum();\n\n  // clipping\n\n  let _clippingEnabled = false;\n  let _localClippingEnabled = false;\n\n  // transmission\n\n  let _transmissionRenderTarget = null;\n\n  // camera matrices cache\n\n  const _projScreenMatrix = new Matrix4();\n\n  const _vector3 = new Vector3();\n\n  const _emptyScene = {\n    background: null,\n    fog: null,\n    environment: null,\n    overrideMaterial: null,\n    isScene: true,\n  };\n\n  function getTargetPixelRatio() {\n    return _currentRenderTarget === null ? _pixelRatio : 1;\n  }\n\n  // initialize\n\n  let _gl = _context;\n\n  function getContext(contextNames, contextAttributes) {\n    for (let i = 0; i < contextNames.length; i++) {\n      const contextName = contextNames[i];\n      const context = _canvas.getContext(contextName, contextAttributes);\n      if (context !== null) return context;\n    }\n\n    return null;\n  }\n\n  try {\n    const contextAttributes = {\n      alpha: _alpha,\n      depth: _depth,\n      stencil: _stencil,\n      antialias: _antialias,\n      premultipliedAlpha: _premultipliedAlpha,\n      preserveDrawingBuffer: _preserveDrawingBuffer,\n      powerPreference: _powerPreference,\n      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,\n    };\n\n    // event listeners must be registered before WebGL context is created, see #12753\n\n    _canvas.addEventListener('webglcontextlost', onContextLost, false);\n    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);\n\n    if (_gl === null) {\n      const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];\n\n      if (_this.isWebGL1Renderer === true) {\n        contextNames.shift();\n      }\n\n      _gl = getContext(contextNames, contextAttributes);\n\n      if (_gl === null) {\n        if (getContext(contextNames)) {\n          throw new Error(\n            'Error creating WebGL context with your selected attributes.',\n          );\n        } else {\n          throw new Error('Error creating WebGL context.');\n        }\n      }\n    }\n\n    // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n    if (_gl.getShaderPrecisionFormat === undefined) {\n      _gl.getShaderPrecisionFormat = function () {\n        return { rangeMin: 1, rangeMax: 1, precision: 1 };\n      };\n    }\n  } catch (error) {\n    console.error('THREE.WebGLRenderer: ' + error.message);\n    throw error;\n  }\n\n  let extensions, capabilities, state, info;\n  let properties,\n    textures,\n    cubemaps,\n    cubeuvmaps,\n    attributes,\n    geometries,\n    objects;\n  let programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n  let background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n  let utils, bindingStates;\n\n  function initGLContext() {\n    extensions = new WebGLExtensions(_gl);\n\n    capabilities = new WebGLCapabilities(_gl, extensions, parameters);\n\n    extensions.init(capabilities);\n\n    utils = new WebGLUtils(_gl, extensions, capabilities);\n\n    state = new WebGLState(_gl, extensions, capabilities);\n\n    _currentDrawBuffers[0] = 1029;\n\n    info = new WebGLInfo(_gl);\n    properties = new WebGLProperties();\n    textures = new WebGLTextures(\n      _gl,\n      extensions,\n      state,\n      properties,\n      capabilities,\n      utils,\n      info,\n    );\n    cubemaps = new WebGLCubeMaps(_this);\n    cubeuvmaps = new WebGLCubeUVMaps(_this);\n    attributes = new WebGLAttributes(_gl, capabilities);\n    bindingStates = new WebGLBindingStates(\n      _gl,\n      extensions,\n      attributes,\n      capabilities,\n    );\n    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n    objects = new WebGLObjects(_gl, geometries, attributes, info);\n    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);\n    clipping = new WebGLClipping(properties);\n    programCache = new WebGLPrograms(\n      _this,\n      cubemaps,\n      cubeuvmaps,\n      extensions,\n      capabilities,\n      bindingStates,\n      clipping,\n    );\n    materials = new WebGLMaterials(properties);\n    renderLists = new WebGLRenderLists(properties);\n    renderStates = new WebGLRenderStates(extensions, capabilities);\n    background = new WebGLBackground(\n      _this,\n      cubemaps,\n      state,\n      objects,\n      _premultipliedAlpha,\n    );\n    shadowMap = new WebGLShadowMap(_this, objects, capabilities);\n\n    bufferRenderer = new WebGLBufferRenderer(\n      _gl,\n      extensions,\n      info,\n      capabilities,\n    );\n    indexedBufferRenderer = new WebGLIndexedBufferRenderer(\n      _gl,\n      extensions,\n      info,\n      capabilities,\n    );\n\n    info.programs = programCache.programs;\n\n    _this.capabilities = capabilities;\n    _this.extensions = extensions;\n    _this.properties = properties;\n    _this.renderLists = renderLists;\n    _this.shadowMap = shadowMap;\n    _this.state = state;\n    _this.info = info;\n  }\n\n  initGLContext();\n\n  // xr\n\n  const xr = new WebXRManager(_this, _gl);\n\n  this.xr = xr;\n\n  // API\n\n  this.getContext = function () {\n    return _gl;\n  };\n\n  this.getContextAttributes = function () {\n    return _gl.getContextAttributes();\n  };\n\n  this.forceContextLoss = function () {\n    const extension = extensions.get('WEBGL_lose_context');\n    if (extension) extension.loseContext();\n  };\n\n  this.forceContextRestore = function () {\n    const extension = extensions.get('WEBGL_lose_context');\n    if (extension) extension.restoreContext();\n  };\n\n  this.getPixelRatio = function () {\n    return _pixelRatio;\n  };\n\n  this.setPixelRatio = function (value) {\n    if (value === undefined) return;\n\n    _pixelRatio = value;\n\n    this.setSize(_width, _height, false);\n  };\n\n  this.getSize = function (target) {\n    return target.set(_width, _height);\n  };\n\n  this.setSize = function (width, height, updateStyle) {\n    if (xr.isPresenting) {\n      console.warn(\n        \"THREE.WebGLRenderer: Can't change size while VR device is presenting.\",\n      );\n      return;\n    }\n\n    _width = width;\n    _height = height;\n\n    _canvas.width = Math.floor(width * _pixelRatio);\n    _canvas.height = Math.floor(height * _pixelRatio);\n\n    if (updateStyle !== false) {\n      _canvas.style.width = width + 'px';\n      _canvas.style.height = height + 'px';\n    }\n\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.getDrawingBufferSize = function (target) {\n    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n  };\n\n  this.setDrawingBufferSize = function (width, height, pixelRatio) {\n    _width = width;\n    _height = height;\n\n    _pixelRatio = pixelRatio;\n\n    _canvas.width = Math.floor(width * pixelRatio);\n    _canvas.height = Math.floor(height * pixelRatio);\n\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.getCurrentViewport = function (target) {\n    return target.copy(_currentViewport);\n  };\n\n  this.getViewport = function (target) {\n    return target.copy(_viewport);\n  };\n\n  this.setViewport = function (x, y, width, height) {\n    if (x.isVector4) {\n      _viewport.set(x.x, x.y, x.z, x.w);\n    } else {\n      _viewport.set(x, y, width, height);\n    }\n\n    state.viewport(\n      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor(),\n    );\n  };\n\n  this.getScissor = function (target) {\n    return target.copy(_scissor);\n  };\n\n  this.setScissor = function (x, y, width, height) {\n    if (x.isVector4) {\n      _scissor.set(x.x, x.y, x.z, x.w);\n    } else {\n      _scissor.set(x, y, width, height);\n    }\n\n    state.scissor(\n      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor(),\n    );\n  };\n\n  this.getScissorTest = function () {\n    return _scissorTest;\n  };\n\n  this.setScissorTest = function (boolean) {\n    state.setScissorTest((_scissorTest = boolean));\n  };\n\n  this.setOpaqueSort = function (method) {\n    _opaqueSort = method;\n  };\n\n  this.setTransparentSort = function (method) {\n    _transparentSort = method;\n  };\n\n  // Clearing\n\n  this.getClearColor = function (target) {\n    return target.copy(background.getClearColor());\n  };\n\n  this.setClearColor = function () {\n    background.setClearColor.apply(background, arguments);\n  };\n\n  this.getClearAlpha = function () {\n    return background.getClearAlpha();\n  };\n\n  this.setClearAlpha = function () {\n    background.setClearAlpha.apply(background, arguments);\n  };\n\n  this.clear = function (color, depth, stencil) {\n    let bits = 0;\n\n    if (color === undefined || color) bits |= 16384;\n    if (depth === undefined || depth) bits |= 256;\n    if (stencil === undefined || stencil) bits |= 1024;\n\n    _gl.clear(bits);\n  };\n\n  this.clearColor = function () {\n    this.clear(true, false, false);\n  };\n\n  this.clearDepth = function () {\n    this.clear(false, true, false);\n  };\n\n  this.clearStencil = function () {\n    this.clear(false, false, true);\n  };\n\n  //\n\n  this.dispose = function () {\n    _canvas.removeEventListener('webglcontextlost', onContextLost, false);\n    _canvas.removeEventListener(\n      'webglcontextrestored',\n      onContextRestore,\n      false,\n    );\n\n    renderLists.dispose();\n    renderStates.dispose();\n    properties.dispose();\n    cubemaps.dispose();\n    cubeuvmaps.dispose();\n    objects.dispose();\n    bindingStates.dispose();\n\n    xr.dispose();\n\n    xr.removeEventListener('sessionstart', onXRSessionStart);\n    xr.removeEventListener('sessionend', onXRSessionEnd);\n\n    if (_transmissionRenderTarget) {\n      _transmissionRenderTarget.dispose();\n      _transmissionRenderTarget = null;\n    }\n\n    animation.stop();\n  };\n\n  // Events\n\n  function onContextLost(event) {\n    event.preventDefault();\n\n    console.log('THREE.WebGLRenderer: Context Lost.');\n\n    _isContextLost = true;\n  }\n\n  function onContextRestore(/* event */) {\n    console.log('THREE.WebGLRenderer: Context Restored.');\n\n    _isContextLost = false;\n\n    const infoAutoReset = info.autoReset;\n    const shadowMapEnabled = shadowMap.enabled;\n    const shadowMapAutoUpdate = shadowMap.autoUpdate;\n    const shadowMapNeedsUpdate = shadowMap.needsUpdate;\n    const shadowMapType = shadowMap.type;\n\n    initGLContext();\n\n    info.autoReset = infoAutoReset;\n    shadowMap.enabled = shadowMapEnabled;\n    shadowMap.autoUpdate = shadowMapAutoUpdate;\n    shadowMap.needsUpdate = shadowMapNeedsUpdate;\n    shadowMap.type = shadowMapType;\n  }\n\n  function onMaterialDispose(event) {\n    const material = event.target;\n\n    material.removeEventListener('dispose', onMaterialDispose);\n\n    deallocateMaterial(material);\n  }\n\n  // Buffer deallocation\n\n  function deallocateMaterial(material) {\n    releaseMaterialProgramReferences(material);\n\n    properties.remove(material);\n  }\n\n  function releaseMaterialProgramReferences(material) {\n    const programs = properties.get(material).programs;\n\n    if (programs !== undefined) {\n      programs.forEach(function (program) {\n        programCache.releaseProgram(program);\n      });\n    }\n  }\n\n  // Buffer rendering\n\n  function renderObjectImmediate(object, program) {\n    object.render(function (object) {\n      _this.renderBufferImmediate(object, program);\n    });\n  }\n\n  this.renderBufferImmediate = function (object, program) {\n    bindingStates.initAttributes();\n\n    const buffers = properties.get(object);\n\n    if (object.hasPositions && !buffers.position)\n      buffers.position = _gl.createBuffer();\n    if (object.hasNormals && !buffers.normal)\n      buffers.normal = _gl.createBuffer();\n    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();\n    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();\n\n    const programAttributes = program.getAttributes();\n\n    if (object.hasPositions) {\n      _gl.bindBuffer(34962, buffers.position);\n      _gl.bufferData(34962, object.positionArray, 35048);\n\n      bindingStates.enableAttribute(programAttributes.position.location);\n      _gl.vertexAttribPointer(\n        programAttributes.position.location,\n        3,\n        5126,\n        false,\n        0,\n        0,\n      );\n    }\n\n    if (object.hasNormals) {\n      _gl.bindBuffer(34962, buffers.normal);\n      _gl.bufferData(34962, object.normalArray, 35048);\n\n      bindingStates.enableAttribute(programAttributes.normal.location);\n      _gl.vertexAttribPointer(\n        programAttributes.normal.location,\n        3,\n        5126,\n        false,\n        0,\n        0,\n      );\n    }\n\n    if (object.hasUvs) {\n      _gl.bindBuffer(34962, buffers.uv);\n      _gl.bufferData(34962, object.uvArray, 35048);\n\n      bindingStates.enableAttribute(programAttributes.uv.location);\n      _gl.vertexAttribPointer(\n        programAttributes.uv.location,\n        2,\n        5126,\n        false,\n        0,\n        0,\n      );\n    }\n\n    if (object.hasColors) {\n      _gl.bindBuffer(34962, buffers.color);\n      _gl.bufferData(34962, object.colorArray, 35048);\n\n      bindingStates.enableAttribute(programAttributes.color.location);\n      _gl.vertexAttribPointer(\n        programAttributes.color.location,\n        3,\n        5126,\n        false,\n        0,\n        0,\n      );\n    }\n\n    bindingStates.disableUnusedAttributes();\n\n    _gl.drawArrays(4, 0, object.count);\n\n    object.count = 0;\n  };\n\n  this.renderBufferDirect = function (\n    camera,\n    scene,\n    geometry,\n    material,\n    object,\n    group,\n  ) {\n    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n\n    const program = setProgram(camera, scene, geometry, material, object);\n\n    state.setMaterial(material, frontFaceCW);\n\n    //\n\n    let index = geometry.index;\n    const position = geometry.attributes.position;\n\n    //\n\n    if (index === null) {\n      if (position === undefined || position.count === 0) return;\n    } else if (index.count === 0) {\n      return;\n    }\n\n    //\n\n    let rangeFactor = 1;\n\n    if (material.wireframe === true) {\n      index = geometries.getWireframeAttribute(geometry);\n      rangeFactor = 2;\n    }\n\n    bindingStates.setup(object, material, program, geometry, index);\n\n    let attribute;\n    let renderer = bufferRenderer;\n\n    if (index !== null) {\n      attribute = attributes.get(index);\n\n      renderer = indexedBufferRenderer;\n      renderer.setIndex(attribute);\n    }\n\n    //\n\n    const dataCount = index !== null ? index.count : position.count;\n\n    const rangeStart = geometry.drawRange.start * rangeFactor;\n    const rangeCount = geometry.drawRange.count * rangeFactor;\n\n    const groupStart = group !== null ? group.start * rangeFactor : 0;\n    const groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n    const drawStart = Math.max(rangeStart, groupStart);\n    const drawEnd =\n      Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\n\n    const drawCount = Math.max(0, drawEnd - drawStart + 1);\n\n    if (drawCount === 0) return;\n\n    //\n\n    if (object.isMesh) {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n        renderer.setMode(1);\n      } else {\n        renderer.setMode(4);\n      }\n    } else if (object.isLine) {\n      let lineWidth = material.linewidth;\n\n      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n      state.setLineWidth(lineWidth * getTargetPixelRatio());\n\n      if (object.isLineSegments) {\n        renderer.setMode(1);\n      } else if (object.isLineLoop) {\n        renderer.setMode(2);\n      } else {\n        renderer.setMode(3);\n      }\n    } else if (object.isPoints) {\n      renderer.setMode(0);\n    } else if (object.isSprite) {\n      renderer.setMode(4);\n    }\n\n    if (object.isInstancedMesh) {\n      renderer.renderInstances(drawStart, drawCount, object.count);\n    } else if (geometry.isInstancedBufferGeometry) {\n      const instanceCount = Math.min(\n        geometry.instanceCount,\n        geometry._maxInstanceCount,\n      );\n\n      renderer.renderInstances(drawStart, drawCount, instanceCount);\n    } else {\n      renderer.render(drawStart, drawCount);\n    }\n  };\n\n  // Compile\n\n  this.compile = function (scene, camera) {\n    currentRenderState = renderStates.get(scene);\n    currentRenderState.init();\n\n    renderStateStack.push(currentRenderState);\n\n    scene.traverseVisible(function (object) {\n      if (object.isLight && object.layers.test(camera.layers)) {\n        currentRenderState.pushLight(object);\n\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      }\n    });\n\n    currentRenderState.setupLights(_this.physicallyCorrectLights);\n\n    scene.traverse(function (object) {\n      const material = object.material;\n\n      if (material) {\n        if (Array.isArray(material)) {\n          for (let i = 0; i < material.length; i++) {\n            const material2 = material[i];\n\n            getProgram(material2, scene, object);\n          }\n        } else {\n          getProgram(material, scene, object);\n        }\n      }\n    });\n\n    renderStateStack.pop();\n    currentRenderState = null;\n  };\n\n  // Animation Loop\n\n  let onAnimationFrameCallback = null;\n\n  function onAnimationFrame(time) {\n    if (onAnimationFrameCallback) onAnimationFrameCallback(time);\n  }\n\n  function onXRSessionStart() {\n    animation.stop();\n  }\n\n  function onXRSessionEnd() {\n    animation.start();\n  }\n\n  const animation = new WebGLAnimation();\n  animation.setAnimationLoop(onAnimationFrame);\n\n  if (typeof window !== 'undefined') animation.setContext(window);\n\n  this.setAnimationLoop = function (callback) {\n    onAnimationFrameCallback = callback;\n    xr.setAnimationLoop(callback);\n\n    callback === null ? animation.stop() : animation.start();\n  };\n\n  xr.addEventListener('sessionstart', onXRSessionStart);\n  xr.addEventListener('sessionend', onXRSessionEnd);\n\n  // Rendering\n\n  this.render = function (scene, camera) {\n    if (camera !== undefined && camera.isCamera !== true) {\n      console.error(\n        'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',\n      );\n      return;\n    }\n\n    if (_isContextLost === true) return;\n\n    // update scene graph\n\n    if (scene.autoUpdate === true) scene.updateMatrixWorld();\n\n    // update camera matrices and frustum\n\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    if (xr.enabled === true && xr.isPresenting === true) {\n      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n\n      camera = xr.getCamera(); // use XR camera for rendering\n    }\n\n    //\n    if (scene.isScene === true)\n      scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n\n    currentRenderState = renderStates.get(scene, renderStateStack.length);\n    currentRenderState.init();\n\n    renderStateStack.push(currentRenderState);\n\n    _projScreenMatrix.multiplyMatrices(\n      camera.projectionMatrix,\n      camera.matrixWorldInverse,\n    );\n    _frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n    _localClippingEnabled = this.localClippingEnabled;\n    _clippingEnabled = clipping.init(\n      this.clippingPlanes,\n      _localClippingEnabled,\n      camera,\n    );\n\n    currentRenderList = renderLists.get(scene, renderListStack.length);\n    currentRenderList.init();\n\n    renderListStack.push(currentRenderList);\n\n    projectObject(scene, camera, 0, _this.sortObjects);\n\n    currentRenderList.finish();\n\n    if (_this.sortObjects === true) {\n      currentRenderList.sort(_opaqueSort, _transparentSort);\n    }\n\n    //\n\n    if (_clippingEnabled === true) clipping.beginShadows();\n\n    const shadowsArray = currentRenderState.state.shadowsArray;\n\n    shadowMap.render(shadowsArray, scene, camera);\n\n    if (_clippingEnabled === true) clipping.endShadows();\n\n    //\n\n    if (this.info.autoReset === true) this.info.reset();\n\n    //\n\n    background.render(currentRenderList, scene);\n\n    // render scene\n\n    currentRenderState.setupLights(_this.physicallyCorrectLights);\n\n    if (camera.isArrayCamera) {\n      const cameras = camera.cameras;\n\n      for (let i = 0, l = cameras.length; i < l; i++) {\n        const camera2 = cameras[i];\n\n        renderScene(currentRenderList, scene, camera2, camera2.viewport);\n      }\n    } else {\n      renderScene(currentRenderList, scene, camera);\n    }\n\n    //\n\n    if (_currentRenderTarget !== null) {\n      // resolve multisample renderbuffers to a single-sample texture if necessary\n\n      textures.updateMultisampleRenderTarget(_currentRenderTarget);\n\n      // Generate mipmap if we're using any kind of mipmap filtering\n\n      textures.updateRenderTargetMipmap(_currentRenderTarget);\n    }\n\n    //\n\n    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);\n\n    // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n    state.buffers.depth.setTest(true);\n    state.buffers.depth.setMask(true);\n    state.buffers.color.setMask(true);\n\n    state.setPolygonOffset(false);\n\n    // _gl.finish();\n\n    bindingStates.resetDefaultState();\n    _currentMaterialId = -1;\n    _currentCamera = null;\n\n    renderStateStack.pop();\n\n    if (renderStateStack.length > 0) {\n      currentRenderState = renderStateStack[renderStateStack.length - 1];\n    } else {\n      currentRenderState = null;\n    }\n\n    renderListStack.pop();\n\n    if (renderListStack.length > 0) {\n      currentRenderList = renderListStack[renderListStack.length - 1];\n    } else {\n      currentRenderList = null;\n    }\n  };\n\n  function projectObject(object, camera, groupOrder, sortObjects) {\n    if (object.visible === false) return;\n\n    const visible = object.layers.test(camera.layers);\n\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        currentRenderState.pushLight(object);\n\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (sortObjects) {\n            _vector3\n              .setFromMatrixPosition(object.matrixWorld)\n              .applyMatrix4(_projScreenMatrix);\n          }\n\n          const geometry = objects.update(object);\n          const material = object.material;\n\n          if (material.visible) {\n            currentRenderList.push(\n              object,\n              geometry,\n              material,\n              groupOrder,\n              _vector3.z,\n              null,\n            );\n          }\n        }\n      } else if (object.isImmediateRenderObject) {\n        if (sortObjects) {\n          _vector3\n            .setFromMatrixPosition(object.matrixWorld)\n            .applyMatrix4(_projScreenMatrix);\n        }\n\n        currentRenderList.push(\n          object,\n          null,\n          object.material,\n          groupOrder,\n          _vector3.z,\n          null,\n        );\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.isSkinnedMesh) {\n          // update skeleton only once in a frame\n\n          if (object.skeleton.frame !== info.render.frame) {\n            object.skeleton.update();\n            object.skeleton.frame = info.render.frame;\n          }\n        }\n\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          if (sortObjects) {\n            _vector3\n              .setFromMatrixPosition(object.matrixWorld)\n              .applyMatrix4(_projScreenMatrix);\n          }\n\n          const geometry = objects.update(object);\n          const material = object.material;\n\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n\n              if (groupMaterial && groupMaterial.visible) {\n                currentRenderList.push(\n                  object,\n                  geometry,\n                  groupMaterial,\n                  groupOrder,\n                  _vector3.z,\n                  group,\n                );\n              }\n            }\n          } else if (material.visible) {\n            currentRenderList.push(\n              object,\n              geometry,\n              material,\n              groupOrder,\n              _vector3.z,\n              null,\n            );\n          }\n        }\n      }\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i], camera, groupOrder, sortObjects);\n    }\n  }\n\n  function renderScene(currentRenderList, scene, camera, viewport) {\n    const opaqueObjects = currentRenderList.opaque;\n    const transmissiveObjects = currentRenderList.transmissive;\n    const transparentObjects = currentRenderList.transparent;\n\n    currentRenderState.setupLightsView(camera);\n\n    if (transmissiveObjects.length > 0)\n      renderTransmissionPass(opaqueObjects, scene, camera);\n\n    if (viewport) state.viewport(_currentViewport.copy(viewport));\n\n    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n    if (transmissiveObjects.length > 0)\n      renderObjects(transmissiveObjects, scene, camera);\n    if (transparentObjects.length > 0)\n      renderObjects(transparentObjects, scene, camera);\n  }\n\n  function renderTransmissionPass(opaqueObjects, scene, camera) {\n    if (_transmissionRenderTarget === null) {\n      const needsAntialias =\n        _antialias === true && capabilities.isWebGL2 === true;\n      const renderTargetType = needsAntialias\n        ? WebGLMultisampleRenderTarget\n        : WebGLRenderTarget;\n\n      _transmissionRenderTarget = new renderTargetType(1024, 1024, {\n        generateMipmaps: true,\n        type:\n          utils.convert(HalfFloatType) !== null\n            ? HalfFloatType\n            : UnsignedByteType,\n        minFilter: LinearMipmapLinearFilter,\n        magFilter: NearestFilter,\n        wrapS: ClampToEdgeWrapping,\n        wrapT: ClampToEdgeWrapping,\n      });\n    }\n\n    const currentRenderTarget = _this.getRenderTarget();\n    _this.setRenderTarget(_transmissionRenderTarget);\n    _this.clear();\n\n    // Turn off the features which can affect the frag color for opaque objects pass.\n    // Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n    const currentToneMapping = _this.toneMapping;\n    _this.toneMapping = NoToneMapping;\n\n    renderObjects(opaqueObjects, scene, camera);\n\n    _this.toneMapping = currentToneMapping;\n\n    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);\n    textures.updateRenderTargetMipmap(_transmissionRenderTarget);\n\n    _this.setRenderTarget(currentRenderTarget);\n  }\n\n  function renderObjects(renderList, scene, camera) {\n    const overrideMaterial =\n      scene.isScene === true ? scene.overrideMaterial : null;\n\n    for (let i = 0, l = renderList.length; i < l; i++) {\n      const renderItem = renderList[i];\n\n      const object = renderItem.object;\n      const geometry = renderItem.geometry;\n      const material =\n        overrideMaterial === null ? renderItem.material : overrideMaterial;\n      const group = renderItem.group;\n\n      if (object.layers.test(camera.layers)) {\n        renderObject(object, scene, camera, geometry, material, group);\n      }\n    }\n  }\n\n  function renderObject(object, scene, camera, geometry, material, group) {\n    object.onBeforeRender(_this, scene, camera, geometry, material, group);\n\n    object.modelViewMatrix.multiplyMatrices(\n      camera.matrixWorldInverse,\n      object.matrixWorld,\n    );\n    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n\n    material.onBeforeRender(_this, scene, camera, geometry, object, group);\n\n    if (object.isImmediateRenderObject) {\n      const program = setProgram(camera, scene, geometry, material, object);\n\n      state.setMaterial(material);\n\n      bindingStates.reset();\n\n      renderObjectImmediate(object, program);\n    } else {\n      if (material.transparent === true && material.side === DoubleSide) {\n        material.side = BackSide;\n        material.needsUpdate = true;\n        _this.renderBufferDirect(\n          camera,\n          scene,\n          geometry,\n          material,\n          object,\n          group,\n        );\n\n        material.side = FrontSide;\n        material.needsUpdate = true;\n        _this.renderBufferDirect(\n          camera,\n          scene,\n          geometry,\n          material,\n          object,\n          group,\n        );\n\n        material.side = DoubleSide;\n      } else {\n        _this.renderBufferDirect(\n          camera,\n          scene,\n          geometry,\n          material,\n          object,\n          group,\n        );\n      }\n    }\n\n    object.onAfterRender(_this, scene, camera, geometry, material, group);\n  }\n\n  function getProgram(material, scene, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    const materialProperties = properties.get(material);\n\n    const lights = currentRenderState.state.lights;\n    const shadowsArray = currentRenderState.state.shadowsArray;\n\n    const lightsStateVersion = lights.state.version;\n\n    const parameters = programCache.getParameters(\n      material,\n      lights.state,\n      shadowsArray,\n      scene,\n      object,\n    );\n    const programCacheKey = programCache.getProgramCacheKey(parameters);\n\n    let programs = materialProperties.programs;\n\n    // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n    materialProperties.environment = material.isMeshStandardMaterial\n      ? scene.environment\n      : null;\n    materialProperties.fog = scene.fog;\n    materialProperties.envMap = (\n      material.isMeshStandardMaterial ? cubeuvmaps : cubemaps\n    ).get(material.envMap || materialProperties.environment);\n\n    if (programs === undefined) {\n      // new material\n\n      material.addEventListener('dispose', onMaterialDispose);\n\n      programs = new Map();\n      materialProperties.programs = programs;\n    }\n\n    let program = programs.get(programCacheKey);\n\n    if (program !== undefined) {\n      // early out if program and light state is identical\n\n      if (\n        materialProperties.currentProgram === program &&\n        materialProperties.lightsStateVersion === lightsStateVersion\n      ) {\n        updateCommonMaterialProperties(material, parameters);\n\n        return program;\n      }\n    } else {\n      parameters.uniforms = programCache.getUniforms(material);\n\n      material.onBuild(parameters, _this);\n\n      material.onBeforeCompile(parameters, _this);\n\n      program = programCache.acquireProgram(parameters, programCacheKey);\n      programs.set(programCacheKey, program);\n\n      materialProperties.uniforms = parameters.uniforms;\n    }\n\n    const uniforms = materialProperties.uniforms;\n\n    if (\n      (!material.isShaderMaterial && !material.isRawShaderMaterial) ||\n      material.clipping === true\n    ) {\n      uniforms.clippingPlanes = clipping.uniform;\n    }\n\n    updateCommonMaterialProperties(material, parameters);\n\n    // store the light setup it was created for\n\n    materialProperties.needsLights = materialNeedsLights(material);\n    materialProperties.lightsStateVersion = lightsStateVersion;\n\n    if (materialProperties.needsLights) {\n      // wire up the material to this renderer's lighting state\n\n      uniforms.ambientLightColor.value = lights.state.ambient;\n      uniforms.lightProbe.value = lights.state.probe;\n      uniforms.directionalLights.value = lights.state.directional;\n      uniforms.directionalLightShadows.value = lights.state.directionalShadow;\n      uniforms.spotLights.value = lights.state.spot;\n      uniforms.spotLightShadows.value = lights.state.spotShadow;\n      uniforms.rectAreaLights.value = lights.state.rectArea;\n      uniforms.ltc_1.value = lights.state.rectAreaLTC1;\n      uniforms.ltc_2.value = lights.state.rectAreaLTC2;\n      uniforms.pointLights.value = lights.state.point;\n      uniforms.pointLightShadows.value = lights.state.pointShadow;\n      uniforms.hemisphereLights.value = lights.state.hemi;\n\n      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n      uniforms.directionalShadowMatrix.value =\n        lights.state.directionalShadowMatrix;\n      uniforms.spotShadowMap.value = lights.state.spotShadowMap;\n      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n      uniforms.pointShadowMap.value = lights.state.pointShadowMap;\n      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n      // TODO (abelnation): add area lights shadow info to uniforms\n    }\n\n    const progUniforms = program.getUniforms();\n    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n\n    materialProperties.currentProgram = program;\n    materialProperties.uniformsList = uniformsList;\n\n    return program;\n  }\n\n  function updateCommonMaterialProperties(material, parameters) {\n    const materialProperties = properties.get(material);\n\n    materialProperties.outputEncoding = parameters.outputEncoding;\n    materialProperties.instancing = parameters.instancing;\n    materialProperties.skinning = parameters.skinning;\n    materialProperties.morphTargets = parameters.morphTargets;\n    materialProperties.morphNormals = parameters.morphNormals;\n    materialProperties.morphTargetsCount = parameters.morphTargetsCount;\n    materialProperties.numClippingPlanes = parameters.numClippingPlanes;\n    materialProperties.numIntersection = parameters.numClipIntersection;\n    materialProperties.vertexAlphas = parameters.vertexAlphas;\n    materialProperties.vertexTangents = parameters.vertexTangents;\n  }\n\n  function setProgram(camera, scene, geometry, material, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    textures.resetTextureUnits();\n\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial\n      ? scene.environment\n      : null;\n    const encoding =\n      _currentRenderTarget === null\n        ? _this.outputEncoding\n        : _currentRenderTarget.texture.encoding;\n    const envMap = (\n      material.isMeshStandardMaterial ? cubeuvmaps : cubemaps\n    ).get(material.envMap || environment);\n    const vertexAlphas =\n      material.vertexColors === true &&\n      !!geometry &&\n      !!geometry.attributes.color &&\n      geometry.attributes.color.itemSize === 4;\n    const vertexTangents =\n      !!material.normalMap && !!geometry && !!geometry.attributes.tangent;\n    const morphTargets = !!geometry && !!geometry.morphAttributes.position;\n    const morphNormals = !!geometry && !!geometry.morphAttributes.normal;\n    const morphTargetsCount =\n      !!geometry && !!geometry.morphAttributes.position\n        ? geometry.morphAttributes.position.length\n        : 0;\n\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n\n    if (_clippingEnabled === true) {\n      if (_localClippingEnabled === true || camera !== _currentCamera) {\n        const useCache =\n          camera === _currentCamera && material.id === _currentMaterialId;\n\n        // we might want to call this function with some ClippingGroup\n        // object instead of the material, once it becomes feasible\n        // (#8465, #8379)\n        clipping.setState(material, camera, useCache);\n      }\n    }\n\n    //\n\n    let needsProgramChange = false;\n\n    if (material.version === materialProperties.__version) {\n      if (\n        materialProperties.needsLights &&\n        materialProperties.lightsStateVersion !== lights.state.version\n      ) {\n        needsProgramChange = true;\n      } else if (materialProperties.outputEncoding !== encoding) {\n        needsProgramChange = true;\n      } else if (\n        object.isInstancedMesh &&\n        materialProperties.instancing === false\n      ) {\n        needsProgramChange = true;\n      } else if (\n        !object.isInstancedMesh &&\n        materialProperties.instancing === true\n      ) {\n        needsProgramChange = true;\n      } else if (\n        object.isSkinnedMesh &&\n        materialProperties.skinning === false\n      ) {\n        needsProgramChange = true;\n      } else if (\n        !object.isSkinnedMesh &&\n        materialProperties.skinning === true\n      ) {\n        needsProgramChange = true;\n      } else if (materialProperties.envMap !== envMap) {\n        needsProgramChange = true;\n      } else if (material.fog && materialProperties.fog !== fog) {\n        needsProgramChange = true;\n      } else if (\n        materialProperties.numClippingPlanes !== undefined &&\n        (materialProperties.numClippingPlanes !== clipping.numPlanes ||\n          materialProperties.numIntersection !== clipping.numIntersection)\n      ) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexAlphas !== vertexAlphas) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexTangents !== vertexTangents) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphTargets !== morphTargets) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphNormals !== morphNormals) {\n        needsProgramChange = true;\n      } else if (\n        capabilities.isWebGL2 === true &&\n        materialProperties.morphTargetsCount !== morphTargetsCount\n      ) {\n        needsProgramChange = true;\n      }\n    } else {\n      needsProgramChange = true;\n      materialProperties.__version = material.version;\n    }\n\n    //\n\n    let program = materialProperties.currentProgram;\n\n    if (needsProgramChange === true) {\n      program = getProgram(material, scene, object);\n    }\n\n    let refreshProgram = false;\n    let refreshMaterial = false;\n    let refreshLights = false;\n\n    const p_uniforms = program.getUniforms(),\n      m_uniforms = materialProperties.uniforms;\n\n    if (state.useProgram(program.program)) {\n      refreshProgram = true;\n      refreshMaterial = true;\n      refreshLights = true;\n    }\n\n    if (material.id !== _currentMaterialId) {\n      _currentMaterialId = material.id;\n\n      refreshMaterial = true;\n    }\n\n    if (refreshProgram || _currentCamera !== camera) {\n      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);\n\n      if (capabilities.logarithmicDepthBuffer) {\n        p_uniforms.setValue(\n          _gl,\n          'logDepthBufFC',\n          2.0 / (Math.log(camera.far + 1.0) / Math.LN2),\n        );\n      }\n\n      if (_currentCamera !== camera) {\n        _currentCamera = camera;\n\n        // lighting uniforms depend on the camera so enforce an update\n        // now, in case this material supports lights - or later, when\n        // the next material that does gets activated:\n\n        refreshMaterial = true; // set to true on material change\n        refreshLights = true; // remains set until update done\n      }\n\n      // load material specific uniforms\n      // (shader material also gets them for the sake of genericity)\n\n      if (\n        material.isShaderMaterial ||\n        material.isMeshPhongMaterial ||\n        material.isMeshToonMaterial ||\n        material.isMeshStandardMaterial ||\n        material.envMap\n      ) {\n        const uCamPos = p_uniforms.map.cameraPosition;\n\n        if (uCamPos !== undefined) {\n          uCamPos.setValue(\n            _gl,\n            _vector3.setFromMatrixPosition(camera.matrixWorld),\n          );\n        }\n      }\n\n      if (\n        material.isMeshPhongMaterial ||\n        material.isMeshToonMaterial ||\n        material.isMeshLambertMaterial ||\n        material.isMeshBasicMaterial ||\n        material.isMeshStandardMaterial ||\n        material.isShaderMaterial\n      ) {\n        p_uniforms.setValue(\n          _gl,\n          'isOrthographic',\n          camera.isOrthographicCamera === true,\n        );\n      }\n\n      if (\n        material.isMeshPhongMaterial ||\n        material.isMeshToonMaterial ||\n        material.isMeshLambertMaterial ||\n        material.isMeshBasicMaterial ||\n        material.isMeshStandardMaterial ||\n        material.isShaderMaterial ||\n        material.isShadowMaterial ||\n        object.isSkinnedMesh\n      ) {\n        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);\n      }\n    }\n\n    // skinning and morph target uniforms must be set even if material didn't change\n    // auto-setting of texture unit for bone and morph texture must go before other textures\n    // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n    if (object.isSkinnedMesh) {\n      p_uniforms.setOptional(_gl, object, 'bindMatrix');\n      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');\n\n      const skeleton = object.skeleton;\n\n      if (skeleton) {\n        if (capabilities.floatVertexTextures) {\n          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n\n          p_uniforms.setValue(\n            _gl,\n            'boneTexture',\n            skeleton.boneTexture,\n            textures,\n          );\n          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);\n        } else {\n          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');\n        }\n      }\n    }\n\n    if (\n      !!geometry &&\n      (geometry.morphAttributes.position !== undefined ||\n        geometry.morphAttributes.normal !== undefined)\n    ) {\n      morphtargets.update(object, geometry, material, program);\n    }\n\n    if (\n      refreshMaterial ||\n      materialProperties.receiveShadow !== object.receiveShadow\n    ) {\n      materialProperties.receiveShadow = object.receiveShadow;\n      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);\n    }\n\n    if (refreshMaterial) {\n      p_uniforms.setValue(\n        _gl,\n        'toneMappingExposure',\n        _this.toneMappingExposure,\n      );\n\n      if (materialProperties.needsLights) {\n        // the current material requires lighting info\n\n        // note: all lighting uniforms are always set correctly\n        // they simply reference the renderer's state for their\n        // values\n        //\n        // use the current material's .needsUpdate flags to set\n        // the GL state when required\n\n        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n      }\n\n      // refresh uniforms common to several materials\n\n      if (fog && material.fog) {\n        materials.refreshFogUniforms(m_uniforms, fog);\n      }\n\n      materials.refreshMaterialUniforms(\n        m_uniforms,\n        material,\n        _pixelRatio,\n        _height,\n        _transmissionRenderTarget,\n      );\n\n      WebGLUniforms.upload(\n        _gl,\n        materialProperties.uniformsList,\n        m_uniforms,\n        textures,\n      );\n    }\n\n    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n      WebGLUniforms.upload(\n        _gl,\n        materialProperties.uniformsList,\n        m_uniforms,\n        textures,\n      );\n      material.uniformsNeedUpdate = false;\n    }\n\n    if (material.isSpriteMaterial) {\n      p_uniforms.setValue(_gl, 'center', object.center);\n    }\n\n    // common matrices\n\n    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);\n    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);\n    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);\n\n    return program;\n  }\n\n  // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n  function markUniformsLightsNeedsUpdate(uniforms, value) {\n    uniforms.ambientLightColor.needsUpdate = value;\n    uniforms.lightProbe.needsUpdate = value;\n\n    uniforms.directionalLights.needsUpdate = value;\n    uniforms.directionalLightShadows.needsUpdate = value;\n    uniforms.pointLights.needsUpdate = value;\n    uniforms.pointLightShadows.needsUpdate = value;\n    uniforms.spotLights.needsUpdate = value;\n    uniforms.spotLightShadows.needsUpdate = value;\n    uniforms.rectAreaLights.needsUpdate = value;\n    uniforms.hemisphereLights.needsUpdate = value;\n  }\n\n  function materialNeedsLights(material) {\n    return (\n      material.isMeshLambertMaterial ||\n      material.isMeshToonMaterial ||\n      material.isMeshPhongMaterial ||\n      material.isMeshStandardMaterial ||\n      material.isShadowMaterial ||\n      (material.isShaderMaterial && material.lights === true)\n    );\n  }\n\n  this.getActiveCubeFace = function () {\n    return _currentActiveCubeFace;\n  };\n\n  this.getActiveMipmapLevel = function () {\n    return _currentActiveMipmapLevel;\n  };\n\n  this.getRenderTarget = function () {\n    return _currentRenderTarget;\n  };\n\n  this.setRenderTarget = function (\n    renderTarget,\n    activeCubeFace = 0,\n    activeMipmapLevel = 0,\n  ) {\n    _currentRenderTarget = renderTarget;\n    _currentActiveCubeFace = activeCubeFace;\n    _currentActiveMipmapLevel = activeMipmapLevel;\n\n    if (\n      renderTarget &&\n      properties.get(renderTarget).__webglFramebuffer === undefined\n    ) {\n      textures.setupRenderTarget(renderTarget);\n    }\n\n    let framebuffer = null;\n    let isCube = false;\n    let isRenderTarget3D = false;\n\n    if (renderTarget) {\n      const texture = renderTarget.texture;\n\n      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {\n        isRenderTarget3D = true;\n      }\n\n      const __webglFramebuffer =\n        properties.get(renderTarget).__webglFramebuffer;\n\n      if (renderTarget.isWebGLCubeRenderTarget) {\n        framebuffer = __webglFramebuffer[activeCubeFace];\n        isCube = true;\n      } else if (renderTarget.isWebGLMultisampleRenderTarget) {\n        framebuffer =\n          properties.get(renderTarget).__webglMultisampledFramebuffer;\n      } else {\n        framebuffer = __webglFramebuffer;\n      }\n\n      _currentViewport.copy(renderTarget.viewport);\n      _currentScissor.copy(renderTarget.scissor);\n      _currentScissorTest = renderTarget.scissorTest;\n    } else {\n      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n      _currentScissorTest = _scissorTest;\n    }\n\n    const framebufferBound = state.bindFramebuffer(36160, framebuffer);\n\n    if (framebufferBound && capabilities.drawBuffers) {\n      let needsUpdate = false;\n\n      if (renderTarget) {\n        if (renderTarget.isWebGLMultipleRenderTargets) {\n          const textures = renderTarget.texture;\n\n          if (\n            _currentDrawBuffers.length !== textures.length ||\n            _currentDrawBuffers[0] !== 36064\n          ) {\n            for (let i = 0, il = textures.length; i < il; i++) {\n              _currentDrawBuffers[i] = 36064 + i;\n            }\n\n            _currentDrawBuffers.length = textures.length;\n\n            needsUpdate = true;\n          }\n        } else {\n          if (\n            _currentDrawBuffers.length !== 1 ||\n            _currentDrawBuffers[0] !== 36064\n          ) {\n            _currentDrawBuffers[0] = 36064;\n            _currentDrawBuffers.length = 1;\n\n            needsUpdate = true;\n          }\n        }\n      } else {\n        if (\n          _currentDrawBuffers.length !== 1 ||\n          _currentDrawBuffers[0] !== 1029\n        ) {\n          _currentDrawBuffers[0] = 1029;\n          _currentDrawBuffers.length = 1;\n\n          needsUpdate = true;\n        }\n      }\n\n      if (needsUpdate) {\n        if (capabilities.isWebGL2) {\n          _gl.drawBuffers(_currentDrawBuffers);\n        } else {\n          extensions\n            .get('WEBGL_draw_buffers')\n            .drawBuffersWEBGL(_currentDrawBuffers);\n        }\n      }\n    }\n\n    state.viewport(_currentViewport);\n    state.scissor(_currentScissor);\n    state.setScissorTest(_currentScissorTest);\n\n    if (isCube) {\n      const textureProperties = properties.get(renderTarget.texture);\n      _gl.framebufferTexture2D(\n        36160,\n        36064,\n        34069 + activeCubeFace,\n        textureProperties.__webglTexture,\n        activeMipmapLevel,\n      );\n    } else if (isRenderTarget3D) {\n      const textureProperties = properties.get(renderTarget.texture);\n      const layer = activeCubeFace || 0;\n      _gl.framebufferTextureLayer(\n        36160,\n        36064,\n        textureProperties.__webglTexture,\n        activeMipmapLevel || 0,\n        layer,\n      );\n    }\n\n    _currentMaterialId = -1; // reset current material to ensure correct uniform bindings\n  };\n\n  this.readRenderTargetPixels = function (\n    renderTarget,\n    x,\n    y,\n    width,\n    height,\n    buffer,\n    activeCubeFaceIndex,\n  ) {\n    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n      console.error(\n        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',\n      );\n      return;\n    }\n\n    let framebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n    if (\n      renderTarget.isWebGLCubeRenderTarget &&\n      activeCubeFaceIndex !== undefined\n    ) {\n      framebuffer = framebuffer[activeCubeFaceIndex];\n    }\n\n    if (framebuffer) {\n      state.bindFramebuffer(36160, framebuffer);\n\n      try {\n        const texture = renderTarget.texture;\n        const textureFormat = texture.format;\n        const textureType = texture.type;\n\n        if (\n          textureFormat !== RGBAFormat &&\n          utils.convert(textureFormat) !== _gl.getParameter(35739)\n        ) {\n          console.error(\n            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',\n          );\n          return;\n        }\n\n        const halfFloatSupportedByExt =\n          textureType === HalfFloatType &&\n          (extensions.has('EXT_color_buffer_half_float') ||\n            (capabilities.isWebGL2 &&\n              extensions.has('EXT_color_buffer_float')));\n\n        if (\n          textureType !== UnsignedByteType &&\n          utils.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)\n          !(\n            textureType === FloatType &&\n            (capabilities.isWebGL2 ||\n              extensions.has('OES_texture_float') ||\n              extensions.has('WEBGL_color_buffer_float'))\n          ) && // Chrome Mac >= 52 and Firefox\n          !halfFloatSupportedByExt\n        ) {\n          console.error(\n            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',\n          );\n          return;\n        }\n\n        if (_gl.checkFramebufferStatus(36160) === 36053) {\n          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n          if (\n            x >= 0 &&\n            x <= renderTarget.width - width &&\n            y >= 0 &&\n            y <= renderTarget.height - height\n          ) {\n            _gl.readPixels(\n              x,\n              y,\n              width,\n              height,\n              utils.convert(textureFormat),\n              utils.convert(textureType),\n              buffer,\n            );\n          }\n        } else {\n          console.error(\n            'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.',\n          );\n        }\n      } finally {\n        // restore framebuffer of current render target if necessary\n\n        const framebuffer =\n          _currentRenderTarget !== null\n            ? properties.get(_currentRenderTarget).__webglFramebuffer\n            : null;\n        state.bindFramebuffer(36160, framebuffer);\n      }\n    }\n  };\n\n  this.copyFramebufferToTexture = function (position, texture, level = 0) {\n    const levelScale = Math.pow(2, -level);\n    const width = Math.floor(texture.image.width * levelScale);\n    const height = Math.floor(texture.image.height * levelScale);\n\n    let glFormat = utils.convert(texture.format);\n\n    if (capabilities.isWebGL2) {\n      // Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100\n      // Not needed in Chrome 93+\n\n      if (glFormat === 6407) glFormat = 32849;\n      if (glFormat === 6408) glFormat = 32856;\n    }\n\n    textures.setTexture2D(texture, 0);\n\n    _gl.copyTexImage2D(\n      3553,\n      level,\n      glFormat,\n      position.x,\n      position.y,\n      width,\n      height,\n      0,\n    );\n\n    state.unbindTexture();\n  };\n\n  this.copyTextureToTexture = function (\n    position,\n    srcTexture,\n    dstTexture,\n    level = 0,\n  ) {\n    const width = srcTexture.image.width;\n    const height = srcTexture.image.height;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n\n    textures.setTexture2D(dstTexture, 0);\n\n    // As another texture upload may have changed pixelStorei\n    // parameters, make sure they are correct for the dstTexture\n    _gl.pixelStorei(37440, dstTexture.flipY);\n    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);\n    _gl.pixelStorei(3317, dstTexture.unpackAlignment);\n\n    if (srcTexture.isDataTexture) {\n      _gl.texSubImage2D(\n        3553,\n        level,\n        position.x,\n        position.y,\n        width,\n        height,\n        glFormat,\n        glType,\n        srcTexture.image.data,\n      );\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        _gl.compressedTexSubImage2D(\n          3553,\n          level,\n          position.x,\n          position.y,\n          srcTexture.mipmaps[0].width,\n          srcTexture.mipmaps[0].height,\n          glFormat,\n          srcTexture.mipmaps[0].data,\n        );\n      } else {\n        _gl.texSubImage2D(\n          3553,\n          level,\n          position.x,\n          position.y,\n          glFormat,\n          glType,\n          srcTexture.image,\n        );\n      }\n    }\n\n    // Generate mipmaps only when copying level 0\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);\n\n    state.unbindTexture();\n  };\n\n  this.copyTextureToTexture3D = function (\n    sourceBox,\n    position,\n    srcTexture,\n    dstTexture,\n    level = 0,\n  ) {\n    if (_this.isWebGL1Renderer) {\n      console.warn(\n        'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.',\n      );\n      return;\n    }\n\n    const width = sourceBox.max.x - sourceBox.min.x + 1;\n    const height = sourceBox.max.y - sourceBox.min.y + 1;\n    const depth = sourceBox.max.z - sourceBox.min.z + 1;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    let glTarget;\n\n    if (dstTexture.isDataTexture3D) {\n      textures.setTexture3D(dstTexture, 0);\n      glTarget = 32879;\n    } else if (dstTexture.isDataTexture2DArray) {\n      textures.setTexture2DArray(dstTexture, 0);\n      glTarget = 35866;\n    } else {\n      console.warn(\n        'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.',\n      );\n      return;\n    }\n\n    _gl.pixelStorei(37440, dstTexture.flipY);\n    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);\n    _gl.pixelStorei(3317, dstTexture.unpackAlignment);\n\n    const unpackRowLen = _gl.getParameter(3314);\n    const unpackImageHeight = _gl.getParameter(32878);\n    const unpackSkipPixels = _gl.getParameter(3316);\n    const unpackSkipRows = _gl.getParameter(3315);\n    const unpackSkipImages = _gl.getParameter(32877);\n\n    const image = srcTexture.isCompressedTexture\n      ? srcTexture.mipmaps[0]\n      : srcTexture.image;\n\n    _gl.pixelStorei(3314, image.width);\n    _gl.pixelStorei(32878, image.height);\n    _gl.pixelStorei(3316, sourceBox.min.x);\n    _gl.pixelStorei(3315, sourceBox.min.y);\n    _gl.pixelStorei(32877, sourceBox.min.z);\n\n    if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {\n      _gl.texSubImage3D(\n        glTarget,\n        level,\n        position.x,\n        position.y,\n        position.z,\n        width,\n        height,\n        depth,\n        glFormat,\n        glType,\n        image.data,\n      );\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        console.warn(\n          'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.',\n        );\n        _gl.compressedTexSubImage3D(\n          glTarget,\n          level,\n          position.x,\n          position.y,\n          position.z,\n          width,\n          height,\n          depth,\n          glFormat,\n          image.data,\n        );\n      } else {\n        _gl.texSubImage3D(\n          glTarget,\n          level,\n          position.x,\n          position.y,\n          position.z,\n          width,\n          height,\n          depth,\n          glFormat,\n          glType,\n          image,\n        );\n      }\n    }\n\n    _gl.pixelStorei(3314, unpackRowLen);\n    _gl.pixelStorei(32878, unpackImageHeight);\n    _gl.pixelStorei(3316, unpackSkipPixels);\n    _gl.pixelStorei(3315, unpackSkipRows);\n    _gl.pixelStorei(32877, unpackSkipImages);\n\n    // Generate mipmaps only when copying level 0\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);\n\n    state.unbindTexture();\n  };\n\n  this.initTexture = function (texture) {\n    textures.setTexture2D(texture, 0);\n\n    state.unbindTexture();\n  };\n\n  this.resetState = function () {\n    _currentActiveCubeFace = 0;\n    _currentActiveMipmapLevel = 0;\n    _currentRenderTarget = null;\n\n    state.reset();\n    bindingStates.reset();\n  };\n\n  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n    __THREE_DEVTOOLS__.dispatchEvent(\n      new CustomEvent('observe', { detail: this }),\n    ); // eslint-disable-line no-undef\n  }\n}\n\nclass WebGL1Renderer extends WebGLRenderer {}\n\nWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\nclass Scene extends Object3D {\n  constructor() {\n    super();\n\n    this.type = 'Scene';\n\n    this.background = null;\n    this.environment = null;\n    this.fog = null;\n\n    this.overrideMaterial = null;\n\n    this.autoUpdate = true; // checked by the renderer\n\n    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n      __THREE_DEVTOOLS__.dispatchEvent(\n        new CustomEvent('observe', { detail: this }),\n      ); // eslint-disable-line no-undef\n    }\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n\n    if (source.background !== null) this.background = source.background.clone();\n    if (source.environment !== null)\n      this.environment = source.environment.clone();\n    if (source.fog !== null) this.fog = source.fog.clone();\n\n    if (source.overrideMaterial !== null)\n      this.overrideMaterial = source.overrideMaterial.clone();\n\n    this.autoUpdate = source.autoUpdate;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n\n    if (this.fog !== null) data.object.fog = this.fog.toJSON();\n\n    return data;\n  }\n}\n\nScene.prototype.isScene = true;\n\nclass InterleavedBuffer {\n  constructor(array, stride) {\n    this.array = array;\n    this.stride = stride;\n    this.count = array !== undefined ? array.length / stride : 0;\n\n    this.usage = StaticDrawUsage;\n    this.updateRange = { offset: 0, count: -1 };\n\n    this.version = 0;\n\n    this.uuid = generateUUID();\n  }\n\n  onUploadCallback() {}\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n\n  setUsage(value) {\n    this.usage = value;\n\n    return this;\n  }\n\n  copy(source) {\n    this.array = new source.array.constructor(source.array);\n    this.count = source.count;\n    this.stride = source.stride;\n    this.usage = source.usage;\n\n    return this;\n  }\n\n  copyAt(index1, attribute, index2) {\n    index1 *= this.stride;\n    index2 *= attribute.stride;\n\n    for (let i = 0, l = this.stride; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n\n    return this;\n  }\n\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n\n    return this;\n  }\n\n  clone(data) {\n    if (data.arrayBuffers === undefined) {\n      data.arrayBuffers = {};\n    }\n\n    if (this.array.buffer._uuid === undefined) {\n      this.array.buffer._uuid = generateUUID();\n    }\n\n    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n    }\n\n    const array = new this.array.constructor(\n      data.arrayBuffers[this.array.buffer._uuid],\n    );\n\n    const ib = new this.constructor(array, this.stride);\n    ib.setUsage(this.usage);\n\n    return ib;\n  }\n\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n\n    return this;\n  }\n\n  toJSON(data) {\n    if (data.arrayBuffers === undefined) {\n      data.arrayBuffers = {};\n    }\n\n    // generate UUID for array buffer if necessary\n\n    if (this.array.buffer._uuid === undefined) {\n      this.array.buffer._uuid = generateUUID();\n    }\n\n    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(\n        new Uint32Array(this.array.buffer),\n      );\n    }\n\n    //\n\n    return {\n      uuid: this.uuid,\n      buffer: this.array.buffer._uuid,\n      type: this.array.constructor.name,\n      stride: this.stride,\n    };\n  }\n}\n\nInterleavedBuffer.prototype.isInterleavedBuffer = true;\n\nconst _vector$6 = /*@__PURE__*/ new Vector3();\n\nclass InterleavedBufferAttribute {\n  constructor(interleavedBuffer, itemSize, offset, normalized = false) {\n    this.name = '';\n\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n\n    this.normalized = normalized === true;\n  }\n\n  get count() {\n    return this.data.count;\n  }\n\n  get array() {\n    return this.data.array;\n  }\n\n  set needsUpdate(value) {\n    this.data.needsUpdate = value;\n  }\n\n  applyMatrix4(m) {\n    for (let i = 0, l = this.data.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n\n      _vector$6.applyMatrix4(m);\n\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n\n    return this;\n  }\n\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n\n      _vector$6.applyNormalMatrix(m);\n\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n\n    return this;\n  }\n\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n\n      _vector$6.transformDirection(m);\n\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n\n    return this;\n  }\n\n  setX(index, x) {\n    this.data.array[index * this.data.stride + this.offset] = x;\n\n    return this;\n  }\n\n  setY(index, y) {\n    this.data.array[index * this.data.stride + this.offset + 1] = y;\n\n    return this;\n  }\n\n  setZ(index, z) {\n    this.data.array[index * this.data.stride + this.offset + 2] = z;\n\n    return this;\n  }\n\n  setW(index, w) {\n    this.data.array[index * this.data.stride + this.offset + 3] = w;\n\n    return this;\n  }\n\n  getX(index) {\n    return this.data.array[index * this.data.stride + this.offset];\n  }\n\n  getY(index) {\n    return this.data.array[index * this.data.stride + this.offset + 1];\n  }\n\n  getZ(index) {\n    return this.data.array[index * this.data.stride + this.offset + 2];\n  }\n\n  getW(index) {\n    return this.data.array[index * this.data.stride + this.offset + 3];\n  }\n\n  setXY(index, x, y) {\n    index = index * this.data.stride + this.offset;\n\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n\n    return this;\n  }\n\n  setXYZ(index, x, y, z) {\n    index = index * this.data.stride + this.offset;\n\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n\n    return this;\n  }\n\n  setXYZW(index, x, y, z, w) {\n    index = index * this.data.stride + this.offset;\n\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    this.data.array[index + 3] = w;\n\n    return this;\n  }\n\n  clone(data) {\n    if (data === undefined) {\n      console.log(\n        'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.',\n      );\n\n      const array = [];\n\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n\n      return new BufferAttribute(\n        new this.array.constructor(array),\n        this.itemSize,\n        this.normalized,\n      );\n    } else {\n      if (data.interleavedBuffers === undefined) {\n        data.interleavedBuffers = {};\n      }\n\n      if (data.interleavedBuffers[this.data.uuid] === undefined) {\n        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n      }\n\n      return new InterleavedBufferAttribute(\n        data.interleavedBuffers[this.data.uuid],\n        this.itemSize,\n        this.offset,\n        this.normalized,\n      );\n    }\n  }\n\n  toJSON(data) {\n    if (data === undefined) {\n      console.log(\n        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.',\n      );\n\n      const array = [];\n\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n\n      // deinterleave data and save it as an ordinary buffer attribute for now\n\n      return {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: array,\n        normalized: this.normalized,\n      };\n    } else {\n      // save as true interlaved attribtue\n\n      if (data.interleavedBuffers === undefined) {\n        data.interleavedBuffers = {};\n      }\n\n      if (data.interleavedBuffers[this.data.uuid] === undefined) {\n        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n      }\n\n      return {\n        isInterleavedBufferAttribute: true,\n        itemSize: this.itemSize,\n        data: this.data.uuid,\n        offset: this.offset,\n        normalized: this.normalized,\n      };\n    }\n  }\n}\n\nInterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *  rotation: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nclass SpriteMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'SpriteMaterial';\n\n    this.color = new Color(0xffffff);\n\n    this.map = null;\n\n    this.alphaMap = null;\n\n    this.rotation = 0;\n\n    this.sizeAttenuation = true;\n\n    this.transparent = true;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n\n    this.map = source.map;\n\n    this.alphaMap = source.alphaMap;\n\n    this.rotation = source.rotation;\n\n    this.sizeAttenuation = source.sizeAttenuation;\n\n    return this;\n  }\n}\n\nSpriteMaterial.prototype.isSpriteMaterial = true;\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends Object3D {\n  constructor(material) {\n    super();\n\n    this.type = 'Sprite';\n\n    if (_geometry === undefined) {\n      _geometry = new BufferGeometry();\n\n      const float32Array = new Float32Array([\n        -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,\n        0, 0, 1,\n      ]);\n\n      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n\n      _geometry.setIndex([0, 1, 2, 0, 2, 3]);\n      _geometry.setAttribute(\n        'position',\n        new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false),\n      );\n      _geometry.setAttribute(\n        'uv',\n        new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false),\n      );\n    }\n\n    this.geometry = _geometry;\n    this.material = material !== undefined ? material : new SpriteMaterial();\n\n    this.center = new Vector2(0.5, 0.5);\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error(\n        'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.',\n      );\n    }\n\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n\n    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n    this.modelViewMatrix.multiplyMatrices(\n      raycaster.camera.matrixWorldInverse,\n      this.matrixWorld,\n    );\n\n    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n\n    if (\n      raycaster.camera.isPerspectiveCamera &&\n      this.material.sizeAttenuation === false\n    ) {\n      _worldScale.multiplyScalar(-_mvPosition.z);\n    }\n\n    const rotation = this.material.rotation;\n    let sin, cos;\n\n    if (rotation !== 0) {\n      cos = Math.cos(rotation);\n      sin = Math.sin(rotation);\n    }\n\n    const center = this.center;\n\n    transformVertex(\n      _vA.set(-0.5, -0.5, 0),\n      _mvPosition,\n      center,\n      _worldScale,\n      sin,\n      cos,\n    );\n    transformVertex(\n      _vB.set(0.5, -0.5, 0),\n      _mvPosition,\n      center,\n      _worldScale,\n      sin,\n      cos,\n    );\n    transformVertex(\n      _vC.set(0.5, 0.5, 0),\n      _mvPosition,\n      center,\n      _worldScale,\n      sin,\n      cos,\n    );\n\n    _uvA.set(0, 0);\n    _uvB.set(1, 0);\n    _uvC.set(1, 1);\n\n    // check first triangle\n    let intersect = raycaster.ray.intersectTriangle(\n      _vA,\n      _vB,\n      _vC,\n      false,\n      _intersectPoint,\n    );\n\n    if (intersect === null) {\n      // check second triangle\n      transformVertex(\n        _vB.set(-0.5, 0.5, 0),\n        _mvPosition,\n        center,\n        _worldScale,\n        sin,\n        cos,\n      );\n      _uvB.set(0, 1);\n\n      intersect = raycaster.ray.intersectTriangle(\n        _vA,\n        _vC,\n        _vB,\n        false,\n        _intersectPoint,\n      );\n      if (intersect === null) {\n        return;\n      }\n    }\n\n    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n\n    if (distance < raycaster.near || distance > raycaster.far) return;\n\n    intersects.push({\n      distance: distance,\n      point: _intersectPoint.clone(),\n      uv: Triangle.getUV(\n        _intersectPoint,\n        _vA,\n        _vB,\n        _vC,\n        _uvA,\n        _uvB,\n        _uvC,\n        new Vector2(),\n      ),\n      face: null,\n      object: this,\n    });\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    if (source.center !== undefined) this.center.copy(source.center);\n\n    this.material = source.material;\n\n    return this;\n  }\n}\n\nSprite.prototype.isSprite = true;\n\nfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n  // compute position in camera space\n  _alignedPosition\n    .subVectors(vertexPosition, center)\n    .addScalar(0.5)\n    .multiply(scale);\n\n  // to check if rotation is not zero\n  if (sin !== undefined) {\n    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n  } else {\n    _rotatedPosition.copy(_alignedPosition);\n  }\n\n  vertexPosition.copy(mvPosition);\n  vertexPosition.x += _rotatedPosition.x;\n  vertexPosition.y += _rotatedPosition.y;\n\n  // transform to world space\n  vertexPosition.applyMatrix4(_viewWorldMatrix);\n}\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector$5 = /*@__PURE__*/ new Vector3();\nconst _matrix = /*@__PURE__*/ new Matrix4();\n\nclass SkinnedMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n\n    this.type = 'SkinnedMesh';\n\n    this.bindMode = 'attached';\n    this.bindMatrix = new Matrix4();\n    this.bindMatrixInverse = new Matrix4();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.bindMode = source.bindMode;\n    this.bindMatrix.copy(source.bindMatrix);\n    this.bindMatrixInverse.copy(source.bindMatrixInverse);\n\n    this.skeleton = source.skeleton;\n\n    return this;\n  }\n\n  bind(skeleton, bindMatrix) {\n    this.skeleton = skeleton;\n\n    if (bindMatrix === undefined) {\n      this.updateMatrixWorld(true);\n\n      this.skeleton.calculateInverses();\n\n      bindMatrix = this.matrixWorld;\n    }\n\n    this.bindMatrix.copy(bindMatrix);\n    this.bindMatrixInverse.copy(bindMatrix).invert();\n  }\n\n  pose() {\n    this.skeleton.pose();\n  }\n\n  normalizeSkinWeights() {\n    const vector = new Vector4();\n\n    const skinWeight = this.geometry.attributes.skinWeight;\n\n    for (let i = 0, l = skinWeight.count; i < l; i++) {\n      vector.x = skinWeight.getX(i);\n      vector.y = skinWeight.getY(i);\n      vector.z = skinWeight.getZ(i);\n      vector.w = skinWeight.getW(i);\n\n      const scale = 1.0 / vector.manhattanLength();\n\n      if (scale !== Infinity) {\n        vector.multiplyScalar(scale);\n      } else {\n        vector.set(1, 0, 0, 0); // do something reasonable\n      }\n\n      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n    }\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    if (this.bindMode === 'attached') {\n      this.bindMatrixInverse.copy(this.matrixWorld).invert();\n    } else if (this.bindMode === 'detached') {\n      this.bindMatrixInverse.copy(this.bindMatrix).invert();\n    } else {\n      console.warn(\n        'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode,\n      );\n    }\n  }\n\n  boneTransform(index, target) {\n    const skeleton = this.skeleton;\n    const geometry = this.geometry;\n\n    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n    _basePosition.copy(target).applyMatrix4(this.bindMatrix);\n\n    target.set(0, 0, 0);\n\n    for (let i = 0; i < 4; i++) {\n      const weight = _skinWeight.getComponent(i);\n\n      if (weight !== 0) {\n        const boneIndex = _skinIndex.getComponent(i);\n\n        _matrix.multiplyMatrices(\n          skeleton.bones[boneIndex].matrixWorld,\n          skeleton.boneInverses[boneIndex],\n        );\n\n        target.addScaledVector(\n          _vector$5.copy(_basePosition).applyMatrix4(_matrix),\n          weight,\n        );\n      }\n    }\n\n    return target.applyMatrix4(this.bindMatrixInverse);\n  }\n}\n\nSkinnedMesh.prototype.isSkinnedMesh = true;\n\nclass Bone extends Object3D {\n  constructor() {\n    super();\n\n    this.type = 'Bone';\n  }\n}\n\nBone.prototype.isBone = true;\n\nclass DataTexture extends Texture$1 {\n  constructor(\n    data = null,\n    width = 1,\n    height = 1,\n    format,\n    type,\n    mapping,\n    wrapS,\n    wrapT,\n    magFilter = NearestFilter,\n    minFilter = NearestFilter,\n    anisotropy,\n    encoding,\n  ) {\n    super(\n      null,\n      mapping,\n      wrapS,\n      wrapT,\n      magFilter,\n      minFilter,\n      format,\n      type,\n      anisotropy,\n      encoding,\n    );\n\n    this.image = { data: data, width: width, height: height };\n\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n\n    this.needsUpdate = true;\n  }\n}\n\nDataTexture.prototype.isDataTexture = true;\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n  constructor(bones = [], boneInverses = []) {\n    this.uuid = generateUUID();\n\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n\n    this.boneTexture = null;\n    this.boneTextureSize = 0;\n\n    this.frame = -1;\n\n    this.init();\n  }\n\n  init() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n\n    this.boneMatrices = new Float32Array(bones.length * 16);\n\n    // calculate inverse bone matrices if necessary\n\n    if (boneInverses.length === 0) {\n      this.calculateInverses();\n    } else {\n      // handle special case\n\n      if (bones.length !== boneInverses.length) {\n        console.warn(\n          'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.',\n        );\n\n        this.boneInverses = [];\n\n        for (let i = 0, il = this.bones.length; i < il; i++) {\n          this.boneInverses.push(new Matrix4());\n        }\n      }\n    }\n  }\n\n  calculateInverses() {\n    this.boneInverses.length = 0;\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const inverse = new Matrix4();\n\n      if (this.bones[i]) {\n        inverse.copy(this.bones[i].matrixWorld).invert();\n      }\n\n      this.boneInverses.push(inverse);\n    }\n  }\n\n  pose() {\n    // recover the bind-time world matrices\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone) {\n        bone.matrixWorld.copy(this.boneInverses[i]).invert();\n      }\n    }\n\n    // compute the local matrices, positions, rotations and scales\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone) {\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(bone.matrixWorld);\n        } else {\n          bone.matrix.copy(bone.matrixWorld);\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      }\n    }\n  }\n\n  update() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    const boneMatrices = this.boneMatrices;\n    const boneTexture = this.boneTexture;\n\n    // flatten bone matrices to array\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      // compute the offset between the current and the original transform\n\n      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n\n    if (boneTexture !== null) {\n      boneTexture.needsUpdate = true;\n    }\n  }\n\n  clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  }\n\n  computeBoneTexture() {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n    let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n    size = ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n\n    const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n    boneMatrices.set(this.boneMatrices); // copy current values\n\n    const boneTexture = new DataTexture(\n      boneMatrices,\n      size,\n      size,\n      RGBAFormat,\n      FloatType,\n    );\n\n    this.boneMatrices = boneMatrices;\n    this.boneTexture = boneTexture;\n    this.boneTextureSize = size;\n\n    return this;\n  }\n\n  getBoneByName(name) {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n\n    return undefined;\n  }\n\n  dispose() {\n    if (this.boneTexture !== null) {\n      this.boneTexture.dispose();\n\n      this.boneTexture = null;\n    }\n  }\n\n  fromJSON(json, bones) {\n    this.uuid = json.uuid;\n\n    for (let i = 0, l = json.bones.length; i < l; i++) {\n      const uuid = json.bones[i];\n      let bone = bones[uuid];\n\n      if (bone === undefined) {\n        console.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n        bone = new Bone();\n      }\n\n      this.bones.push(bone);\n      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n    }\n\n    this.init();\n\n    return this;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Skeleton',\n        generator: 'Skeleton.toJSON',\n      },\n      bones: [],\n      boneInverses: [],\n    };\n\n    data.uuid = this.uuid;\n\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n\n    for (let i = 0, l = bones.length; i < l; i++) {\n      const bone = bones[i];\n      data.bones.push(bone.uuid);\n\n      const boneInverse = boneInverses[i];\n      data.boneInverses.push(boneInverse.toArray());\n    }\n\n    return data;\n  }\n}\n\nclass InstancedBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized, meshPerAttribute = 1) {\n    if (typeof normalized === 'number') {\n      meshPerAttribute = normalized;\n\n      normalized = false;\n\n      console.error(\n        'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.',\n      );\n    }\n\n    super(array, itemSize, normalized);\n\n    this.meshPerAttribute = meshPerAttribute;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.meshPerAttribute = source.meshPerAttribute;\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.meshPerAttribute = this.meshPerAttribute;\n\n    data.isInstancedBufferAttribute = true;\n\n    return data;\n  }\n}\n\nInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh$1 = /*@__PURE__*/ new Mesh();\n\nclass InstancedMesh extends Mesh {\n  constructor(geometry, material, count) {\n    super(geometry, material);\n\n    this.instanceMatrix = new InstancedBufferAttribute(\n      new Float32Array(count * 16),\n      16,\n    );\n    this.instanceColor = null;\n\n    this.count = count;\n\n    this.frustumCulled = false;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.instanceMatrix.copy(source.instanceMatrix);\n\n    if (source.instanceColor !== null)\n      this.instanceColor = source.instanceColor.clone();\n\n    this.count = source.count;\n\n    return this;\n  }\n\n  getColorAt(index, color) {\n    color.fromArray(this.instanceColor.array, index * 3);\n  }\n\n  getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  }\n\n  raycast(raycaster, intersects) {\n    const matrixWorld = this.matrixWorld;\n    const raycastTimes = this.count;\n\n    _mesh$1.geometry = this.geometry;\n    _mesh$1.material = this.material;\n\n    if (_mesh$1.material === undefined) return;\n\n    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      // calculate the world matrix for each instance\n\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);\n\n      // the mesh represents this single instance\n\n      _mesh$1.matrixWorld = _instanceWorldMatrix;\n\n      _mesh$1.raycast(raycaster, _instanceIntersects);\n\n      // process the result of raycast\n\n      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n        const intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects.push(intersect);\n      }\n\n      _instanceIntersects.length = 0;\n    }\n  }\n\n  setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new InstancedBufferAttribute(\n        new Float32Array(this.instanceMatrix.count * 3),\n        3,\n      );\n    }\n\n    color.toArray(this.instanceColor.array, index * 3);\n  }\n\n  setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  }\n\n  updateMorphTargets() {}\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' });\n  }\n}\n\nInstancedMesh.prototype.isInstancedMesh = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nclass LineBasicMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'LineBasicMaterial';\n\n    this.color = new Color(0xffffff);\n\n    this.linewidth = 1;\n    this.linecap = 'round';\n    this.linejoin = 'round';\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n\n    this.linewidth = source.linewidth;\n    this.linecap = source.linecap;\n    this.linejoin = source.linejoin;\n\n    return this;\n  }\n}\n\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\nconst _start$1 = /*@__PURE__*/ new Vector3();\nconst _end$1 = /*@__PURE__*/ new Vector3();\nconst _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _ray$1 = /*@__PURE__*/ new Ray();\nconst _sphere$1 = /*@__PURE__*/ new Sphere();\n\nclass Line extends Object3D {\n  constructor(\n    geometry = new BufferGeometry(),\n    material = new LineBasicMaterial(),\n  ) {\n    super();\n\n    this.type = 'Line';\n\n    this.geometry = geometry;\n    this.material = material;\n\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.material = source.material;\n    this.geometry = source.geometry;\n\n    return this;\n  }\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n\n      if (geometry.index === null) {\n        const positionAttribute = geometry.attributes.position;\n        const lineDistances = [0];\n\n        for (let i = 1, l = positionAttribute.count; i < l; i++) {\n          _start$1.fromBufferAttribute(positionAttribute, i - 1);\n          _end$1.fromBufferAttribute(positionAttribute, i);\n\n          lineDistances[i] = lineDistances[i - 1];\n          lineDistances[i] += _start$1.distanceTo(_end$1);\n        }\n\n        geometry.setAttribute(\n          'lineDistance',\n          new Float32BufferAttribute(lineDistances, 1),\n        );\n      } else {\n        console.warn(\n          'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',\n        );\n      }\n    } else if (geometry.isGeometry) {\n      console.error(\n        'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',\n      );\n    }\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Line.threshold;\n    const drawRange = geometry.drawRange;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere$1.copy(geometry.boundingSphere);\n    _sphere$1.applyMatrix4(matrixWorld);\n    _sphere$1.radius += threshold;\n\n    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;\n\n    //\n\n    _inverseMatrix$1.copy(matrixWorld).invert();\n    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n\n    const localThreshold =\n      threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n\n    const vStart = new Vector3();\n    const vEnd = new Vector3();\n    const interSegment = new Vector3();\n    const interRay = new Vector3();\n    const step = this.isLineSegments ? 2 : 1;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const attributes = geometry.attributes;\n      const positionAttribute = attributes.position;\n\n      if (index !== null) {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (let i = start, l = end - 1; i < l; i += step) {\n          const a = index.getX(i);\n          const b = index.getX(i + 1);\n\n          vStart.fromBufferAttribute(positionAttribute, a);\n          vEnd.fromBufferAttribute(positionAttribute, b);\n\n          const distSq = _ray$1.distanceSqToSegment(\n            vStart,\n            vEnd,\n            interRay,\n            interSegment,\n          );\n\n          if (distSq > localThresholdSq) continue;\n\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          const distance = raycaster.ray.origin.distanceTo(interRay);\n\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this,\n          });\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(\n          positionAttribute.count,\n          drawRange.start + drawRange.count,\n        );\n\n        for (let i = start, l = end - 1; i < l; i += step) {\n          vStart.fromBufferAttribute(positionAttribute, i);\n          vEnd.fromBufferAttribute(positionAttribute, i + 1);\n\n          const distSq = _ray$1.distanceSqToSegment(\n            vStart,\n            vEnd,\n            interRay,\n            interSegment,\n          );\n\n          if (distSq > localThresholdSq) continue;\n\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          const distance = raycaster.ray.origin.distanceTo(interRay);\n\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this,\n          });\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error(\n        'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',\n      );\n    }\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error(\n          'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',\n        );\n      }\n    }\n  }\n}\n\nLine.prototype.isLine = true;\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\n\nclass LineSegments extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n\n    this.type = 'LineSegments';\n  }\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n\n      if (geometry.index === null) {\n        const positionAttribute = geometry.attributes.position;\n        const lineDistances = [];\n\n        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {\n          _start.fromBufferAttribute(positionAttribute, i);\n          _end.fromBufferAttribute(positionAttribute, i + 1);\n\n          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n        }\n\n        geometry.setAttribute(\n          'lineDistance',\n          new Float32BufferAttribute(lineDistances, 1),\n        );\n      } else {\n        console.warn(\n          'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',\n        );\n      }\n    } else if (geometry.isGeometry) {\n      console.error(\n        'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',\n      );\n    }\n\n    return this;\n  }\n}\n\nLineSegments.prototype.isLineSegments = true;\n\nclass LineLoop extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n\n    this.type = 'LineLoop';\n  }\n}\n\nLineLoop.prototype.isLineLoop = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n *\n * }\n */\n\nclass PointsMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'PointsMaterial';\n\n    this.color = new Color(0xffffff);\n\n    this.map = null;\n\n    this.alphaMap = null;\n\n    this.size = 1;\n    this.sizeAttenuation = true;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n\n    this.map = source.map;\n\n    this.alphaMap = source.alphaMap;\n\n    this.size = source.size;\n    this.sizeAttenuation = source.sizeAttenuation;\n\n    return this;\n  }\n}\n\nPointsMaterial.prototype.isPointsMaterial = true;\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position$2 = /*@__PURE__*/ new Vector3();\n\nclass Points extends Object3D {\n  constructor(\n    geometry = new BufferGeometry(),\n    material = new PointsMaterial(),\n  ) {\n    super();\n\n    this.type = 'Points';\n\n    this.geometry = geometry;\n    this.material = material;\n\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.material = source.material;\n    this.geometry = source.geometry;\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Points.threshold;\n    const drawRange = geometry.drawRange;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n    _sphere.applyMatrix4(matrixWorld);\n    _sphere.radius += threshold;\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n    //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    const localThreshold =\n      threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const attributes = geometry.attributes;\n      const positionAttribute = attributes.position;\n\n      if (index !== null) {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (let i = start, il = end; i < il; i++) {\n          const a = index.getX(i);\n\n          _position$2.fromBufferAttribute(positionAttribute, a);\n\n          testPoint(\n            _position$2,\n            a,\n            localThresholdSq,\n            matrixWorld,\n            raycaster,\n            intersects,\n            this,\n          );\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(\n          positionAttribute.count,\n          drawRange.start + drawRange.count,\n        );\n\n        for (let i = start, l = end; i < l; i++) {\n          _position$2.fromBufferAttribute(positionAttribute, i);\n\n          testPoint(\n            _position$2,\n            i,\n            localThresholdSq,\n            matrixWorld,\n            raycaster,\n            intersects,\n            this,\n          );\n        }\n      }\n    } else {\n      console.error(\n        'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',\n      );\n    }\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error(\n          'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',\n        );\n      }\n    }\n  }\n}\n\nPoints.prototype.isPoints = true;\n\nfunction testPoint(\n  point,\n  index,\n  localThresholdSq,\n  matrixWorld,\n  raycaster,\n  intersects,\n  object,\n) {\n  const rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n  if (rayPointDistanceSq < localThresholdSq) {\n    const intersectPoint = new Vector3();\n\n    _ray.closestPointToPoint(point, intersectPoint);\n    intersectPoint.applyMatrix4(matrixWorld);\n\n    const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n\n    if (distance < raycaster.near || distance > raycaster.far) return;\n\n    intersects.push({\n      distance: distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index: index,\n      face: null,\n      object: object,\n    });\n  }\n}\n\nclass VideoTexture extends Texture$1 {\n  constructor(\n    video,\n    mapping,\n    wrapS,\n    wrapT,\n    magFilter,\n    minFilter,\n    format,\n    type,\n    anisotropy,\n  ) {\n    super(\n      video,\n      mapping,\n      wrapS,\n      wrapT,\n      magFilter,\n      minFilter,\n      format,\n      type,\n      anisotropy,\n    );\n\n    this.format = format !== undefined ? format : RGBFormat;\n\n    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n    this.generateMipmaps = false;\n\n    const scope = this;\n\n    function updateVideo() {\n      scope.needsUpdate = true;\n      video.requestVideoFrameCallback(updateVideo);\n    }\n\n    if ('requestVideoFrameCallback' in video) {\n      video.requestVideoFrameCallback(updateVideo);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.image).copy(this);\n  }\n\n  update() {\n    const video = this.image;\n    const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n    if (\n      hasVideoFrameCallback === false &&\n      video.readyState >= video.HAVE_CURRENT_DATA\n    ) {\n      this.needsUpdate = true;\n    }\n  }\n}\n\nVideoTexture.prototype.isVideoTexture = true;\n\nclass CompressedTexture extends Texture$1 {\n  constructor(\n    mipmaps,\n    width,\n    height,\n    format,\n    type,\n    mapping,\n    wrapS,\n    wrapT,\n    magFilter,\n    minFilter,\n    anisotropy,\n    encoding,\n  ) {\n    super(\n      null,\n      mapping,\n      wrapS,\n      wrapT,\n      magFilter,\n      minFilter,\n      format,\n      type,\n      anisotropy,\n      encoding,\n    );\n\n    this.image = { width: width, height: height };\n    this.mipmaps = mipmaps;\n\n    // no flipping for cube textures\n    // (also flipping doesn't work for compressed textures )\n\n    this.flipY = false;\n\n    // can't generate mipmaps for compressed textures\n    // mips must be embedded in DDS files\n\n    this.generateMipmaps = false;\n  }\n}\n\nCompressedTexture.prototype.isCompressedTexture = true;\n\nclass CanvasTexture extends Texture$1 {\n  constructor(\n    canvas,\n    mapping,\n    wrapS,\n    wrapT,\n    magFilter,\n    minFilter,\n    format,\n    type,\n    anisotropy,\n  ) {\n    super(\n      canvas,\n      mapping,\n      wrapS,\n      wrapT,\n      magFilter,\n      minFilter,\n      format,\n      type,\n      anisotropy,\n    );\n\n    this.needsUpdate = true;\n  }\n}\n\nCanvasTexture.prototype.isCanvasTexture = true;\n\nclass DepthTexture extends Texture$1 {\n  constructor(\n    width,\n    height,\n    type,\n    mapping,\n    wrapS,\n    wrapT,\n    magFilter,\n    minFilter,\n    anisotropy,\n    format,\n  ) {\n    format = format !== undefined ? format : DepthFormat;\n\n    if (format !== DepthFormat && format !== DepthStencilFormat) {\n      throw new Error(\n        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',\n      );\n    }\n\n    if (type === undefined && format === DepthFormat) type = UnsignedShortType;\n    if (type === undefined && format === DepthStencilFormat)\n      type = UnsignedInt248Type;\n\n    super(\n      null,\n      mapping,\n      wrapS,\n      wrapT,\n      magFilter,\n      minFilter,\n      format,\n      type,\n      anisotropy,\n    );\n\n    this.image = { width: width, height: height };\n\n    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n    this.flipY = false;\n    this.generateMipmaps = false;\n  }\n}\n\nDepthTexture.prototype.isDepthTexture = true;\n\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Triangle();\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n  constructor() {\n    this.type = 'Curve';\n\n    this.arcLengthDivisions = 200;\n  }\n\n  // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n\n  getPoint(/* t, optionalTarget */) {\n    console.warn('THREE.Curve: .getPoint() not implemented.');\n    return null;\n  }\n\n  // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n\n  getPointAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getPoint(t, optionalTarget);\n  }\n\n  // Get sequence of points using getPoint( t )\n\n  getPoints(divisions = 5) {\n    const points = [];\n\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n\n    return points;\n  }\n\n  // Get sequence of points using getPointAt( u )\n\n  getSpacedPoints(divisions = 5) {\n    const points = [];\n\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n\n    return points;\n  }\n\n  // Get total curve arc length\n\n  getLength() {\n    const lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  }\n\n  // Get list of cumulative segment lengths\n\n  getLengths(divisions = this.arcLengthDivisions) {\n    if (\n      this.cacheArcLengths &&\n      this.cacheArcLengths.length === divisions + 1 &&\n      !this.needsUpdate\n    ) {\n      return this.cacheArcLengths;\n    }\n\n    this.needsUpdate = false;\n\n    const cache = [];\n    let current,\n      last = this.getPoint(0);\n    let sum = 0;\n\n    cache.push(0);\n\n    for (let p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache.push(sum);\n      last = current;\n    }\n\n    this.cacheArcLengths = cache;\n\n    return cache; // { sums: cache, sum: sum }; Sum is in the last element.\n  }\n\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  }\n\n  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n  getUtoTmapping(u, distance) {\n    const arcLengths = this.getLengths();\n\n    let i = 0;\n    const il = arcLengths.length;\n\n    let targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    }\n\n    // binary search for the index with largest value smaller than target u distance\n\n    let low = 0,\n      high = il - 1,\n      comparison;\n\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break;\n\n        // DONE\n      }\n    }\n\n    i = high;\n\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    }\n\n    // we could get finer grain at lengths, or use simple interpolation between two points\n\n    const lengthBefore = arcLengths[i];\n    const lengthAfter = arcLengths[i + 1];\n\n    const segmentLength = lengthAfter - lengthBefore;\n\n    // determine where we are between the 'before' and 'after' points\n\n    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\n\n    // add that fractional amount to t\n\n    const t = (i + segmentFraction) / (il - 1);\n\n    return t;\n  }\n\n  // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n\n  getTangent(t, optionalTarget) {\n    const delta = 0.0001;\n    let t1 = t - delta;\n    let t2 = t + delta;\n\n    // Capping in case of danger\n\n    if (t1 < 0) t1 = 0;\n    if (t2 > 1) t2 = 1;\n\n    const pt1 = this.getPoint(t1);\n    const pt2 = this.getPoint(t2);\n\n    const tangent =\n      optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n\n    tangent.copy(pt2).sub(pt1).normalize();\n\n    return tangent;\n  }\n\n  getTangentAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getTangent(t, optionalTarget);\n  }\n\n  computeFrenetFrames(segments, closed) {\n    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n    const normal = new Vector3();\n\n    const tangents = [];\n    const normals = [];\n    const binormals = [];\n\n    const vec = new Vector3();\n    const mat = new Matrix4();\n\n    // compute the tangent vectors for each segment on the curve\n\n    for (let i = 0; i <= segments; i++) {\n      const u = i / segments;\n\n      tangents[i] = this.getTangentAt(u, new Vector3());\n    }\n\n    // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    let min = Number.MAX_VALUE;\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n\n    vec.crossVectors(tangents[0], normal).normalize();\n\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]);\n\n    // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n    for (let i = 1; i <= segments; i++) {\n      normals[i] = normals[i - 1].clone();\n\n      binormals[i] = binormals[i - 1].clone();\n\n      vec.crossVectors(tangents[i - 1], tangents[i]);\n\n      if (vec.length() > Number.EPSILON) {\n        vec.normalize();\n\n        const theta = Math.acos(\n          clamp$1(tangents[i - 1].dot(tangents[i]), -1, 1),\n        ); // clamp for floating pt errors\n\n        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    }\n\n    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n    if (closed === true) {\n      let theta = Math.acos(clamp$1(normals[0].dot(normals[segments]), -1, 1));\n      theta /= segments;\n\n      if (\n        tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0\n      ) {\n        theta = -theta;\n      }\n\n      for (let i = 1; i <= segments; i++) {\n        // twist a little...\n        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n        binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n\n    return {\n      tangents: tangents,\n      normals: normals,\n      binormals: binormals,\n    };\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n\n    return this;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Curve',\n        generator: 'Curve.toJSON',\n      },\n    };\n\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n\n    return data;\n  }\n\n  fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n\n    return this;\n  }\n}\n\nclass EllipseCurve extends Curve {\n  constructor(\n    aX = 0,\n    aY = 0,\n    xRadius = 1,\n    yRadius = 1,\n    aStartAngle = 0,\n    aEndAngle = Math.PI * 2,\n    aClockwise = false,\n    aRotation = 0,\n  ) {\n    super();\n\n    this.type = 'EllipseCurve';\n\n    this.aX = aX;\n    this.aY = aY;\n\n    this.xRadius = xRadius;\n    this.yRadius = yRadius;\n\n    this.aStartAngle = aStartAngle;\n    this.aEndAngle = aEndAngle;\n\n    this.aClockwise = aClockwise;\n\n    this.aRotation = aRotation;\n  }\n\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector2();\n\n    const twoPi = Math.PI * 2;\n    let deltaAngle = this.aEndAngle - this.aStartAngle;\n    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\n\n    // ensures that deltaAngle is 0 .. 2 PI\n    while (deltaAngle < 0) deltaAngle += twoPi;\n    while (deltaAngle > twoPi) deltaAngle -= twoPi;\n\n    if (deltaAngle < Number.EPSILON) {\n      if (samePoints) {\n        deltaAngle = 0;\n      } else {\n        deltaAngle = twoPi;\n      }\n    }\n\n    if (this.aClockwise === true && !samePoints) {\n      if (deltaAngle === twoPi) {\n        deltaAngle = -twoPi;\n      } else {\n        deltaAngle = deltaAngle - twoPi;\n      }\n    }\n\n    const angle = this.aStartAngle + t * deltaAngle;\n    let x = this.aX + this.xRadius * Math.cos(angle);\n    let y = this.aY + this.yRadius * Math.sin(angle);\n\n    if (this.aRotation !== 0) {\n      const cos = Math.cos(this.aRotation);\n      const sin = Math.sin(this.aRotation);\n\n      const tx = x - this.aX;\n      const ty = y - this.aY;\n\n      // Rotate the point about the center of the ellipse.\n      x = tx * cos - ty * sin + this.aX;\n      y = tx * sin + ty * cos + this.aY;\n    }\n\n    return point.set(x, y);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.aX = source.aX;\n    this.aY = source.aY;\n\n    this.xRadius = source.xRadius;\n    this.yRadius = source.yRadius;\n\n    this.aStartAngle = source.aStartAngle;\n    this.aEndAngle = source.aEndAngle;\n\n    this.aClockwise = source.aClockwise;\n\n    this.aRotation = source.aRotation;\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.aX = this.aX;\n    data.aY = this.aY;\n\n    data.xRadius = this.xRadius;\n    data.yRadius = this.yRadius;\n\n    data.aStartAngle = this.aStartAngle;\n    data.aEndAngle = this.aEndAngle;\n\n    data.aClockwise = this.aClockwise;\n\n    data.aRotation = this.aRotation;\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.aX = json.aX;\n    this.aY = json.aY;\n\n    this.xRadius = json.xRadius;\n    this.yRadius = json.yRadius;\n\n    this.aStartAngle = json.aStartAngle;\n    this.aEndAngle = json.aEndAngle;\n\n    this.aClockwise = json.aClockwise;\n\n    this.aRotation = json.aRotation;\n\n    return this;\n  }\n}\n\nEllipseCurve.prototype.isEllipseCurve = true;\n\nclass ArcCurve extends EllipseCurve {\n  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\n    this.type = 'ArcCurve';\n  }\n}\n\nArcCurve.prototype.isArcCurve = true;\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n  let c0 = 0,\n    c1 = 0,\n    c2 = 0,\n    c3 = 0;\n\n  /*\n   * Compute coefficients for a cubic polynomial\n   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n   * such that\n   *   p(0) = x0, p(1) = x1\n   *  and\n   *   p'(0) = t0, p'(1) = t1.\n   */\n  function init(x0, x1, t0, t1) {\n    c0 = x0;\n    c1 = t0;\n    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n    c3 = 2 * x0 - 2 * x1 + t0 + t1;\n  }\n\n  return {\n    initCatmullRom: function (x0, x1, x2, x3, tension) {\n      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n    },\n\n    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {\n      // compute tangents when parameterized in [t1,t2]\n      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;\n\n      // rescale tangents for parametrization in [0,1]\n      t1 *= dt1;\n      t2 *= dt1;\n\n      init(x1, x2, t1, t2);\n    },\n\n    calc: function (t) {\n      const t2 = t * t;\n      const t3 = t2 * t;\n      return c0 + c1 * t + c2 * t2 + c3 * t3;\n    },\n  };\n}\n\n//\n\nconst tmp = new Vector3();\nconst px = new CubicPoly(),\n  py = new CubicPoly(),\n  pz = new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n  constructor(\n    points = [],\n    closed = false,\n    curveType = 'centripetal',\n    tension = 0.5,\n  ) {\n    super();\n\n    this.type = 'CatmullRomCurve3';\n\n    this.points = points;\n    this.closed = closed;\n    this.curveType = curveType;\n    this.tension = tension;\n  }\n\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n\n    const points = this.points;\n    const l = points.length;\n\n    const p = (l - (this.closed ? 0 : 1)) * t;\n    let intPoint = Math.floor(p);\n    let weight = p - intPoint;\n\n    if (this.closed) {\n      intPoint +=\n        intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n    } else if (weight === 0 && intPoint === l - 1) {\n      intPoint = l - 2;\n      weight = 1;\n    }\n\n    let p0, p3; // 4 points (p1 & p2 defined below)\n\n    if (this.closed || intPoint > 0) {\n      p0 = points[(intPoint - 1) % l];\n    } else {\n      // extrapolate first point\n      tmp.subVectors(points[0], points[1]).add(points[0]);\n      p0 = tmp;\n    }\n\n    const p1 = points[intPoint % l];\n    const p2 = points[(intPoint + 1) % l];\n\n    if (this.closed || intPoint + 2 < l) {\n      p3 = points[(intPoint + 2) % l];\n    } else {\n      // extrapolate last point\n      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n      p3 = tmp;\n    }\n\n    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {\n      // init Centripetal / Chordal Catmull-Rom\n      const pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);\n\n      // safety check for repeated points\n      if (dt1 < 1e-4) dt1 = 1.0;\n      if (dt0 < 1e-4) dt0 = dt1;\n      if (dt2 < 1e-4) dt2 = dt1;\n\n      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n    } else if (this.curveType === 'catmullrom') {\n      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n    }\n\n    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.points = [];\n\n    for (let i = 0, l = source.points.length; i < l; i++) {\n      const point = source.points[i];\n\n      this.points.push(point.clone());\n    }\n\n    this.closed = source.closed;\n    this.curveType = source.curveType;\n    this.tension = source.tension;\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.points = [];\n\n    for (let i = 0, l = this.points.length; i < l; i++) {\n      const point = this.points[i];\n      data.points.push(point.toArray());\n    }\n\n    data.closed = this.closed;\n    data.curveType = this.curveType;\n    data.tension = this.tension;\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.points = [];\n\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const point = json.points[i];\n      this.points.push(new Vector3().fromArray(point));\n    }\n\n    this.closed = json.closed;\n    this.curveType = json.curveType;\n    this.tension = json.tension;\n\n    return this;\n  }\n}\n\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\n/**\n * Bezier Curves formulas obtained from\n * http://en.wikipedia.org/wiki/Bézier_curve\n */\n\nfunction CatmullRom(t, p0, p1, p2, p3) {\n  const v0 = (p2 - p0) * 0.5;\n  const v1 = (p3 - p1) * 0.5;\n  const t2 = t * t;\n  const t3 = t * t2;\n  return (\n    (2 * p1 - 2 * p2 + v0 + v1) * t3 +\n    (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 +\n    v0 * t +\n    p1\n  );\n}\n\n//\n\nfunction QuadraticBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * p;\n}\n\nfunction QuadraticBezierP1(t, p) {\n  return 2 * (1 - t) * t * p;\n}\n\nfunction QuadraticBezierP2(t, p) {\n  return t * t * p;\n}\n\nfunction QuadraticBezier(t, p0, p1, p2) {\n  return (\n    QuadraticBezierP0(t, p0) +\n    QuadraticBezierP1(t, p1) +\n    QuadraticBezierP2(t, p2)\n  );\n}\n\n//\n\nfunction CubicBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * k * p;\n}\n\nfunction CubicBezierP1(t, p) {\n  const k = 1 - t;\n  return 3 * k * k * t * p;\n}\n\nfunction CubicBezierP2(t, p) {\n  return 3 * (1 - t) * t * t * p;\n}\n\nfunction CubicBezierP3(t, p) {\n  return t * t * t * p;\n}\n\nfunction CubicBezier(t, p0, p1, p2, p3) {\n  return (\n    CubicBezierP0(t, p0) +\n    CubicBezierP1(t, p1) +\n    CubicBezierP2(t, p2) +\n    CubicBezierP3(t, p3)\n  );\n}\n\nclass CubicBezierCurve extends Curve {\n  constructor(\n    v0 = new Vector2(),\n    v1 = new Vector2(),\n    v2 = new Vector2(),\n    v3 = new Vector2(),\n  ) {\n    super();\n\n    this.type = 'CubicBezierCurve';\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n\n    const v0 = this.v0,\n      v1 = this.v1,\n      v2 = this.v2,\n      v3 = this.v3;\n\n    point.set(\n      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),\n      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),\n    );\n\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    this.v3.copy(source.v3);\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = this.v3.toArray();\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    this.v3.fromArray(json.v3);\n\n    return this;\n  }\n}\n\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\nclass CubicBezierCurve3 extends Curve {\n  constructor(\n    v0 = new Vector3(),\n    v1 = new Vector3(),\n    v2 = new Vector3(),\n    v3 = new Vector3(),\n  ) {\n    super();\n\n    this.type = 'CubicBezierCurve3';\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n\n    const v0 = this.v0,\n      v1 = this.v1,\n      v2 = this.v2,\n      v3 = this.v3;\n\n    point.set(\n      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),\n      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),\n      CubicBezier(t, v0.z, v1.z, v2.z, v3.z),\n    );\n\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    this.v3.copy(source.v3);\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = this.v3.toArray();\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    this.v3.fromArray(json.v3);\n\n    return this;\n  }\n}\n\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\nclass LineCurve extends Curve {\n  constructor(v1 = new Vector2(), v2 = new Vector2()) {\n    super();\n\n    this.type = 'LineCurve';\n\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n\n    if (t === 1) {\n      point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n      point.multiplyScalar(t).add(this.v1);\n    }\n\n    return point;\n  }\n\n  // Line curve is linear, so we can overwrite default getPointAt\n  getPointAt(u, optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector2();\n\n    tangent.copy(this.v2).sub(this.v1).normalize();\n\n    return tangent;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n\n    return this;\n  }\n}\n\nLineCurve.prototype.isLineCurve = true;\n\nclass LineCurve3 extends Curve {\n  constructor(v1 = new Vector3(), v2 = new Vector3()) {\n    super();\n\n    this.type = 'LineCurve3';\n    this.isLineCurve3 = true;\n\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n\n    if (t === 1) {\n      point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n      point.multiplyScalar(t).add(this.v1);\n    }\n\n    return point;\n  }\n  // Line curve is linear, so we can overwrite default getPointAt\n  getPointAt(u, optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n  copy(source) {\n    super.copy(source);\n\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n\n    return this;\n  }\n}\n\nclass QuadraticBezierCurve extends Curve {\n  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {\n    super();\n\n    this.type = 'QuadraticBezierCurve';\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n\n    const v0 = this.v0,\n      v1 = this.v1,\n      v2 = this.v2;\n\n    point.set(\n      QuadraticBezier(t, v0.x, v1.x, v2.x),\n      QuadraticBezier(t, v0.y, v1.y, v2.y),\n    );\n\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n\n    return this;\n  }\n}\n\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\nclass QuadraticBezierCurve3 extends Curve {\n  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {\n    super();\n\n    this.type = 'QuadraticBezierCurve3';\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n\n    const v0 = this.v0,\n      v1 = this.v1,\n      v2 = this.v2;\n\n    point.set(\n      QuadraticBezier(t, v0.x, v1.x, v2.x),\n      QuadraticBezier(t, v0.y, v1.y, v2.y),\n      QuadraticBezier(t, v0.z, v1.z, v2.z),\n    );\n\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n\n    return this;\n  }\n}\n\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\nclass SplineCurve extends Curve {\n  constructor(points = []) {\n    super();\n\n    this.type = 'SplineCurve';\n\n    this.points = points;\n  }\n\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n\n    const points = this.points;\n    const p = (points.length - 1) * t;\n\n    const intPoint = Math.floor(p);\n    const weight = p - intPoint;\n\n    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n    const p1 = points[intPoint];\n    const p2 =\n      points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n    const p3 =\n      points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n\n    point.set(\n      CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),\n      CatmullRom(weight, p0.y, p1.y, p2.y, p3.y),\n    );\n\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.points = [];\n\n    for (let i = 0, l = source.points.length; i < l; i++) {\n      const point = source.points[i];\n\n      this.points.push(point.clone());\n    }\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.points = [];\n\n    for (let i = 0, l = this.points.length; i < l; i++) {\n      const point = this.points[i];\n      data.points.push(point.toArray());\n    }\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.points = [];\n\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const point = json.points[i];\n      this.points.push(new Vector2().fromArray(point));\n    }\n\n    return this;\n  }\n}\n\nSplineCurve.prototype.isSplineCurve = true;\n\nvar Curves = /*#__PURE__*/ Object.freeze({\n  __proto__: null,\n  ArcCurve: ArcCurve,\n  CatmullRomCurve3: CatmullRomCurve3,\n  CubicBezierCurve: CubicBezierCurve,\n  CubicBezierCurve3: CubicBezierCurve3,\n  EllipseCurve: EllipseCurve,\n  LineCurve: LineCurve,\n  LineCurve3: LineCurve3,\n  QuadraticBezierCurve: QuadraticBezierCurve,\n  QuadraticBezierCurve3: QuadraticBezierCurve3,\n  SplineCurve: SplineCurve,\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n  constructor() {\n    super();\n\n    this.type = 'CurvePath';\n\n    this.curves = [];\n    this.autoClose = false; // Automatically closes the path\n  }\n\n  add(curve) {\n    this.curves.push(curve);\n  }\n\n  closePath() {\n    // Add a line curve if start and end of lines are not connected\n    const startPoint = this.curves[0].getPoint(0);\n    const endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n    if (!startPoint.equals(endPoint)) {\n      this.curves.push(new LineCurve(endPoint, startPoint));\n    }\n  }\n\n  // To get accurate point with reference to\n  // entire path distance at time t,\n  // following has to be done:\n\n  // 1. Length of each sub path have to be known\n  // 2. Locate and identify type of curve\n  // 3. Get t for the curve\n  // 4. Return curve.getPointAt(t')\n\n  getPoint(t, optionalTarget) {\n    const d = t * this.getLength();\n    const curveLengths = this.getCurveLengths();\n    let i = 0;\n\n    // To think about boundaries points.\n\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        const diff = curveLengths[i] - d;\n        const curve = this.curves[i];\n\n        const segmentLength = curve.getLength();\n        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n        return curve.getPointAt(u, optionalTarget);\n      }\n\n      i++;\n    }\n\n    return null;\n\n    // loop where sum != 0, sum > d , sum+1 <d\n  }\n\n  // We cannot use the default THREE.Curve getPoint() with getLength() because in\n  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n  // getPoint() depends on getLength\n\n  getLength() {\n    const lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  }\n\n  // cacheLengths must be recalculated.\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  }\n\n  // Compute lengths and cache them\n  // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n  getCurveLengths() {\n    // We use cache values if curves and cache array are same length\n\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    }\n\n    // Get length of sub-curve\n    // Push sums into cached array\n\n    const lengths = [];\n    let sums = 0;\n\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n\n    this.cacheLengths = lengths;\n\n    return lengths;\n  }\n\n  getSpacedPoints(divisions = 40) {\n    const points = [];\n\n    for (let i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n\n    return points;\n  }\n\n  getPoints(divisions = 12) {\n    const points = [];\n    let last;\n\n    for (let i = 0, curves = this.curves; i < curves.length; i++) {\n      const curve = curves[i];\n      const resolution =\n        curve && curve.isEllipseCurve\n          ? divisions * 2\n          : curve && (curve.isLineCurve || curve.isLineCurve3)\n          ? 1\n          : curve && curve.isSplineCurve\n          ? divisions * curve.points.length\n          : divisions;\n\n      const pts = curve.getPoints(resolution);\n\n      for (let j = 0; j < pts.length; j++) {\n        const point = pts[j];\n\n        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n        points.push(point);\n        last = point;\n      }\n    }\n\n    if (\n      this.autoClose &&\n      points.length > 1 &&\n      !points[points.length - 1].equals(points[0])\n    ) {\n      points.push(points[0]);\n    }\n\n    return points;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.curves = [];\n\n    for (let i = 0, l = source.curves.length; i < l; i++) {\n      const curve = source.curves[i];\n\n      this.curves.push(curve.clone());\n    }\n\n    this.autoClose = source.autoClose;\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.autoClose = this.autoClose;\n    data.curves = [];\n\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      const curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.autoClose = json.autoClose;\n    this.curves = [];\n\n    for (let i = 0, l = json.curves.length; i < l; i++) {\n      const curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n\n    return this;\n  }\n}\n\nclass Path extends CurvePath {\n  constructor(points) {\n    super();\n    this.type = 'Path';\n\n    this.currentPoint = new Vector2();\n\n    if (points) {\n      this.setFromPoints(points);\n    }\n  }\n\n  setFromPoints(points) {\n    this.moveTo(points[0].x, points[0].y);\n\n    for (let i = 1, l = points.length; i < l; i++) {\n      this.lineTo(points[i].x, points[i].y);\n    }\n\n    return this;\n  }\n\n  moveTo(x, y) {\n    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n    return this;\n  }\n\n  lineTo(x, y) {\n    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n    this.curves.push(curve);\n\n    this.currentPoint.set(x, y);\n\n    return this;\n  }\n\n  quadraticCurveTo(aCPx, aCPy, aX, aY) {\n    const curve = new QuadraticBezierCurve(\n      this.currentPoint.clone(),\n      new Vector2(aCPx, aCPy),\n      new Vector2(aX, aY),\n    );\n\n    this.curves.push(curve);\n\n    this.currentPoint.set(aX, aY);\n\n    return this;\n  }\n\n  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    const curve = new CubicBezierCurve(\n      this.currentPoint.clone(),\n      new Vector2(aCP1x, aCP1y),\n      new Vector2(aCP2x, aCP2y),\n      new Vector2(aX, aY),\n    );\n\n    this.curves.push(curve);\n\n    this.currentPoint.set(aX, aY);\n\n    return this;\n  }\n\n  splineThru(pts /*Array of Vector*/) {\n    const npts = [this.currentPoint.clone()].concat(pts);\n\n    const curve = new SplineCurve(npts);\n    this.curves.push(curve);\n\n    this.currentPoint.copy(pts[pts.length - 1]);\n\n    return this;\n  }\n\n  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    const x0 = this.currentPoint.x;\n    const y0 = this.currentPoint.y;\n\n    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n\n    return this;\n  }\n\n  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    this.absellipse(\n      aX,\n      aY,\n      aRadius,\n      aRadius,\n      aStartAngle,\n      aEndAngle,\n      aClockwise,\n    );\n\n    return this;\n  }\n\n  ellipse(\n    aX,\n    aY,\n    xRadius,\n    yRadius,\n    aStartAngle,\n    aEndAngle,\n    aClockwise,\n    aRotation,\n  ) {\n    const x0 = this.currentPoint.x;\n    const y0 = this.currentPoint.y;\n\n    this.absellipse(\n      aX + x0,\n      aY + y0,\n      xRadius,\n      yRadius,\n      aStartAngle,\n      aEndAngle,\n      aClockwise,\n      aRotation,\n    );\n\n    return this;\n  }\n\n  absellipse(\n    aX,\n    aY,\n    xRadius,\n    yRadius,\n    aStartAngle,\n    aEndAngle,\n    aClockwise,\n    aRotation,\n  ) {\n    const curve = new EllipseCurve(\n      aX,\n      aY,\n      xRadius,\n      yRadius,\n      aStartAngle,\n      aEndAngle,\n      aClockwise,\n      aRotation,\n    );\n\n    if (this.curves.length > 0) {\n      // if a previous curve is present, attempt to join\n      const firstPoint = curve.getPoint(0);\n\n      if (!firstPoint.equals(this.currentPoint)) {\n        this.lineTo(firstPoint.x, firstPoint.y);\n      }\n    }\n\n    this.curves.push(curve);\n\n    const lastPoint = curve.getPoint(1);\n    this.currentPoint.copy(lastPoint);\n\n    return this;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.currentPoint.copy(source.currentPoint);\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.currentPoint = this.currentPoint.toArray();\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.currentPoint.fromArray(json.currentPoint);\n\n    return this;\n  }\n}\n\nclass Shape extends Path {\n  constructor(points) {\n    super(points);\n\n    this.uuid = generateUUID();\n\n    this.type = 'Shape';\n\n    this.holes = [];\n  }\n\n  getPointsHoles(divisions) {\n    const holesPts = [];\n\n    for (let i = 0, l = this.holes.length; i < l; i++) {\n      holesPts[i] = this.holes[i].getPoints(divisions);\n    }\n\n    return holesPts;\n  }\n\n  // get points of shape and holes (keypoints based on segments parameter)\n\n  extractPoints(divisions) {\n    return {\n      shape: this.getPoints(divisions),\n      holes: this.getPointsHoles(divisions),\n    };\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.holes = [];\n\n    for (let i = 0, l = source.holes.length; i < l; i++) {\n      const hole = source.holes[i];\n\n      this.holes.push(hole.clone());\n    }\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.uuid = this.uuid;\n    data.holes = [];\n\n    for (let i = 0, l = this.holes.length; i < l; i++) {\n      const hole = this.holes[i];\n      data.holes.push(hole.toJSON());\n    }\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n\n    this.uuid = json.uuid;\n    this.holes = [];\n\n    for (let i = 0, l = json.holes.length; i < l; i++) {\n      const hole = json.holes[i];\n      this.holes.push(new Path().fromJSON(hole));\n    }\n\n    return this;\n  }\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.2)\n */\n\nconst Earcut = {\n  triangulate: function (data, holeIndices, dim = 2) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    let minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n      minX = maxX = data[0];\n      minY = maxY = data[1];\n\n      for (let i = dim; i < outerLen; i += dim) {\n        x = data[i];\n        y = data[i + 1];\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n      }\n\n      // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n      invSize = Math.max(maxX - minX, maxY - minY);\n      invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n  },\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n  let i, last;\n\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (i = start; i < end; i += dim)\n      last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim)\n      last = insertNode(i, data[i], data[i + 1], last);\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n\n  let p = start,\n    again;\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n  let stop = ear,\n    prev,\n    next;\n\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n\n      removeNode(ear);\n\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n\n      continue;\n    }\n\n    ear = next;\n\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev,\n    b = ear,\n    c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // now make sure we don't have other points inside the potential ear\n  let p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev,\n    b = ear,\n    c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // triangle bbox; min & max are calculated like this for speed\n  const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : b.x < c.x ? b.x : c.x,\n    minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : b.y < c.y ? b.y : c.y,\n    maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : b.x > c.x ? b.x : c.x,\n    maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : b.y > c.y ? b.y : c.y;\n\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(minTX, minTY, minX, minY, invSize),\n    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n  let p = ear.prevZ,\n    n = ear.nextZ;\n\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (\n      p !== ear.prev &&\n      p !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n\n    if (\n      n !== ear.prev &&\n      n !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (\n      p !== ear.prev &&\n      p !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n  }\n\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (\n      n !== ear.prev &&\n      n !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev,\n      b = p.next.next;\n\n    if (\n      !equals(a, b) &&\n      intersects(a, p, p.next, b) &&\n      locallyInside(a, b) &&\n      locallyInside(b, a)\n    ) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim);\n\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n\n      p = start = b;\n    }\n\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n\n      b = b.next;\n    }\n\n    a = a.next;\n  } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  const queue = [];\n  let i, len, start, end, list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX);\n\n  // process holes from left to right\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n  if (outerNode) {\n    const b = splitPolygon(outerNode, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity,\n    m;\n\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + ((hy - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n\n  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m,\n    mx = m.x,\n    my = m.y;\n  let tanMin = Infinity,\n    tan;\n\n  p = m;\n\n  do {\n    if (\n      hx >= p.x &&\n      p.x >= mx &&\n      hx !== p.x &&\n      pointInTriangle(\n        hy < my ? hx : qx,\n        hy,\n        mx,\n        my,\n        hy < my ? qx : hx,\n        hy,\n        p.x,\n        p.y,\n      )\n    ) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (\n        locallyInside(p, hole) &&\n        (tan < tanMin ||\n          (tan === tanMin &&\n            (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))\n      ) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n\n  sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let i,\n    p,\n    q,\n    e,\n    tail,\n    numMerges,\n    pSize,\n    qSize,\n    inSize = 1;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n\n      qSize = inSize;\n\n      while (pSize > 0 || (qSize > 0 && q)) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;\n        else list = e;\n\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n\n  x = (x | (x << 8)) & 0x00ff00ff;\n  x = (x | (x << 4)) & 0x0f0f0f0f;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y = (y | (y << 8)) & 0x00ff00ff;\n  y = (y | (y << 4)) & 0x0f0f0f0f;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start,\n    leftmost = start;\n  do {\n    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y))\n      leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (\n    (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n    (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n    (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0\n  );\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return (\n    a.next.i !== b.i &&\n    a.prev.i !== b.i &&\n    !intersectsPolygon(a, b) && // dones't intersect other edges\n    ((locallyInside(a, b) &&\n      locallyInside(b, a) &&\n      middleInside(a, b) && // locally visible\n      (area(a.prev, a, b.prev) || area(a, b.prev, b))) || // does not create opposite-facing sectors\n      (equals(a, b) &&\n        area(a.prev, a, a.next) > 0 &&\n        area(b.prev, b, b.next) > 0))\n  ); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return (\n    q.x <= Math.max(p.x, r.x) &&\n    q.x >= Math.min(p.x, r.x) &&\n    q.y <= Math.max(p.y, r.y) &&\n    q.y >= Math.min(p.y, r.y)\n  );\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (\n      p.i !== a.i &&\n      p.next.i !== a.i &&\n      p.i !== b.i &&\n      p.next.i !== b.i &&\n      intersects(p, p.next, a, b)\n    )\n      return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0\n    ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0\n    : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a,\n    inside = false;\n  const px = (a.x + b.x) / 2,\n    py = (a.y + b.y) / 2;\n  do {\n    if (\n      p.y > py !== p.next.y > py &&\n      p.next.y !== p.y &&\n      px < ((p.next.x - p.x) * (py - p.y)) / (p.next.y - p.y) + p.x\n    )\n      inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = new Node$2(a.i, a.x, a.y),\n    b2 = new Node$2(b.i, b.x, b.y),\n    an = a.next,\n    bp = b.prev;\n\n  a.next = b;\n  b.prev = a;\n\n  a2.next = an;\n  an.prev = a2;\n\n  b2.next = a2;\n  a2.prev = b2;\n\n  bp.next = b2;\n  b2.prev = bp;\n\n  return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = new Node$2(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node$2(i, x, y) {\n  // vertex index in coordinates array\n  this.i = i;\n\n  // vertex coordinates\n  this.x = x;\n  this.y = y;\n\n  // previous and next vertex nodes in a polygon ring\n  this.prev = null;\n  this.next = null;\n\n  // z-order curve value\n  this.z = null;\n\n  // previous and next nodes in z-order\n  this.prevZ = null;\n  this.nextZ = null;\n\n  // indicates whether this is a steiner point\n  this.steiner = false;\n}\n\nfunction signedArea(data, start, end, dim) {\n  let sum = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n    j = i;\n  }\n\n  return sum;\n}\n\nclass ShapeUtils {\n  // calculate area of the contour polygon\n\n  static area(contour) {\n    const n = contour.length;\n    let a = 0.0;\n\n    for (let p = n - 1, q = 0; q < n; p = q++) {\n      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n    }\n\n    return a * 0.5;\n  }\n\n  static isClockWise(pts) {\n    return ShapeUtils.area(pts) < 0;\n  }\n\n  static triangulateShape(contour, holes) {\n    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n    const holeIndices = []; // array of hole indices\n    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n    removeDupEndPts(contour);\n    addContour(vertices, contour);\n\n    //\n\n    let holeIndex = contour.length;\n\n    holes.forEach(removeDupEndPts);\n\n    for (let i = 0; i < holes.length; i++) {\n      holeIndices.push(holeIndex);\n      holeIndex += holes[i].length;\n      addContour(vertices, holes[i]);\n    }\n\n    //\n\n    const triangles = Earcut.triangulate(vertices, holeIndices);\n\n    //\n\n    for (let i = 0; i < triangles.length; i += 3) {\n      faces.push(triangles.slice(i, i + 3));\n    }\n\n    return faces;\n  }\n}\n\nfunction removeDupEndPts(points) {\n  const l = points.length;\n\n  if (l > 2 && points[l - 1].equals(points[0])) {\n    points.pop();\n  }\n}\n\nfunction addContour(vertices, contour) {\n  for (let i = 0; i < contour.length; i++) {\n    vertices.push(contour[i].x);\n    vertices.push(contour[i].y);\n  }\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nclass ExtrudeGeometry extends BufferGeometry {\n  constructor(\n    shapes = new Shape([\n      new Vector2(0.5, 0.5),\n      new Vector2(-0.5, 0.5),\n      new Vector2(-0.5, -0.5),\n      new Vector2(0.5, -0.5),\n    ]),\n    options = {},\n  ) {\n    super();\n\n    this.type = 'ExtrudeGeometry';\n\n    this.parameters = {\n      shapes: shapes,\n      options: options,\n    };\n\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\n\n    const scope = this;\n\n    const verticesArray = [];\n    const uvArray = [];\n\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      addShape(shape);\n    }\n\n    // build geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n\n    this.computeVertexNormals();\n\n    // functions\n\n    function addShape(shape) {\n      const placeholder = [];\n\n      // options\n\n      const curveSegments =\n        options.curveSegments !== undefined ? options.curveSegments : 12;\n      const steps = options.steps !== undefined ? options.steps : 1;\n      let depth = options.depth !== undefined ? options.depth : 1;\n\n      let bevelEnabled =\n        options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n      let bevelThickness =\n        options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n      let bevelSize =\n        options.bevelSize !== undefined\n          ? options.bevelSize\n          : bevelThickness - 0.1;\n      let bevelOffset =\n        options.bevelOffset !== undefined ? options.bevelOffset : 0;\n      let bevelSegments =\n        options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n      const extrudePath = options.extrudePath;\n\n      const uvgen =\n        options.UVGenerator !== undefined\n          ? options.UVGenerator\n          : WorldUVGenerator;\n\n      // deprecated options\n\n      if (options.amount !== undefined) {\n        console.warn(\n          'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.',\n        );\n        depth = options.amount;\n      }\n\n      //\n\n      let extrudePts,\n        extrudeByPath = false;\n      let splineTube, binormal, normal, position2;\n\n      if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n\n        extrudeByPath = true;\n        bevelEnabled = false; // bevels not supported for path extrusion\n\n        // SETUP TNB variables\n\n        // TODO1 - have a .isClosed in spline?\n\n        splineTube = extrudePath.computeFrenetFrames(steps, false);\n\n        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n        binormal = new Vector3();\n        normal = new Vector3();\n        position2 = new Vector3();\n      }\n\n      // Safeguards if bevels are not enabled\n\n      if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n        bevelOffset = 0;\n      }\n\n      // Variables initialization\n\n      const shapePoints = shape.extractPoints(curveSegments);\n\n      let vertices = shapePoints.shape;\n      const holes = shapePoints.holes;\n\n      const reverse = !ShapeUtils.isClockWise(vertices);\n\n      if (reverse) {\n        vertices = vertices.reverse();\n\n        // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n\n          if (ShapeUtils.isClockWise(ahole)) {\n            holes[h] = ahole.reverse();\n          }\n        }\n      }\n\n      const faces = ShapeUtils.triangulateShape(vertices, holes);\n\n      /* Vertices */\n\n      const contour = vertices; // vertices has all points but contour has only points of circumference\n\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n\n        vertices = vertices.concat(ahole);\n      }\n\n      function scalePt2(pt, vec, size) {\n        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\n\n        return vec.clone().multiplyScalar(size).add(pt);\n      }\n\n      const vlen = vertices.length,\n        flen = faces.length;\n\n      // Find directions for point movement\n\n      function getBevelVec(inPt, inPrev, inNext) {\n        // computes for inPt the corresponding point inPt' on a new contour\n        //   shifted by 1 unit (length of normalized vector) to the left\n        // if we walk along contour clockwise, this new contour is outside the old one\n        //\n        // inPt' is the intersection of the two lines parallel to the two\n        //  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n        // good reading for geometry algorithms (here: line-line intersection)\n        // http://geomalgorithms.com/a05-_intersect-1.html\n\n        const v_prev_x = inPt.x - inPrev.x,\n          v_prev_y = inPt.y - inPrev.y;\n        const v_next_x = inNext.x - inPt.x,\n          v_next_y = inNext.y - inPt.y;\n\n        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;\n\n        // check for collinear edges\n        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n        if (Math.abs(collinear0) > Number.EPSILON) {\n          // not collinear\n\n          // length of vectors for normalizing\n\n          const v_prev_len = Math.sqrt(v_prev_lensq);\n          const v_next_len = Math.sqrt(\n            v_next_x * v_next_x + v_next_y * v_next_y,\n          );\n\n          // shift adjacent points by unit vectors to the left\n\n          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n\n          const ptNextShift_x = inNext.x - v_next_y / v_next_len;\n          const ptNextShift_y = inNext.y + v_next_x / v_next_len;\n\n          // scaling factor for v_prev to intersection point\n\n          const sf =\n            ((ptNextShift_x - ptPrevShift_x) * v_next_y -\n              (ptNextShift_y - ptPrevShift_y) * v_next_x) /\n            (v_prev_x * v_next_y - v_prev_y * v_next_x);\n\n          // vector from inPt to intersection point\n\n          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;\n\n          // Don't normalize!, otherwise sharp corners become ugly\n          //  but prevent crazy spikes\n          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n          if (v_trans_lensq <= 2) {\n            return new Vector2(v_trans_x, v_trans_y);\n          } else {\n            shrink_by = Math.sqrt(v_trans_lensq / 2);\n          }\n        } else {\n          // handle special case of collinear edges\n\n          let direction_eq = false; // assumes: opposite\n\n          if (v_prev_x > Number.EPSILON) {\n            if (v_next_x > Number.EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (v_prev_x < -Number.EPSILON) {\n              if (v_next_x < -Number.EPSILON) {\n                direction_eq = true;\n              }\n            } else {\n              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n                direction_eq = true;\n              }\n            }\n          }\n\n          if (direction_eq) {\n            // console.log(\"Warning: lines are a straight sequence\");\n            v_trans_x = -v_prev_y;\n            v_trans_y = v_prev_x;\n            shrink_by = Math.sqrt(v_prev_lensq);\n          } else {\n            // console.log(\"Warning: lines are a straight spike\");\n            v_trans_x = v_prev_x;\n            v_trans_y = v_prev_y;\n            shrink_by = Math.sqrt(v_prev_lensq / 2);\n          }\n        }\n\n        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n      }\n\n      const contourMovements = [];\n\n      for (\n        let i = 0, il = contour.length, j = il - 1, k = i + 1;\n        i < il;\n        i++, j++, k++\n      ) {\n        if (j === il) j = 0;\n        if (k === il) k = 0;\n\n        //  (j)---(i)---(k)\n        // console.log('i,j,k', i, j , k)\n\n        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n      }\n\n      const holesMovements = [];\n      let oneHoleMovements,\n        verticesMovements = contourMovements.concat();\n\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n\n        oneHoleMovements = [];\n\n        for (\n          let i = 0, il = ahole.length, j = il - 1, k = i + 1;\n          i < il;\n          i++, j++, k++\n        ) {\n          if (j === il) j = 0;\n          if (k === il) k = 0;\n\n          //  (j)---(i)---(k)\n          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n        }\n\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n      }\n\n      // Loop bevelSegments, 1 for the front, 1 for the back\n\n      for (let b = 0; b < bevelSegments; b++) {\n        //for ( b = bevelSegments; b > 0; b -- ) {\n\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos((t * Math.PI) / 2);\n        const bs = bevelSize * Math.sin((t * Math.PI) / 2) + bevelOffset;\n\n        // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n\n          v(vert.x, vert.y, -z);\n        }\n\n        // expand holes\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n            v(vert.x, vert.y, -z);\n          }\n        }\n      }\n\n      const bs = bevelSize + bevelOffset;\n\n      // Back facing vertices\n\n      for (let i = 0; i < vlen; i++) {\n        const vert = bevelEnabled\n          ? scalePt2(vertices[i], verticesMovements[i], bs)\n          : vertices[i];\n\n        if (!extrudeByPath) {\n          v(vert.x, vert.y, 0);\n        } else {\n          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n\n          position2.copy(extrudePts[0]).add(normal).add(binormal);\n\n          v(position2.x, position2.y, position2.z);\n        }\n      }\n\n      // Add stepped vertices...\n      // Including front facing vertices\n\n      for (let s = 1; s <= steps; s++) {\n        for (let i = 0; i < vlen; i++) {\n          const vert = bevelEnabled\n            ? scalePt2(vertices[i], verticesMovements[i], bs)\n            : vertices[i];\n\n          if (!extrudeByPath) {\n            v(vert.x, vert.y, (depth / steps) * s);\n          } else {\n            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n\n            v(position2.x, position2.y, position2.z);\n          }\n        }\n      }\n\n      // Add bevel segments planes\n\n      //for ( b = 1; b <= bevelSegments; b ++ ) {\n      for (let b = bevelSegments - 1; b >= 0; b--) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos((t * Math.PI) / 2);\n        const bs = bevelSize * Math.sin((t * Math.PI) / 2) + bevelOffset;\n\n        // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, depth + z);\n        }\n\n        // expand holes\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n            if (!extrudeByPath) {\n              v(vert.x, vert.y, depth + z);\n            } else {\n              v(\n                vert.x,\n                vert.y + extrudePts[steps - 1].y,\n                extrudePts[steps - 1].x + z,\n              );\n            }\n          }\n        }\n      }\n\n      /* Faces */\n\n      // Top and bottom faces\n\n      buildLidFaces();\n\n      // Sides faces\n\n      buildSideFaces();\n\n      /////  Internal functions\n\n      function buildLidFaces() {\n        const start = verticesArray.length / 3;\n\n        if (bevelEnabled) {\n          let layer = 0; // steps + 1\n          let offset = vlen * layer;\n\n          // Bottom faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2] + offset, face[1] + offset, face[0] + offset);\n          }\n\n          layer = steps + bevelSegments * 2;\n          offset = vlen * layer;\n\n          // Top faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + offset, face[1] + offset, face[2] + offset);\n          }\n        } else {\n          // Bottom faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2], face[1], face[0]);\n          }\n\n          // Top faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(\n              face[0] + vlen * steps,\n              face[1] + vlen * steps,\n              face[2] + vlen * steps,\n            );\n          }\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 0);\n      }\n\n      // Create faces for the z-sides of the shape\n\n      function buildSideFaces() {\n        const start = verticesArray.length / 3;\n        let layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          sidewalls(ahole, layeroffset);\n\n          //, true\n          layeroffset += ahole.length;\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 1);\n      }\n\n      function sidewalls(contour, layeroffset) {\n        let i = contour.length;\n\n        while (--i >= 0) {\n          const j = i;\n          let k = i - 1;\n          if (k < 0) k = contour.length - 1;\n\n          //console.log('b', i,j, i-1, k,vertices.length);\n\n          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n            const slen1 = vlen * s;\n            const slen2 = vlen * (s + 1);\n\n            const a = layeroffset + j + slen1,\n              b = layeroffset + k + slen1,\n              c = layeroffset + k + slen2,\n              d = layeroffset + j + slen2;\n\n            f4(a, b, c, d);\n          }\n        }\n      }\n\n      function v(x, y, z) {\n        placeholder.push(x);\n        placeholder.push(y);\n        placeholder.push(z);\n      }\n\n      function f3(a, b, c) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(c);\n\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateTopUV(\n          scope,\n          verticesArray,\n          nextIndex - 3,\n          nextIndex - 2,\n          nextIndex - 1,\n        );\n\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n      }\n\n      function f4(a, b, c, d) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(d);\n\n        addVertex(b);\n        addVertex(c);\n        addVertex(d);\n\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateSideWallUV(\n          scope,\n          verticesArray,\n          nextIndex - 6,\n          nextIndex - 3,\n          nextIndex - 2,\n          nextIndex - 1,\n        );\n\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[3]);\n\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n        addUV(uvs[3]);\n      }\n\n      function addVertex(index) {\n        verticesArray.push(placeholder[index * 3 + 0]);\n        verticesArray.push(placeholder[index * 3 + 1]);\n        verticesArray.push(placeholder[index * 3 + 2]);\n      }\n\n      function addUV(vector2) {\n        uvArray.push(vector2.x);\n        uvArray.push(vector2.y);\n      }\n    }\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    const shapes = this.parameters.shapes;\n    const options = this.parameters.options;\n\n    return toJSON$1(shapes, options, data);\n  }\n\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n\n      geometryShapes.push(shape);\n    }\n\n    const extrudePath = data.options.extrudePath;\n\n    if (extrudePath !== undefined) {\n      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(\n        extrudePath,\n      );\n    }\n\n    return new ExtrudeGeometry(geometryShapes, data.options);\n  }\n}\n\nconst WorldUVGenerator = {\n  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n\n    return [\n      new Vector2(a_x, a_y),\n      new Vector2(b_x, b_y),\n      new Vector2(c_x, c_y),\n    ];\n  },\n\n  generateSideWallUV: function (\n    geometry,\n    vertices,\n    indexA,\n    indexB,\n    indexC,\n    indexD,\n  ) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const a_z = vertices[indexA * 3 + 2];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const b_z = vertices[indexB * 3 + 2];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    const c_z = vertices[indexC * 3 + 2];\n    const d_x = vertices[indexD * 3];\n    const d_y = vertices[indexD * 3 + 1];\n    const d_z = vertices[indexD * 3 + 2];\n\n    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n      return [\n        new Vector2(a_x, 1 - a_z),\n        new Vector2(b_x, 1 - b_z),\n        new Vector2(c_x, 1 - c_z),\n        new Vector2(d_x, 1 - d_z),\n      ];\n    } else {\n      return [\n        new Vector2(a_y, 1 - a_z),\n        new Vector2(b_y, 1 - b_z),\n        new Vector2(c_y, 1 - c_z),\n        new Vector2(d_y, 1 - d_z),\n      ];\n    }\n  },\n};\n\nfunction toJSON$1(shapes, options, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  if (options.extrudePath !== undefined)\n    data.options.extrudePath = options.extrudePath.toJSON();\n\n  return data;\n}\n\nclass ShapeGeometry extends BufferGeometry {\n  constructor(\n    shapes = new Shape([\n      new Vector2(0, 0.5),\n      new Vector2(-0.5, -0.5),\n      new Vector2(0.5, -0.5),\n    ]),\n    curveSegments = 12,\n  ) {\n    super();\n    this.type = 'ShapeGeometry';\n\n    this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments,\n    };\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // helper variables\n\n    let groupStart = 0;\n    let groupCount = 0;\n\n    // allow single and array values for \"shapes\" parameter\n\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (let i = 0; i < shapes.length; i++) {\n        addShape(shapes[i]);\n\n        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    // helper functions\n\n    function addShape(shape) {\n      const indexOffset = vertices.length / 3;\n      const points = shape.extractPoints(curveSegments);\n\n      let shapeVertices = points.shape;\n      const shapeHoles = points.holes;\n\n      // check direction of vertices\n\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[i] = shapeHole.reverse();\n        }\n      }\n\n      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);\n\n      // join vertices of inner and outer paths to a single array\n\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        shapeVertices = shapeVertices.concat(shapeHole);\n      }\n\n      // vertices, normals, uvs\n\n      for (let i = 0, l = shapeVertices.length; i < l; i++) {\n        const vertex = shapeVertices[i];\n\n        vertices.push(vertex.x, vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(vertex.x, vertex.y); // world uvs\n      }\n\n      // incides\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n\n        const a = face[0] + indexOffset;\n        const b = face[1] + indexOffset;\n        const c = face[2] + indexOffset;\n\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    const shapes = this.parameters.shapes;\n\n    return toJSON(shapes, data);\n  }\n\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n\n      geometryShapes.push(shape);\n    }\n\n    return new ShapeGeometry(geometryShapes, data.curveSegments);\n  }\n}\n\nfunction toJSON(shapes, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  return data;\n}\n\n/**\n * parameters = {\n *  color: <THREE.Color>\n * }\n */\n\nclass ShadowMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'ShadowMaterial';\n\n    this.color = new Color(0x000000);\n    this.transparent = true;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n\n    return this;\n  }\n}\n\nShadowMaterial.prototype.isShadowMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshStandardMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.defines = { STANDARD: '' };\n\n    this.type = 'MeshStandardMaterial';\n\n    this.color = new Color(0xffffff); // diffuse\n    this.roughness = 1.0;\n    this.metalness = 0.0;\n\n    this.map = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n\n    this.bumpMap = null;\n    this.bumpScale = 1;\n\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.roughnessMap = null;\n\n    this.metalnessMap = null;\n\n    this.alphaMap = null;\n\n    this.envMap = null;\n    this.envMapIntensity = 1.0;\n\n    this.refractionRatio = 0.98;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.flatShading = false;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.defines = { STANDARD: '' };\n\n    this.color.copy(source.color);\n    this.roughness = source.roughness;\n    this.metalness = source.metalness;\n\n    this.map = source.map;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.roughnessMap = source.roughnessMap;\n\n    this.metalnessMap = source.metalnessMap;\n\n    this.alphaMap = source.alphaMap;\n\n    this.envMap = source.envMap;\n    this.envMapIntensity = source.envMapIntensity;\n\n    this.refractionRatio = source.refractionRatio;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    this.flatShading = source.flatShading;\n\n    return this;\n  }\n}\n\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n/**\n * parameters = {\n *  clearcoat: <float>,\n *  clearcoatMap: new THREE.Texture( <Image> ),\n *  clearcoatRoughness: <float>,\n *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),\n *  clearcoatNormalScale: <Vector2>,\n *  clearcoatNormalMap: new THREE.Texture( <Image> ),\n *\n *  ior: <float>,\n *  reflectivity: <float>,\n *\n *  sheen: <float>,\n *  sheenTint: <Color>,\n *  sheenRoughness: <float>,\n *\n *  transmission: <float>,\n *  transmissionMap: new THREE.Texture( <Image> ),\n *\n *  thickness: <float>,\n *  thicknessMap: new THREE.Texture( <Image> ),\n *  attenuationDistance: <float>,\n *  attenuationTint: <Color>,\n *\n *  specularIntensity: <float>,\n *  specularIntensityhMap: new THREE.Texture( <Image> ),\n *  specularTint: <Color>,\n *  specularTintMap: new THREE.Texture( <Image> )\n * }\n */\n\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n  constructor(parameters) {\n    super();\n\n    this.defines = {\n      STANDARD: '',\n      PHYSICAL: '',\n    };\n\n    this.type = 'MeshPhysicalMaterial';\n\n    this.clearcoatMap = null;\n    this.clearcoatRoughness = 0.0;\n    this.clearcoatRoughnessMap = null;\n    this.clearcoatNormalScale = new Vector2(1, 1);\n    this.clearcoatNormalMap = null;\n\n    this.ior = 1.5;\n\n    Object.defineProperty(this, 'reflectivity', {\n      get: function () {\n        return clamp$1((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);\n      },\n      set: function (reflectivity) {\n        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);\n      },\n    });\n\n    this.sheenTint = new Color(0x000000);\n    this.sheenRoughness = 1.0;\n\n    this.transmissionMap = null;\n\n    this.thickness = 0.01;\n    this.thicknessMap = null;\n    this.attenuationDistance = 0.0;\n    this.attenuationTint = new Color(1, 1, 1);\n\n    this.specularIntensity = 1.0;\n    this.specularIntensityMap = null;\n    this.specularTint = new Color(1, 1, 1);\n    this.specularTintMap = null;\n\n    this._sheen = 0.0;\n    this._clearcoat = 0;\n    this._transmission = 0;\n\n    this.setValues(parameters);\n  }\n\n  get sheen() {\n    return this._sheen;\n  }\n\n  set sheen(value) {\n    if (this._sheen > 0 !== value > 0) {\n      this.version++;\n    }\n\n    this._sheen = value;\n  }\n\n  get clearcoat() {\n    return this._clearcoat;\n  }\n\n  set clearcoat(value) {\n    if (this._clearcoat > 0 !== value > 0) {\n      this.version++;\n    }\n\n    this._clearcoat = value;\n  }\n\n  get transmission() {\n    return this._transmission;\n  }\n\n  set transmission(value) {\n    if (this._transmission > 0 !== value > 0) {\n      this.version++;\n    }\n\n    this._transmission = value;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.defines = {\n      STANDARD: '',\n      PHYSICAL: '',\n    };\n\n    this.clearcoat = source.clearcoat;\n    this.clearcoatMap = source.clearcoatMap;\n    this.clearcoatRoughness = source.clearcoatRoughness;\n    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n    this.clearcoatNormalMap = source.clearcoatNormalMap;\n    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n\n    this.ior = source.ior;\n\n    this.sheen = source.sheen;\n    this.sheenTint.copy(source.sheenTint);\n    this.sheenRoughness = source.sheenRoughness;\n\n    this.transmission = source.transmission;\n    this.transmissionMap = source.transmissionMap;\n\n    this.thickness = source.thickness;\n    this.thicknessMap = source.thicknessMap;\n    this.attenuationDistance = source.attenuationDistance;\n    this.attenuationTint.copy(source.attenuationTint);\n\n    this.specularIntensity = source.specularIntensity;\n    this.specularIntensityMap = source.specularIntensityMap;\n    this.specularTint.copy(source.specularTint);\n    this.specularTintMap = source.specularTintMap;\n\n    return this;\n  }\n}\n\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.MultiplyOperation,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshPhongMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'MeshPhongMaterial';\n\n    this.color = new Color(0xffffff); // diffuse\n    this.specular = new Color(0x111111);\n    this.shininess = 30;\n\n    this.map = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n\n    this.bumpMap = null;\n    this.bumpScale = 1;\n\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.specularMap = null;\n\n    this.alphaMap = null;\n\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.flatShading = false;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n    this.specular.copy(source.specular);\n    this.shininess = source.shininess;\n\n    this.map = source.map;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.specularMap = source.specularMap;\n\n    this.alphaMap = source.alphaMap;\n\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    this.flatShading = source.flatShading;\n\n    return this;\n  }\n}\n\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *\n *  map: new THREE.Texture( <Image> ),\n *  gradientMap: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n * }\n */\n\nclass MeshToonMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.defines = { TOON: '' };\n\n    this.type = 'MeshToonMaterial';\n\n    this.color = new Color(0xffffff);\n\n    this.map = null;\n    this.gradientMap = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n\n    this.bumpMap = null;\n    this.bumpScale = 1;\n\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.alphaMap = null;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n\n    this.map = source.map;\n    this.gradientMap = source.gradientMap;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.alphaMap = source.alphaMap;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    return this;\n  }\n}\n\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\n/**\n * parameters = {\n *  opacity: <float>,\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshNormalMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'MeshNormalMaterial';\n\n    this.bumpMap = null;\n    this.bumpScale = 1;\n\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n\n    this.fog = false;\n\n    this.flatShading = false;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n\n    this.flatShading = source.flatShading;\n\n    return this;\n  }\n}\n\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n * }\n */\n\nclass MeshLambertMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.type = 'MeshLambertMaterial';\n\n    this.color = new Color(0xffffff); // diffuse\n\n    this.map = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n\n    this.specularMap = null;\n\n    this.alphaMap = null;\n\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n\n    this.map = source.map;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n\n    this.specularMap = source.specularMap;\n\n    this.alphaMap = source.alphaMap;\n\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    return this;\n  }\n}\n\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  matcap: new THREE.Texture( <Image> ),\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshMatcapMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n\n    this.defines = { MATCAP: '' };\n\n    this.type = 'MeshMatcapMaterial';\n\n    this.color = new Color(0xffffff); // diffuse\n\n    this.matcap = null;\n\n    this.map = null;\n\n    this.bumpMap = null;\n    this.bumpScale = 1;\n\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.alphaMap = null;\n\n    this.flatShading = false;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.defines = { MATCAP: '' };\n\n    this.color.copy(source.color);\n\n    this.matcap = source.matcap;\n\n    this.map = source.map;\n\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.alphaMap = source.alphaMap;\n\n    this.flatShading = source.flatShading;\n\n    return this;\n  }\n}\n\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nclass LineDashedMaterial extends LineBasicMaterial {\n  constructor(parameters) {\n    super();\n\n    this.type = 'LineDashedMaterial';\n\n    this.scale = 1;\n    this.dashSize = 3;\n    this.gapSize = 1;\n\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.scale = source.scale;\n    this.dashSize = source.dashSize;\n    this.gapSize = source.gapSize;\n\n    return this;\n  }\n}\n\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\nconst AnimationUtils = {\n  // same as Array.prototype.slice, but also works on typed arrays\n  arraySlice: function (array, from, to) {\n    if (AnimationUtils.isTypedArray(array)) {\n      // in ios9 array.subarray(from, undefined) will return empty array\n      // but array.subarray(from) or array.subarray(from, len) is correct\n      return new array.constructor(\n        array.subarray(from, to !== undefined ? to : array.length),\n      );\n    }\n\n    return array.slice(from, to);\n  },\n\n  // converts an array to a specific type\n  convertArray: function (array, type, forceClone) {\n    if (\n      !array || // let 'undefined' and 'null' pass\n      (!forceClone && array.constructor === type)\n    )\n      return array;\n\n    if (typeof type.BYTES_PER_ELEMENT === 'number') {\n      return new type(array); // create typed array\n    }\n\n    return Array.prototype.slice.call(array); // create Array\n  },\n\n  isTypedArray: function (object) {\n    return ArrayBuffer.isView(object) && !(object instanceof DataView);\n  },\n\n  // returns an array by which times and values can be sorted\n  getKeyframeOrder: function (times) {\n    function compareTime(i, j) {\n      return times[i] - times[j];\n    }\n\n    const n = times.length;\n    const result = new Array(n);\n    for (let i = 0; i !== n; ++i) result[i] = i;\n\n    result.sort(compareTime);\n\n    return result;\n  },\n\n  // uses the array previously returned by 'getKeyframeOrder' to sort data\n  sortedArray: function (values, stride, order) {\n    const nValues = values.length;\n    const result = new values.constructor(nValues);\n\n    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n      const srcOffset = order[i] * stride;\n\n      for (let j = 0; j !== stride; ++j) {\n        result[dstOffset++] = values[srcOffset + j];\n      }\n    }\n\n    return result;\n  },\n\n  // function for parsing AOS keyframe formats\n  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {\n    let i = 1,\n      key = jsonKeys[0];\n\n    while (key !== undefined && key[valuePropertyName] === undefined) {\n      key = jsonKeys[i++];\n    }\n\n    if (key === undefined) return; // no data\n\n    let value = key[valuePropertyName];\n    if (value === undefined) return; // no data\n\n    if (Array.isArray(value)) {\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push.apply(values, value); // push all elements\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else if (value.toArray !== undefined) {\n      // ...assume THREE.Math-ish\n\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          value.toArray(values, values.length);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else {\n      // otherwise push as-is\n\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push(value);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    }\n  },\n\n  subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {\n    const clip = sourceClip.clone();\n\n    clip.name = name;\n\n    const tracks = [];\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      const track = clip.tracks[i];\n      const valueSize = track.getValueSize();\n\n      const times = [];\n      const values = [];\n\n      for (let j = 0; j < track.times.length; ++j) {\n        const frame = track.times[j] * fps;\n\n        if (frame < startFrame || frame >= endFrame) continue;\n\n        times.push(track.times[j]);\n\n        for (let k = 0; k < valueSize; ++k) {\n          values.push(track.values[j * valueSize + k]);\n        }\n      }\n\n      if (times.length === 0) continue;\n\n      track.times = AnimationUtils.convertArray(times, track.times.constructor);\n      track.values = AnimationUtils.convertArray(\n        values,\n        track.values.constructor,\n      );\n\n      tracks.push(track);\n    }\n\n    clip.tracks = tracks;\n\n    // find minimum .times value across all tracks in the trimmed clip\n\n    let minStartTime = Infinity;\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      if (minStartTime > clip.tracks[i].times[0]) {\n        minStartTime = clip.tracks[i].times[0];\n      }\n    }\n\n    // shift all tracks such that clip begins at t=0\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      clip.tracks[i].shift(-1 * minStartTime);\n    }\n\n    clip.resetDuration();\n\n    return clip;\n  },\n\n  makeClipAdditive: function (\n    targetClip,\n    referenceFrame = 0,\n    referenceClip = targetClip,\n    fps = 30,\n  ) {\n    if (fps <= 0) fps = 30;\n\n    const numTracks = referenceClip.tracks.length;\n    const referenceTime = referenceFrame / fps;\n\n    // Make each track's values relative to the values at the reference frame\n    for (let i = 0; i < numTracks; ++i) {\n      const referenceTrack = referenceClip.tracks[i];\n      const referenceTrackType = referenceTrack.ValueTypeName;\n\n      // Skip this track if it's non-numeric\n      if (referenceTrackType === 'bool' || referenceTrackType === 'string')\n        continue;\n\n      // Find the track in the target clip whose name and type matches the reference track\n      const targetTrack = targetClip.tracks.find(function (track) {\n        return (\n          track.name === referenceTrack.name &&\n          track.ValueTypeName === referenceTrackType\n        );\n      });\n\n      if (targetTrack === undefined) continue;\n\n      let referenceOffset = 0;\n      const referenceValueSize = referenceTrack.getValueSize();\n\n      if (\n        referenceTrack.createInterpolant\n          .isInterpolantFactoryMethodGLTFCubicSpline\n      ) {\n        referenceOffset = referenceValueSize / 3;\n      }\n\n      let targetOffset = 0;\n      const targetValueSize = targetTrack.getValueSize();\n\n      if (\n        targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline\n      ) {\n        targetOffset = targetValueSize / 3;\n      }\n\n      const lastIndex = referenceTrack.times.length - 1;\n      let referenceValue;\n\n      // Find the value to subtract out of the track\n      if (referenceTime <= referenceTrack.times[0]) {\n        // Reference frame is earlier than the first keyframe, so just use the first keyframe\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(\n          referenceTrack.values,\n          startIndex,\n          endIndex,\n        );\n      } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n        // Reference frame is after the last keyframe, so just use the last keyframe\n        const startIndex = lastIndex * referenceValueSize + referenceOffset;\n        const endIndex = startIndex + referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(\n          referenceTrack.values,\n          startIndex,\n          endIndex,\n        );\n      } else {\n        // Interpolate to the reference value\n        const interpolant = referenceTrack.createInterpolant();\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        interpolant.evaluate(referenceTime);\n        referenceValue = AnimationUtils.arraySlice(\n          interpolant.resultBuffer,\n          startIndex,\n          endIndex,\n        );\n      }\n\n      // Conjugate the quaternion\n      if (referenceTrackType === 'quaternion') {\n        const referenceQuat = new Quaternion()\n          .fromArray(referenceValue)\n          .normalize()\n          .conjugate();\n        referenceQuat.toArray(referenceValue);\n      }\n\n      // Subtract the reference value from all of the track values\n\n      const numTimes = targetTrack.times.length;\n      for (let j = 0; j < numTimes; ++j) {\n        const valueStart = j * targetValueSize + targetOffset;\n\n        if (referenceTrackType === 'quaternion') {\n          // Multiply the conjugate for quaternion track types\n          Quaternion.multiplyQuaternionsFlat(\n            targetTrack.values,\n            valueStart,\n            referenceValue,\n            0,\n            targetTrack.values,\n            valueStart,\n          );\n        } else {\n          const valueEnd = targetValueSize - targetOffset * 2;\n\n          // Subtract each value for all other numeric track types\n          for (let k = 0; k < valueEnd; ++k) {\n            targetTrack.values[valueStart + k] -= referenceValue[k];\n          }\n        }\n      }\n    }\n\n    targetClip.blendMode = AdditiveAnimationBlendMode;\n\n    return targetClip;\n  },\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n\n    this.resultBuffer =\n      resultBuffer !== undefined\n        ? resultBuffer\n        : new sampleValues.constructor(sampleSize);\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n\n    this.settings = null;\n    this.DefaultSettings_ = {};\n  }\n\n  evaluate(t) {\n    const pp = this.parameterPositions;\n    let i1 = this._cachedIndex,\n      t1 = pp[i1],\n      t0 = pp[i1 - 1];\n\n    validate_interval: {\n      seek: {\n        let right;\n\n        linear_scan: {\n          //- See http://jsperf.com/comparison-to-undefined/3\n          //- slower code:\n          //-\n          //- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n          forward_scan: if (!(t < t1)) {\n            for (let giveUpAt = i1 + 2; ; ) {\n              if (t1 === undefined) {\n                if (t < t0) break forward_scan;\n\n                // after end\n\n                i1 = pp.length;\n                this._cachedIndex = i1;\n                return this.afterEnd_(i1 - 1, t, t0);\n              }\n\n              if (i1 === giveUpAt) break; // this loop\n\n              t0 = t1;\n              t1 = pp[++i1];\n\n              if (t < t1) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            }\n\n            // prepare binary search on the right side of the index\n            right = pp.length;\n            break linear_scan;\n          }\n\n          //- slower code:\n          //-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n          if (!(t >= t0)) {\n            // looping?\n\n            const t1global = pp[1];\n\n            if (t < t1global) {\n              i1 = 2; // + 1, using the scan for the details\n              t0 = t1global;\n            }\n\n            // linear reverse scan\n\n            for (let giveUpAt = i1 - 2; ; ) {\n              if (t0 === undefined) {\n                // before start\n\n                this._cachedIndex = 0;\n                return this.beforeStart_(0, t, t1);\n              }\n\n              if (i1 === giveUpAt) break; // this loop\n\n              t1 = t0;\n              t0 = pp[--i1 - 1];\n\n              if (t >= t0) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            }\n\n            // prepare binary search on the left side of the index\n            right = i1;\n            i1 = 0;\n            break linear_scan;\n          }\n\n          // the interval is valid\n\n          break validate_interval;\n        } // linear scan\n\n        // binary search\n\n        while (i1 < right) {\n          const mid = (i1 + right) >>> 1;\n\n          if (t < pp[mid]) {\n            right = mid;\n          } else {\n            i1 = mid + 1;\n          }\n        }\n\n        t1 = pp[i1];\n        t0 = pp[i1 - 1];\n\n        // check boundary cases, again\n\n        if (t0 === undefined) {\n          this._cachedIndex = 0;\n          return this.beforeStart_(0, t, t1);\n        }\n\n        if (t1 === undefined) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n          return this.afterEnd_(i1 - 1, t0, t);\n        }\n      } // seek\n\n      this._cachedIndex = i1;\n\n      this.intervalChanged_(i1, t0, t1);\n    } // validate_interval\n\n    return this.interpolate_(i1, t0, t, t1);\n  }\n\n  getSettings_() {\n    return this.settings || this.DefaultSettings_;\n  }\n\n  copySampleValue_(index) {\n    // copies a sample value to the result buffer\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      offset = index * stride;\n\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  }\n\n  // Template methods for derived classes:\n\n  interpolate_(/* i1, t0, t, t1 */) {\n    throw new Error('call to abstract method');\n    // implementations shall return this.resultBuffer\n  }\n\n  intervalChanged_(/* i1, t0, t1 */) {\n    // empty\n  }\n}\n\n// ALIAS DEFINITIONS\n\nInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\nInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\n    this._weightPrev = -0;\n    this._offsetPrev = -0;\n    this._weightNext = -0;\n    this._offsetNext = -0;\n\n    this.DefaultSettings_ = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding,\n    };\n  }\n\n  intervalChanged_(i1, t0, t1) {\n    const pp = this.parameterPositions;\n    let iPrev = i1 - 2,\n      iNext = i1 + 1,\n      tPrev = pp[iPrev],\n      tNext = pp[iNext];\n\n    if (tPrev === undefined) {\n      switch (this.getSettings_().endingStart) {\n        case ZeroSlopeEnding:\n          // f'(t0) = 0\n          iPrev = i1;\n          tPrev = 2 * t0 - t1;\n\n          break;\n\n        case WrapAroundEnding:\n          // use the other end of the curve\n          iPrev = pp.length - 2;\n          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n\n          break;\n\n        default:\n          // ZeroCurvatureEnding\n\n          // f''(t0) = 0 a.k.a. Natural Spline\n          iPrev = i1;\n          tPrev = t1;\n      }\n    }\n\n    if (tNext === undefined) {\n      switch (this.getSettings_().endingEnd) {\n        case ZeroSlopeEnding:\n          // f'(tN) = 0\n          iNext = i1;\n          tNext = 2 * t1 - t0;\n\n          break;\n\n        case WrapAroundEnding:\n          // use the other end of the curve\n          iNext = 1;\n          tNext = t1 + pp[1] - pp[0];\n\n          break;\n\n        default:\n          // ZeroCurvatureEnding\n\n          // f''(tN) = 0, a.k.a. Natural Spline\n          iNext = i1 - 1;\n          tNext = t0;\n      }\n    }\n\n    const halfDt = (t1 - t0) * 0.5,\n      stride = this.valueSize;\n\n    this._weightPrev = halfDt / (t0 - tPrev);\n    this._weightNext = halfDt / (tNext - t1);\n    this._offsetPrev = iPrev * stride;\n    this._offsetNext = iNext * stride;\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      o1 = i1 * stride,\n      o0 = o1 - stride,\n      oP = this._offsetPrev,\n      oN = this._offsetNext,\n      wP = this._weightPrev,\n      wN = this._weightNext,\n      p = (t - t0) / (t1 - t0),\n      pp = p * p,\n      ppp = pp * p;\n\n    // evaluate polynomials\n\n    const sP = -wP * ppp + 2 * wP * pp - wP * p;\n    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const sN = wN * ppp - wN * pp;\n\n    // combine data linearly\n\n    for (let i = 0; i !== stride; ++i) {\n      result[i] =\n        sP * values[oP + i] +\n        s0 * values[o0 + i] +\n        s1 * values[o1 + i] +\n        sN * values[oN + i];\n    }\n\n    return result;\n  }\n}\n\nclass LinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      offset1 = i1 * stride,\n      offset0 = offset1 - stride,\n      weight1 = (t - t0) / (t1 - t0),\n      weight0 = 1 - weight1;\n\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n    }\n\n    return result;\n  }\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  interpolate_(i1 /*, t0, t, t1 */) {\n    return this.copySampleValue_(i1 - 1);\n  }\n}\n\nclass KeyframeTrack {\n  constructor(name, times, values, interpolation) {\n    if (name === undefined)\n      throw new Error('THREE.KeyframeTrack: track name is undefined');\n    if (times === undefined || times.length === 0)\n      throw new Error(\n        'THREE.KeyframeTrack: no keyframes in track named ' + name,\n      );\n\n    this.name = name;\n\n    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\n  }\n\n  // Serialization (in static context, because of constructor invocation\n  // and automatic invocation of .toJSON):\n\n  static toJSON(track) {\n    const trackType = track.constructor;\n\n    let json;\n\n    // derived classes can define a static toJSON method\n    if (trackType.toJSON !== this.toJSON) {\n      json = trackType.toJSON(track);\n    } else {\n      // by default, we assume the data can be serialized as-is\n      json = {\n        name: track.name,\n        times: AnimationUtils.convertArray(track.times, Array),\n        values: AnimationUtils.convertArray(track.values, Array),\n      };\n\n      const interpolation = track.getInterpolation();\n\n      if (interpolation !== track.DefaultInterpolation) {\n        json.interpolation = interpolation;\n      }\n    }\n\n    json.type = track.ValueTypeName; // mandatory\n\n    return json;\n  }\n\n  InterpolantFactoryMethodDiscrete(result) {\n    return new DiscreteInterpolant(\n      this.times,\n      this.values,\n      this.getValueSize(),\n      result,\n    );\n  }\n\n  InterpolantFactoryMethodLinear(result) {\n    return new LinearInterpolant(\n      this.times,\n      this.values,\n      this.getValueSize(),\n      result,\n    );\n  }\n\n  InterpolantFactoryMethodSmooth(result) {\n    return new CubicInterpolant(\n      this.times,\n      this.values,\n      this.getValueSize(),\n      result,\n    );\n  }\n\n  setInterpolation(interpolation) {\n    let factoryMethod;\n\n    switch (interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n        break;\n\n      case InterpolateLinear:\n        factoryMethod = this.InterpolantFactoryMethodLinear;\n\n        break;\n\n      case InterpolateSmooth:\n        factoryMethod = this.InterpolantFactoryMethodSmooth;\n\n        break;\n    }\n\n    if (factoryMethod === undefined) {\n      const message =\n        'unsupported interpolation for ' +\n        this.ValueTypeName +\n        ' keyframe track named ' +\n        this.name;\n\n      if (this.createInterpolant === undefined) {\n        // fall back to default, unless the default itself is messed up\n        if (interpolation !== this.DefaultInterpolation) {\n          this.setInterpolation(this.DefaultInterpolation);\n        } else {\n          throw new Error(message); // fatal, in this case\n        }\n      }\n\n      console.warn('THREE.KeyframeTrack:', message);\n      return this;\n    }\n\n    this.createInterpolant = factoryMethod;\n\n    return this;\n  }\n\n  getInterpolation() {\n    switch (this.createInterpolant) {\n      case this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n\n      case this.InterpolantFactoryMethodLinear:\n        return InterpolateLinear;\n\n      case this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth;\n    }\n  }\n\n  getValueSize() {\n    return this.values.length / this.times.length;\n  }\n\n  // move all keyframes either forwards or backwards in time\n  shift(timeOffset) {\n    if (timeOffset !== 0.0) {\n      const times = this.times;\n\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    }\n\n    return this;\n  }\n\n  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n  scale(timeScale) {\n    if (timeScale !== 1.0) {\n      const times = this.times;\n\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    }\n\n    return this;\n  }\n\n  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n  trim(startTime, endTime) {\n    const times = this.times,\n      nKeys = times.length;\n\n    let from = 0,\n      to = nKeys - 1;\n\n    while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n\n    while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n\n    ++to; // inclusive -> exclusive bound\n\n    if (from !== 0 || to !== nKeys) {\n      // empty tracks are forbidden, so keep at least one keyframe\n      if (from >= to) {\n        to = Math.max(to, 1);\n        from = to - 1;\n      }\n\n      const stride = this.getValueSize();\n      this.times = AnimationUtils.arraySlice(times, from, to);\n      this.values = AnimationUtils.arraySlice(\n        this.values,\n        from * stride,\n        to * stride,\n      );\n    }\n\n    return this;\n  }\n\n  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n  validate() {\n    let valid = true;\n\n    const valueSize = this.getValueSize();\n    if (valueSize - Math.floor(valueSize) !== 0) {\n      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n      valid = false;\n    }\n\n    const times = this.times,\n      values = this.values,\n      nKeys = times.length;\n\n    if (nKeys === 0) {\n      console.error('THREE.KeyframeTrack: Track is empty.', this);\n      valid = false;\n    }\n\n    let prevTime = null;\n\n    for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n\n      if (typeof currTime === 'number' && isNaN(currTime)) {\n        console.error(\n          'THREE.KeyframeTrack: Time is not a valid number.',\n          this,\n          i,\n          currTime,\n        );\n        valid = false;\n        break;\n      }\n\n      if (prevTime !== null && prevTime > currTime) {\n        console.error(\n          'THREE.KeyframeTrack: Out of order keys.',\n          this,\n          i,\n          currTime,\n          prevTime,\n        );\n        valid = false;\n        break;\n      }\n\n      prevTime = currTime;\n    }\n\n    if (values !== undefined) {\n      if (AnimationUtils.isTypedArray(values)) {\n        for (let i = 0, n = values.length; i !== n; ++i) {\n          const value = values[i];\n\n          if (isNaN(value)) {\n            console.error(\n              'THREE.KeyframeTrack: Value is not a valid number.',\n              this,\n              i,\n              value,\n            );\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n\n    return valid;\n  }\n\n  // removes equivalent sequential keys as common in morph target sequences\n  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n  optimize() {\n    // times or values may be shared with other tracks, so overwriting is unsafe\n    const times = AnimationUtils.arraySlice(this.times),\n      values = AnimationUtils.arraySlice(this.values),\n      stride = this.getValueSize(),\n      smoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n      lastIndex = times.length - 1;\n\n    let writeIndex = 1;\n\n    for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n\n      const time = times[i];\n      const timeNext = times[i + 1];\n\n      // remove adjacent keyframes scheduled at the same time\n\n      if (time !== timeNext && (i !== 1 || time !== times[0])) {\n        if (!smoothInterpolation) {\n          // remove unnecessary keyframes same as their neighbors\n\n          const offset = i * stride,\n            offsetP = offset - stride,\n            offsetN = offset + stride;\n\n          for (let j = 0; j !== stride; ++j) {\n            const value = values[offset + j];\n\n            if (\n              value !== values[offsetP + j] ||\n              value !== values[offsetN + j]\n            ) {\n              keep = true;\n              break;\n            }\n          }\n        } else {\n          keep = true;\n        }\n      }\n\n      // in-place compaction\n\n      if (keep) {\n        if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n\n          const readOffset = i * stride,\n            writeOffset = writeIndex * stride;\n\n          for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = values[readOffset + j];\n          }\n        }\n\n        ++writeIndex;\n      }\n    }\n\n    // flush last keyframe (compaction looks ahead)\n\n    if (lastIndex > 0) {\n      times[writeIndex] = times[lastIndex];\n\n      for (\n        let readOffset = lastIndex * stride,\n          writeOffset = writeIndex * stride,\n          j = 0;\n        j !== stride;\n        ++j\n      ) {\n        values[writeOffset + j] = values[readOffset + j];\n      }\n\n      ++writeIndex;\n    }\n\n    if (writeIndex !== times.length) {\n      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n    } else {\n      this.times = times;\n      this.values = values;\n    }\n\n    return this;\n  }\n\n  clone() {\n    const times = AnimationUtils.arraySlice(this.times, 0);\n    const values = AnimationUtils.arraySlice(this.values, 0);\n\n    const TypedKeyframeTrack = this.constructor;\n    const track = new TypedKeyframeTrack(this.name, times, values);\n\n    // Interpolant argument to constructor is not saved, so copy the factory method directly.\n    track.createInterpolant = this.createInterpolant;\n\n    return track;\n  }\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      stride = this.valueSize,\n      alpha = (t - t0) / (t1 - t0);\n\n    let offset = i1 * stride;\n\n    for (let end = offset + stride; offset !== end; offset += 4) {\n      Quaternion.slerpFlat(\n        result,\n        0,\n        values,\n        offset - stride,\n        values,\n        offset,\n        alpha,\n      );\n    }\n\n    return result;\n  }\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n  InterpolantFactoryMethodLinear(result) {\n    return new QuaternionLinearInterpolant(\n      this.times,\n      this.values,\n      this.getValueSize(),\n      result,\n    );\n  }\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\nQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n  constructor(\n    name,\n    duration = -1,\n    tracks,\n    blendMode = NormalAnimationBlendMode,\n  ) {\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = duration;\n    this.blendMode = blendMode;\n\n    this.uuid = generateUUID();\n\n    // this means it should figure out its duration by scanning the tracks\n    if (this.duration < 0) {\n      this.resetDuration();\n    }\n  }\n\n  static parse(json) {\n    const tracks = [],\n      jsonTracks = json.tracks,\n      frameTime = 1.0 / (json.fps || 1.0);\n\n    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n\n    const clip = new this(json.name, json.duration, tracks, json.blendMode);\n    clip.uuid = json.uuid;\n\n    return clip;\n  }\n\n  static toJSON(clip) {\n    const tracks = [],\n      clipTracks = clip.tracks;\n\n    const json = {\n      name: clip.name,\n      duration: clip.duration,\n      tracks: tracks,\n      uuid: clip.uuid,\n      blendMode: clip.blendMode,\n    };\n\n    for (let i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n\n    return json;\n  }\n\n  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n    const numMorphTargets = morphTargetSequence.length;\n    const tracks = [];\n\n    for (let i = 0; i < numMorphTargets; i++) {\n      let times = [];\n      let values = [];\n\n      times.push(\n        (i + numMorphTargets - 1) % numMorphTargets,\n        i,\n        (i + 1) % numMorphTargets,\n      );\n\n      values.push(0, 1, 0);\n\n      const order = AnimationUtils.getKeyframeOrder(times);\n      times = AnimationUtils.sortedArray(times, 1, order);\n      values = AnimationUtils.sortedArray(values, 1, order);\n\n      // if there is a key at the first frame, duplicate it as the\n      // last frame as well for perfect loop.\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n\n      tracks.push(\n        new NumberKeyframeTrack(\n          '.morphTargetInfluences[' + morphTargetSequence[i].name + ']',\n          times,\n          values,\n        ).scale(1.0 / fps),\n      );\n    }\n\n    return new this(name, -1, tracks);\n  }\n\n  static findByName(objectOrClipArray, name) {\n    let clipArray = objectOrClipArray;\n\n    if (!Array.isArray(objectOrClipArray)) {\n      const o = objectOrClipArray;\n      clipArray = (o.geometry && o.geometry.animations) || o.animations;\n    }\n\n    for (let i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n\n    return null;\n  }\n\n  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n    const animationToMorphTargets = {};\n\n    // tested with https://regex101.com/ on trick sequences\n    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n    const pattern = /^([\\w-]*?)([\\d]+)$/;\n\n    // sort morph target names into animation groups based\n    // patterns like Walk_001, Walk_002, Run_001, Run_002\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = morphTargets[i];\n      const parts = morphTarget.name.match(pattern);\n\n      if (parts && parts.length > 1) {\n        const name = parts[1];\n\n        let animationMorphTargets = animationToMorphTargets[name];\n\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n\n    const clips = [];\n\n    for (const name in animationToMorphTargets) {\n      clips.push(\n        this.CreateFromMorphTargetSequence(\n          name,\n          animationToMorphTargets[name],\n          fps,\n          noLoop,\n        ),\n      );\n    }\n\n    return clips;\n  }\n\n  // parse the animation.hierarchy format\n  static parseAnimation(animation, bones) {\n    if (!animation) {\n      console.error('THREE.AnimationClip: No animation in JSONLoader data.');\n      return null;\n    }\n\n    const addNonemptyTrack = function (\n      trackType,\n      trackName,\n      animationKeys,\n      propertyName,\n      destTracks,\n    ) {\n      // only return track if there are actually keys.\n      if (animationKeys.length !== 0) {\n        const times = [];\n        const values = [];\n\n        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);\n\n        // empty keys are filtered out, so check again\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n\n    const tracks = [];\n\n    const clipName = animation.name || 'default';\n    const fps = animation.fps || 30;\n    const blendMode = animation.blendMode;\n\n    // automatic length determination in AnimationClip.\n    let duration = animation.length || -1;\n\n    const hierarchyTracks = animation.hierarchy || [];\n\n    for (let h = 0; h < hierarchyTracks.length; h++) {\n      const animationKeys = hierarchyTracks[h].keys;\n\n      // skip empty tracks\n      if (!animationKeys || animationKeys.length === 0) continue;\n\n      // process morph targets\n      if (animationKeys[0].morphTargets) {\n        // figure out all morph targets used in this track\n        const morphTargetNames = {};\n\n        let k;\n\n        for (k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        }\n\n        // create a track for each morph target with all zero\n        // morphTargetInfluences except for the keys in which\n        // the morphTarget is named.\n        for (const morphTargetName in morphTargetNames) {\n          const times = [];\n          const values = [];\n\n          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n            const animationKey = animationKeys[k];\n\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n\n          tracks.push(\n            new NumberKeyframeTrack(\n              '.morphTargetInfluence[' + morphTargetName + ']',\n              times,\n              values,\n            ),\n          );\n        }\n\n        duration = morphTargetNames.length * (fps || 1.0);\n      } else {\n        // ...assume skeletal animation\n\n        const boneName = '.bones[' + bones[h].name + ']';\n\n        addNonemptyTrack(\n          VectorKeyframeTrack,\n          boneName + '.position',\n          animationKeys,\n          'pos',\n          tracks,\n        );\n\n        addNonemptyTrack(\n          QuaternionKeyframeTrack,\n          boneName + '.quaternion',\n          animationKeys,\n          'rot',\n          tracks,\n        );\n\n        addNonemptyTrack(\n          VectorKeyframeTrack,\n          boneName + '.scale',\n          animationKeys,\n          'scl',\n          tracks,\n        );\n      }\n    }\n\n    if (tracks.length === 0) {\n      return null;\n    }\n\n    const clip = new this(clipName, duration, tracks, blendMode);\n\n    return clip;\n  }\n\n  resetDuration() {\n    const tracks = this.tracks;\n    let duration = 0;\n\n    for (let i = 0, n = tracks.length; i !== n; ++i) {\n      const track = this.tracks[i];\n\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n\n    this.duration = duration;\n\n    return this;\n  }\n\n  trim() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n\n    return this;\n  }\n\n  validate() {\n    let valid = true;\n\n    for (let i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n\n    return valid;\n  }\n\n  optimize() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n\n    return this;\n  }\n\n  clone() {\n    const tracks = [];\n\n    for (let i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n\n    return new this.constructor(\n      this.name,\n      this.duration,\n      tracks,\n      this.blendMode,\n    );\n  }\n\n  toJSON() {\n    return this.constructor.toJSON(this);\n  }\n}\n\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case 'scalar':\n    case 'double':\n    case 'float':\n    case 'number':\n    case 'integer':\n      return NumberKeyframeTrack;\n\n    case 'vector':\n    case 'vector2':\n    case 'vector3':\n    case 'vector4':\n      return VectorKeyframeTrack;\n\n    case 'color':\n      return ColorKeyframeTrack;\n\n    case 'quaternion':\n      return QuaternionKeyframeTrack;\n\n    case 'bool':\n    case 'boolean':\n      return BooleanKeyframeTrack;\n\n    case 'string':\n      return StringKeyframeTrack;\n  }\n\n  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n}\n\nfunction parseKeyframeTrack(json) {\n  if (json.type === undefined) {\n    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n  }\n\n  const trackType = getTrackTypeForValueTypeName(json.type);\n\n  if (json.times === undefined) {\n    const times = [],\n      values = [];\n\n    AnimationUtils.flattenJSON(json.keys, times, values, 'value');\n\n    json.times = times;\n    json.values = values;\n  }\n\n  // derived classes can define a static parse method\n  if (trackType.parse !== undefined) {\n    return trackType.parse(json);\n  } else {\n    // by default, we assume a constructor compatible with the base\n    return new trackType(\n      json.name,\n      json.times,\n      json.values,\n      json.interpolation,\n    );\n  }\n}\n\nconst Cache = {\n  enabled: false,\n\n  files: {},\n\n  add: function (key, file) {\n    if (this.enabled === false) return;\n\n    // console.log( 'THREE.Cache', 'Adding key:', key );\n\n    this.files[key] = file;\n  },\n\n  get: function (key) {\n    if (this.enabled === false) return;\n\n    // console.log( 'THREE.Cache', 'Checking key:', key );\n\n    return this.files[key];\n  },\n\n  remove: function (key) {\n    delete this.files[key];\n  },\n\n  clear: function () {\n    this.files = {};\n  },\n};\n\nclass LoadingManager {\n  constructor(onLoad, onProgress, onError) {\n    const scope = this;\n\n    let isLoading = false;\n    let itemsLoaded = 0;\n    let itemsTotal = 0;\n    let urlModifier = undefined;\n    const handlers = [];\n\n    // Refer to #5689 for the reason why we don't set .onStart\n    // in the constructor\n\n    this.onStart = undefined;\n    this.onLoad = onLoad;\n    this.onProgress = onProgress;\n    this.onError = onError;\n\n    this.itemStart = function (url) {\n      itemsTotal++;\n\n      if (isLoading === false) {\n        if (scope.onStart !== undefined) {\n          scope.onStart(url, itemsLoaded, itemsTotal);\n        }\n      }\n\n      isLoading = true;\n    };\n\n    this.itemEnd = function (url) {\n      itemsLoaded++;\n\n      if (scope.onProgress !== undefined) {\n        scope.onProgress(url, itemsLoaded, itemsTotal);\n      }\n\n      if (itemsLoaded === itemsTotal) {\n        isLoading = false;\n\n        if (scope.onLoad !== undefined) {\n          scope.onLoad();\n        }\n      }\n    };\n\n    this.itemError = function (url) {\n      if (scope.onError !== undefined) {\n        scope.onError(url);\n      }\n    };\n\n    this.resolveURL = function (url) {\n      if (urlModifier) {\n        return urlModifier(url);\n      }\n\n      return url;\n    };\n\n    this.setURLModifier = function (transform) {\n      urlModifier = transform;\n\n      return this;\n    };\n\n    this.addHandler = function (regex, loader) {\n      handlers.push(regex, loader);\n\n      return this;\n    };\n\n    this.removeHandler = function (regex) {\n      const index = handlers.indexOf(regex);\n\n      if (index !== -1) {\n        handlers.splice(index, 2);\n      }\n\n      return this;\n    };\n\n    this.getHandler = function (file) {\n      for (let i = 0, l = handlers.length; i < l; i += 2) {\n        const regex = handlers[i];\n        const loader = handlers[i + 1];\n\n        if (regex.global) regex.lastIndex = 0; // see #17920\n\n        if (regex.test(file)) {\n          return loader;\n        }\n      }\n\n      return null;\n    };\n  }\n}\n\nconst DefaultLoadingManager = new LoadingManager();\n\nclass Loader {\n  constructor(manager) {\n    this.manager = manager !== undefined ? manager : DefaultLoadingManager;\n\n    this.crossOrigin = 'anonymous';\n    this.withCredentials = false;\n    this.path = '';\n    this.resourcePath = '';\n    this.requestHeader = {};\n  }\n\n  load(/* url, onLoad, onProgress, onError */) {}\n\n  loadAsync(url, onProgress) {\n    const scope = this;\n\n    return new Promise(function (resolve, reject) {\n      scope.load(url, resolve, onProgress, reject);\n    });\n  }\n\n  parse(/* data */) {}\n\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n\n  setWithCredentials(value) {\n    this.withCredentials = value;\n    return this;\n  }\n\n  setPath(path) {\n    this.path = path;\n    return this;\n  }\n\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n\n  setRequestHeader(requestHeader) {\n    this.requestHeader = requestHeader;\n    return this;\n  }\n}\n\nconst loading = {};\n\nclass FileLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n\n    if (this.path !== undefined) url = this.path + url;\n\n    url = this.manager.resolveURL(url);\n\n    const scope = this;\n\n    const cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n\n        scope.manager.itemEnd(url);\n      }, 0);\n\n      return cached;\n    }\n\n    // Check if request is duplicate\n\n    if (loading[url] !== undefined) {\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError,\n      });\n\n      return;\n    }\n\n    // Check for data: URI\n    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n    const dataUriRegexResult = url.match(dataUriRegex);\n    let request;\n\n    // Safari can not handle Data URIs through XMLHttpRequest so process manually\n    if (dataUriRegexResult) {\n      const mimeType = dataUriRegexResult[1];\n      const isBase64 = !!dataUriRegexResult[2];\n\n      let data = dataUriRegexResult[3];\n      data = decodeURIComponent(data);\n\n      if (isBase64) data = atob(data);\n\n      try {\n        let response;\n        const responseType = (this.responseType || '').toLowerCase();\n\n        switch (responseType) {\n          case 'arraybuffer':\n          case 'blob':\n            const view = new Uint8Array(data.length);\n\n            for (let i = 0; i < data.length; i++) {\n              view[i] = data.charCodeAt(i);\n            }\n\n            if (responseType === 'blob') {\n              response = new Blob([view.buffer], { type: mimeType });\n            } else {\n              response = view.buffer;\n            }\n\n            break;\n\n          case 'document':\n            const parser = new DOMParser();\n            response = parser.parseFromString(data, mimeType);\n\n            break;\n\n          case 'json':\n            response = JSON.parse(data);\n\n            break;\n\n          default:\n            // 'text' or other\n\n            response = data;\n\n            break;\n        }\n\n        // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n        setTimeout(function () {\n          if (onLoad) onLoad(response);\n\n          scope.manager.itemEnd(url);\n        }, 0);\n      } catch (error) {\n        // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n        setTimeout(function () {\n          if (onError) onError(error);\n\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        }, 0);\n      }\n    } else {\n      // Initialise array for duplicate requests\n\n      loading[url] = [];\n\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError,\n      });\n\n      request = new XMLHttpRequest();\n\n      request.open('GET', url, true);\n\n      request.addEventListener(\n        'load',\n        function (event) {\n          const response = this.response;\n\n          const callbacks = loading[url];\n\n          delete loading[url];\n\n          if (this.status === 200 || this.status === 0) {\n            // Some browsers return HTTP Status 0 when using non-http protocol\n            // e.g. 'file://' or 'data://'. Handle as success.\n\n            if (this.status === 0)\n              console.warn('THREE.FileLoader: HTTP Status 0 received.');\n\n            // Add to cache only on HTTP success, so that we do not cache\n            // error response bodies as proper responses to requests.\n            Cache.add(url, response);\n\n            for (let i = 0, il = callbacks.length; i < il; i++) {\n              const callback = callbacks[i];\n              if (callback.onLoad) callback.onLoad(response);\n            }\n\n            scope.manager.itemEnd(url);\n          } else {\n            for (let i = 0, il = callbacks.length; i < il; i++) {\n              const callback = callbacks[i];\n              if (callback.onError) callback.onError(event);\n            }\n\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n          }\n        },\n        false,\n      );\n\n      request.addEventListener(\n        'progress',\n        function (event) {\n          const callbacks = loading[url];\n\n          for (let i = 0, il = callbacks.length; i < il; i++) {\n            const callback = callbacks[i];\n            if (callback.onProgress) callback.onProgress(event);\n          }\n        },\n        false,\n      );\n\n      request.addEventListener(\n        'error',\n        function (event) {\n          const callbacks = loading[url];\n\n          delete loading[url];\n\n          for (let i = 0, il = callbacks.length; i < il; i++) {\n            const callback = callbacks[i];\n            if (callback.onError) callback.onError(event);\n          }\n\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        },\n        false,\n      );\n\n      request.addEventListener(\n        'abort',\n        function (event) {\n          const callbacks = loading[url];\n\n          delete loading[url];\n\n          for (let i = 0, il = callbacks.length; i < il; i++) {\n            const callback = callbacks[i];\n            if (callback.onError) callback.onError(event);\n          }\n\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        },\n        false,\n      );\n\n      if (this.responseType !== undefined)\n        request.responseType = this.responseType;\n      if (this.withCredentials !== undefined)\n        request.withCredentials = this.withCredentials;\n\n      if (request.overrideMimeType)\n        request.overrideMimeType(\n          this.mimeType !== undefined ? this.mimeType : 'text/plain',\n        );\n\n      for (const header in this.requestHeader) {\n        request.setRequestHeader(header, this.requestHeader[header]);\n      }\n\n      request.send(null);\n    }\n\n    scope.manager.itemStart(url);\n\n    return request;\n  }\n\n  setResponseType(value) {\n    this.responseType = value;\n    return this;\n  }\n\n  setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n}\n\nclass ImageLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (this.path !== undefined) url = this.path + url;\n\n    url = this.manager.resolveURL(url);\n\n    const scope = this;\n\n    const cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n\n        scope.manager.itemEnd(url);\n      }, 0);\n\n      return cached;\n    }\n\n    const image = createElementNS('img');\n\n    function onImageLoad() {\n      image.removeEventListener('load', onImageLoad, false);\n      image.removeEventListener('error', onImageError, false);\n\n      Cache.add(url, this);\n\n      if (onLoad) onLoad(this);\n\n      scope.manager.itemEnd(url);\n    }\n\n    function onImageError(event) {\n      image.removeEventListener('load', onImageLoad, false);\n      image.removeEventListener('error', onImageError, false);\n\n      if (onError) onError(event);\n\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    }\n\n    image.addEventListener('load', onImageLoad, false);\n    image.addEventListener('error', onImageError, false);\n\n    if (url.substr(0, 5) !== 'data:') {\n      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n    }\n\n    scope.manager.itemStart(url);\n\n    image.src = url;\n\n    return image;\n  }\n}\n\nclass CubeTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(urls, onLoad, onProgress, onError) {\n    const texture = new CubeTexture();\n\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n\n    let loaded = 0;\n\n    function loadTexture(i) {\n      loader.load(\n        urls[i],\n        function (image) {\n          texture.images[i] = image;\n\n          loaded++;\n\n          if (loaded === 6) {\n            texture.needsUpdate = true;\n\n            if (onLoad) onLoad(texture);\n          }\n        },\n        undefined,\n        onError,\n      );\n    }\n\n    for (let i = 0; i < urls.length; ++i) {\n      loadTexture(i);\n    }\n\n    return texture;\n  }\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n\n    const texture = new DataTexture();\n\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function (buffer) {\n        const texData = scope.parse(buffer);\n\n        if (!texData) return;\n\n        if (texData.image !== undefined) {\n          texture.image = texData.image;\n        } else if (texData.data !== undefined) {\n          texture.image.width = texData.width;\n          texture.image.height = texData.height;\n          texture.image.data = texData.data;\n        }\n\n        texture.wrapS =\n          texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n        texture.wrapT =\n          texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n        texture.magFilter =\n          texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n        texture.minFilter =\n          texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n        texture.anisotropy =\n          texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n        if (texData.encoding !== undefined) {\n          texture.encoding = texData.encoding;\n        }\n\n        if (texData.flipY !== undefined) {\n          texture.flipY = texData.flipY;\n        }\n\n        if (texData.format !== undefined) {\n          texture.format = texData.format;\n        }\n\n        if (texData.type !== undefined) {\n          texture.type = texData.type;\n        }\n\n        if (texData.mipmaps !== undefined) {\n          texture.mipmaps = texData.mipmaps;\n          texture.minFilter = LinearMipmapLinearFilter; // presumably...\n        }\n\n        if (texData.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n\n        if (texData.generateMipmaps !== undefined) {\n          texture.generateMipmaps = texData.generateMipmaps;\n        }\n\n        texture.needsUpdate = true;\n\n        if (onLoad) onLoad(texture, texData);\n      },\n      onProgress,\n      onError,\n    );\n\n    return texture;\n  }\n}\n\nclass TextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const texture = new Texture$1();\n\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n\n    loader.load(\n      url,\n      function (image) {\n        texture.image = image;\n        texture.needsUpdate = true;\n\n        if (onLoad !== undefined) {\n          onLoad(texture);\n        }\n      },\n      onProgress,\n      onError,\n    );\n\n    return texture;\n  }\n}\n\nclass Light extends Object3D {\n  constructor(color, intensity = 1) {\n    super();\n\n    this.type = 'Light';\n\n    this.color = new Color(color);\n    this.intensity = intensity;\n  }\n\n  dispose() {\n    // Empty here in base class; some subclasses override.\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.color.copy(source.color);\n    this.intensity = source.intensity;\n\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n\n    data.object.color = this.color.getHex();\n    data.object.intensity = this.intensity;\n\n    if (this.groundColor !== undefined)\n      data.object.groundColor = this.groundColor.getHex();\n\n    if (this.distance !== undefined) data.object.distance = this.distance;\n    if (this.angle !== undefined) data.object.angle = this.angle;\n    if (this.decay !== undefined) data.object.decay = this.decay;\n    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;\n\n    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();\n\n    return data;\n  }\n}\n\nLight.prototype.isLight = true;\n\nclass HemisphereLight extends Light {\n  constructor(skyColor, groundColor, intensity) {\n    super(skyColor, intensity);\n\n    this.type = 'HemisphereLight';\n\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n\n    this.groundColor = new Color(groundColor);\n  }\n\n  copy(source) {\n    Light.prototype.copy.call(this, source);\n\n    this.groundColor.copy(source.groundColor);\n\n    return this;\n  }\n}\n\nHemisphereLight.prototype.isHemisphereLight = true;\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n  constructor(camera) {\n    this.camera = camera;\n\n    this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n    this.blurSamples = 8;\n\n    this.mapSize = new Vector2(512, 512);\n\n    this.map = null;\n    this.mapPass = null;\n    this.matrix = new Matrix4();\n\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n\n    this._frustum = new Frustum();\n    this._frameExtents = new Vector2(1, 1);\n\n    this._viewportCount = 1;\n\n    this._viewports = [new Vector4(0, 0, 1, 1)];\n  }\n\n  getViewportCount() {\n    return this._viewportCount;\n  }\n\n  getFrustum() {\n    return this._frustum;\n  }\n\n  updateMatrices(light) {\n    const shadowCamera = this.camera;\n    const shadowMatrix = this.matrix;\n\n    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n    shadowCamera.position.copy(_lightPositionWorld$1);\n\n    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n    shadowCamera.lookAt(_lookTarget$1);\n    shadowCamera.updateMatrixWorld();\n\n    _projScreenMatrix$1.multiplyMatrices(\n      shadowCamera.projectionMatrix,\n      shadowCamera.matrixWorldInverse,\n    );\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n\n    shadowMatrix.set(\n      0.5,\n      0.0,\n      0.0,\n      0.5,\n      0.0,\n      0.5,\n      0.0,\n      0.5,\n      0.0,\n      0.0,\n      0.5,\n      0.5,\n      0.0,\n      0.0,\n      0.0,\n      1.0,\n    );\n\n    shadowMatrix.multiply(shadowCamera.projectionMatrix);\n    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n  }\n\n  getViewport(viewportIndex) {\n    return this._viewports[viewportIndex];\n  }\n\n  getFrameExtents() {\n    return this._frameExtents;\n  }\n\n  dispose() {\n    if (this.map) {\n      this.map.dispose();\n    }\n\n    if (this.mapPass) {\n      this.mapPass.dispose();\n    }\n  }\n\n  copy(source) {\n    this.camera = source.camera.clone();\n\n    this.bias = source.bias;\n    this.radius = source.radius;\n\n    this.mapSize.copy(source.mapSize);\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  toJSON() {\n    const object = {};\n\n    if (this.bias !== 0) object.bias = this.bias;\n    if (this.normalBias !== 0) object.normalBias = this.normalBias;\n    if (this.radius !== 1) object.radius = this.radius;\n    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)\n      object.mapSize = this.mapSize.toArray();\n\n    object.camera = this.camera.toJSON(false).object;\n    delete object.camera.matrix;\n\n    return object;\n  }\n}\n\nclass SpotLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(50, 1, 0.5, 500));\n\n    this.focus = 1;\n  }\n\n  updateMatrices(light) {\n    const camera = this.camera;\n\n    const fov = RAD2DEG * 2 * light.angle * this.focus;\n    const aspect = this.mapSize.width / this.mapSize.height;\n    const far = light.distance || camera.far;\n\n    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {\n      camera.fov = fov;\n      camera.aspect = aspect;\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n\n    super.updateMatrices(light);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.focus = source.focus;\n\n    return this;\n  }\n}\n\nSpotLightShadow.prototype.isSpotLightShadow = true;\n\nclass SpotLight extends Light {\n  constructor(\n    color,\n    intensity,\n    distance = 0,\n    angle = Math.PI / 3,\n    penumbra = 0,\n    decay = 1,\n  ) {\n    super(color, intensity);\n\n    this.type = 'SpotLight';\n\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n\n    this.target = new Object3D();\n\n    this.distance = distance;\n    this.angle = angle;\n    this.penumbra = penumbra;\n    this.decay = decay; // for physically correct lights, should be 2.\n\n    this.shadow = new SpotLightShadow();\n  }\n\n  get power() {\n    // compute the light's luminous power (in lumens) from its intensity (in candela)\n    // by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)\n    return this.intensity * Math.PI;\n  }\n\n  set power(power) {\n    // set the light's intensity (in candela) from the desired luminous power (in lumens)\n    this.intensity = power / Math.PI;\n  }\n\n  dispose() {\n    this.shadow.dispose();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.distance = source.distance;\n    this.angle = source.angle;\n    this.penumbra = source.penumbra;\n    this.decay = source.decay;\n\n    this.target = source.target.clone();\n\n    this.shadow = source.shadow.clone();\n\n    return this;\n  }\n}\n\nSpotLight.prototype.isSpotLight = true;\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(90, 1, 0.5, 500));\n\n    this._frameExtents = new Vector2(4, 2);\n\n    this._viewportCount = 6;\n\n    this._viewports = [\n      // These viewports map a cube-map onto a 2D texture with the\n      // following orientation:\n      //\n      //  xzXZ\n      //   y Y\n      //\n      // X - Positive x direction\n      // x - Negative x direction\n      // Y - Positive y direction\n      // y - Negative y direction\n      // Z - Positive z direction\n      // z - Negative z direction\n\n      // positive X\n      new Vector4(2, 1, 1, 1),\n      // negative X\n      new Vector4(0, 1, 1, 1),\n      // positive Z\n      new Vector4(3, 1, 1, 1),\n      // negative Z\n      new Vector4(1, 1, 1, 1),\n      // positive Y\n      new Vector4(3, 0, 1, 1),\n      // negative Y\n      new Vector4(1, 0, 1, 1),\n    ];\n\n    this._cubeDirections = [\n      new Vector3(1, 0, 0),\n      new Vector3(-1, 0, 0),\n      new Vector3(0, 0, 1),\n      new Vector3(0, 0, -1),\n      new Vector3(0, 1, 0),\n      new Vector3(0, -1, 0),\n    ];\n\n    this._cubeUps = [\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 0, 1),\n      new Vector3(0, 0, -1),\n    ];\n  }\n\n  updateMatrices(light, viewportIndex = 0) {\n    const camera = this.camera;\n    const shadowMatrix = this.matrix;\n\n    const far = light.distance || camera.far;\n\n    if (far !== camera.far) {\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n\n    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n    camera.position.copy(_lightPositionWorld);\n\n    _lookTarget.copy(camera.position);\n    _lookTarget.add(this._cubeDirections[viewportIndex]);\n    camera.up.copy(this._cubeUps[viewportIndex]);\n    camera.lookAt(_lookTarget);\n    camera.updateMatrixWorld();\n\n    shadowMatrix.makeTranslation(\n      -_lightPositionWorld.x,\n      -_lightPositionWorld.y,\n      -_lightPositionWorld.z,\n    );\n\n    _projScreenMatrix.multiplyMatrices(\n      camera.projectionMatrix,\n      camera.matrixWorldInverse,\n    );\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix);\n  }\n}\n\nPointLightShadow.prototype.isPointLightShadow = true;\n\nclass PointLight extends Light {\n  constructor(color, intensity, distance = 0, decay = 1) {\n    super(color, intensity);\n\n    this.type = 'PointLight';\n\n    this.distance = distance;\n    this.decay = decay; // for physically correct lights, should be 2.\n\n    this.shadow = new PointLightShadow();\n  }\n\n  get power() {\n    // compute the light's luminous power (in lumens) from its intensity (in candela)\n    // for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)\n    return this.intensity * 4 * Math.PI;\n  }\n\n  set power(power) {\n    // set the light's intensity (in candela) from the desired luminous power (in lumens)\n    this.intensity = power / (4 * Math.PI);\n  }\n\n  dispose() {\n    this.shadow.dispose();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.distance = source.distance;\n    this.decay = source.decay;\n\n    this.shadow = source.shadow.clone();\n\n    return this;\n  }\n}\n\nPointLight.prototype.isPointLight = true;\n\nclass DirectionalLightShadow extends LightShadow {\n  constructor() {\n    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n  }\n}\n\nDirectionalLightShadow.prototype.isDirectionalLightShadow = true;\n\nclass DirectionalLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n\n    this.type = 'DirectionalLight';\n\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n\n    this.target = new Object3D();\n\n    this.shadow = new DirectionalLightShadow();\n  }\n\n  dispose() {\n    this.shadow.dispose();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n\n    return this;\n  }\n}\n\nDirectionalLight.prototype.isDirectionalLight = true;\n\nclass AmbientLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n\n    this.type = 'AmbientLight';\n  }\n}\n\nAmbientLight.prototype.isAmbientLight = true;\n\nclass RectAreaLight extends Light {\n  constructor(color, intensity, width = 10, height = 10) {\n    super(color, intensity);\n\n    this.type = 'RectAreaLight';\n\n    this.width = width;\n    this.height = height;\n  }\n\n  get power() {\n    // compute the light's luminous power (in lumens) from its intensity (in nits)\n    return this.intensity * this.width * this.height * Math.PI;\n  }\n\n  set power(power) {\n    // set the light's intensity (in nits) from the desired luminous power (in lumens)\n    this.intensity = power / (this.width * this.height * Math.PI);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.width = source.width;\n    this.height = source.height;\n\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n\n    data.object.width = this.width;\n    data.object.height = this.height;\n\n    return data;\n  }\n}\n\nRectAreaLight.prototype.isRectAreaLight = true;\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n  constructor() {\n    this.coefficients = [];\n\n    for (let i = 0; i < 9; i++) {\n      this.coefficients.push(new Vector3());\n    }\n  }\n\n  set(coefficients) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].copy(coefficients[i]);\n    }\n\n    return this;\n  }\n\n  zero() {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].set(0, 0, 0);\n    }\n\n    return this;\n  }\n\n  // get the radiance in the direction of the normal\n  // target is a Vector3\n  getAt(normal, target) {\n    // normal is assumed to be unit length\n\n    const x = normal.x,\n      y = normal.y,\n      z = normal.z;\n\n    const coeff = this.coefficients;\n\n    // band 0\n    target.copy(coeff[0]).multiplyScalar(0.282095);\n\n    // band 1\n    target.addScaledVector(coeff[1], 0.488603 * y);\n    target.addScaledVector(coeff[2], 0.488603 * z);\n    target.addScaledVector(coeff[3], 0.488603 * x);\n\n    // band 2\n    target.addScaledVector(coeff[4], 1.092548 * (x * y));\n    target.addScaledVector(coeff[5], 1.092548 * (y * z));\n    target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\n    target.addScaledVector(coeff[7], 1.092548 * (x * z));\n    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n\n    return target;\n  }\n\n  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n  // target is a Vector3\n  // https://graphics.stanford.edu/papers/envmap/envmap.pdf\n  getIrradianceAt(normal, target) {\n    // normal is assumed to be unit length\n\n    const x = normal.x,\n      y = normal.y,\n      z = normal.z;\n\n    const coeff = this.coefficients;\n\n    // band 0\n    target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095\n\n    // band 1\n    target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603\n    target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);\n    target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);\n\n    // band 2\n    target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548\n    target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);\n    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3\n    target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);\n    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274\n\n    return target;\n  }\n\n  add(sh) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].add(sh.coefficients[i]);\n    }\n\n    return this;\n  }\n\n  addScaledSH(sh, s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].addScaledVector(sh.coefficients[i], s);\n    }\n\n    return this;\n  }\n\n  scale(s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].multiplyScalar(s);\n    }\n\n    return this;\n  }\n\n  lerp(sh, alpha) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].lerp(sh.coefficients[i], alpha);\n    }\n\n    return this;\n  }\n\n  equals(sh) {\n    for (let i = 0; i < 9; i++) {\n      if (!this.coefficients[i].equals(sh.coefficients[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  copy(sh) {\n    return this.set(sh.coefficients);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  fromArray(array, offset = 0) {\n    const coefficients = this.coefficients;\n\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].fromArray(array, offset + i * 3);\n    }\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    const coefficients = this.coefficients;\n\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].toArray(array, offset + i * 3);\n    }\n\n    return array;\n  }\n\n  // evaluate the basis functions\n  // shBasis is an Array[ 9 ]\n  static getBasisAt(normal, shBasis) {\n    // normal is assumed to be unit length\n\n    const x = normal.x,\n      y = normal.y,\n      z = normal.z;\n\n    // band 0\n    shBasis[0] = 0.282095;\n\n    // band 1\n    shBasis[1] = 0.488603 * y;\n    shBasis[2] = 0.488603 * z;\n    shBasis[3] = 0.488603 * x;\n\n    // band 2\n    shBasis[4] = 1.092548 * x * y;\n    shBasis[5] = 1.092548 * y * z;\n    shBasis[6] = 0.315392 * (3 * z * z - 1);\n    shBasis[7] = 1.092548 * x * z;\n    shBasis[8] = 0.546274 * (x * x - y * y);\n  }\n}\n\nSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\n\nclass LightProbe extends Light {\n  constructor(sh = new SphericalHarmonics3(), intensity = 1) {\n    super(undefined, intensity);\n\n    this.sh = sh;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.sh.copy(source.sh);\n\n    return this;\n  }\n\n  fromJSON(json) {\n    this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n    this.sh.fromArray(json.sh);\n\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n\n    data.object.sh = this.sh.toArray();\n\n    return data;\n  }\n}\n\nLightProbe.prototype.isLightProbe = true;\n\nclass LoaderUtils {\n  static decodeText(array) {\n    if (typeof TextDecoder !== 'undefined') {\n      return new TextDecoder().decode(array);\n    }\n\n    // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n    // throws a \"maximum call stack size exceeded\" error for large arrays.\n\n    let s = '';\n\n    for (let i = 0, il = array.length; i < il; i++) {\n      // Implicitly assumes little-endian.\n      s += String.fromCharCode(array[i]);\n    }\n\n    try {\n      // merges multi-byte utf-8 characters.\n\n      return decodeURIComponent(escape(s));\n    } catch (e) {\n      // see #16358\n\n      return s;\n    }\n  }\n\n  static extractUrlBase(url) {\n    const index = url.lastIndexOf('/');\n\n    if (index === -1) return './';\n\n    return url.substr(0, index + 1);\n  }\n}\n\nclass InstancedBufferGeometry extends BufferGeometry {\n  constructor() {\n    super();\n\n    this.type = 'InstancedBufferGeometry';\n    this.instanceCount = Infinity;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.instanceCount = source.instanceCount;\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  toJSON() {\n    const data = super.toJSON(this);\n\n    data.instanceCount = this.instanceCount;\n\n    data.isInstancedBufferGeometry = true;\n\n    return data;\n  }\n}\n\nInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\nclass ImageBitmapLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n\n    if (typeof createImageBitmap === 'undefined') {\n      console.warn(\n        'THREE.ImageBitmapLoader: createImageBitmap() not supported.',\n      );\n    }\n\n    if (typeof fetch === 'undefined') {\n      console.warn('THREE.ImageBitmapLoader: fetch() not supported.');\n    }\n\n    this.options = { premultiplyAlpha: 'none' };\n  }\n\n  setOptions(options) {\n    this.options = options;\n\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n\n    if (this.path !== undefined) url = this.path + url;\n\n    url = this.manager.resolveURL(url);\n\n    const scope = this;\n\n    const cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n\n        scope.manager.itemEnd(url);\n      }, 0);\n\n      return cached;\n    }\n\n    const fetchOptions = {};\n    fetchOptions.credentials =\n      this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';\n    fetchOptions.headers = this.requestHeader;\n\n    fetch(url, fetchOptions)\n      .then(function (res) {\n        return res.blob();\n      })\n      .then(function (blob) {\n        return createImageBitmap(\n          blob,\n          Object.assign(scope.options, { colorSpaceConversion: 'none' }),\n        );\n      })\n      .then(function (imageBitmap) {\n        Cache.add(url, imageBitmap);\n\n        if (onLoad) onLoad(imageBitmap);\n\n        scope.manager.itemEnd(url);\n      })\n      .catch(function (e) {\n        if (onError) onError(e);\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      });\n\n    scope.manager.itemStart(url);\n  }\n}\n\nImageBitmapLoader.prototype.isImageBitmapLoader = true;\n\nlet _context;\n\nconst AudioContext = {\n  getContext: function () {\n    if (_context === undefined) {\n      _context = new (window.AudioContext || window.webkitAudioContext)();\n    }\n\n    return _context;\n  },\n\n  setContext: function (value) {\n    _context = value;\n  },\n};\n\nclass AudioLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          // Create a copy of the buffer. The `decodeAudioData` method\n          // detaches the buffer when complete, preventing reuse.\n          const bufferCopy = buffer.slice(0);\n\n          const context = AudioContext.getContext();\n          context.decodeAudioData(bufferCopy, function (audioBuffer) {\n            onLoad(audioBuffer);\n          });\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError,\n    );\n  }\n}\n\nclass HemisphereLightProbe extends LightProbe {\n  constructor(skyColor, groundColor, intensity = 1) {\n    super(undefined, intensity);\n\n    const color1 = new Color().set(skyColor);\n    const color2 = new Color().set(groundColor);\n\n    const sky = new Vector3(color1.r, color1.g, color1.b);\n    const ground = new Vector3(color2.r, color2.g, color2.b);\n\n    // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n    const c0 = Math.sqrt(Math.PI);\n    const c1 = c0 * Math.sqrt(0.75);\n\n    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);\n    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);\n  }\n}\n\nHemisphereLightProbe.prototype.isHemisphereLightProbe = true;\n\nclass AmbientLightProbe extends LightProbe {\n  constructor(color, intensity = 1) {\n    super(undefined, intensity);\n\n    const color1 = new Color().set(color);\n\n    // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n    this.sh.coefficients[0]\n      .set(color1.r, color1.g, color1.b)\n      .multiplyScalar(2 * Math.sqrt(Math.PI));\n  }\n}\n\nAmbientLightProbe.prototype.isAmbientLightProbe = true;\n\nclass Audio extends Object3D {\n  constructor(listener) {\n    super();\n\n    this.type = 'Audio';\n\n    this.listener = listener;\n    this.context = listener.context;\n\n    this.gain = this.context.createGain();\n    this.gain.connect(listener.getInput());\n\n    this.autoplay = false;\n\n    this.buffer = null;\n    this.detune = 0;\n    this.loop = false;\n    this.loopStart = 0;\n    this.loopEnd = 0;\n    this.offset = 0;\n    this.duration = undefined;\n    this.playbackRate = 1;\n    this.isPlaying = false;\n    this.hasPlaybackControl = true;\n    this.source = null;\n    this.sourceType = 'empty';\n\n    this._startedAt = 0;\n    this._progress = 0;\n    this._connected = false;\n\n    this.filters = [];\n  }\n\n  getOutput() {\n    return this.gain;\n  }\n\n  setNodeSource(audioNode) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'audioNode';\n    this.source = audioNode;\n    this.connect();\n\n    return this;\n  }\n\n  setMediaElementSource(mediaElement) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'mediaNode';\n    this.source = this.context.createMediaElementSource(mediaElement);\n    this.connect();\n\n    return this;\n  }\n\n  setMediaStreamSource(mediaStream) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'mediaStreamNode';\n    this.source = this.context.createMediaStreamSource(mediaStream);\n    this.connect();\n\n    return this;\n  }\n\n  setBuffer(audioBuffer) {\n    this.buffer = audioBuffer;\n    this.sourceType = 'buffer';\n\n    if (this.autoplay) this.play();\n\n    return this;\n  }\n\n  play(delay = 0) {\n    if (this.isPlaying === true) {\n      console.warn('THREE.Audio: Audio is already playing.');\n      return;\n    }\n\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    this._startedAt = this.context.currentTime + delay;\n\n    const source = this.context.createBufferSource();\n    source.buffer = this.buffer;\n    source.loop = this.loop;\n    source.loopStart = this.loopStart;\n    source.loopEnd = this.loopEnd;\n    source.onended = this.onEnded.bind(this);\n    source.start(this._startedAt, this._progress + this.offset, this.duration);\n\n    this.isPlaying = true;\n\n    this.source = source;\n\n    this.setDetune(this.detune);\n    this.setPlaybackRate(this.playbackRate);\n\n    return this.connect();\n  }\n\n  pause() {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    if (this.isPlaying === true) {\n      // update current progress\n\n      this._progress +=\n        Math.max(this.context.currentTime - this._startedAt, 0) *\n        this.playbackRate;\n\n      if (this.loop === true) {\n        // ensure _progress does not exceed duration with looped audios\n\n        this._progress =\n          this._progress % (this.duration || this.buffer.duration);\n      }\n\n      this.source.stop();\n      this.source.onended = null;\n\n      this.isPlaying = false;\n    }\n\n    return this;\n  }\n\n  stop() {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    this._progress = 0;\n\n    this.source.stop();\n    this.source.onended = null;\n    this.isPlaying = false;\n\n    return this;\n  }\n\n  connect() {\n    if (this.filters.length > 0) {\n      this.source.connect(this.filters[0]);\n\n      for (let i = 1, l = this.filters.length; i < l; i++) {\n        this.filters[i - 1].connect(this.filters[i]);\n      }\n\n      this.filters[this.filters.length - 1].connect(this.getOutput());\n    } else {\n      this.source.connect(this.getOutput());\n    }\n\n    this._connected = true;\n\n    return this;\n  }\n\n  disconnect() {\n    if (this.filters.length > 0) {\n      this.source.disconnect(this.filters[0]);\n\n      for (let i = 1, l = this.filters.length; i < l; i++) {\n        this.filters[i - 1].disconnect(this.filters[i]);\n      }\n\n      this.filters[this.filters.length - 1].disconnect(this.getOutput());\n    } else {\n      this.source.disconnect(this.getOutput());\n    }\n\n    this._connected = false;\n\n    return this;\n  }\n\n  getFilters() {\n    return this.filters;\n  }\n\n  setFilters(value) {\n    if (!value) value = [];\n\n    if (this._connected === true) {\n      this.disconnect();\n      this.filters = value.slice();\n      this.connect();\n    } else {\n      this.filters = value.slice();\n    }\n\n    return this;\n  }\n\n  setDetune(value) {\n    this.detune = value;\n\n    if (this.source.detune === undefined) return; // only set detune when available\n\n    if (this.isPlaying === true) {\n      this.source.detune.setTargetAtTime(\n        this.detune,\n        this.context.currentTime,\n        0.01,\n      );\n    }\n\n    return this;\n  }\n\n  getDetune() {\n    return this.detune;\n  }\n\n  getFilter() {\n    return this.getFilters()[0];\n  }\n\n  setFilter(filter) {\n    return this.setFilters(filter ? [filter] : []);\n  }\n\n  setPlaybackRate(value) {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    this.playbackRate = value;\n\n    if (this.isPlaying === true) {\n      this.source.playbackRate.setTargetAtTime(\n        this.playbackRate,\n        this.context.currentTime,\n        0.01,\n      );\n    }\n\n    return this;\n  }\n\n  getPlaybackRate() {\n    return this.playbackRate;\n  }\n\n  onEnded() {\n    this.isPlaying = false;\n  }\n\n  getLoop() {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return false;\n    }\n\n    return this.loop;\n  }\n\n  setLoop(value) {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    this.loop = value;\n\n    if (this.isPlaying === true) {\n      this.source.loop = this.loop;\n    }\n\n    return this;\n  }\n\n  setLoopStart(value) {\n    this.loopStart = value;\n\n    return this;\n  }\n\n  setLoopEnd(value) {\n    this.loopEnd = value;\n\n    return this;\n  }\n\n  getVolume() {\n    return this.gain.gain.value;\n  }\n\n  setVolume(value) {\n    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n\n    return this;\n  }\n}\n\nclass PropertyMixer {\n  constructor(binding, typeName, valueSize) {\n    this.binding = binding;\n    this.valueSize = valueSize;\n\n    let mixFunction, mixFunctionAdditive, setIdentity;\n\n    // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n    //\n    // interpolators can use .buffer as their .result\n    // the data then goes to 'incoming'\n    //\n    // 'accu0' and 'accu1' are used frame-interleaved for\n    // the cumulative result and are compared to detect\n    // changes\n    //\n    // 'orig' stores the original state of the property\n    //\n    // 'add' is used for additive cumulative results\n    //\n    // 'work' is optional and is only present for quaternion types. It is used\n    // to store intermediate quaternion multiplication results\n\n    switch (typeName) {\n      case 'quaternion':\n        mixFunction = this._slerp;\n        mixFunctionAdditive = this._slerpAdditive;\n        setIdentity = this._setAdditiveIdentityQuaternion;\n\n        this.buffer = new Float64Array(valueSize * 6);\n        this._workIndex = 5;\n        break;\n\n      case 'string':\n      case 'bool':\n        mixFunction = this._select;\n\n        // Use the regular mix function and for additive on these types,\n        // additive is not relevant for non-numeric types\n        mixFunctionAdditive = this._select;\n\n        setIdentity = this._setAdditiveIdentityOther;\n\n        this.buffer = new Array(valueSize * 5);\n        break;\n\n      default:\n        mixFunction = this._lerp;\n        mixFunctionAdditive = this._lerpAdditive;\n        setIdentity = this._setAdditiveIdentityNumeric;\n\n        this.buffer = new Float64Array(valueSize * 5);\n    }\n\n    this._mixBufferRegion = mixFunction;\n    this._mixBufferRegionAdditive = mixFunctionAdditive;\n    this._setIdentity = setIdentity;\n    this._origIndex = 3;\n    this._addIndex = 4;\n\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n\n    this.useCount = 0;\n    this.referenceCount = 0;\n  }\n\n  // accumulate data in the 'incoming' region into 'accu<i>'\n  accumulate(accuIndex, weight) {\n    // note: happily accumulating nothing when weight = 0, the caller knows\n    // the weight and shouldn't have made the call in the first place\n\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      offset = accuIndex * stride + stride;\n\n    let currentWeight = this.cumulativeWeight;\n\n    if (currentWeight === 0) {\n      // accuN := incoming * weight\n\n      for (let i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n\n      currentWeight = weight;\n    } else {\n      // accuN := accuN + incoming * weight\n\n      currentWeight += weight;\n      const mix = weight / currentWeight;\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n\n    this.cumulativeWeight = currentWeight;\n  }\n\n  // accumulate data in the 'incoming' region into 'add'\n  accumulateAdditive(weight) {\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      offset = stride * this._addIndex;\n\n    if (this.cumulativeWeightAdditive === 0) {\n      // add = identity\n\n      this._setIdentity();\n    }\n\n    // add := add + incoming * weight\n\n    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n    this.cumulativeWeightAdditive += weight;\n  }\n\n  // apply the state of 'accu<i>' to the binding when accus differ\n  apply(accuIndex) {\n    const stride = this.valueSize,\n      buffer = this.buffer,\n      offset = accuIndex * stride + stride,\n      weight = this.cumulativeWeight,\n      weightAdditive = this.cumulativeWeightAdditive,\n      binding = this.binding;\n\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n\n    if (weight < 1) {\n      // accuN := accuN + original * ( 1 - cumulativeWeight )\n\n      const originalValueOffset = stride * this._origIndex;\n\n      this._mixBufferRegion(\n        buffer,\n        offset,\n        originalValueOffset,\n        1 - weight,\n        stride,\n      );\n    }\n\n    if (weightAdditive > 0) {\n      // accuN := accuN + additive accuN\n\n      this._mixBufferRegionAdditive(\n        buffer,\n        offset,\n        this._addIndex * stride,\n        1,\n        stride,\n      );\n    }\n\n    for (let i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        // value has changed -> update scene graph\n\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  }\n\n  // remember the state of the bound property and copy it to both accus\n  saveOriginalState() {\n    const binding = this.binding;\n\n    const buffer = this.buffer,\n      stride = this.valueSize,\n      originalValueOffset = stride * this._origIndex;\n\n    binding.getValue(buffer, originalValueOffset);\n\n    // accu[0..1] := orig -- initially detect changes against the original\n    for (let i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + (i % stride)];\n    }\n\n    // Add to identity for additive\n    this._setIdentity();\n\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n  }\n\n  // apply the state previously taken via 'saveOriginalState' to the binding\n  restoreOriginalState() {\n    const originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  }\n\n  _setAdditiveIdentityNumeric() {\n    const startIndex = this._addIndex * this.valueSize;\n    const endIndex = startIndex + this.valueSize;\n\n    for (let i = startIndex; i < endIndex; i++) {\n      this.buffer[i] = 0;\n    }\n  }\n\n  _setAdditiveIdentityQuaternion() {\n    this._setAdditiveIdentityNumeric();\n    this.buffer[this._addIndex * this.valueSize + 3] = 1;\n  }\n\n  _setAdditiveIdentityOther() {\n    const startIndex = this._origIndex * this.valueSize;\n    const targetIndex = this._addIndex * this.valueSize;\n\n    for (let i = 0; i < this.valueSize; i++) {\n      this.buffer[targetIndex + i] = this.buffer[startIndex + i];\n    }\n  }\n\n  // mix functions\n\n  _select(buffer, dstOffset, srcOffset, t, stride) {\n    if (t >= 0.5) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  }\n\n  _slerp(buffer, dstOffset, srcOffset, t) {\n    Quaternion.slerpFlat(\n      buffer,\n      dstOffset,\n      buffer,\n      dstOffset,\n      buffer,\n      srcOffset,\n      t,\n    );\n  }\n\n  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    const workOffset = this._workIndex * stride;\n\n    // Store result in intermediate buffer offset\n    Quaternion.multiplyQuaternionsFlat(\n      buffer,\n      workOffset,\n      buffer,\n      dstOffset,\n      buffer,\n      srcOffset,\n    );\n\n    // Slerp to the intermediate result\n    Quaternion.slerpFlat(\n      buffer,\n      dstOffset,\n      buffer,\n      dstOffset,\n      buffer,\n      workOffset,\n      t,\n    );\n  }\n\n  _lerp(buffer, dstOffset, srcOffset, t, stride) {\n    const s = 1 - t;\n\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n    }\n  }\n\n  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n\n      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n    }\n  }\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace('WC', _wordChar);\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar);\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\n\nconst _trackRe = new RegExp(\n  '' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$',\n);\n\nconst _supportedObjectNames = ['material', 'materials', 'bones'];\n\nclass Composite {\n  constructor(targetGroup, path, optionalParsedPath) {\n    const parsedPath =\n      optionalParsedPath || PropertyBinding.parseTrackName(path);\n\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n\n  getValue(array, offset) {\n    this.bind(); // bind all binding\n\n    const firstValidIndex = this._targetGroup.nCachedObjects_,\n      binding = this._bindings[firstValidIndex];\n\n    // and only call .getValue on the first\n    if (binding !== undefined) binding.getValue(array, offset);\n  }\n\n  setValue(array, offset) {\n    const bindings = this._bindings;\n\n    for (\n      let i = this._targetGroup.nCachedObjects_, n = bindings.length;\n      i !== n;\n      ++i\n    ) {\n      bindings[i].setValue(array, offset);\n    }\n  }\n\n  bind() {\n    const bindings = this._bindings;\n\n    for (\n      let i = this._targetGroup.nCachedObjects_, n = bindings.length;\n      i !== n;\n      ++i\n    ) {\n      bindings[i].bind();\n    }\n  }\n\n  unbind() {\n    const bindings = this._bindings;\n\n    for (\n      let i = this._targetGroup.nCachedObjects_, n = bindings.length;\n      i !== n;\n      ++i\n    ) {\n      bindings[i].unbind();\n    }\n  }\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n  constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n\n    this.node =\n      PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n\n    this.rootNode = rootNode;\n\n    // initial state of these methods that calls 'bind'\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n\n  static create(root, path, parsedPath) {\n    if (!(root && root.isAnimationObjectGroup)) {\n      return new PropertyBinding(root, path, parsedPath);\n    } else {\n      return new PropertyBinding.Composite(root, path, parsedPath);\n    }\n  }\n\n  /**\n   * Replaces spaces with underscores and removes unsupported characters from\n   * node names, to ensure compatibility with parseTrackName().\n   *\n   * @param {string} name Node name to be sanitized.\n   * @return {string}\n   */\n  static sanitizeNodeName(name) {\n    return name.replace(/\\s/g, '_').replace(_reservedRe, '');\n  }\n\n  static parseTrackName(trackName) {\n    const matches = _trackRe.exec(trackName);\n\n    if (!matches) {\n      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n    }\n\n    const results = {\n      // directoryName: matches[ 1 ], // (tschw) currently unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      objectIndex: matches[4],\n      propertyName: matches[5], // required\n      propertyIndex: matches[6],\n    };\n\n    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n\n    if (lastDot !== undefined && lastDot !== -1) {\n      const objectName = results.nodeName.substring(lastDot + 1);\n\n      // Object names must be checked against an allowlist. Otherwise, there\n      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n      // 'bar' could be the objectName, or part of a nodeName (which can\n      // include '.' characters).\n      if (_supportedObjectNames.indexOf(objectName) !== -1) {\n        results.nodeName = results.nodeName.substring(0, lastDot);\n        results.objectName = objectName;\n      }\n    }\n\n    if (results.propertyName === null || results.propertyName.length === 0) {\n      throw new Error(\n        'PropertyBinding: can not parse propertyName from trackName: ' +\n          trackName,\n      );\n    }\n\n    return results;\n  }\n\n  static findNode(root, nodeName) {\n    if (\n      !nodeName ||\n      nodeName === '' ||\n      nodeName === '.' ||\n      nodeName === -1 ||\n      nodeName === root.name ||\n      nodeName === root.uuid\n    ) {\n      return root;\n    }\n\n    // search into skeleton bones.\n    if (root.skeleton) {\n      const bone = root.skeleton.getBoneByName(nodeName);\n\n      if (bone !== undefined) {\n        return bone;\n      }\n    }\n\n    // search into node subtree.\n    if (root.children) {\n      const searchNodeSubtree = function (children) {\n        for (let i = 0; i < children.length; i++) {\n          const childNode = children[i];\n\n          if (childNode.name === nodeName || childNode.uuid === nodeName) {\n            return childNode;\n          }\n\n          const result = searchNodeSubtree(childNode.children);\n\n          if (result) return result;\n        }\n\n        return null;\n      };\n\n      const subTreeNode = searchNodeSubtree(root.children);\n\n      if (subTreeNode) {\n        return subTreeNode;\n      }\n    }\n\n    return null;\n  }\n\n  // these are used to \"bind\" a nonexistent property\n  _getValue_unavailable() {}\n  _setValue_unavailable() {}\n\n  // Getters\n\n  _getValue_direct(buffer, offset) {\n    buffer[offset] = this.targetObject[this.propertyName];\n  }\n\n  _getValue_array(buffer, offset) {\n    const source = this.resolvedProperty;\n\n    for (let i = 0, n = source.length; i !== n; ++i) {\n      buffer[offset++] = source[i];\n    }\n  }\n\n  _getValue_arrayElement(buffer, offset) {\n    buffer[offset] = this.resolvedProperty[this.propertyIndex];\n  }\n\n  _getValue_toArray(buffer, offset) {\n    this.resolvedProperty.toArray(buffer, offset);\n  }\n\n  // Direct\n\n  _setValue_direct(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n  }\n\n  _setValue_direct_setNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // EntireArray\n\n  _setValue_array(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n  }\n\n  _setValue_array_setNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // ArrayElement\n\n  _setValue_arrayElement(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n  }\n\n  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  // HasToFromArray\n\n  _setValue_fromArray(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n  }\n\n  _setValue_fromArray_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  _getValue_unbound(targetArray, offset) {\n    this.bind();\n    this.getValue(targetArray, offset);\n  }\n\n  _setValue_unbound(sourceArray, offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  }\n\n  // create getter / setter pair for a property in the scene graph\n  bind() {\n    let targetObject = this.node;\n    const parsedPath = this.parsedPath;\n\n    const objectName = parsedPath.objectName;\n    const propertyName = parsedPath.propertyName;\n    let propertyIndex = parsedPath.propertyIndex;\n\n    if (!targetObject) {\n      targetObject =\n        PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) ||\n        this.rootNode;\n\n      this.node = targetObject;\n    }\n\n    // set fail state so we can just 'return' on error\n    this.getValue = this._getValue_unavailable;\n    this.setValue = this._setValue_unavailable;\n\n    // ensure there is a value node\n    if (!targetObject) {\n      console.error(\n        'THREE.PropertyBinding: Trying to update node for track: ' +\n          this.path +\n          \" but it wasn't found.\",\n      );\n      return;\n    }\n\n    if (objectName) {\n      let objectIndex = parsedPath.objectIndex;\n\n      // special cases were we need to reach deeper into the hierarchy to get the face materials....\n      switch (objectName) {\n        case 'materials':\n          if (!targetObject.material) {\n            console.error(\n              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',\n              this,\n            );\n            return;\n          }\n\n          if (!targetObject.material.materials) {\n            console.error(\n              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',\n              this,\n            );\n            return;\n          }\n\n          targetObject = targetObject.material.materials;\n\n          break;\n\n        case 'bones':\n          if (!targetObject.skeleton) {\n            console.error(\n              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',\n              this,\n            );\n            return;\n          }\n\n          // potential future optimization: skip this if propertyIndex is already an integer\n          // and convert the integer string to a true integer.\n\n          targetObject = targetObject.skeleton.bones;\n\n          // support resolving morphTarget names into indices.\n          for (let i = 0; i < targetObject.length; i++) {\n            if (targetObject[i].name === objectIndex) {\n              objectIndex = i;\n              break;\n            }\n          }\n\n          break;\n\n        default:\n          if (targetObject[objectName] === undefined) {\n            console.error(\n              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',\n              this,\n            );\n            return;\n          }\n\n          targetObject = targetObject[objectName];\n      }\n\n      if (objectIndex !== undefined) {\n        if (targetObject[objectIndex] === undefined) {\n          console.error(\n            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',\n            this,\n            targetObject,\n          );\n          return;\n        }\n\n        targetObject = targetObject[objectIndex];\n      }\n    }\n\n    // resolve property\n    const nodeProperty = targetObject[propertyName];\n\n    if (nodeProperty === undefined) {\n      const nodeName = parsedPath.nodeName;\n\n      console.error(\n        'THREE.PropertyBinding: Trying to update property for track: ' +\n          nodeName +\n          '.' +\n          propertyName +\n          \" but it wasn't found.\",\n        targetObject,\n      );\n      return;\n    }\n\n    // determine versioning scheme\n    let versioning = this.Versioning.None;\n\n    this.targetObject = targetObject;\n\n    if (targetObject.needsUpdate !== undefined) {\n      // material\n\n      versioning = this.Versioning.NeedsUpdate;\n    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n      // node transform\n\n      versioning = this.Versioning.MatrixWorldNeedsUpdate;\n    }\n\n    // determine how the property gets bound\n    let bindingType = this.BindingType.Direct;\n\n    if (propertyIndex !== undefined) {\n      // access a sub element of the property array (only primitives are supported right now)\n\n      if (propertyName === 'morphTargetInfluences') {\n        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n        // support resolving morphTarget names into indices.\n        if (!targetObject.geometry) {\n          console.error(\n            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',\n            this,\n          );\n          return;\n        }\n\n        if (targetObject.geometry.isBufferGeometry) {\n          if (!targetObject.geometry.morphAttributes) {\n            console.error(\n              'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',\n              this,\n            );\n            return;\n          }\n\n          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n          }\n        } else {\n          console.error(\n            'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',\n            this,\n          );\n          return;\n        }\n      }\n\n      bindingType = this.BindingType.ArrayElement;\n\n      this.resolvedProperty = nodeProperty;\n      this.propertyIndex = propertyIndex;\n    } else if (\n      nodeProperty.fromArray !== undefined &&\n      nodeProperty.toArray !== undefined\n    ) {\n      // must use copy for Object3D.Euler/Quaternion\n\n      bindingType = this.BindingType.HasFromToArray;\n\n      this.resolvedProperty = nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      bindingType = this.BindingType.EntireArray;\n\n      this.resolvedProperty = nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    }\n\n    // select getter / setter\n    this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue =\n      this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n\n  unbind() {\n    this.node = null;\n\n    // back to the prototype version of getValue / setValue\n    // note: avoiding to mutate the shape of 'this' via 'delete'\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: 3,\n};\n\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: 1,\n  MatrixWorldNeedsUpdate: 2,\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n  PropertyBinding.prototype._getValue_direct,\n  PropertyBinding.prototype._getValue_array,\n  PropertyBinding.prototype._getValue_arrayElement,\n  PropertyBinding.prototype._getValue_toArray,\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n  [\n    // Direct\n    PropertyBinding.prototype._setValue_direct,\n    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n  ],\n  [\n    // EntireArray\n\n    PropertyBinding.prototype._setValue_array,\n    PropertyBinding.prototype._setValue_array_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n  ],\n  [\n    // ArrayElement\n    PropertyBinding.prototype._setValue_arrayElement,\n    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n  ],\n  [\n    // HasToFromArray\n    PropertyBinding.prototype._setValue_fromArray,\n    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n  ],\n];\n\nclass AnimationAction {\n  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {\n    this._mixer = mixer;\n    this._clip = clip;\n    this._localRoot = localRoot;\n    this.blendMode = blendMode;\n\n    const tracks = clip.tracks,\n      nTracks = tracks.length,\n      interpolants = new Array(nTracks);\n\n    const interpolantSettings = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding,\n    };\n\n    for (let i = 0; i !== nTracks; ++i) {\n      const interpolant = tracks[i].createInterpolant(null);\n      interpolants[i] = interpolant;\n      interpolant.settings = interpolantSettings;\n    }\n\n    this._interpolantSettings = interpolantSettings;\n\n    this._interpolants = interpolants; // bound by the mixer\n\n    // inside: PropertyMixer (managed by the mixer)\n    this._propertyBindings = new Array(nTracks);\n\n    this._cacheIndex = null; // for the memory manager\n    this._byClipCacheIndex = null; // for the memory manager\n\n    this._timeScaleInterpolant = null;\n    this._weightInterpolant = null;\n\n    this.loop = LoopRepeat;\n    this._loopCount = -1;\n\n    // global mixer time when the action is to be started\n    // it's set back to 'null' upon start of the action\n    this._startTime = null;\n\n    // scaled local time of the action\n    // gets clamped or wrapped to 0..clip.duration according to loop\n    this.time = 0;\n\n    this.timeScale = 1;\n    this._effectiveTimeScale = 1;\n\n    this.weight = 1;\n    this._effectiveWeight = 1;\n\n    this.repetitions = Infinity; // no. of repetitions when looping\n\n    this.paused = false; // true -> zero effective time scale\n    this.enabled = true; // false -> zero effective weight\n\n    this.clampWhenFinished = false; // keep feeding the last frame?\n\n    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n    this.zeroSlopeAtEnd = true; // clips for start, loop and end\n  }\n\n  // State & Scheduling\n\n  play() {\n    this._mixer._activateAction(this);\n\n    return this;\n  }\n\n  stop() {\n    this._mixer._deactivateAction(this);\n\n    return this.reset();\n  }\n\n  reset() {\n    this.paused = false;\n    this.enabled = true;\n\n    this.time = 0; // restart clip\n    this._loopCount = -1; // forget previous loops\n    this._startTime = null; // forget scheduling\n\n    return this.stopFading().stopWarping();\n  }\n\n  isRunning() {\n    return (\n      this.enabled &&\n      !this.paused &&\n      this.timeScale !== 0 &&\n      this._startTime === null &&\n      this._mixer._isActiveAction(this)\n    );\n  }\n\n  // return true when play has been called\n  isScheduled() {\n    return this._mixer._isActiveAction(this);\n  }\n\n  startAt(time) {\n    this._startTime = time;\n\n    return this;\n  }\n\n  setLoop(mode, repetitions) {\n    this.loop = mode;\n    this.repetitions = repetitions;\n\n    return this;\n  }\n\n  // Weight\n\n  // set the weight stopping any scheduled fading\n  // although .enabled = false yields an effective weight of zero, this\n  // method does *not* change .enabled, because it would be confusing\n  setEffectiveWeight(weight) {\n    this.weight = weight;\n\n    // note: same logic as when updated at runtime\n    this._effectiveWeight = this.enabled ? weight : 0;\n\n    return this.stopFading();\n  }\n\n  // return the weight considering fading and .enabled\n  getEffectiveWeight() {\n    return this._effectiveWeight;\n  }\n\n  fadeIn(duration) {\n    return this._scheduleFading(duration, 0, 1);\n  }\n\n  fadeOut(duration) {\n    return this._scheduleFading(duration, 1, 0);\n  }\n\n  crossFadeFrom(fadeOutAction, duration, warp) {\n    fadeOutAction.fadeOut(duration);\n    this.fadeIn(duration);\n\n    if (warp) {\n      const fadeInDuration = this._clip.duration,\n        fadeOutDuration = fadeOutAction._clip.duration,\n        startEndRatio = fadeOutDuration / fadeInDuration,\n        endStartRatio = fadeInDuration / fadeOutDuration;\n\n      fadeOutAction.warp(1.0, startEndRatio, duration);\n      this.warp(endStartRatio, 1.0, duration);\n    }\n\n    return this;\n  }\n\n  crossFadeTo(fadeInAction, duration, warp) {\n    return fadeInAction.crossFadeFrom(this, duration, warp);\n  }\n\n  stopFading() {\n    const weightInterpolant = this._weightInterpolant;\n\n    if (weightInterpolant !== null) {\n      this._weightInterpolant = null;\n      this._mixer._takeBackControlInterpolant(weightInterpolant);\n    }\n\n    return this;\n  }\n\n  // Time Scale Control\n\n  // set the time scale stopping any scheduled warping\n  // although .paused = true yields an effective time scale of zero, this\n  // method does *not* change .paused, because it would be confusing\n  setEffectiveTimeScale(timeScale) {\n    this.timeScale = timeScale;\n    this._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n    return this.stopWarping();\n  }\n\n  // return the time scale considering warping and .paused\n  getEffectiveTimeScale() {\n    return this._effectiveTimeScale;\n  }\n\n  setDuration(duration) {\n    this.timeScale = this._clip.duration / duration;\n\n    return this.stopWarping();\n  }\n\n  syncWith(action) {\n    this.time = action.time;\n    this.timeScale = action.timeScale;\n\n    return this.stopWarping();\n  }\n\n  halt(duration) {\n    return this.warp(this._effectiveTimeScale, 0, duration);\n  }\n\n  warp(startTimeScale, endTimeScale, duration) {\n    const mixer = this._mixer,\n      now = mixer.time,\n      timeScale = this.timeScale;\n\n    let interpolant = this._timeScaleInterpolant;\n\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._timeScaleInterpolant = interpolant;\n    }\n\n    const times = interpolant.parameterPositions,\n      values = interpolant.sampleValues;\n\n    times[0] = now;\n    times[1] = now + duration;\n\n    values[0] = startTimeScale / timeScale;\n    values[1] = endTimeScale / timeScale;\n\n    return this;\n  }\n\n  stopWarping() {\n    const timeScaleInterpolant = this._timeScaleInterpolant;\n\n    if (timeScaleInterpolant !== null) {\n      this._timeScaleInterpolant = null;\n      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n    }\n\n    return this;\n  }\n\n  // Object Accessors\n\n  getMixer() {\n    return this._mixer;\n  }\n\n  getClip() {\n    return this._clip;\n  }\n\n  getRoot() {\n    return this._localRoot || this._mixer._root;\n  }\n\n  // Interna\n\n  _update(time, deltaTime, timeDirection, accuIndex) {\n    // called by the mixer\n\n    if (!this.enabled) {\n      // call ._updateWeight() to update ._effectiveWeight\n\n      this._updateWeight(time);\n      return;\n    }\n\n    const startTime = this._startTime;\n\n    if (startTime !== null) {\n      // check for scheduled start of action\n\n      const timeRunning = (time - startTime) * timeDirection;\n      if (timeRunning < 0 || timeDirection === 0) {\n        return; // yet to come / don't decide when delta = 0\n      }\n\n      // start\n\n      this._startTime = null; // unschedule\n      deltaTime = timeDirection * timeRunning;\n    }\n\n    // apply time scale and advance time\n\n    deltaTime *= this._updateTimeScale(time);\n    const clipTime = this._updateTime(deltaTime);\n\n    // note: _updateTime may disable the action resulting in\n    // an effective weight of 0\n\n    const weight = this._updateWeight(time);\n\n    if (weight > 0) {\n      const interpolants = this._interpolants;\n      const propertyMixers = this._propertyBindings;\n\n      switch (this.blendMode) {\n        case AdditiveAnimationBlendMode:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulateAdditive(weight);\n          }\n\n          break;\n\n        case NormalAnimationBlendMode:\n        default:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulate(accuIndex, weight);\n          }\n      }\n    }\n  }\n\n  _updateWeight(time) {\n    let weight = 0;\n\n    if (this.enabled) {\n      weight = this.weight;\n      const interpolant = this._weightInterpolant;\n\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n\n        weight *= interpolantValue;\n\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopFading();\n\n          if (interpolantValue === 0) {\n            // faded out, disable\n            this.enabled = false;\n          }\n        }\n      }\n    }\n\n    this._effectiveWeight = weight;\n    return weight;\n  }\n\n  _updateTimeScale(time) {\n    let timeScale = 0;\n\n    if (!this.paused) {\n      timeScale = this.timeScale;\n\n      const interpolant = this._timeScaleInterpolant;\n\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n\n        timeScale *= interpolantValue;\n\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopWarping();\n\n          if (timeScale === 0) {\n            // motion has halted, pause\n            this.paused = true;\n          } else {\n            // warp done - apply final time scale\n            this.timeScale = timeScale;\n          }\n        }\n      }\n    }\n\n    this._effectiveTimeScale = timeScale;\n    return timeScale;\n  }\n\n  _updateTime(deltaTime) {\n    const duration = this._clip.duration;\n    const loop = this.loop;\n\n    let time = this.time + deltaTime;\n    let loopCount = this._loopCount;\n\n    const pingPong = loop === LoopPingPong;\n\n    if (deltaTime === 0) {\n      if (loopCount === -1) return time;\n\n      return pingPong && (loopCount & 1) === 1 ? duration - time : time;\n    }\n\n    if (loop === LoopOnce) {\n      if (loopCount === -1) {\n        // just started\n\n        this._loopCount = 0;\n        this._setEndings(true, true, false);\n      }\n\n      handle_stop: {\n        if (time >= duration) {\n          time = duration;\n        } else if (time < 0) {\n          time = 0;\n        } else {\n          this.time = time;\n\n          break handle_stop;\n        }\n\n        if (this.clampWhenFinished) this.paused = true;\n        else this.enabled = false;\n\n        this.time = time;\n\n        this._mixer.dispatchEvent({\n          type: 'finished',\n          action: this,\n          direction: deltaTime < 0 ? -1 : 1,\n        });\n      }\n    } else {\n      // repetitive Repeat or PingPong\n\n      if (loopCount === -1) {\n        // just started\n\n        if (deltaTime >= 0) {\n          loopCount = 0;\n\n          this._setEndings(true, this.repetitions === 0, pingPong);\n        } else {\n          // when looping in reverse direction, the initial\n          // transition through zero counts as a repetition,\n          // so leave loopCount at -1\n\n          this._setEndings(this.repetitions === 0, true, pingPong);\n        }\n      }\n\n      if (time >= duration || time < 0) {\n        // wrap around\n\n        const loopDelta = Math.floor(time / duration); // signed\n        time -= duration * loopDelta;\n\n        loopCount += Math.abs(loopDelta);\n\n        const pending = this.repetitions - loopCount;\n\n        if (pending <= 0) {\n          // have to stop (switch state, clamp time, fire event)\n\n          if (this.clampWhenFinished) this.paused = true;\n          else this.enabled = false;\n\n          time = deltaTime > 0 ? duration : 0;\n\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: 'finished',\n            action: this,\n            direction: deltaTime > 0 ? 1 : -1,\n          });\n        } else {\n          // keep running\n\n          if (pending === 1) {\n            // entering the last round\n\n            const atStart = deltaTime < 0;\n            this._setEndings(atStart, !atStart, pingPong);\n          } else {\n            this._setEndings(false, false, pingPong);\n          }\n\n          this._loopCount = loopCount;\n\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: 'loop',\n            action: this,\n            loopDelta: loopDelta,\n          });\n        }\n      } else {\n        this.time = time;\n      }\n\n      if (pingPong && (loopCount & 1) === 1) {\n        // invert time for the \"pong round\"\n\n        return duration - time;\n      }\n    }\n\n    return time;\n  }\n\n  _setEndings(atStart, atEnd, pingPong) {\n    const settings = this._interpolantSettings;\n\n    if (pingPong) {\n      settings.endingStart = ZeroSlopeEnding;\n      settings.endingEnd = ZeroSlopeEnding;\n    } else {\n      // assuming for LoopOnce atStart == atEnd == true\n\n      if (atStart) {\n        settings.endingStart = this.zeroSlopeAtStart\n          ? ZeroSlopeEnding\n          : ZeroCurvatureEnding;\n      } else {\n        settings.endingStart = WrapAroundEnding;\n      }\n\n      if (atEnd) {\n        settings.endingEnd = this.zeroSlopeAtEnd\n          ? ZeroSlopeEnding\n          : ZeroCurvatureEnding;\n      } else {\n        settings.endingEnd = WrapAroundEnding;\n      }\n    }\n  }\n\n  _scheduleFading(duration, weightNow, weightThen) {\n    const mixer = this._mixer,\n      now = mixer.time;\n    let interpolant = this._weightInterpolant;\n\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._weightInterpolant = interpolant;\n    }\n\n    const times = interpolant.parameterPositions,\n      values = interpolant.sampleValues;\n\n    times[0] = now;\n    values[0] = weightNow;\n    times[1] = now + duration;\n    values[1] = weightThen;\n\n    return this;\n  }\n}\n\nclass AnimationMixer extends EventDispatcher {\n  constructor(root) {\n    super();\n\n    this._root = root;\n    this._initMemoryManager();\n    this._accuIndex = 0;\n    this.time = 0;\n    this.timeScale = 1.0;\n  }\n\n  _bindAction(action, prototypeAction) {\n    const root = action._localRoot || this._root,\n      tracks = action._clip.tracks,\n      nTracks = tracks.length,\n      bindings = action._propertyBindings,\n      interpolants = action._interpolants,\n      rootUuid = root.uuid,\n      bindingsByRoot = this._bindingsByRootAndName;\n\n    let bindingsByName = bindingsByRoot[rootUuid];\n\n    if (bindingsByName === undefined) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n\n    for (let i = 0; i !== nTracks; ++i) {\n      const track = tracks[i],\n        trackName = track.name;\n\n      let binding = bindingsByName[trackName];\n\n      if (binding !== undefined) {\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n\n        if (binding !== undefined) {\n          // existing binding, make sure the cache knows\n\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n\n          continue;\n        }\n\n        const path =\n          prototypeAction &&\n          prototypeAction._propertyBindings[i].binding.parsedPath;\n\n        binding = new PropertyMixer(\n          PropertyBinding.create(root, trackName, path),\n          track.ValueTypeName,\n          track.getValueSize(),\n        );\n\n        ++binding.referenceCount;\n        this._addInactiveBinding(binding, rootUuid, trackName);\n\n        bindings[i] = binding;\n      }\n\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  }\n\n  _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        // this action has been forgotten by the cache, but the user\n        // appears to be still using it -> rebind\n\n        const rootUuid = (action._localRoot || this._root).uuid,\n          clipUuid = action._clip.uuid,\n          actionsForClip = this._actionsByClip[clipUuid];\n\n        this._bindAction(\n          action,\n          actionsForClip && actionsForClip.knownActions[0],\n        );\n\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n\n      const bindings = action._propertyBindings;\n\n      // increment reference counts / sort out state\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n          binding.saveOriginalState();\n        }\n      }\n\n      this._lendAction(action);\n    }\n  }\n\n  _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      const bindings = action._propertyBindings;\n\n      // decrement reference counts / sort out state\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n          this._takeBackBinding(binding);\n        }\n      }\n\n      this._takeBackAction(action);\n    }\n  }\n\n  // Memory manager\n\n  _initMemoryManager() {\n    this._actions = []; // 'nActiveActions' followed by inactive ones\n    this._nActiveActions = 0;\n\n    this._actionsByClip = {};\n    // inside:\n    // {\n    // \tknownActions: Array< AnimationAction > - used as prototypes\n    // \tactionByRoot: AnimationAction - lookup\n    // }\n\n    this._bindings = []; // 'nActiveBindings' followed by inactive ones\n    this._nActiveBindings = 0;\n\n    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n    this._controlInterpolants = []; // same game as above\n    this._nActiveControlInterpolants = 0;\n\n    const scope = this;\n\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n        get inUse() {\n          return scope._nActiveActions;\n        },\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n        get inUse() {\n          return scope._nActiveBindings;\n        },\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        },\n      },\n    };\n  }\n\n  // Memory management for AnimationAction objects\n\n  _isActiveAction(action) {\n    const index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  }\n\n  _addInactiveAction(action, clipUuid, rootUuid) {\n    const actions = this._actions,\n      actionsByClip = this._actionsByClip;\n\n    let actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip === undefined) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {},\n      };\n\n      action._byClipCacheIndex = 0;\n\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      const knownActions = actionsForClip.knownActions;\n\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n\n    action._cacheIndex = actions.length;\n    actions.push(action);\n\n    actionsForClip.actionByRoot[rootUuid] = action;\n  }\n\n  _removeInactiveAction(action) {\n    const actions = this._actions,\n      lastInactiveAction = actions[actions.length - 1],\n      cacheIndex = action._cacheIndex;\n\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n\n    action._cacheIndex = null;\n\n    const clipUuid = action._clip.uuid,\n      actionsByClip = this._actionsByClip,\n      actionsForClip = actionsByClip[clipUuid],\n      knownActionsForClip = actionsForClip.knownActions,\n      lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n      byClipCacheIndex = action._byClipCacheIndex;\n\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n\n    action._byClipCacheIndex = null;\n\n    const actionByRoot = actionsForClip.actionByRoot,\n      rootUuid = (action._localRoot || this._root).uuid;\n\n    delete actionByRoot[rootUuid];\n\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n\n    this._removeInactiveBindingsForAction(action);\n  }\n\n  _removeInactiveBindingsForAction(action) {\n    const bindings = action._propertyBindings;\n\n    for (let i = 0, n = bindings.length; i !== n; ++i) {\n      const binding = bindings[i];\n\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n\n  _lendAction(action) {\n    // [ active actions |  inactive actions  ]\n    // [  active actions >| inactive actions ]\n    //                 s        a\n    //                  <-swap->\n    //                 a        s\n\n    const actions = this._actions,\n      prevIndex = action._cacheIndex,\n      lastActiveIndex = this._nActiveActions++,\n      firstInactiveAction = actions[lastActiveIndex];\n\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  }\n\n  _takeBackAction(action) {\n    // [  active actions  | inactive actions ]\n    // [ active actions |< inactive actions  ]\n    //        a        s\n    //         <-swap->\n    //        s        a\n\n    const actions = this._actions,\n      prevIndex = action._cacheIndex,\n      firstInactiveIndex = --this._nActiveActions,\n      lastActiveAction = actions[firstInactiveIndex];\n\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  }\n\n  // Memory management for PropertyMixer objects\n\n  _addInactiveBinding(binding, rootUuid, trackName) {\n    const bindingsByRoot = this._bindingsByRootAndName,\n      bindings = this._bindings;\n\n    let bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName === undefined) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n\n    bindingByName[trackName] = binding;\n\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  }\n\n  _removeInactiveBinding(binding) {\n    const bindings = this._bindings,\n      propBinding = binding.binding,\n      rootUuid = propBinding.rootNode.uuid,\n      trackName = propBinding.path,\n      bindingsByRoot = this._bindingsByRootAndName,\n      bindingByName = bindingsByRoot[rootUuid],\n      lastInactiveBinding = bindings[bindings.length - 1],\n      cacheIndex = binding._cacheIndex;\n\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n\n    delete bindingByName[trackName];\n\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  }\n\n  _lendBinding(binding) {\n    const bindings = this._bindings,\n      prevIndex = binding._cacheIndex,\n      lastActiveIndex = this._nActiveBindings++,\n      firstInactiveBinding = bindings[lastActiveIndex];\n\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  }\n\n  _takeBackBinding(binding) {\n    const bindings = this._bindings,\n      prevIndex = binding._cacheIndex,\n      firstInactiveIndex = --this._nActiveBindings,\n      lastActiveBinding = bindings[firstInactiveIndex];\n\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  }\n\n  // Memory management of Interpolants for weight and time scale\n\n  _lendControlInterpolant() {\n    const interpolants = this._controlInterpolants,\n      lastActiveIndex = this._nActiveControlInterpolants++;\n\n    let interpolant = interpolants[lastActiveIndex];\n\n    if (interpolant === undefined) {\n      interpolant = new LinearInterpolant(\n        new Float32Array(2),\n        new Float32Array(2),\n        1,\n        this._controlInterpolantsResultBuffer,\n      );\n\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n\n    return interpolant;\n  }\n\n  _takeBackControlInterpolant(interpolant) {\n    const interpolants = this._controlInterpolants,\n      prevIndex = interpolant.__cacheIndex,\n      firstInactiveIndex = --this._nActiveControlInterpolants,\n      lastActiveInterpolant = interpolants[firstInactiveIndex];\n\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  }\n\n  // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n  clipAction(clip, optionalRoot, blendMode) {\n    const root = optionalRoot || this._root,\n      rootUuid = root.uuid;\n\n    let clipObject =\n      typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n\n    const clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n    const actionsForClip = this._actionsByClip[clipUuid];\n    let prototypeAction = null;\n\n    if (blendMode === undefined) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n\n    if (actionsForClip !== undefined) {\n      const existingAction = actionsForClip.actionByRoot[rootUuid];\n\n      if (\n        existingAction !== undefined &&\n        existingAction.blendMode === blendMode\n      ) {\n        return existingAction;\n      }\n\n      // we know the clip, so we don't have to parse all\n      // the bindings again but can just copy\n      prototypeAction = actionsForClip.knownActions[0];\n\n      // also, take the clip from the prototype action\n      if (clipObject === null) clipObject = prototypeAction._clip;\n    }\n\n    // clip must be known when specified via string\n    if (clipObject === null) return null;\n\n    // allocate all resources required to run it\n    const newAction = new AnimationAction(\n      this,\n      clipObject,\n      optionalRoot,\n      blendMode,\n    );\n\n    this._bindAction(newAction, prototypeAction);\n\n    // and make the action known to the memory manager\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n\n    return newAction;\n  }\n\n  // get an existing action\n  existingAction(clip, optionalRoot) {\n    const root = optionalRoot || this._root,\n      rootUuid = root.uuid,\n      clipObject =\n        typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n      clipUuid = clipObject ? clipObject.uuid : clip,\n      actionsForClip = this._actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n\n    return null;\n  }\n\n  // deactivates all previously scheduled actions\n  stopAllAction() {\n    const actions = this._actions,\n      nActions = this._nActiveActions;\n\n    for (let i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n\n    return this;\n  }\n\n  // advance the time and update apply the animation\n  update(deltaTime) {\n    deltaTime *= this.timeScale;\n\n    const actions = this._actions,\n      nActions = this._nActiveActions,\n      time = (this.time += deltaTime),\n      timeDirection = Math.sign(deltaTime),\n      accuIndex = (this._accuIndex ^= 1);\n\n    // run active actions\n\n    for (let i = 0; i !== nActions; ++i) {\n      const action = actions[i];\n\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    }\n\n    // update scene graph\n\n    const bindings = this._bindings,\n      nBindings = this._nActiveBindings;\n\n    for (let i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n\n    return this;\n  }\n\n  // Allows you to seek to a specific time in an animation.\n  setTime(timeInSeconds) {\n    this.time = 0; // Zero out time attribute for AnimationMixer object;\n    for (let i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n    }\n\n    return this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n  }\n\n  // return this mixer's root target object\n  getRoot() {\n    return this._root;\n  }\n\n  // free all resources specific to a particular clip\n  uncacheClip(clip) {\n    const actions = this._actions,\n      clipUuid = clip.uuid,\n      actionsByClip = this._actionsByClip,\n      actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      // note: just calling _removeInactiveAction would mess up the\n      // iteration state and also require updating the state we can\n      // just throw away\n\n      const actionsToRemove = actionsForClip.knownActions;\n\n      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        const action = actionsToRemove[i];\n\n        this._deactivateAction(action);\n\n        const cacheIndex = action._cacheIndex,\n          lastInactiveAction = actions[actions.length - 1];\n\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n\n        this._removeInactiveBindingsForAction(action);\n      }\n\n      delete actionsByClip[clipUuid];\n    }\n  }\n\n  // free all resources specific to a particular root target object\n  uncacheRoot(root) {\n    const rootUuid = root.uuid,\n      actionsByClip = this._actionsByClip;\n\n    for (const clipUuid in actionsByClip) {\n      const actionByRoot = actionsByClip[clipUuid].actionByRoot,\n        action = actionByRoot[rootUuid];\n\n      if (action !== undefined) {\n        this._deactivateAction(action);\n        this._removeInactiveAction(action);\n      }\n    }\n\n    const bindingsByRoot = this._bindingsByRootAndName,\n      bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName !== undefined) {\n      for (const trackName in bindingByName) {\n        const binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n\n  // remove a targeted clip from the cache\n  uncacheAction(clip, optionalRoot) {\n    const action = this.existingAction(clip, optionalRoot);\n\n    if (action !== null) {\n      this._deactivateAction(action);\n      this._removeInactiveAction(action);\n    }\n  }\n}\n\nAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\n\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n  constructor(array, stride, meshPerAttribute = 1) {\n    super(array, stride);\n\n    this.meshPerAttribute = meshPerAttribute;\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.meshPerAttribute = source.meshPerAttribute;\n\n    return this;\n  }\n\n  clone(data) {\n    const ib = super.clone(data);\n\n    ib.meshPerAttribute = this.meshPerAttribute;\n\n    return ib;\n  }\n\n  toJSON(data) {\n    const json = super.toJSON(data);\n\n    json.isInstancedInterleavedBuffer = true;\n    json.meshPerAttribute = this.meshPerAttribute;\n\n    return json;\n  }\n}\n\nInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\nclass Raycaster {\n  constructor(origin, direction, near = 0, far = Infinity) {\n    this.ray = new Ray(origin, direction);\n    // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.near = near;\n    this.far = far;\n    this.camera = null;\n    this.layers = new Layers();\n\n    this.params = {\n      Mesh: {},\n      Line: { threshold: 1 },\n      LOD: {},\n      Points: { threshold: 1 },\n      Sprite: {},\n    };\n  }\n\n  set(origin, direction) {\n    // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.ray.set(origin, direction);\n  }\n\n  setFromCamera(coords, camera) {\n    if (camera && camera.isPerspectiveCamera) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction\n        .set(coords.x, coords.y, 0.5)\n        .unproject(camera)\n        .sub(this.ray.origin)\n        .normalize();\n      this.camera = camera;\n    } else if (camera && camera.isOrthographicCamera) {\n      this.ray.origin\n        .set(\n          coords.x,\n          coords.y,\n          (camera.near + camera.far) / (camera.near - camera.far),\n        )\n        .unproject(camera); // set origin in plane of camera\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      this.camera = camera;\n    } else {\n      console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);\n    }\n  }\n\n  intersectObject(object, recursive = true, intersects = []) {\n    intersectObject(object, this, intersects, recursive);\n\n    intersects.sort(ascSort);\n\n    return intersects;\n  }\n\n  intersectObjects(objects, recursive = true, intersects = []) {\n    for (let i = 0, l = objects.length; i < l; i++) {\n      intersectObject(objects[i], this, intersects, recursive);\n    }\n\n    intersects.sort(ascSort);\n\n    return intersects;\n  }\n}\n\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\n\nfunction intersectObject(object, raycaster, intersects, recursive) {\n  if (object.layers.test(raycaster.layers)) {\n    object.raycast(raycaster, intersects);\n  }\n\n  if (recursive === true) {\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      intersectObject(children[i], raycaster, intersects, true);\n    }\n  }\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axis.\n */\n\nclass Spherical {\n  constructor(radius = 1, phi = 0, theta = 0) {\n    this.radius = radius;\n    this.phi = phi; // polar angle\n    this.theta = theta; // azimuthal angle\n\n    return this;\n  }\n\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n\n    return this;\n  }\n\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n\n    return this;\n  }\n\n  // restrict phi to be betwee EPS and PI-EPS\n  makeSafe() {\n    const EPS = 0.000001;\n    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n\n    return this;\n  }\n\n  setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n\n  setFromCartesianCoords(x, y, z) {\n    this.radius = Math.sqrt(x * x + y * y + z * z);\n\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(x, z);\n      this.phi = Math.acos(clamp$1(y / this.radius, -1, 1));\n    }\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\n\nclass ImmediateRenderObject extends Object3D {\n  constructor(material) {\n    super();\n\n    this.material = material;\n    this.render = function (/* renderCallback */) {};\n\n    this.hasPositions = false;\n    this.hasNormals = false;\n    this.hasColors = false;\n    this.hasUvs = false;\n\n    this.positionArray = null;\n    this.normalArray = null;\n    this.colorArray = null;\n    this.uvArray = null;\n\n    this.count = 0;\n  }\n}\n\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\nclass SkeletonHelper extends LineSegments {\n  constructor(object) {\n    const bones = getBoneList(object);\n\n    const geometry = new BufferGeometry();\n\n    const vertices = [];\n    const colors = [];\n\n    const color1 = new Color(0, 0, 1);\n    const color2 = new Color(0, 1, 0);\n\n    for (let i = 0; i < bones.length; i++) {\n      const bone = bones[i];\n\n      if (bone.parent && bone.parent.isBone) {\n        vertices.push(0, 0, 0);\n        vertices.push(0, 0, 0);\n        colors.push(color1.r, color1.g, color1.b);\n        colors.push(color2.r, color2.g, color2.b);\n      }\n    }\n\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\n    const material = new LineBasicMaterial({\n      vertexColors: true,\n      depthTest: false,\n      depthWrite: false,\n      toneMapped: false,\n      transparent: true,\n    });\n\n    super(geometry, material);\n\n    this.type = 'SkeletonHelper';\n    this.isSkeletonHelper = true;\n\n    this.root = object;\n    this.bones = bones;\n\n    this.matrix = object.matrixWorld;\n    this.matrixAutoUpdate = false;\n  }\n\n  updateMatrixWorld(force) {\n    const bones = this.bones;\n\n    const geometry = this.geometry;\n    const position = geometry.getAttribute('position');\n\n    _matrixWorldInv.copy(this.root.matrixWorld).invert();\n\n    for (let i = 0, j = 0; i < bones.length; i++) {\n      const bone = bones[i];\n\n      if (bone.parent && bone.parent.isBone) {\n        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);\n        _vector$2.setFromMatrixPosition(_boneMatrix);\n        position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);\n\n        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);\n        _vector$2.setFromMatrixPosition(_boneMatrix);\n        position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);\n\n        j += 2;\n      }\n    }\n\n    geometry.getAttribute('position').needsUpdate = true;\n\n    super.updateMatrixWorld(force);\n  }\n}\n\nfunction getBoneList(object) {\n  const boneList = [];\n\n  if (object && object.isBone) {\n    boneList.push(object);\n  }\n\n  for (let i = 0; i < object.children.length; i++) {\n    boneList.push.apply(boneList, getBoneList(object.children[i]));\n  }\n\n  return boneList;\n}\n\nclass GridHelper extends LineSegments {\n  constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n\n    const center = divisions / 2;\n    const step = size / divisions;\n    const halfSize = size / 2;\n\n    const vertices = [],\n      colors = [];\n\n    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n      vertices.push(-halfSize, 0, k, halfSize, 0, k);\n      vertices.push(k, 0, -halfSize, k, 0, halfSize);\n\n      const color = i === center ? color1 : color2;\n\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n    }\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\n    const material = new LineBasicMaterial({\n      vertexColors: true,\n      toneMapped: false,\n    });\n\n    super(geometry, material);\n\n    this.type = 'GridHelper';\n  }\n}\n\nconst _floatView = new Float32Array(1);\nconst _int32View = new Int32Array(_floatView.buffer);\n\nclass DataUtils {\n  // Converts float32 to float16 (stored as uint16 value).\n\n  static toHalfFloat(val) {\n    if (val > 65504) {\n      console.warn('THREE.DataUtils.toHalfFloat(): value exceeds 65504.');\n\n      val = 65504; // maximum representable value in float16\n    }\n\n    // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n    /* This method is faster than the OpenEXR implementation (very often\n     * used, eg. in Ogre), with the additional benefit of rounding, inspired\n     * by James Tursa?s half-precision code. */\n\n    _floatView[0] = val;\n    const x = _int32View[0];\n\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\n\n    /* If zero, or denormal, or exponent underflows too much for a denormal\n     * half, return signed zero. */\n    if (e < 103) return bits;\n\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n    if (e > 142) {\n      bits |= 0x7c00;\n      /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n       * not Inf, so make sure we set one mantissa bit too. */\n      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n      return bits;\n    }\n\n    /* If exponent underflows but not too much, return a denormal */\n    if (e < 113) {\n      m |= 0x0800;\n      /* Extra rounding may overflow and set mantissa to 0 and exponent\n       * to 1, which is OK. */\n      bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n      return bits;\n    }\n\n    bits |= ((e - 112) << 10) | (m >> 1);\n    /* Extra rounding. An overflow will set mantissa to 0 and increment\n     * the exponent, which is OK. */\n    bits += m & 1;\n    return bits;\n  }\n}\n\n//\n\nCurve.create = function (construct, getPoint) {\n  console.log('THREE.Curve.create() has been deprecated');\n\n  construct.prototype = Object.create(Curve.prototype);\n  construct.prototype.constructor = construct;\n  construct.prototype.getPoint = getPoint;\n\n  return construct;\n};\n\n//\n\nPath.prototype.fromPoints = function (points) {\n  console.warn(\n    'THREE.Path: .fromPoints() has been renamed to .setFromPoints().',\n  );\n  return this.setFromPoints(points);\n};\n\nGridHelper.prototype.setColors = function () {\n  console.error(\n    'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.',\n  );\n};\n\nSkeletonHelper.prototype.update = function () {\n  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');\n};\n\n//\n\nLoader.prototype.extractUrlBase = function (url) {\n  console.warn(\n    'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.',\n  );\n  return LoaderUtils.extractUrlBase(url);\n};\n\nLoader.Handlers = {\n  add: function (/* regex, loader */) {\n    console.error(\n      'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.',\n    );\n  },\n\n  get: function (/* file */) {\n    console.error(\n      'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.',\n    );\n  },\n};\n\n//\n\nBox3.prototype.center = function (optionalTarget) {\n  console.warn('THREE.Box3: .center() has been renamed to .getCenter().');\n  return this.getCenter(optionalTarget);\n};\n\nBox3.prototype.empty = function () {\n  console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');\n  return this.isEmpty();\n};\n\nBox3.prototype.isIntersectionBox = function (box) {\n  console.warn(\n    'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().',\n  );\n  return this.intersectsBox(box);\n};\n\nBox3.prototype.isIntersectionSphere = function (sphere) {\n  console.warn(\n    'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().',\n  );\n  return this.intersectsSphere(sphere);\n};\n\nBox3.prototype.size = function (optionalTarget) {\n  console.warn('THREE.Box3: .size() has been renamed to .getSize().');\n  return this.getSize(optionalTarget);\n};\n\n//\n\nSphere.prototype.empty = function () {\n  console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');\n  return this.isEmpty();\n};\n\n//\n\nFrustum.prototype.setFromMatrix = function (m) {\n  console.warn(\n    'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().',\n  );\n  return this.setFromProjectionMatrix(m);\n};\n\n//\n\nMatrix3.prototype.flattenToArrayOffset = function (array, offset) {\n  console.warn(\n    'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',\n  );\n  return this.toArray(array, offset);\n};\n\nMatrix3.prototype.multiplyVector3 = function (vector) {\n  console.warn(\n    'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.',\n  );\n  return vector.applyMatrix3(this);\n};\n\nMatrix3.prototype.multiplyVector3Array = function (/* a */) {\n  console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');\n};\n\nMatrix3.prototype.applyToBufferAttribute = function (attribute) {\n  console.warn(\n    'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.',\n  );\n  return attribute.applyMatrix3(this);\n};\n\nMatrix3.prototype.applyToVector3Array = function (/* array, offset, length */) {\n  console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');\n};\n\nMatrix3.prototype.getInverse = function (matrix) {\n  console.warn(\n    'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.',\n  );\n  return this.copy(matrix).invert();\n};\n\n//\n\nMatrix4.prototype.extractPosition = function (m) {\n  console.warn(\n    'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().',\n  );\n  return this.copyPosition(m);\n};\n\nMatrix4.prototype.flattenToArrayOffset = function (array, offset) {\n  console.warn(\n    'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',\n  );\n  return this.toArray(array, offset);\n};\n\nMatrix4.prototype.getPosition = function () {\n  console.warn(\n    'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.',\n  );\n  return new Vector3().setFromMatrixColumn(this, 3);\n};\n\nMatrix4.prototype.setRotationFromQuaternion = function (q) {\n  console.warn(\n    'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().',\n  );\n  return this.makeRotationFromQuaternion(q);\n};\n\nMatrix4.prototype.multiplyToArray = function () {\n  console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');\n};\n\nMatrix4.prototype.multiplyVector3 = function (vector) {\n  console.warn(\n    'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.',\n  );\n  return vector.applyMatrix4(this);\n};\n\nMatrix4.prototype.multiplyVector4 = function (vector) {\n  console.warn(\n    'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.',\n  );\n  return vector.applyMatrix4(this);\n};\n\nMatrix4.prototype.multiplyVector3Array = function (/* a */) {\n  console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');\n};\n\nMatrix4.prototype.rotateAxis = function (v) {\n  console.warn(\n    'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.',\n  );\n  v.transformDirection(this);\n};\n\nMatrix4.prototype.crossVector = function (vector) {\n  console.warn(\n    'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.',\n  );\n  return vector.applyMatrix4(this);\n};\n\nMatrix4.prototype.translate = function () {\n  console.error('THREE.Matrix4: .translate() has been removed.');\n};\n\nMatrix4.prototype.rotateX = function () {\n  console.error('THREE.Matrix4: .rotateX() has been removed.');\n};\n\nMatrix4.prototype.rotateY = function () {\n  console.error('THREE.Matrix4: .rotateY() has been removed.');\n};\n\nMatrix4.prototype.rotateZ = function () {\n  console.error('THREE.Matrix4: .rotateZ() has been removed.');\n};\n\nMatrix4.prototype.rotateByAxis = function () {\n  console.error('THREE.Matrix4: .rotateByAxis() has been removed.');\n};\n\nMatrix4.prototype.applyToBufferAttribute = function (attribute) {\n  console.warn(\n    'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.',\n  );\n  return attribute.applyMatrix4(this);\n};\n\nMatrix4.prototype.applyToVector3Array = function (/* array, offset, length */) {\n  console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');\n};\n\nMatrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {\n  console.warn(\n    'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.',\n  );\n  return this.makePerspective(left, right, top, bottom, near, far);\n};\n\nMatrix4.prototype.getInverse = function (matrix) {\n  console.warn(\n    'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.',\n  );\n  return this.copy(matrix).invert();\n};\n\n//\n\nPlane.prototype.isIntersectionLine = function (line) {\n  console.warn(\n    'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().',\n  );\n  return this.intersectsLine(line);\n};\n\n//\n\nQuaternion.prototype.multiplyVector3 = function (vector) {\n  console.warn(\n    'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.',\n  );\n  return vector.applyQuaternion(this);\n};\n\nQuaternion.prototype.inverse = function () {\n  console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');\n  return this.invert();\n};\n\n//\n\nRay.prototype.isIntersectionBox = function (box) {\n  console.warn(\n    'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().',\n  );\n  return this.intersectsBox(box);\n};\n\nRay.prototype.isIntersectionPlane = function (plane) {\n  console.warn(\n    'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().',\n  );\n  return this.intersectsPlane(plane);\n};\n\nRay.prototype.isIntersectionSphere = function (sphere) {\n  console.warn(\n    'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().',\n  );\n  return this.intersectsSphere(sphere);\n};\n\n//\n\nTriangle.prototype.area = function () {\n  console.warn('THREE.Triangle: .area() has been renamed to .getArea().');\n  return this.getArea();\n};\n\nTriangle.prototype.barycoordFromPoint = function (point, target) {\n  console.warn(\n    'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',\n  );\n  return this.getBarycoord(point, target);\n};\n\nTriangle.prototype.midpoint = function (target) {\n  console.warn(\n    'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().',\n  );\n  return this.getMidpoint(target);\n};\n\nTriangle.prototypenormal = function (target) {\n  console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n  return this.getNormal(target);\n};\n\nTriangle.prototype.plane = function (target) {\n  console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');\n  return this.getPlane(target);\n};\n\nTriangle.barycoordFromPoint = function (point, a, b, c, target) {\n  console.warn(\n    'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',\n  );\n  return Triangle.getBarycoord(point, a, b, c, target);\n};\n\nTriangle.normal = function (a, b, c, target) {\n  console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n  return Triangle.getNormal(a, b, c, target);\n};\n\n//\n\nShape.prototype.extractAllPoints = function (divisions) {\n  console.warn(\n    'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.',\n  );\n  return this.extractPoints(divisions);\n};\n\nShape.prototype.extrude = function (options) {\n  console.warn(\n    'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.',\n  );\n  return new ExtrudeGeometry(this, options);\n};\n\nShape.prototype.makeGeometry = function (options) {\n  console.warn(\n    'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.',\n  );\n  return new ShapeGeometry(this, options);\n};\n\n//\n\nVector2.prototype.fromAttribute = function (attribute, index, offset) {\n  console.warn(\n    'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().',\n  );\n  return this.fromBufferAttribute(attribute, index, offset);\n};\n\nVector2.prototype.distanceToManhattan = function (v) {\n  console.warn(\n    'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',\n  );\n  return this.manhattanDistanceTo(v);\n};\n\nVector2.prototype.lengthManhattan = function () {\n  console.warn(\n    'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().',\n  );\n  return this.manhattanLength();\n};\n\n//\n\nVector3.prototype.setEulerFromRotationMatrix = function () {\n  console.error(\n    'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.',\n  );\n};\n\nVector3.prototype.setEulerFromQuaternion = function () {\n  console.error(\n    'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.',\n  );\n};\n\nVector3.prototype.getPositionFromMatrix = function (m) {\n  console.warn(\n    'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().',\n  );\n  return this.setFromMatrixPosition(m);\n};\n\nVector3.prototype.getScaleFromMatrix = function (m) {\n  console.warn(\n    'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().',\n  );\n  return this.setFromMatrixScale(m);\n};\n\nVector3.prototype.getColumnFromMatrix = function (index, matrix) {\n  console.warn(\n    'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().',\n  );\n  return this.setFromMatrixColumn(matrix, index);\n};\n\nVector3.prototype.applyProjection = function (m) {\n  console.warn(\n    'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.',\n  );\n  return this.applyMatrix4(m);\n};\n\nVector3.prototype.fromAttribute = function (attribute, index, offset) {\n  console.warn(\n    'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().',\n  );\n  return this.fromBufferAttribute(attribute, index, offset);\n};\n\nVector3.prototype.distanceToManhattan = function (v) {\n  console.warn(\n    'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',\n  );\n  return this.manhattanDistanceTo(v);\n};\n\nVector3.prototype.lengthManhattan = function () {\n  console.warn(\n    'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().',\n  );\n  return this.manhattanLength();\n};\n\n//\n\nVector4.prototype.fromAttribute = function (attribute, index, offset) {\n  console.warn(\n    'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().',\n  );\n  return this.fromBufferAttribute(attribute, index, offset);\n};\n\nVector4.prototype.lengthManhattan = function () {\n  console.warn(\n    'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().',\n  );\n  return this.manhattanLength();\n};\n\n//\n\nObject3D.prototype.getChildByName = function (name) {\n  console.warn(\n    'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().',\n  );\n  return this.getObjectByName(name);\n};\n\nObject3D.prototype.renderDepth = function () {\n  console.warn(\n    'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.',\n  );\n};\n\nObject3D.prototype.translate = function (distance, axis) {\n  console.warn(\n    'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.',\n  );\n  return this.translateOnAxis(axis, distance);\n};\n\nObject3D.prototype.getWorldRotation = function () {\n  console.error(\n    'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.',\n  );\n};\n\nObject3D.prototype.applyMatrix = function (matrix) {\n  console.warn(\n    'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().',\n  );\n  return this.applyMatrix4(matrix);\n};\n\nObject.defineProperties(Object3D.prototype, {\n  eulerOrder: {\n    get: function () {\n      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n      return this.rotation.order;\n    },\n    set: function (value) {\n      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n      this.rotation.order = value;\n    },\n  },\n  useQuaternion: {\n    get: function () {\n      console.warn(\n        'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',\n      );\n    },\n    set: function () {\n      console.warn(\n        'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',\n      );\n    },\n  },\n});\n\nMesh.prototype.setDrawMode = function () {\n  console.error(\n    'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',\n  );\n};\n\nObject.defineProperties(Mesh.prototype, {\n  drawMode: {\n    get: function () {\n      console.error(\n        'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.',\n      );\n      return TrianglesDrawMode;\n    },\n    set: function () {\n      console.error(\n        'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',\n      );\n    },\n  },\n});\n\nSkinnedMesh.prototype.initBones = function () {\n  console.error('THREE.SkinnedMesh: initBones() has been removed.');\n};\n\n//\n\nPerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {\n  console.warn(\n    'THREE.PerspectiveCamera.setLens is deprecated. ' +\n      'Use .setFocalLength and .filmGauge for a photographic setup.',\n  );\n\n  if (filmGauge !== undefined) this.filmGauge = filmGauge;\n  this.setFocalLength(focalLength);\n};\n\n//\n\nObject.defineProperties(Light.prototype, {\n  onlyShadow: {\n    set: function () {\n      console.warn('THREE.Light: .onlyShadow has been removed.');\n    },\n  },\n  shadowCameraFov: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');\n      this.shadow.camera.fov = value;\n    },\n  },\n  shadowCameraLeft: {\n    set: function (value) {\n      console.warn(\n        'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.',\n      );\n      this.shadow.camera.left = value;\n    },\n  },\n  shadowCameraRight: {\n    set: function (value) {\n      console.warn(\n        'THREE.Light: .shadowCameraRight is now .shadow.camera.right.',\n      );\n      this.shadow.camera.right = value;\n    },\n  },\n  shadowCameraTop: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');\n      this.shadow.camera.top = value;\n    },\n  },\n  shadowCameraBottom: {\n    set: function (value) {\n      console.warn(\n        'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.',\n      );\n      this.shadow.camera.bottom = value;\n    },\n  },\n  shadowCameraNear: {\n    set: function (value) {\n      console.warn(\n        'THREE.Light: .shadowCameraNear is now .shadow.camera.near.',\n      );\n      this.shadow.camera.near = value;\n    },\n  },\n  shadowCameraFar: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');\n      this.shadow.camera.far = value;\n    },\n  },\n  shadowCameraVisible: {\n    set: function () {\n      console.warn(\n        'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.',\n      );\n    },\n  },\n  shadowBias: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');\n      this.shadow.bias = value;\n    },\n  },\n  shadowDarkness: {\n    set: function () {\n      console.warn('THREE.Light: .shadowDarkness has been removed.');\n    },\n  },\n  shadowMapWidth: {\n    set: function (value) {\n      console.warn(\n        'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.',\n      );\n      this.shadow.mapSize.width = value;\n    },\n  },\n  shadowMapHeight: {\n    set: function (value) {\n      console.warn(\n        'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.',\n      );\n      this.shadow.mapSize.height = value;\n    },\n  },\n});\n\n//\n\nObject.defineProperties(BufferAttribute.prototype, {\n  length: {\n    get: function () {\n      console.warn(\n        'THREE.BufferAttribute: .length has been deprecated. Use .count instead.',\n      );\n      return this.array.length;\n    },\n  },\n  dynamic: {\n    get: function () {\n      console.warn(\n        'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',\n      );\n      return this.usage === DynamicDrawUsage;\n    },\n    set: function (/* value */) {\n      console.warn(\n        'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',\n      );\n      this.setUsage(DynamicDrawUsage);\n    },\n  },\n});\n\nBufferAttribute.prototype.setDynamic = function (value) {\n  console.warn(\n    'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.',\n  );\n  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n  return this;\n};\n\n(BufferAttribute.prototype.copyIndicesArray = function (/* indices */) {\n  console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');\n}),\n  (BufferAttribute.prototype.setArray = function (/* array */) {\n    console.error(\n      'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',\n    );\n  });\n\n//\n\nBufferGeometry.prototype.addIndex = function (index) {\n  console.warn(\n    'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().',\n  );\n  this.setIndex(index);\n};\n\nBufferGeometry.prototype.addAttribute = function (name, attribute) {\n  console.warn(\n    'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().',\n  );\n\n  if (\n    !(attribute && attribute.isBufferAttribute) &&\n    !(attribute && attribute.isInterleavedBufferAttribute)\n  ) {\n    console.warn(\n      'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).',\n    );\n\n    return this.setAttribute(\n      name,\n      new BufferAttribute(arguments[1], arguments[2]),\n    );\n  }\n\n  if (name === 'index') {\n    console.warn(\n      'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.',\n    );\n    this.setIndex(attribute);\n\n    return this;\n  }\n\n  return this.setAttribute(name, attribute);\n};\n\nBufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {\n  if (indexOffset !== undefined) {\n    console.warn(\n      'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.',\n    );\n  }\n\n  console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');\n  this.addGroup(start, count);\n};\n\nBufferGeometry.prototype.clearDrawCalls = function () {\n  console.warn(\n    'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().',\n  );\n  this.clearGroups();\n};\n\nBufferGeometry.prototype.computeOffsets = function () {\n  console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');\n};\n\nBufferGeometry.prototype.removeAttribute = function (name) {\n  console.warn(\n    'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().',\n  );\n\n  return this.deleteAttribute(name);\n};\n\nBufferGeometry.prototype.applyMatrix = function (matrix) {\n  console.warn(\n    'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().',\n  );\n  return this.applyMatrix4(matrix);\n};\n\nObject.defineProperties(BufferGeometry.prototype, {\n  drawcalls: {\n    get: function () {\n      console.error(\n        'THREE.BufferGeometry: .drawcalls has been renamed to .groups.',\n      );\n      return this.groups;\n    },\n  },\n  offsets: {\n    get: function () {\n      console.warn(\n        'THREE.BufferGeometry: .offsets has been renamed to .groups.',\n      );\n      return this.groups;\n    },\n  },\n});\n\nInterleavedBuffer.prototype.setDynamic = function (value) {\n  console.warn(\n    'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.',\n  );\n  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n  return this;\n};\n\nInterleavedBuffer.prototype.setArray = function (/* array */) {\n  console.error(\n    'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',\n  );\n};\n\n//\n\nExtrudeGeometry.prototype.getArrays = function () {\n  console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');\n};\n\nExtrudeGeometry.prototype.addShapeList = function () {\n  console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');\n};\n\nExtrudeGeometry.prototype.addShape = function () {\n  console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');\n};\n\n//\n\nScene.prototype.dispose = function () {\n  console.error('THREE.Scene: .dispose() has been removed.');\n};\n\n//\n\nObject.defineProperties(Material$1.prototype, {\n  wrapAround: {\n    get: function () {\n      console.warn('THREE.Material: .wrapAround has been removed.');\n    },\n    set: function () {\n      console.warn('THREE.Material: .wrapAround has been removed.');\n    },\n  },\n\n  overdraw: {\n    get: function () {\n      console.warn('THREE.Material: .overdraw has been removed.');\n    },\n    set: function () {\n      console.warn('THREE.Material: .overdraw has been removed.');\n    },\n  },\n\n  wrapRGB: {\n    get: function () {\n      console.warn('THREE.Material: .wrapRGB has been removed.');\n      return new Color();\n    },\n  },\n\n  shading: {\n    get: function () {\n      console.error(\n        'THREE.' +\n          this.type +\n          ': .shading has been removed. Use the boolean .flatShading instead.',\n      );\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.' +\n          this.type +\n          ': .shading has been removed. Use the boolean .flatShading instead.',\n      );\n      this.flatShading = value === FlatShading;\n    },\n  },\n\n  stencilMask: {\n    get: function () {\n      console.warn(\n        'THREE.' +\n          this.type +\n          ': .stencilMask has been removed. Use .stencilFuncMask instead.',\n      );\n      return this.stencilFuncMask;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.' +\n          this.type +\n          ': .stencilMask has been removed. Use .stencilFuncMask instead.',\n      );\n      this.stencilFuncMask = value;\n    },\n  },\n\n  vertexTangents: {\n    get: function () {\n      console.warn(\n        'THREE.' + this.type + ': .vertexTangents has been removed.',\n      );\n    },\n    set: function () {\n      console.warn(\n        'THREE.' + this.type + ': .vertexTangents has been removed.',\n      );\n    },\n  },\n});\n\nObject.defineProperties(ShaderMaterial.prototype, {\n  derivatives: {\n    get: function () {\n      console.warn(\n        'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',\n      );\n      return this.extensions.derivatives;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',\n      );\n      this.extensions.derivatives = value;\n    },\n  },\n});\n\n//\n\nWebGLRenderer.prototype.clearTarget = function (\n  renderTarget,\n  color,\n  depth,\n  stencil,\n) {\n  console.warn(\n    'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.',\n  );\n  this.setRenderTarget(renderTarget);\n  this.clear(color, depth, stencil);\n};\n\nWebGLRenderer.prototype.animate = function (callback) {\n  console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');\n  this.setAnimationLoop(callback);\n};\n\nWebGLRenderer.prototype.getCurrentRenderTarget = function () {\n  console.warn(\n    'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().',\n  );\n  return this.getRenderTarget();\n};\n\nWebGLRenderer.prototype.getMaxAnisotropy = function () {\n  console.warn(\n    'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().',\n  );\n  return this.capabilities.getMaxAnisotropy();\n};\n\nWebGLRenderer.prototype.getPrecision = function () {\n  console.warn(\n    'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.',\n  );\n  return this.capabilities.precision;\n};\n\nWebGLRenderer.prototype.resetGLState = function () {\n  console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');\n  return this.state.reset();\n};\n\nWebGLRenderer.prototype.supportsFloatTextures = function () {\n  console.warn(\n    \"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).\",\n  );\n  return this.extensions.get('OES_texture_float');\n};\n\nWebGLRenderer.prototype.supportsHalfFloatTextures = function () {\n  console.warn(\n    \"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).\",\n  );\n  return this.extensions.get('OES_texture_half_float');\n};\n\nWebGLRenderer.prototype.supportsStandardDerivatives = function () {\n  console.warn(\n    \"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).\",\n  );\n  return this.extensions.get('OES_standard_derivatives');\n};\n\nWebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {\n  console.warn(\n    \"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).\",\n  );\n  return this.extensions.get('WEBGL_compressed_texture_s3tc');\n};\n\nWebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {\n  console.warn(\n    \"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).\",\n  );\n  return this.extensions.get('WEBGL_compressed_texture_pvrtc');\n};\n\nWebGLRenderer.prototype.supportsBlendMinMax = function () {\n  console.warn(\n    \"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).\",\n  );\n  return this.extensions.get('EXT_blend_minmax');\n};\n\nWebGLRenderer.prototype.supportsVertexTextures = function () {\n  console.warn(\n    'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.',\n  );\n  return this.capabilities.vertexTextures;\n};\n\nWebGLRenderer.prototype.supportsInstancedArrays = function () {\n  console.warn(\n    \"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).\",\n  );\n  return this.extensions.get('ANGLE_instanced_arrays');\n};\n\nWebGLRenderer.prototype.enableScissorTest = function (boolean) {\n  console.warn(\n    'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().',\n  );\n  this.setScissorTest(boolean);\n};\n\nWebGLRenderer.prototype.initMaterial = function () {\n  console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');\n};\n\nWebGLRenderer.prototype.addPrePlugin = function () {\n  console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');\n};\n\nWebGLRenderer.prototype.addPostPlugin = function () {\n  console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');\n};\n\nWebGLRenderer.prototype.updateShadowMap = function () {\n  console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');\n};\n\nWebGLRenderer.prototype.setFaceCulling = function () {\n  console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');\n};\n\nWebGLRenderer.prototype.allocTextureUnit = function () {\n  console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');\n};\n\nWebGLRenderer.prototype.setTexture = function () {\n  console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');\n};\n\nWebGLRenderer.prototype.setTexture2D = function () {\n  console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');\n};\n\nWebGLRenderer.prototype.setTextureCube = function () {\n  console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');\n};\n\nWebGLRenderer.prototype.getActiveMipMapLevel = function () {\n  console.warn(\n    'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().',\n  );\n  return this.getActiveMipmapLevel();\n};\n\nObject.defineProperties(WebGLRenderer.prototype, {\n  shadowMapEnabled: {\n    get: function () {\n      return this.shadowMap.enabled;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.',\n      );\n      this.shadowMap.enabled = value;\n    },\n  },\n  shadowMapType: {\n    get: function () {\n      return this.shadowMap.type;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.',\n      );\n      this.shadowMap.type = value;\n    },\n  },\n  shadowMapCullFace: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',\n      );\n      return undefined;\n    },\n    set: function (/* value */) {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',\n      );\n    },\n  },\n  context: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.',\n      );\n      return this.getContext();\n    },\n  },\n  vr: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');\n      return this.xr;\n    },\n  },\n  gammaInput: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',\n      );\n      return false;\n    },\n    set: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',\n      );\n    },\n  },\n  gammaOutput: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',\n      );\n      return false;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',\n      );\n      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;\n    },\n  },\n  toneMappingWhitePoint: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.',\n      );\n      return 1.0;\n    },\n    set: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.',\n      );\n    },\n  },\n});\n\nObject.defineProperties(WebGLShadowMap.prototype, {\n  cullFace: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',\n      );\n      return undefined;\n    },\n    set: function (/* cullFace */) {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',\n      );\n    },\n  },\n  renderReverseSided: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',\n      );\n      return undefined;\n    },\n    set: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',\n      );\n    },\n  },\n  renderSingleSided: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',\n      );\n      return undefined;\n    },\n    set: function () {\n      console.warn(\n        'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',\n      );\n    },\n  },\n});\n\n//\n\nObject.defineProperties(WebGLRenderTarget.prototype, {\n  wrapS: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n      return this.texture.wrapS;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n      this.texture.wrapS = value;\n    },\n  },\n  wrapT: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n      return this.texture.wrapT;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n      this.texture.wrapT = value;\n    },\n  },\n  magFilter: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',\n      );\n      return this.texture.magFilter;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',\n      );\n      this.texture.magFilter = value;\n    },\n  },\n  minFilter: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',\n      );\n      return this.texture.minFilter;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',\n      );\n      this.texture.minFilter = value;\n    },\n  },\n  anisotropy: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',\n      );\n      return this.texture.anisotropy;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',\n      );\n      this.texture.anisotropy = value;\n    },\n  },\n  offset: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n      return this.texture.offset;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n      this.texture.offset = value;\n    },\n  },\n  repeat: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n      return this.texture.repeat;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n      this.texture.repeat = value;\n    },\n  },\n  format: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n      return this.texture.format;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n      this.texture.format = value;\n    },\n  },\n  type: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n      return this.texture.type;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n      this.texture.type = value;\n    },\n  },\n  generateMipmaps: {\n    get: function () {\n      console.warn(\n        'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',\n      );\n      return this.texture.generateMipmaps;\n    },\n    set: function (value) {\n      console.warn(\n        'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',\n      );\n      this.texture.generateMipmaps = value;\n    },\n  },\n});\n\n//\n\nAudio.prototype.load = function (file) {\n  console.warn(\n    'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.',\n  );\n  const scope = this;\n  const audioLoader = new AudioLoader();\n  audioLoader.load(file, function (buffer) {\n    scope.setBuffer(buffer);\n  });\n  return this;\n};\n\n//\n\nCubeCamera.prototype.updateCubeMap = function (renderer, scene) {\n  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');\n  return this.update(renderer, scene);\n};\n\nCubeCamera.prototype.clear = function (renderer, color, depth, stencil) {\n  console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');\n  return this.renderTarget.clear(renderer, color, depth, stencil);\n};\n\nImageUtils.crossOrigin = undefined;\n\nImageUtils.loadTexture = function (url, mapping, onLoad, onError) {\n  console.warn(\n    'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.',\n  );\n\n  const loader = new TextureLoader();\n  loader.setCrossOrigin(this.crossOrigin);\n\n  const texture = loader.load(url, onLoad, undefined, onError);\n\n  if (mapping) texture.mapping = mapping;\n\n  return texture;\n};\n\nImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {\n  console.warn(\n    'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.',\n  );\n\n  const loader = new CubeTextureLoader();\n  loader.setCrossOrigin(this.crossOrigin);\n\n  const texture = loader.load(urls, onLoad, undefined, onError);\n\n  if (mapping) texture.mapping = mapping;\n\n  return texture;\n};\n\nImageUtils.loadCompressedTexture = function () {\n  console.error(\n    'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.',\n  );\n};\n\nImageUtils.loadCompressedTextureCube = function () {\n  console.error(\n    'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.',\n  );\n};\n\nif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n  /* eslint-disable no-undef */\n  __THREE_DEVTOOLS__.dispatchEvent(\n    new CustomEvent('register', {\n      detail: {\n        revision: REVISION,\n      },\n    }),\n  );\n  /* eslint-enable no-undef */\n}\n\nif (typeof window !== 'undefined') {\n  if (window.__THREE__) {\n    console.warn('WARNING: Multiple instances of Three.js being imported.');\n  } else {\n    window.__THREE__ = REVISION;\n  }\n}\n\nconst _taskCache$1 = new WeakMap();\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n\n    this.decoderPath = '';\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    };\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    };\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path;\n\n    return this;\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        };\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError,\n    );\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    };\n\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig);\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache$1.has(buffer)) {\n      const cachedTask = _taskCache$1.get(buffer);\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        );\n      }\n    }\n\n    //\n\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker;\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject };\n\n          worker.postMessage(\n            { type: 'decode', id: taskID, taskConfig, buffer },\n            [buffer],\n          );\n\n          // this.debug();\n        });\n      })\n      .then((message) => this._createGeometry(message.geometry));\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID);\n\n          // this.debug();\n        }\n      });\n\n    // Cache the task result.\n    _taskCache$1.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    });\n\n    return geometryPending;\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  }\n\n  preload() {\n    this._initDecoder();\n\n    return this;\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n\n    const useJS =\n      typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    const librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(\n        this._loadLibrary('draco_decoder.wasm', 'arraybuffer'),\n      );\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      const fn = DRACOWorker.toString();\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n');\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n\n    return this.decoderPending;\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n              break;\n\n            default:\n              console.error(\n                'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"',\n              );\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    );\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n\n    return this;\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            const geometry = decodeGeometry(\n              draco,\n              decoder,\n              decoderBuffer,\n              taskConfig,\n            );\n\n            const buffers = geometry.attributes.map(\n              (attr) => attr.array.buffer,\n            );\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n\n            self.postMessage(\n              { type: 'decode', id: message.id, geometry },\n              buffers,\n            );\n          } catch (error) {\n            console.error(error);\n\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message,\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n\n    let dracoGeometry;\n    let decodingStatus;\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(\n        decoderBuffer,\n        dracoGeometry,\n      );\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\n        'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg(),\n      );\n    }\n\n    const geometry = { index: null, attributes: [] };\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n\n      let attribute;\n      let attributeID;\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(\n          dracoGeometry,\n          draco[attributeIDs[attributeName]],\n        );\n\n        if (attributeID === -1) continue;\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(\n        decodeAttribute(\n          draco,\n          decoder,\n          dracoGeometry,\n          attributeName,\n          attributeType,\n          attribute,\n        ),\n      );\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(\n      draco.HEAPF32.buffer,\n      ptr,\n      numIndices,\n    ).slice();\n    draco._free(ptr);\n\n    return { array: index, itemSize: 1 };\n  }\n\n  function decodeAttribute(\n    draco,\n    decoder,\n    dracoGeometry,\n    attributeName,\n    attributeType,\n    attribute,\n  ) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(\n      dracoGeometry,\n      attribute,\n      dataType,\n      byteLength,\n      ptr,\n    );\n    const array = new attributeType(\n      draco.HEAPF32.buffer,\n      ptr,\n      numValues,\n    ).slice();\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n\n    this.pluginCallbacks = [];\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension$1(parser);\n    });\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension$1(parser);\n    });\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser);\n    });\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n\n    let resourcePath;\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== '') {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url);\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n\n    const loader = new FileLoader(this.manager);\n\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf);\n\n              scope.manager.itemEnd(url);\n            },\n            _onError,\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError,\n    );\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n\n  setDDSLoader() {\n    throw new Error(\n      'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".',\n    );\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  parse(data, path, onLoad, onError) {\n    let content;\n    const extensions = {};\n    const plugins = {};\n\n    if (typeof data === 'string') {\n      content = data;\n    } else {\n      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(\n            data,\n          );\n        } catch (error) {\n          if (onError) onError(error);\n          return;\n        }\n\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n      } else {\n        content = LoaderUtils.decodeText(new Uint8Array(data));\n      }\n    }\n\n    const json = JSON.parse(content);\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError)\n        onError(\n          new Error(\n            'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.',\n          ),\n        );\n      return;\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    });\n\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      plugins[plugin.name] = plugin;\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true;\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension$1();\n            break;\n\n          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n            extensions[extensionName] =\n              new GLTFMaterialsPbrSpecularGlossinessExtension();\n            break;\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(\n              json,\n              this.dracoLoader,\n            );\n            break;\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n\n          default:\n            if (\n              extensionsRequired.indexOf(extensionName) >= 0 &&\n              plugins[extensionName] === undefined\n            ) {\n              console.warn(\n                'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".',\n              );\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {};\n\n  return {\n    get: function (key) {\n      return objects[key];\n    },\n\n    add: function (key, object) {\n      objects[key] = object;\n    },\n\n    remove: function (key) {\n      delete objects[key];\n    },\n\n    removeAll: function () {\n      objects = {};\n    },\n  };\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} };\n  }\n\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n\n    for (\n      let nodeIndex = 0, nodeLength = nodeDefs.length;\n      nodeIndex < nodeLength;\n      nodeIndex++\n    ) {\n      const nodeDef = nodeDefs[nodeIndex];\n\n      if (\n        nodeDef.extensions &&\n        nodeDef.extensions[this.name] &&\n        nodeDef.extensions[this.name].light !== undefined\n      ) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = 'light:' + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n\n    if (dependency) return dependency;\n\n    const json = parser.json;\n    const extensions = (json.extensions && json.extensions[this.name]) || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n\n    const color = new Color(0xffffff);\n\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new SpotLight(color);\n        lightNode.distance = range;\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle =\n          lightDef.spot.innerConeAngle !== undefined\n            ? lightDef.spot.innerConeAngle\n            : 0;\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined\n            ? lightDef.spot.outerConeAngle\n            : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra =\n          1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error(\n          'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type,\n        );\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0);\n\n    lightNode.decay = 2;\n\n    if (lightDef.intensity !== undefined)\n      lightNode.intensity = lightDef.intensity;\n\n    lightNode.name = parser.createUniqueName(\n      lightDef.name || 'light_' + lightIndex,\n    );\n\n    dependency = Promise.resolve(lightNode);\n\n    parser.cache.add(cacheKey, dependency);\n\n    return dependency;\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef =\n      (nodeDef.extensions && nodeDef.extensions[this.name]) || {};\n    const lightIndex = lightDef.light;\n\n    if (lightIndex === undefined) return null;\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light);\n    });\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension$1 {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(\n          parser.assignTexture(\n            materialParams,\n            'map',\n            metallicRoughness.baseColorTexture,\n          ),\n        );\n      }\n    }\n\n    return Promise.all(pending);\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'clearcoatMap',\n          extension.clearcoatTexture,\n        ),\n      );\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'clearcoatRoughnessMap',\n          extension.clearcoatRoughnessTexture,\n        ),\n      );\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'clearcoatNormalMap',\n          extension.clearcoatNormalTexture,\n        ),\n      );\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale;\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\n      }\n    }\n\n    return Promise.all(pending);\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension$1 {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'transmissionMap',\n          extension.transmissionTexture,\n        ),\n      );\n    }\n\n    return Promise.all(pending);\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension$1 {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n\n    const extension = materialDef.extensions[this.name];\n\n    materialParams.thickness =\n      extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'thicknessMap',\n          extension.thicknessTexture,\n        ),\n      );\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || 0;\n\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationTint = new Color(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n    );\n\n    return Promise.all(pending);\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const extension = materialDef.extensions[this.name];\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n    return Promise.resolve();\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n\n    const extension = materialDef.extensions[this.name];\n\n    materialParams.specularIntensity =\n      extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'specularIntensityMap',\n          extension.specularTexture,\n        ),\n      );\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularTint = new Color(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n    );\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser\n          .assignTexture(\n            materialParams,\n            'specularTintMap',\n            extension.specularColorTexture,\n          )\n          .then(function (texture) {\n            texture.encoding = sRGBEncoding;\n          }),\n      );\n    }\n\n    return Promise.all(pending);\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n\n    const textureDef = json.textures[textureIndex];\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n\n    const extension = textureDef.extensions[this.name];\n    const source = json.images[extension.source];\n    const loader = parser.options.ktx2Loader;\n\n    if (!loader) {\n      if (\n        json.extensionsRequired &&\n        json.extensionsRequired.indexOf(this.name) >= 0\n      ) {\n        throw new Error(\n          'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures',\n        );\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null;\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, source, loader);\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n\n    const textureDef = json.textures[textureIndex];\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, source, loader);\n\n      if (\n        json.extensionsRequired &&\n        json.extensionsRequired.indexOf(name) >= 0\n      ) {\n        throw new Error(\n          'THREE.GLTFLoader: WebP required by asset but unsupported.',\n        );\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex);\n    });\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image();\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src =\n          'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1);\n        };\n      });\n    }\n\n    return this.isSupported;\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n\n      if (!decoder || !decoder.supported) {\n        if (\n          json.extensionsRequired &&\n          json.extensionsRequired.indexOf(this.name) >= 0\n        ) {\n          throw new Error(\n            'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files',\n          );\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null;\n        }\n      }\n\n      return Promise.all([buffer, decoder.ready]).then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n\n        const result = new ArrayBuffer(count * stride);\n        const source = new Uint8Array(res[0], byteOffset, byteLength);\n\n        decoder.decodeGltfBuffer(\n          new Uint8Array(result),\n          count,\n          stride,\n          source,\n          extensionDef.mode,\n          extensionDef.filter,\n        );\n        return result;\n      });\n    } else {\n      return null;\n    }\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 };\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n    }\n\n    const chunkContentsLength =\n      this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(\n          data,\n          BINARY_EXTENSION_HEADER_LENGTH + chunkIndex,\n          chunkLength,\n        );\n        this.content = LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName =\n        ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName =\n        ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] =\n          accessorDef.normalized === true;\n      }\n    }\n\n    return parser\n      .getDependency('bufferView', bufferViewIndex)\n      .then(function (bufferView) {\n        return new Promise(function (resolve) {\n          dracoLoader.decodeDracoFile(\n            bufferView,\n            function (geometry) {\n              for (const attributeName in geometry.attributes) {\n                const attribute = geometry.attributes[attributeName];\n                const normalized = attributeNormalizedMap[attributeName];\n\n                if (normalized !== undefined) attribute.normalized = normalized;\n              }\n\n              resolve(geometry);\n            },\n            threeAttributeMap,\n            attributeTypeMap,\n          );\n        });\n      });\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  extendTexture(texture, transform) {\n    if (transform.texCoord !== undefined) {\n      console.warn(\n        'THREE.GLTFLoader: Custom UV sets in \"' +\n          this.name +\n          '\" extension not yet supported.',\n      );\n    }\n\n    if (\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture;\n    }\n\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    texture.needsUpdate = true;\n\n    return texture;\n  }\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n/**\n * A sub class of StandardMaterial with some of the functionality\n * changed via the `onBeforeCompile` callback\n * @pailhead\n */\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\n  constructor(params) {\n    super();\n\n    this.isGLTFSpecularGlossinessMaterial = true;\n\n    //various chunks that need replacing\n    const specularMapParsFragmentChunk = [\n      '#ifdef USE_SPECULARMAP',\n      '\tuniform sampler2D specularMap;',\n      '#endif',\n    ].join('\\n');\n\n    const glossinessMapParsFragmentChunk = [\n      '#ifdef USE_GLOSSINESSMAP',\n      '\tuniform sampler2D glossinessMap;',\n      '#endif',\n    ].join('\\n');\n\n    const specularMapFragmentChunk = [\n      'vec3 specularFactor = specular;',\n      '#ifdef USE_SPECULARMAP',\n      '\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n      '\ttexelSpecular = sRGBToLinear( texelSpecular );',\n      '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n      '\tspecularFactor *= texelSpecular.rgb;',\n      '#endif',\n    ].join('\\n');\n\n    const glossinessMapFragmentChunk = [\n      'float glossinessFactor = glossiness;',\n      '#ifdef USE_GLOSSINESSMAP',\n      '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n      '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n      '\tglossinessFactor *= texelGlossiness.a;',\n      '#endif',\n    ].join('\\n');\n\n    const lightPhysicalFragmentChunk = [\n      'PhysicalMaterial material;',\n      'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\n      'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n      'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n      'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\n      'material.roughness += geometryRoughness;',\n      'material.roughness = min( material.roughness, 1.0 );',\n      'material.specularColor = specularFactor;',\n    ].join('\\n');\n\n    const uniforms = {\n      specular: { value: new Color().setHex(0xffffff) },\n      glossiness: { value: 1 },\n      specularMap: { value: null },\n      glossinessMap: { value: null },\n    };\n\n    this._extraUniforms = uniforms;\n\n    this.onBeforeCompile = function (shader) {\n      for (const uniformName in uniforms) {\n        shader.uniforms[uniformName] = uniforms[uniformName];\n      }\n\n      shader.fragmentShader = shader.fragmentShader\n        .replace('uniform float roughness;', 'uniform vec3 specular;')\n        .replace('uniform float metalness;', 'uniform float glossiness;')\n        .replace(\n          '#include <roughnessmap_pars_fragment>',\n          specularMapParsFragmentChunk,\n        )\n        .replace(\n          '#include <metalnessmap_pars_fragment>',\n          glossinessMapParsFragmentChunk,\n        )\n        .replace('#include <roughnessmap_fragment>', specularMapFragmentChunk)\n        .replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk)\n        .replace(\n          '#include <lights_physical_fragment>',\n          lightPhysicalFragmentChunk,\n        );\n    };\n\n    Object.defineProperties(this, {\n      specular: {\n        get: function () {\n          return uniforms.specular.value;\n        },\n        set: function (v) {\n          uniforms.specular.value = v;\n        },\n      },\n\n      specularMap: {\n        get: function () {\n          return uniforms.specularMap.value;\n        },\n        set: function (v) {\n          uniforms.specularMap.value = v;\n\n          if (v) {\n            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n          } else {\n            delete this.defines.USE_SPECULARMAP;\n          }\n        },\n      },\n\n      glossiness: {\n        get: function () {\n          return uniforms.glossiness.value;\n        },\n        set: function (v) {\n          uniforms.glossiness.value = v;\n        },\n      },\n\n      glossinessMap: {\n        get: function () {\n          return uniforms.glossinessMap.value;\n        },\n        set: function (v) {\n          uniforms.glossinessMap.value = v;\n\n          if (v) {\n            this.defines.USE_GLOSSINESSMAP = '';\n            this.defines.USE_UV = '';\n          } else {\n            delete this.defines.USE_GLOSSINESSMAP;\n            delete this.defines.USE_UV;\n          }\n        },\n      },\n    });\n\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n\n    this.setValues(params);\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.specularMap = source.specularMap;\n    this.specular.copy(source.specular);\n    this.glossinessMap = source.glossinessMap;\n    this.glossiness = source.glossiness;\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    return this;\n  }\n}\n\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\n    this.specularGlossinessParams = [\n      'color',\n      'map',\n      'lightMap',\n      'lightMapIntensity',\n      'aoMap',\n      'aoMapIntensity',\n      'emissive',\n      'emissiveIntensity',\n      'emissiveMap',\n      'bumpMap',\n      'bumpScale',\n      'normalMap',\n      'normalMapType',\n      'displacementMap',\n      'displacementScale',\n      'displacementBias',\n      'specularMap',\n      'specular',\n      'glossinessMap',\n      'glossiness',\n      'alphaMap',\n      'envMap',\n      'envMapIntensity',\n      'refractionRatio',\n    ];\n  }\n\n  getMaterialType() {\n    return GLTFMeshStandardSGMaterial;\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pbrSpecularGlossiness = materialDef.extensions[this.name];\n\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n\n    const pending = [];\n\n    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n      const array = pbrSpecularGlossiness.diffuseFactor;\n\n      materialParams.color.fromArray(array);\n      materialParams.opacity = array[3];\n    }\n\n    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'map',\n          pbrSpecularGlossiness.diffuseTexture,\n        ),\n      );\n    }\n\n    materialParams.emissive = new Color(0.0, 0.0, 0.0);\n    materialParams.glossiness =\n      pbrSpecularGlossiness.glossinessFactor !== undefined\n        ? pbrSpecularGlossiness.glossinessFactor\n        : 1.0;\n    materialParams.specular = new Color(1.0, 1.0, 1.0);\n\n    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n    }\n\n    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n      pending.push(\n        parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef),\n      );\n      pending.push(\n        parser.assignTexture(materialParams, 'specularMap', specGlossMapDef),\n      );\n    }\n\n    return Promise.all(pending);\n  }\n\n  createMaterial(materialParams) {\n    const material = new GLTFMeshStandardSGMaterial(materialParams);\n    material.fog = true;\n\n    material.color = materialParams.color;\n\n    material.map = materialParams.map === undefined ? null : materialParams.map;\n\n    material.lightMap = null;\n    material.lightMapIntensity = 1.0;\n\n    material.aoMap =\n      materialParams.aoMap === undefined ? null : materialParams.aoMap;\n    material.aoMapIntensity = 1.0;\n\n    material.emissive = materialParams.emissive;\n    material.emissiveIntensity = 1.0;\n    material.emissiveMap =\n      materialParams.emissiveMap === undefined\n        ? null\n        : materialParams.emissiveMap;\n\n    material.bumpMap =\n      materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n    material.bumpScale = 1;\n\n    material.normalMap =\n      materialParams.normalMap === undefined ? null : materialParams.normalMap;\n    material.normalMapType = TangentSpaceNormalMap;\n\n    if (materialParams.normalScale)\n      material.normalScale = materialParams.normalScale;\n\n    material.displacementMap = null;\n    material.displacementScale = 1;\n    material.displacementBias = 0;\n\n    material.specularMap =\n      materialParams.specularMap === undefined\n        ? null\n        : materialParams.specularMap;\n    material.specular = materialParams.specular;\n\n    material.glossinessMap =\n      materialParams.glossinessMap === undefined\n        ? null\n        : materialParams.glossinessMap;\n    material.glossiness = materialParams.glossiness;\n\n    material.alphaMap = null;\n\n    material.envMap =\n      materialParams.envMap === undefined ? null : materialParams.envMap;\n    material.envMapIntensity = 1.0;\n\n    material.refractionRatio = 0.98;\n\n    return material;\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize;\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  }\n}\n\nGLTFCubicSplineInterpolant.prototype.beforeStart_ =\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.afterEnd_ =\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n  const result = this.resultBuffer;\n  const values = this.sampleValues;\n  const stride = this.valueSize;\n\n  const stride2 = stride * 2;\n  const stride3 = stride * 3;\n\n  const td = t1 - t0;\n\n  const p = (t - t0) / td;\n  const pp = p * p;\n  const ppp = pp * p;\n\n  const offset1 = i1 * stride3;\n  const offset0 = offset1 - stride3;\n\n  const s2 = -2 * ppp + 3 * pp;\n  const s3 = ppp - pp;\n  const s0 = 1 - s2;\n  const s1 = s3 - pp + p;\n\n  // Layout of keyframe output values for CUBICSPLINE animations:\n  //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n  for (let i = 0; i !== stride; i++) {\n    const p0 = values[offset0 + i + stride]; // splineVertex_k\n    const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n    const p1 = values[offset1 + i + stride]; // splineVertex_k+1\n    const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n  }\n\n  return result;\n};\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n\n    _q.fromArray(result).normalize().toArray(result);\n\n    return result;\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS$1 = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n};\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n};\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n};\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n};\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES$1 = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n};\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n};\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n};\n\n/* UTILITY FUNCTIONS */\n\nfunction resolveURL(url, path) {\n  // Invalid URL\n  if (typeof url !== 'string' || url === '') return '';\n\n  // Host Relative URL\n  if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n    path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n  }\n\n  // Absolute URL http://,https://,//\n  if (/^(https?:)?\\/\\//i.test(url)) return url;\n\n  // Data URI\n  if (/^data:.*,.*$/i.test(url)) return url;\n\n  // Blob URL\n  if (/^blob:.*$/i.test(url)) return url;\n\n  // Relative URL\n  return path + url;\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    });\n  }\n\n  return cache['DefaultMaterial'];\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\n        'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras,\n      );\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n\n    if (target.POSITION !== undefined) hasMorphPosition = true;\n    if (target.NORMAL !== undefined) hasMorphNormal = true;\n\n    if (hasMorphPosition && hasMorphNormal) break;\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined\n          ? parser.getDependency('accessor', target.POSITION)\n          : geometry.attributes.position;\n\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined\n          ? parser.getDependency('accessor', target.NORMAL)\n          : geometry.attributes.normal;\n\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n    geometry.morphTargetsRelative = true;\n\n    return geometry;\n  });\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\n        'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.',\n      );\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  const dracoExtension =\n    primitiveDef.extensions &&\n    primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  let geometryKey;\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey =\n      primitiveDef.indices +\n      ':' +\n      createAttributesKey(primitiveDef.attributes) +\n      ':' +\n      primitiveDef.mode;\n  }\n\n  return geometryKey;\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = '';\n\n  const keys = Object.keys(attributes).sort();\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n  }\n\n  return attributesKey;\n}\n\nfunction getNormalizedComponentScale$1(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n\n    case Uint8Array:\n      return 1 / 255;\n\n    case Int16Array:\n      return 1 / 32767;\n\n    case Uint16Array:\n      return 1 / 65535;\n\n    default:\n      throw new Error(\n        'THREE.GLTFLoader: Unsupported normalized accessor component type.',\n      );\n  }\n}\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n\n    // loader object cache\n    this.cache = new GLTFRegistry();\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map();\n\n    // BufferGeometry caching\n    this.primitiveCache = {};\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n\n    this.textureCache = {};\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {};\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n    if (\n      typeof createImageBitmap !== 'undefined' &&\n      /Firefox/.test(navigator.userAgent) === false\n    ) {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    } else {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n\n    // Clear the loader cache\n    this.cache.removeAll();\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ]);\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        };\n\n        addUnknownExtensionsToUserData(extensions, result, json);\n\n        assignExtrasToUserData(result, json);\n\n        Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result);\n          }),\n        ).then(function () {\n          onLoad(result);\n        });\n      })\n      .catch(onError);\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (\n      let skinIndex = 0, skinLength = skinDefs.length;\n      skinIndex < skinLength;\n      skinIndex++\n    ) {\n      const joints = skinDefs[skinIndex].joints;\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (\n      let nodeIndex = 0, nodeLength = nodeDefs.length;\n      nodeIndex < nodeLength;\n      nodeIndex++\n    ) {\n      const nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return;\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n\n    cache.refs[index]++;\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object;\n\n    const ref = object.clone();\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n\n    updateMappings(object, ref);\n\n    ref.name += '_instance_' + cache.uses[index]++;\n\n    return ref;\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n\n      if (result) return result;\n    }\n\n    return null;\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n\n    const pending = [];\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n\n      if (result) pending.push(result);\n    }\n\n    return pending;\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index;\n    let dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index);\n        }),\n      );\n\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error(\n        'THREE.GLTFLoader: ' +\n          bufferDef.type +\n          ' buffer type is not supported.',\n      );\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    const options = this.options;\n\n    return new Promise(function (resolve, reject) {\n      loader.load(\n        resolveURL(bufferDef.uri, options.path),\n        resolve,\n        undefined,\n        function () {\n          reject(\n            new Error(\n              'THREE.GLTFLoader: Failed to load buffer \"' +\n                bufferDef.uri +\n                '\".',\n            ),\n          );\n        },\n      );\n    });\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (\n      buffer,\n    ) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n\n    const accessorDef = this.json.accessors[accessorIndex];\n\n    if (\n      accessorDef.bufferView === undefined &&\n      accessorDef.sparse === undefined\n    ) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    const pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(\n        this.getDependency('bufferView', accessorDef.bufferView),\n      );\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(\n        this.getDependency('bufferView', accessorDef.sparse.indices.bufferView),\n      );\n      pendingBufferViews.push(\n        this.getDependency('bufferView', accessorDef.sparse.values.bufferView),\n      );\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0];\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride =\n        accessorDef.bufferView !== undefined\n          ? json.bufferViews[accessorDef.bufferView].byteStride\n          : undefined;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          array = new TypedArray(\n            bufferView,\n            ibSlice * byteStride,\n            (accessorDef.count * byteStride) / elementBytes,\n          );\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(\n            bufferView,\n            byteOffset,\n            accessorDef.count * itemSize,\n          );\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices =\n          WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        );\n        const sparseValues = new TypedArray(\n          bufferViews[2],\n          byteOffsetValues,\n          accessorDef.sparse.count * itemSize,\n        );\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          );\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\n              'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.',\n            );\n        }\n      }\n\n      return bufferAttribute;\n    });\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const source = json.images[textureDef.source];\n\n    let loader = this.textureLoader;\n\n    if (source.uri) {\n      const handler = options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n\n    return this.loadTextureImage(textureIndex, source, loader);\n  }\n\n  loadTextureImage(textureIndex, source, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n\n    const textureDef = json.textures[textureIndex];\n\n    const cacheKey =\n      (source.uri || source.bufferView) + ':' + textureDef.sampler;\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey];\n    }\n\n    const URL = self.URL || self.webkitURL;\n\n    let sourceURI = source.uri || '';\n    let isObjectURL = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser\n        .getDependency('bufferView', source.bufferView)\n        .then(function (bufferView) {\n          isObjectURL = true;\n          const blob = new Blob([bufferView], { type: source.mimeType });\n          sourceURI = URL.createObjectURL(blob);\n          return sourceURI;\n        });\n    } else if (source.uri === undefined) {\n      throw new Error(\n        'THREE.GLTFLoader: Image ' +\n          textureIndex +\n          ' is missing URI and bufferView',\n      );\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve;\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture$1(imageBitmap);\n              texture.needsUpdate = true;\n\n              resolve(texture);\n            };\n          }\n\n          loader.load(\n            resolveURL(sourceURI, options.path),\n            onLoad,\n            undefined,\n            reject,\n          );\n        });\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI);\n        }\n\n        texture.flipY = false;\n\n        if (textureDef.name) texture.name = textureDef.name;\n\n        const samplers = json.samplers || {};\n        const sampler = samplers[textureDef.sampler] || {};\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n        texture.minFilter =\n          WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n\n        parser.associations.set(texture, { textures: textureIndex });\n\n        return texture;\n      })\n      .catch(function () {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n        return null;\n      });\n\n    this.textureCache[cacheKey] = promise;\n\n    return promise;\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef) {\n    const parser = this;\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n      // However, we will copy UV set 0 to UV set 1 on demand for aoMap\n      if (\n        mapDef.texCoord !== undefined &&\n        mapDef.texCoord != 0 &&\n        !(mapName === 'aoMap' && mapDef.texCoord == 1)\n      ) {\n        console.warn(\n          'THREE.GLTFLoader: Custom UV set ' +\n            mapDef.texCoord +\n            ' for texture ' +\n            mapName +\n            ' not yet supported.',\n        );\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined\n            ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]\n            : undefined;\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[\n            EXTENSIONS.KHR_TEXTURE_TRANSFORM\n          ].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n\n      materialParams[mapName] = texture;\n\n      return texture;\n    });\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined;\n    const useVertexColors = geometry.attributes.color !== undefined;\n    const useFlatShading = geometry.attributes.normal === undefined;\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid;\n\n      let pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material$1.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n      let lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material$1.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n      if (material.isGLTFSpecularGlossinessMaterial)\n        cacheKey += 'specular-glossiness:';\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n\n      let cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n\n        if (useVertexColors) cachedMaterial.vertexColors = true;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n\n        this.cache.add(cacheKey, cachedMaterial);\n\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n\n      material = cachedMaterial;\n    }\n\n    // workarounds for mesh and geometry\n\n    if (\n      material.aoMap &&\n      geometry.attributes.uv2 === undefined &&\n      geometry.attributes.uv !== undefined\n    ) {\n      geometry.setAttribute('uv2', geometry.attributes.uv);\n    }\n\n    mesh.material = material;\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial;\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n\n    const pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      const sgExtension =\n        extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(\n        sgExtension.extendParams(materialParams, materialDef, parser),\n      );\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(\n        kmuExtension.extendParams(materialParams, materialDef, parser),\n      );\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n      materialParams.color = new Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(\n          parser.assignTexture(\n            materialParams,\n            'map',\n            metallicRoughness.baseColorTexture,\n          ),\n        );\n      }\n\n      materialParams.metalness =\n        metallicRoughness.metallicFactor !== undefined\n          ? metallicRoughness.metallicFactor\n          : 1.0;\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined\n          ? metallicRoughness.roughnessFactor\n          : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(\n          parser.assignTexture(\n            materialParams,\n            'metalnessMap',\n            metallicRoughness.metallicRoughnessTexture,\n          ),\n        );\n        pending.push(\n          parser.assignTexture(\n            materialParams,\n            'roughnessMap',\n            metallicRoughness.metallicRoughnessTexture,\n          ),\n        );\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return (\n              ext.extendMaterialParams &&\n              ext.extendMaterialParams(materialIndex, materialParams)\n            );\n          }),\n        ),\n      );\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.format = RGBFormat;\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest =\n          materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (\n      materialDef.normalTexture !== undefined &&\n      materialType !== MeshBasicMaterial\n    ) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'normalMap',\n          materialDef.normalTexture,\n        ),\n      );\n\n      materialParams.normalScale = new Vector2(1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale;\n\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n\n    if (\n      materialDef.occlusionTexture !== undefined &&\n      materialType !== MeshBasicMaterial\n    ) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'aoMap',\n          materialDef.occlusionTexture,\n        ),\n      );\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (\n      materialDef.emissiveFactor !== undefined &&\n      materialType !== MeshBasicMaterial\n    ) {\n      materialParams.emissive = new Color().fromArray(\n        materialDef.emissiveFactor,\n      );\n    }\n\n    if (\n      materialDef.emissiveTexture !== undefined &&\n      materialType !== MeshBasicMaterial\n    ) {\n      pending.push(\n        parser.assignTexture(\n          materialParams,\n          'emissiveMap',\n          materialDef.emissiveTexture,\n        ),\n      );\n    }\n\n    return Promise.all(pending).then(function () {\n      let material;\n\n      if (materialType === GLTFMeshStandardSGMaterial) {\n        material =\n          extensions[\n            EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS\n          ].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name) material.name = materialDef.name;\n\n      // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n      if (material.map) material.map.encoding = sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;\n\n      assignExtrasToUserData(material, materialDef);\n\n      parser.associations.set(material, { materials: materialIndex });\n\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n\n      return material;\n    });\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');\n\n    let name = sanitizedName;\n\n    for (let i = 1; this.nodeNamesUsed[name]; ++i) {\n      name = sanitizedName + '_' + i;\n    }\n\n    this.nodeNamesUsed[name] = true;\n\n    return name;\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser);\n        });\n    }\n\n    const pending = [];\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n\n        if (\n          primitive.extensions &&\n          primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        ) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(\n            new BufferGeometry(),\n            primitive,\n            parser,\n          );\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise };\n\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n\n    const pending = [];\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material);\n\n      pending.push(material);\n    }\n\n    pending.push(parser.loadGeometries(primitives));\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n\n      const meshes = [];\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n\n        // 1. create Mesh\n\n        let mesh;\n\n        const material = materials[i];\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS$1.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh =\n            meshDef.isSkinnedMesh === true\n              ? new SkinnedMesh(geometry, material)\n              : new Mesh(geometry, material);\n\n          if (\n            mesh.isSkinnedMesh === true &&\n            !mesh.geometry.attributes.skinWeight.normalized\n          ) {\n            // we normalize floating point skin weight array to fix malformed assets (see #15319)\n            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n            mesh.normalizeSkinWeights();\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(\n              mesh.geometry,\n              TriangleStripDrawMode,\n            );\n          } else if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(\n              mesh.geometry,\n              TriangleFanDrawMode,\n            );\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error(\n            'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode,\n          );\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n\n        mesh.name = parser.createUniqueName(\n          meshDef.name || 'mesh_' + meshIndex,\n        );\n\n        assignExtrasToUserData(mesh, meshDef);\n\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n\n        parser.assignFinalMaterial(mesh);\n\n        meshes.push(mesh);\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        });\n      }\n\n      if (meshes.length === 1) {\n        return meshes[0];\n      }\n\n      const group = new Group();\n\n      parser.associations.set(group, { meshes: meshIndex });\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n\n      return group;\n    });\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      );\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(\n        -params.xmag,\n        params.xmag,\n        params.ymag,\n        -params.ymag,\n        params.znear,\n        params.zfar,\n      );\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n\n    assignExtrasToUserData(camera, cameraDef);\n\n    return Promise.resolve(camera);\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n\n    const skinEntry = { joints: skinDef.joints };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(\n      function (accessor) {\n        skinEntry.inverseBindMatrices = accessor;\n\n        return skinEntry;\n      },\n    );\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n\n    const animationDef = json.animations[animationIndex];\n\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n      const input =\n        animationDef.parameters !== undefined\n          ? animationDef.parameters[sampler.input]\n          : sampler.input;\n      const output =\n        animationDef.parameters !== undefined\n          ? animationDef.parameters[sampler.output]\n          : sampler.output;\n\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n\n      const tracks = [];\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n\n        if (node === undefined) continue;\n\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n\n        let TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES$1[target.path]) {\n          case PATH_PROPERTIES$1.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES$1.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES$1.position:\n          case PATH_PROPERTIES$1.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n\n        const targetName = node.name ? node.name : node.uuid;\n\n        const interpolation =\n          sampler.interpolation !== undefined\n            ? INTERPOLATION[sampler.interpolation]\n            : InterpolateLinear;\n\n        const targetNames = [];\n\n        if (PATH_PROPERTIES$1[target.path] === PATH_PROPERTIES$1.weights) {\n          // Node may be a Group (glTF mesh with several primitives) or a Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        let outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale$1(outputArray.constructor);\n          const scaled = new Float32Array(outputArray.length);\n\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(\n            targetNames[j] + '.' + PATH_PROPERTIES$1[target.path],\n            inputAccessor.array,\n            outputArray,\n            interpolation,\n          );\n\n          // Override interpolation with custom factory method.\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant =\n              function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n                // must be divided by three to get the interpolant's sampleSize argument.\n\n                const interpolantType =\n                  this instanceof QuaternionKeyframeTrack\n                    ? GLTFCubicSplineQuaternionInterpolant\n                    : GLTFCubicSplineInterpolant;\n\n                return new interpolantType(\n                  this.times,\n                  this.values,\n                  this.getValueSize() / 3,\n                  result,\n                );\n              };\n\n            // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      const name = animationDef.name\n        ? animationDef.name\n        : 'animation_' + animationIndex;\n\n      return new AnimationClip(name, undefined, tracks);\n    });\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n\n    if (nodeDef.mesh === undefined) return null;\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return;\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n\n      return node;\n    });\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n\n    const nodeDef = json.nodes[nodeIndex];\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\n\n    return (function () {\n      const pending = [];\n\n      const meshPromise = parser._invokeOne(function (ext) {\n        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n      });\n\n      if (meshPromise) {\n        pending.push(meshPromise);\n      }\n\n      if (nodeDef.camera !== undefined) {\n        pending.push(\n          parser\n            .getDependency('camera', nodeDef.camera)\n            .then(function (camera) {\n              return parser._getNodeRef(\n                parser.cameraCache,\n                nodeDef.camera,\n                camera,\n              );\n            }),\n        );\n      }\n\n      parser\n        ._invokeAll(function (ext) {\n          return (\n            ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n          );\n        })\n        .forEach(function (promise) {\n          pending.push(promise);\n        });\n\n      return Promise.all(pending);\n    })().then(function (objects) {\n      let node;\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n\n      parser.associations.get(node).nodes = nodeIndex;\n\n      return node;\n    });\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group();\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n\n    assignExtrasToUserData(scene, sceneDef);\n\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n\n    const nodeIds = sceneDef.nodes || [];\n\n    const pending = [];\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));\n    }\n\n    return Promise.all(pending).then(function () {\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map();\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material$1 || key instanceof Texture$1) {\n            reducedAssociations.set(key, value);\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node);\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings);\n          }\n        });\n\n        return reducedAssociations;\n      };\n\n      parser.associations = reduceAssociations(scene);\n\n      return scene;\n    });\n  }\n}\n\nfunction buildNodeHierarchy(nodeId, parentObject, json, parser) {\n  const nodeDef = json.nodes[nodeId];\n\n  return parser\n    .getDependency('node', nodeId)\n    .then(function (node) {\n      if (nodeDef.skin === undefined) return node;\n\n      // build skeleton here as well\n\n      let skinEntry;\n\n      return parser\n        .getDependency('skin', nodeDef.skin)\n        .then(function (skin) {\n          skinEntry = skin;\n\n          const pendingJoints = [];\n\n          for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\n            pendingJoints.push(\n              parser.getDependency('node', skinEntry.joints[i]),\n            );\n          }\n\n          return Promise.all(pendingJoints);\n        })\n        .then(function (jointNodes) {\n          node.traverse(function (mesh) {\n            if (!mesh.isMesh) return;\n\n            const bones = [];\n            const boneInverses = [];\n\n            for (let j = 0, jl = jointNodes.length; j < jl; j++) {\n              const jointNode = jointNodes[j];\n\n              if (jointNode) {\n                bones.push(jointNode);\n\n                const mat = new Matrix4();\n\n                if (skinEntry.inverseBindMatrices !== undefined) {\n                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n                }\n\n                boneInverses.push(mat);\n              } else {\n                console.warn(\n                  'THREE.GLTFLoader: Joint \"%s\" could not be found.',\n                  skinEntry.joints[j],\n                );\n              }\n            }\n\n            mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\n          });\n\n          return node;\n        });\n    })\n    .then(function (node) {\n      // build node hierachy\n\n      parentObject.add(node);\n\n      const pending = [];\n\n      if (nodeDef.children) {\n        const children = nodeDef.children;\n\n        for (let i = 0, il = children.length; i < il; i++) {\n          const child = children[i];\n          pending.push(buildNodeHierarchy(child, node, json, parser));\n        }\n      }\n\n      return Promise.all(pending);\n    });\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n\n  const box = new Box3();\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n\n    const min = accessor.min;\n    const max = accessor.max;\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(\n        new Vector3(min[0], min[1], min[2]),\n        new Vector3(max[0], max[1], max[2]),\n      );\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale$1(\n          WEBGL_COMPONENT_TYPES[accessor.componentType],\n        );\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\n        'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',\n      );\n\n      return;\n    }\n  } else {\n    return;\n  }\n\n  const targets = primitiveDef.targets;\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale$1(\n              WEBGL_COMPONENT_TYPES[accessor.componentType],\n            );\n            vector.multiplyScalar(boxScale);\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\n            'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',\n          );\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement);\n  }\n\n  geometry.boundingBox = box;\n\n  const sphere = new Sphere();\n\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n\n  geometry.boundingSphere = sphere;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n\n  const pending = [];\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser\n      .getDependency('accessor', accessorIndex)\n      .then(function (accessor) {\n        geometry.setAttribute(attributeName, accessor);\n      });\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName =\n      ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue;\n\n    pending.push(\n      assignAttributeAccessor(\n        attributes[gltfAttributeName],\n        threeAttributeName,\n      ),\n    );\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser\n      .getDependency('accessor', primitiveDef.indices)\n      .then(function (accessor) {\n        geometry.setIndex(accessor);\n      });\n\n    pending.push(accessor);\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef);\n\n  computeBounds(geometry, primitiveDef, parser);\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined\n      ? addMorphTargets(geometry, primitiveDef.targets, parser)\n      : geometry;\n  });\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {Number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  let index = geometry.getIndex();\n\n  // generate index if not present\n\n  if (index === null) {\n    const indices = [];\n\n    const position = geometry.getAttribute('position');\n\n    if (position !== undefined) {\n      for (let i = 0; i < position.count; i++) {\n        indices.push(i);\n      }\n\n      geometry.setIndex(indices);\n      index = geometry.getIndex();\n    } else {\n      console.error(\n        'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n      );\n      return geometry;\n    }\n  }\n\n  //\n\n  const numberOfTriangles = index.count - 2;\n  const newIndices = [];\n\n  if (drawMode === TriangleFanDrawMode) {\n    // gl.TRIANGLE_FAN\n\n    for (let i = 1; i <= numberOfTriangles; i++) {\n      newIndices.push(index.getX(0));\n      newIndices.push(index.getX(i));\n      newIndices.push(index.getX(i + 1));\n    }\n  } else {\n    // gl.TRIANGLE_STRIP\n\n    for (let i = 0; i < numberOfTriangles; i++) {\n      if (i % 2 === 0) {\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i + 2));\n      } else {\n        newIndices.push(index.getX(i + 2));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i));\n      }\n    }\n  }\n\n  if (newIndices.length / 3 !== numberOfTriangles) {\n    console.error(\n      'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.',\n    );\n  }\n\n  // build final geometry\n\n  const newGeometry = geometry.clone();\n  newGeometry.setIndex(newIndices);\n\n  return newGeometry;\n}\n\n/**\n * @author Deepkolos / https://github.com/deepkolos\n */\n\nclass WorkerPool {\n  constructor(pool = 4) {\n    this.pool = pool;\n    this.queue = [];\n    this.workers = [];\n    this.workersResolve = [];\n    this.workerStatus = 0;\n  }\n\n  _initWorker(workerId) {\n    if (!this.workers[workerId]) {\n      const worker = this.workerCreator();\n      worker.addEventListener('message', this._onMessage.bind(this, workerId));\n      this.workers[workerId] = worker;\n    }\n  }\n\n  _getIdleWorker() {\n    for (let i = 0; i < this.pool; i++)\n      if (!(this.workerStatus & (1 << i))) return i;\n\n    return -1;\n  }\n\n  _onMessage(workerId, msg) {\n    const resolve = this.workersResolve[workerId];\n    resolve && resolve(msg);\n\n    if (this.queue.length) {\n      const { resolve, msg, transfer } = this.queue.shift();\n      this.workersResolve[workerId] = resolve;\n      this.workers[workerId].postMessage(msg, transfer);\n    } else {\n      this.workerStatus ^= 1 << workerId;\n    }\n  }\n\n  setWorkerCreator(workerCreator) {\n    this.workerCreator = workerCreator;\n  }\n\n  setWorkerLimit(pool) {\n    this.pool = pool;\n  }\n\n  postMessage(msg, transfer) {\n    return new Promise((resolve) => {\n      const workerId = this._getIdleWorker();\n\n      if (workerId !== -1) {\n        this._initWorker(workerId);\n        this.workerStatus |= 1 << workerId;\n        this.workersResolve[workerId] = resolve;\n        this.workers[workerId].postMessage(msg, transfer);\n      } else {\n        this.queue.push({ resolve, msg, transfer });\n      }\n    });\n  }\n\n  dispose() {\n    this.workers.forEach((worker) => worker.terminate());\n    this.workersResolve.length = 0;\n    this.workers.length = 0;\n    this.queue.length = 0;\n    this.workerStatus = 0;\n  }\n}\n\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nconst KTX2TransferSRGB = 2;\nconst KTX2_ALPHA_PREMULTIPLIED = 1;\nconst _taskCache = new WeakMap();\n\nclass KTX2Loader extends Loader {\n  constructor(manager) {\n    super(manager);\n\n    this.transcoderPath = '';\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n\n    this.workerPool = new WorkerPool();\n    this.workerSourceURL = '';\n    this.workerConfig = null;\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn(\n        'THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' +\n          ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.',\n      );\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n\n    return this;\n  }\n\n  setWorkerLimit(num) {\n    this.workerPool.setWorkerLimit(num);\n\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported:\n        renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n        renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n    };\n\n    return this;\n  }\n\n  dispose() {\n    this.workerPool.dispose();\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);\n\n    return this;\n  }\n\n  init() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = jsLoader.loadAsync('basis_transcoder.js');\n\n      // Load transcoder WASM binary.\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType('arraybuffer');\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm');\n\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(\n        ([jsContent, binaryContent]) => {\n          const fn = KTX2Loader.BasisWorker.toString();\n\n          const body = [\n            '/* constants */',\n            'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat),\n            'let _TranscoderFormat = ' +\n              JSON.stringify(KTX2Loader.TranscoderFormat),\n            'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat),\n            '/* basis_transcoder.js */',\n            jsContent,\n            '/* worker */',\n            fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n          ].join('\\n');\n\n          this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n          this.transcoderBinary = binaryContent;\n\n          this.workerPool.setWorkerCreator(() => {\n            const worker = new Worker(this.workerSourceURL);\n            const transcoderBinary = this.transcoderBinary.slice(0);\n\n            worker.postMessage(\n              { type: 'init', config: this.workerConfig, transcoderBinary },\n              [transcoderBinary],\n            );\n\n            return worker;\n          });\n        },\n      );\n    }\n\n    return this.transcoderPending;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (this.workerConfig === null) {\n      throw new Error(\n        'THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.',\n      );\n    }\n\n    const loader = new FileLoader(this.manager);\n\n    loader.setResponseType('arraybuffer');\n    loader.setWithCredentials(this.withCredentials);\n\n    const texture = new CompressedTexture();\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer);\n\n          return cachedTask.promise.then(onLoad).catch(onError);\n        }\n\n        this._createTexture([buffer])\n          .then(function (_texture) {\n            texture.copy(_texture);\n            texture.needsUpdate = true;\n\n            if (onLoad) onLoad(texture);\n          })\n          .catch(onError);\n      },\n      onProgress,\n      onError,\n    );\n\n    return texture;\n  }\n\n  _createTextureFrom(transcodeResult) {\n    const {\n      mipmaps,\n      width,\n      height,\n      format,\n      type,\n      error,\n      dfdTransferFn,\n      dfdFlags,\n    } = transcodeResult;\n\n    if (type === 'error') return Promise.reject(error);\n\n    const texture = new CompressedTexture(\n      mipmaps,\n      width,\n      height,\n      format,\n      UnsignedByteType,\n    );\n    texture.minFilter =\n      mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n    texture.magFilter = LinearFilter;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    texture.encoding =\n      dfdTransferFn === KTX2TransferSRGB ? sRGBEncoding : LinearEncoding;\n    texture.premultiplyAlpha = !!(dfdFlags & KTX2_ALPHA_PREMULTIPLIED);\n\n    return texture;\n  }\n\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n  _createTexture(buffers, config = {}) {\n    const taskConfig = config;\n    const texturePending = this.init()\n      .then(() => {\n        return this.workerPool.postMessage(\n          { type: 'transcode', buffers, taskConfig: taskConfig },\n          buffers,\n        );\n      })\n      .then((e) => this._createTextureFrom(e.data));\n\n    // Cache the task result.\n    _taskCache.set(buffers[0], { promise: texturePending });\n\n    return texturePending;\n  }\n\n  dispose() {\n    URL.revokeObjectURL(this.workerSourceURL);\n    this.workerPool.dispose();\n\n    return this;\n  }\n}\n\n/* CONSTANTS */\n\nKTX2Loader.BasisFormat = {\n  ETC1S: 0,\n  UASTC_4x4: 1,\n};\n\nKTX2Loader.TranscoderFormat = {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16,\n};\n\nKTX2Loader.EngineFormat = {\n  RGBAFormat: RGBAFormat,\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format: RGB_ETC1_Format,\n  RGB_ETC2_Format: RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n};\n\n/* WEB WORKER */\n\nKTX2Loader.BasisWorker = function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n\n  const EngineFormat = _EngineFormat; // eslint-disable-line no-undef\n  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\n  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef\n\n  self.addEventListener('message', function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n\n      case 'transcode':\n        transcoderPending.then(() => {\n          try {\n            const {\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format,\n              dfdTransferFn,\n              dfdFlags,\n            } = transcode(message.buffers[0]);\n\n            const buffers = [];\n\n            for (let i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n\n            self.postMessage(\n              {\n                type: 'transcode',\n                id: message.id,\n                width,\n                height,\n                hasAlpha,\n                mipmaps,\n                format,\n                dfdTransferFn,\n                dfdFlags,\n              },\n              buffers,\n            );\n          } catch (error) {\n            console.error(error);\n\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message,\n            });\n          }\n        });\n        break;\n    }\n  });\n\n  function init(wasmBinary) {\n    transcoderPending = new Promise((resolve) => {\n      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };\n      BASIS(BasisModule); // eslint-disable-line no-undef\n    }).then(() => {\n      BasisModule.initializeBasis();\n\n      if (BasisModule.KTX2File === undefined) {\n        console.warn(\n          'THREE.KTX2Loader: Please update Basis Universal transcoder.',\n        );\n      }\n    });\n  }\n\n  function transcode(buffer) {\n    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));\n\n    function cleanup() {\n      ktx2File.close();\n      ktx2File.delete();\n    }\n\n    if (!ktx2File.isValid()) {\n      cleanup();\n      throw new Error('THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file');\n    }\n\n    const basisFormat = ktx2File.isUASTC()\n      ? BasisFormat.UASTC_4x4\n      : BasisFormat.ETC1S;\n    const width = ktx2File.getWidth();\n    const height = ktx2File.getHeight();\n    const levels = ktx2File.getLevels();\n    const hasAlpha = ktx2File.getHasAlpha();\n    const dfdTransferFn = ktx2File.getDFDTransferFunc();\n    const dfdFlags = ktx2File.getDFDFlags();\n\n    const { transcoderFormat, engineFormat } = getTranscoderFormat(\n      basisFormat,\n      width,\n      height,\n      hasAlpha,\n    );\n\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error('THREE.KTX2Loader:\tInvalid texture');\n    }\n\n    if (!ktx2File.startTranscoding()) {\n      cleanup();\n      throw new Error('THREE.KTX2Loader: .startTranscoding failed');\n    }\n\n    const mipmaps = [];\n\n    for (let mip = 0; mip < levels; mip++) {\n      const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);\n      const mipWidth = levelInfo.origWidth;\n      const mipHeight = levelInfo.origHeight;\n      const dst = new Uint8Array(\n        ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat),\n      );\n\n      const status = ktx2File.transcodeImage(\n        dst,\n        mip,\n        0,\n        0,\n        transcoderFormat,\n        0,\n        -1,\n        -1,\n      );\n\n      if (!status) {\n        cleanup();\n        throw new Error('THREE.KTX2Loader: .transcodeImage failed.');\n      }\n\n      mipmaps.push({ data: dst, width: mipWidth, height: mipHeight });\n    }\n\n    cleanup();\n\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat,\n      dfdTransferFn,\n      dfdFlags,\n    };\n  }\n\n  //\n\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\n  // for ETC1S and UASTC.\n  //\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n  const FORMAT_OPTIONS = [\n    {\n      if: 'astcSupported',\n      basisFormat: [BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n      engineFormat: [\n        EngineFormat.RGBA_ASTC_4x4_Format,\n        EngineFormat.RGBA_ASTC_4x4_Format,\n      ],\n      priorityETC1S: Infinity,\n      priorityUASTC: 1,\n      needsPowerOfTwo: false,\n    },\n    {\n      if: 'bptcSupported',\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n      engineFormat: [\n        EngineFormat.RGBA_BPTC_Format,\n        EngineFormat.RGBA_BPTC_Format,\n      ],\n      priorityETC1S: 3,\n      priorityUASTC: 2,\n      needsPowerOfTwo: false,\n    },\n    {\n      if: 'dxtSupported',\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n      engineFormat: [\n        EngineFormat.RGB_S3TC_DXT1_Format,\n        EngineFormat.RGBA_S3TC_DXT5_Format,\n      ],\n      priorityETC1S: 4,\n      priorityUASTC: 5,\n      needsPowerOfTwo: false,\n    },\n    {\n      if: 'etc2Supported',\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n      engineFormat: [\n        EngineFormat.RGB_ETC2_Format,\n        EngineFormat.RGBA_ETC2_EAC_Format,\n      ],\n      priorityETC1S: 1,\n      priorityUASTC: 3,\n      needsPowerOfTwo: false,\n    },\n    {\n      if: 'etc1Supported',\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n      engineFormat: [\n        EngineFormat.RGB_ETC1_Format,\n        EngineFormat.RGB_ETC1_Format,\n      ],\n      priorityETC1S: 2,\n      priorityUASTC: 4,\n      needsPowerOfTwo: false,\n    },\n    {\n      if: 'pvrtcSupported',\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [\n        TranscoderFormat.PVRTC1_4_RGB,\n        TranscoderFormat.PVRTC1_4_RGBA,\n      ],\n      engineFormat: [\n        EngineFormat.RGB_PVRTC_4BPPV1_Format,\n        EngineFormat.RGBA_PVRTC_4BPPV1_Format,\n      ],\n      priorityETC1S: 5,\n      priorityUASTC: 6,\n      needsPowerOfTwo: true,\n    },\n  ];\n\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n\n    const options =\n      basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))\n        continue;\n\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n\n      return { transcoderFormat, engineFormat };\n    }\n\n    console.warn(\n      'THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.',\n    );\n\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n\n    return { transcoderFormat, engineFormat };\n  }\n\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n\n    return (value & (value - 1)) === 0 && value !== 0;\n  }\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a$b, _b$a;\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\nclass CacheEvictionPolicy {\n  constructor(cache, evictionThreshold = 5) {\n    this[_a$b] = new Map();\n    this[_b$a] = [];\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n  set evictionThreshold(value) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n  get evictionThreshold() {\n    return this[$evictionThreshold];\n  }\n  /**\n   * A reference to the cache that operates under this policy\n   */\n  get cache() {\n    return this[$cache];\n  }\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n  retainerCount(key) {\n    return this[$retainerCount].get(key) || 0;\n  }\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n  retain(key) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n    this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n    this[$recentlyUsed].unshift(key);\n    // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n    this[$evict]();\n  }\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n  release(key) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(\n        key,\n        Math.max(this[$retainerCount].get(key) - 1, 0),\n      );\n    }\n    this[$evict]();\n  }\n  [((_a$b = $retainerCount), (_b$a = $recentlyUsed), $evict)]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n    for (\n      let i = this[$recentlyUsed].length - 1;\n      i >= this[$evictionThreshold];\n      --i\n    ) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n}\n\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * KHR_materials_variants specification allows duplicated variant names\n * but it makes handling the extension complex.\n * We ensure tha names and make it easier.\n * If you want to export the extension with the original names\n * you are recommended to write GLTFExporter plugin to restore the names.\n *\n * @param variantNames {Array<string>}\n * @return {Array<string>}\n */\nconst ensureUniqueNames = (variantNames) => {\n  const uniqueNames = [];\n  const knownNames = new Set();\n  for (const name of variantNames) {\n    let uniqueName = name;\n    let suffix = 0;\n    // @TODO: An easy solution.\n    //        O(N^2) in the worst scenario where N is variantNames.length.\n    //        Fix me if needed.\n    while (knownNames.has(uniqueName)) {\n      uniqueName = name + '.' + ++suffix;\n    }\n    knownNames.add(uniqueName);\n    uniqueNames.push(uniqueName);\n  }\n  return uniqueNames;\n};\n/**\n * Convert mappings array to table object to make handling the extension easier.\n *\n * @param\n *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}\n * @param variantNames {Array<string>} Required to be unique names\n * @return {Map}\n */\nconst mappingsArrayToTable = (extensionDef, variantNames) => {\n  const table = new Map();\n  for (const mapping of extensionDef.mappings) {\n    for (const variant of mapping.variants) {\n      table.set(variantNames[variant], {\n        material: null,\n        gltfMaterialIndex: mapping.material,\n      });\n    }\n  }\n  return table;\n};\nclass GLTFMaterialsVariantsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = 'KHR_materials_variants';\n  }\n  // Note that the following properties will be overridden even if they are\n  // pre-defined\n  // - gltf.userData.variants\n  // - mesh.userData.variantMaterials\n  afterRoot(gltf) {\n    const parser = this.parser;\n    const json = parser.json;\n    if (\n      json.extensions === undefined ||\n      json.extensions[this.name] === undefined\n    ) {\n      return null;\n    }\n    const extensionDef = json.extensions[this.name];\n    const variantsDef = extensionDef.variants || [];\n    const variants = ensureUniqueNames(variantsDef.map((v) => v.name));\n    for (const scene of gltf.scenes) {\n      // Save the variants data under associated mesh.userData\n      scene.traverse((object) => {\n        // The following code can be simplified if parser.associations directly\n        // supports meshes.\n        const association = parser.associations.get(object);\n        if (association == null || association.meshes == null) {\n          return;\n        }\n        const meshIndex = association.meshes;\n        // Two limitations:\n        // 1. The nodeDef shouldn't have any objects (camera, light, or\n        // nodeDef.extensions object)\n        //    other than nodeDef.mesh\n        // 2. Other plugins shouldn't change any scene graph hierarchy\n        // The following code can cause error if hitting the either or both\n        // limitations If parser.associations will directly supports meshes\n        // these limitations can be removed\n        const meshDef = json.meshes[meshIndex];\n        const primitivesDef = meshDef.primitives;\n        const meshes = 'isMesh' in object ? [object] : object.children;\n        for (let i = 0; i < primitivesDef.length; i++) {\n          const primitiveDef = primitivesDef[i];\n          const extensionsDef = primitiveDef.extensions;\n          if (!extensionsDef || !extensionsDef[this.name]) {\n            continue;\n          }\n          meshes[i].userData.variantMaterials = mappingsArrayToTable(\n            extensionsDef[this.name],\n            variants,\n          );\n        }\n      });\n    }\n    gltf.userData.variants = variants;\n    return Promise.resolve();\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a$a, _b$9;\n/**\n * A helper to Promise-ify a Three.js GLTFLoader\n */\nconst loadWithLoader = (url, loader, progressCallback = () => {}) => {\n  const onProgress = (event) => {\n    const fraction = event.loaded / event.total;\n    progressCallback(\n      Math.max(0, Math.min(1, isFinite(fraction) ? fraction : 1)),\n    );\n  };\n  return new Promise((resolve, reject) => {\n    loader.load(url, resolve, onProgress, reject);\n  });\n};\n/** Helper to load a script tag. */\nconst fetchScript = (src) => {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    document.body.appendChild(script);\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = src;\n  });\n};\nconst cache = new Map();\nconst preloaded = new Map();\nlet dracoDecoderLocation;\nconst dracoLoader = new DRACOLoader();\nlet ktx2TranscoderLocation;\nconst ktx2Loader = new KTX2Loader();\nlet meshoptDecoderLocation;\nlet meshoptDecoder;\nconst $loader = Symbol('loader');\nconst $evictionPolicy = Symbol('evictionPolicy');\nconst $GLTFInstance = Symbol('GLTFInstance');\nclass CachingGLTFLoader extends EventDispatcher {\n  constructor(GLTFInstance) {\n    super();\n    this[_b$9] = new GLTFLoader().register(\n      (parser) => new GLTFMaterialsVariantsExtension(parser),\n    );\n    this[$GLTFInstance] = GLTFInstance;\n    this[$loader].setDRACOLoader(dracoLoader);\n    this[$loader].setKTX2Loader(ktx2Loader);\n  }\n  static setDRACODecoderLocation(url) {\n    dracoDecoderLocation = url;\n    dracoLoader.setDecoderPath(url);\n  }\n  static getDRACODecoderLocation() {\n    return dracoDecoderLocation;\n  }\n  static setKTX2TranscoderLocation(url) {\n    ktx2TranscoderLocation = url;\n    ktx2Loader.setTranscoderPath(url);\n  }\n  static getKTX2TranscoderLocation() {\n    return ktx2TranscoderLocation;\n  }\n  static setMeshoptDecoderLocation(url) {\n    if (meshoptDecoderLocation !== url) {\n      meshoptDecoderLocation = url;\n      meshoptDecoder = fetchScript(url)\n        .then(() => MeshoptDecoder.ready)\n        .then(() => MeshoptDecoder);\n    }\n  }\n  static getMeshoptDecoderLocation() {\n    return meshoptDecoderLocation;\n  }\n  static initializeKTX2Loader(renderer) {\n    ktx2Loader.detectSupport(renderer);\n  }\n  static get cache() {\n    return cache;\n  }\n  /** @nocollapse */\n  static clearCache() {\n    cache.forEach((_value, url) => {\n      this.delete(url);\n    });\n    this[$evictionPolicy].reset();\n  }\n  static has(url) {\n    return cache.has(url);\n  }\n  /** @nocollapse */\n  static async delete(url) {\n    if (!this.has(url)) {\n      return;\n    }\n    const gltfLoads = cache.get(url);\n    preloaded.delete(url);\n    cache.delete(url);\n    const gltf = await gltfLoads;\n    // Dispose of the cached glTF's materials and geometries:\n    gltf.dispose();\n  }\n  /**\n   * Returns true if the model that corresponds to the specified url is\n   * available in our local cache.\n   */\n  static hasFinishedLoading(url) {\n    return !!preloaded.get(url);\n  }\n  get [((_a$a = $evictionPolicy), (_b$9 = $loader), $evictionPolicy)]() {\n    return this.constructor[$evictionPolicy];\n  }\n  /**\n   * Preloads a glTF, populating the cache. Returns a promise that resolves\n   * when the cache is populated.\n   */\n  async preload(url, element, progressCallback = () => {}) {\n    this.dispatchEvent({ type: 'preload', element: element, src: url });\n    if (!cache.has(url)) {\n      if (meshoptDecoder != null) {\n        this[$loader].setMeshoptDecoder(await meshoptDecoder);\n      }\n      const rawGLTFLoads = loadWithLoader(url, this[$loader], (progress) => {\n        progressCallback(progress * 0.8);\n      });\n      const GLTFInstance = this[$GLTFInstance];\n      const gltfInstanceLoads = rawGLTFLoads\n        .then((rawGLTF) => {\n          return GLTFInstance.prepare(rawGLTF);\n        })\n        .then((preparedGLTF) => {\n          progressCallback(0.9);\n          return new GLTFInstance(preparedGLTF);\n        });\n      cache.set(url, gltfInstanceLoads);\n    }\n    await cache.get(url);\n    preloaded.set(url, true);\n    if (progressCallback) {\n      progressCallback(1.0);\n    }\n  }\n  /**\n   * Loads a glTF from the specified url and resolves a unique clone of the\n   * glTF. If the glTF has already been loaded, makes a clone of the cached\n   * copy.\n   */\n  async load(url, element, progressCallback = () => {}) {\n    await this.preload(url, element, progressCallback);\n    const gltf = await cache.get(url);\n    const clone = await gltf.clone();\n    this[$evictionPolicy].retain(url);\n    // Patch dispose so that we can properly account for instance use\n    // in the caching layer:\n    clone.dispose = (() => {\n      const originalDispose = clone.dispose;\n      let disposed = false;\n      return () => {\n        if (disposed) {\n          return;\n        }\n        disposed = true;\n        originalDispose.apply(clone);\n        this[$evictionPolicy].release(url);\n      };\n    })();\n    return clone;\n  }\n}\nCachingGLTFLoader[_a$a] = new CacheEvictionPolicy(CachingGLTFLoader);\n\nclass CSS2DObject extends Object3D {\n  constructor(element) {\n    super();\n\n    this.element = element || document.createElement('div');\n\n    this.element.style.position = 'absolute';\n    this.element.style.userSelect = 'none';\n\n    this.element.setAttribute('draggable', false);\n\n    this.addEventListener('removed', function () {\n      this.traverse(function (object) {\n        if (\n          object.element instanceof Element &&\n          object.element.parentNode !== null\n        ) {\n          object.element.parentNode.removeChild(object.element);\n        }\n      });\n    });\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n\n    this.element = source.element.cloneNode(true);\n\n    return this;\n  }\n}\n\nCSS2DObject.prototype.isCSS2DObject = true;\n\n//\n\nconst _vector = new Vector3();\nconst _viewMatrix = new Matrix4();\nconst _viewProjectionMatrix = new Matrix4();\nconst _a$9 = new Vector3();\nconst _b$8 = new Vector3();\n\nclass CSS2DRenderer {\n  constructor() {\n    const _this = this;\n\n    let _width, _height;\n    let _widthHalf, _heightHalf;\n\n    const cache = {\n      objects: new WeakMap(),\n    };\n\n    const domElement = document.createElement('div');\n    domElement.style.overflow = 'hidden';\n\n    this.domElement = domElement;\n\n    this.getSize = function () {\n      return {\n        width: _width,\n        height: _height,\n      };\n    };\n\n    this.render = function (scene, camera) {\n      if (scene.autoUpdate === true) scene.updateMatrixWorld();\n      if (camera.parent === null) camera.updateMatrixWorld();\n\n      _viewMatrix.copy(camera.matrixWorldInverse);\n      _viewProjectionMatrix.multiplyMatrices(\n        camera.projectionMatrix,\n        _viewMatrix,\n      );\n\n      renderObject(scene, scene, camera);\n      zOrder(scene);\n    };\n\n    this.setSize = function (width, height) {\n      _width = width;\n      _height = height;\n\n      _widthHalf = _width / 2;\n      _heightHalf = _height / 2;\n\n      domElement.style.width = width + 'px';\n      domElement.style.height = height + 'px';\n    };\n\n    function renderObject(object, scene, camera) {\n      if (object.isCSS2DObject) {\n        object.onBeforeRender(_this, scene, camera);\n\n        _vector.setFromMatrixPosition(object.matrixWorld);\n        _vector.applyMatrix4(_viewProjectionMatrix);\n\n        const element = object.element;\n\n        if (/apple/i.test(navigator.vendor)) {\n          // https://github.com/mrdoob/three.js/issues/21415\n          element.style.transform =\n            'translate(-50%,-50%) translate(' +\n            Math.round(_vector.x * _widthHalf + _widthHalf) +\n            'px,' +\n            Math.round(-_vector.y * _heightHalf + _heightHalf) +\n            'px)';\n        } else {\n          element.style.transform =\n            'translate(-50%,-50%) translate(' +\n            (_vector.x * _widthHalf + _widthHalf) +\n            'px,' +\n            (-_vector.y * _heightHalf + _heightHalf) +\n            'px)';\n        }\n\n        element.style.display =\n          object.visible && _vector.z >= -1 && _vector.z <= 1 ? '' : 'none';\n\n        const objectData = {\n          distanceToCameraSquared: getDistanceToSquared(camera, object),\n        };\n\n        cache.objects.set(object, objectData);\n\n        if (element.parentNode !== domElement) {\n          domElement.appendChild(element);\n        }\n\n        object.onAfterRender(_this, scene, camera);\n      }\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        renderObject(object.children[i], scene, camera);\n      }\n    }\n\n    function getDistanceToSquared(object1, object2) {\n      _a$9.setFromMatrixPosition(object1.matrixWorld);\n      _b$8.setFromMatrixPosition(object2.matrixWorld);\n\n      return _a$9.distanceToSquared(_b$8);\n    }\n\n    function filterAndFlatten(scene) {\n      const result = [];\n\n      scene.traverse(function (object) {\n        if (object.isCSS2DObject) result.push(object);\n      });\n\n      return result;\n    }\n\n    function zOrder(scene) {\n      const sorted = filterAndFlatten(scene).sort(function (a, b) {\n        const distanceA = cache.objects.get(a).distanceToCameraSquared;\n        const distanceB = cache.objects.get(b).distanceToCameraSquared;\n\n        return distanceA - distanceB;\n      });\n\n      const zMax = sorted.length;\n\n      for (let i = 0, l = sorted.length; i < l; i++) {\n        sorted[i].element.style.zIndex = zMax - i;\n      }\n    }\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst deserializeUrl = (url) =>\n  !!url && url !== 'null' ? toFullUrl(url) : null;\nconst assertIsArCandidate = () => {\n  if (IS_WEBXR_AR_CANDIDATE) {\n    return;\n  }\n  const missingApis = [];\n  if (!HAS_WEBXR_DEVICE_API) {\n    missingApis.push('WebXR Device API');\n  }\n  if (!HAS_WEBXR_HIT_TEST_API) {\n    missingApis.push('WebXR Hit Test API');\n  }\n  throw new Error(\n    `The following APIs are required for AR, but are missing in this browser: ${missingApis.join(\n      ', ',\n    )}`,\n  );\n};\n/**\n * Converts a partial URL string to a fully qualified URL string.\n *\n * @param {String} url\n * @return {String}\n */\nconst toFullUrl = (partialUrl) => {\n  const url = new URL(partialUrl, window.location.toString());\n  return url.toString();\n};\n/**\n * Returns a throttled version of a given function that is only invoked at most\n * once within a given threshold of time in milliseconds.\n *\n * The throttled version of the function has a \"flush\" property that resets the\n * threshold for cases when immediate invokation is desired.\n */\nconst throttle = (fn, ms) => {\n  let timer = null;\n  const throttled = (...args) => {\n    if (timer != null) {\n      return;\n    }\n    fn(...args);\n    timer = self.setTimeout(() => (timer = null), ms);\n  };\n  throttled.flush = () => {\n    if (timer != null) {\n      self.clearTimeout(timer);\n      timer = null;\n    }\n  };\n  return throttled;\n};\nconst debounce = (fn, ms) => {\n  let timer = null;\n  return (...args) => {\n    if (timer != null) {\n      self.clearTimeout(timer);\n    }\n    timer = self.setTimeout(() => {\n      timer = null;\n      fn(...args);\n    }, ms);\n  };\n};\n/**\n * @param {Number} value\n * @param {Number} lowerLimit\n * @param {Number} upperLimit\n * @return {Number} value clamped within lowerLimit..upperLimit\n */\nconst clamp = (value, lowerLimit, upperLimit) =>\n  Math.max(lowerLimit, Math.min(upperLimit, value));\n// The DPR we use for a \"capped\" scenario (see resolveDpr below):\nconst CAPPED_DEVICE_PIXEL_RATIO = 1;\n/**\n * This helper analyzes the layout of the current page to decide if we should\n * use the natural device pixel ratio, or a capped value.\n *\n * We cap DPR if there is no meta viewport (suggesting that user is not\n * consciously specifying how to scale the viewport relative to the device\n * screen size).\n *\n * The rationale is that this condition typically leads to a pathological\n * outcome on mobile devices. When the window dimensions are scaled up on a\n * device with a high DPR, we create a canvas that is much larger than\n * appropriate to accomodate for the pixel density if we naively use the\n * reported DPR.\n *\n * This value needs to be measured in real time, as device pixel ratio can\n * change over time (e.g., when a user zooms the page). Also, in some cases\n * (such as Firefox on Android), the window's innerWidth is initially reported\n * as the same as the screen's availWidth but changes later.\n *\n * A user who specifies a meta viewport, thereby consciously creating scaling\n * conditions where <model-viewer> is slow, will be encouraged to live their\n * best life.\n */\nconst resolveDpr = (() => {\n  // If true, implies that the user is conscious of the viewport scaling\n  // relative to the device screen size.\n  const HAS_META_VIEWPORT_TAG = (() => {\n    const metas =\n      document.head != null\n        ? Array.from(document.head.querySelectorAll('meta'))\n        : [];\n    for (const meta of metas) {\n      if (meta.name === 'viewport') {\n        return true;\n      }\n    }\n    return false;\n  })();\n  if (!HAS_META_VIEWPORT_TAG) {\n    console.warn(\n      'No <meta name=\"viewport\"> detected; <model-viewer> will cap pixel density at 1.',\n    );\n  }\n  return () =>\n    HAS_META_VIEWPORT_TAG ? window.devicePixelRatio : CAPPED_DEVICE_PIXEL_RATIO;\n})();\n/**\n * Debug mode is enabled when one of the two following conditions is true:\n *\n *  1. A 'model-viewer-debug-mode' query parameter is present in the current\n *     search string\n *  2. There is a global object ModelViewerElement with a debugMode property set\n *     to true\n */\nconst isDebugMode = (() => {\n  const debugQueryParameterName = 'model-viewer-debug-mode';\n  const debugQueryParameter = new RegExp(`[?&]${debugQueryParameterName}(&|$)`);\n  return () =>\n    (self.ModelViewerElement && self.ModelViewerElement.debugMode) ||\n    (self.location &&\n      self.location.search &&\n      self.location.search.match(debugQueryParameter));\n})();\n/**\n * Returns the first key in a Map in iteration order.\n *\n * NOTE(cdata): This is necessary because IE11 does not implement iterator\n * methods of Map, and polymer-build does not polyfill these methods for\n * compatibility and performance reasons. This helper proposes that it is\n * a reasonable compromise to sacrifice a very small amount of runtime\n * performance in IE11 for the sake of code clarity.\n */\nconst getFirstMapKey = (map) => {\n  if (map.keys != null) {\n    return map.keys().next().value || null;\n  }\n  let firstKey = null;\n  try {\n    map.forEach((_value, key, _map) => {\n      firstKey = key;\n      // Stop iterating the Map with forEach:\n      throw new Error();\n    });\n  } catch (_error) {}\n  return firstKey;\n};\nconst timePasses = (ms = 0) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n/**\n * @param {EventTarget|EventDispatcher} target\n * @param {string} eventName\n * @param {?Function} predicate\n */\nconst waitForEvent = (target, eventName, predicate = null) =>\n  new Promise((resolve) => {\n    function handler(event) {\n      if (!predicate || predicate(event)) {\n        resolve(event);\n        target.removeEventListener(eventName, handler);\n      }\n    }\n    target.addEventListener(eventName, handler);\n  });\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst SETTLING_TIME = 10000; // plenty long enough\nconst MIN_DECAY_MILLISECONDS = 0.001;\nconst DECAY_MILLISECONDS = 50;\n/**\n * The Damper class is a generic second-order critically damped system that does\n * one linear step of the desired length of time. The only parameter is\n * DECAY_MILLISECONDS. This common parameter makes all states converge at the\n * same rate regardless of scale. xNormalization is a number to provide the\n * rough scale of x, such that NIL_SPEED clamping also happens at roughly the\n * same convergence for all states.\n */\nclass Damper {\n  constructor(decayMilliseconds = DECAY_MILLISECONDS) {\n    this.velocity = 0;\n    this.naturalFrequency = 0;\n    this.setDecayTime(decayMilliseconds);\n  }\n  setDecayTime(decayMilliseconds) {\n    this.naturalFrequency =\n      1 / Math.max(MIN_DECAY_MILLISECONDS, decayMilliseconds);\n  }\n  update(x, xGoal, timeStepMilliseconds, xNormalization) {\n    const nilSpeed = 0.0002 * this.naturalFrequency;\n    if (x == null || xNormalization === 0) {\n      return xGoal;\n    }\n    if (x === xGoal && this.velocity === 0) {\n      return xGoal;\n    }\n    if (timeStepMilliseconds < 0) {\n      return x;\n    }\n    // Exact solution to a critically damped second-order system, where:\n    // acceleration = this.naturalFrequency * this.naturalFrequency * (xGoal\n    // - x) - 2 * this.naturalFrequency * this.velocity;\n    const deltaX = x - xGoal;\n    const intermediateVelocity = this.velocity + this.naturalFrequency * deltaX;\n    const intermediateX = deltaX + timeStepMilliseconds * intermediateVelocity;\n    const decay = Math.exp(-this.naturalFrequency * timeStepMilliseconds);\n    const newVelocity =\n      (intermediateVelocity - this.naturalFrequency * intermediateX) * decay;\n    const acceleration =\n      -this.naturalFrequency * (newVelocity + intermediateVelocity * decay);\n    if (\n      Math.abs(newVelocity) < nilSpeed * Math.abs(xNormalization) &&\n      acceleration * deltaX >= 0\n    ) {\n      // This ensures the controls settle and stop calling this function instead\n      // of asymptotically approaching their goal.\n      this.velocity = 0;\n      return xGoal;\n    } else {\n      this.velocity = newVelocity;\n      return xGoal + intermediateX * decay;\n    }\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst numberNode = (value, unit) => ({ type: 'number', number: value, unit });\n/**\n * Given a string representing a comma-separated set of CSS-like expressions,\n * parses and returns an array of ASTs that correspond to those expressions.\n *\n * Currently supported syntax includes:\n *\n *  - functions (top-level and nested)\n *  - calc() arithmetic operators\n *  - numbers with units\n *  - hexidecimal-encoded colors in 3, 6 or 8 digit form\n *  - idents\n *\n * All syntax is intended to match the parsing rules and semantics of the actual\n * CSS spec as closely as possible.\n *\n * @see https://www.w3.org/TR/CSS2/\n * @see https://www.w3.org/TR/css-values-3/\n */\nconst parseExpressions = (() => {\n  const cache = {};\n  const MAX_PARSE_ITERATIONS = 1000; // Arbitrarily large\n  return (inputString) => {\n    const cacheKey = inputString;\n    if (cacheKey in cache) {\n      return cache[cacheKey];\n    }\n    const expressions = [];\n    let parseIterations = 0;\n    while (inputString) {\n      if (++parseIterations > MAX_PARSE_ITERATIONS) {\n        // Avoid a potentially infinite loop due to typos:\n        inputString = '';\n        break;\n      }\n      const expressionParseResult = parseExpression(inputString);\n      const expression = expressionParseResult.nodes[0];\n      if (expression == null || expression.terms.length === 0) {\n        break;\n      }\n      expressions.push(expression);\n      inputString = expressionParseResult.remainingInput;\n    }\n    return (cache[cacheKey] = expressions);\n  };\n})();\n/**\n * Parse a single expression. For the purposes of our supported syntax, an\n * expression is the set of semantically meaningful terms that appear before the\n * next comma, or between the parens of a function invokation.\n */\nconst parseExpression = (() => {\n  const IS_IDENT_RE = /^(\\-\\-|[a-z\\u0240-\\uffff])/i;\n  const IS_OPERATOR_RE = /^([\\*\\+\\/]|[\\-]\\s)/i;\n  const IS_EXPRESSION_END_RE = /^[\\),]/;\n  const FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';\n  const HEX_FIRST_TOKEN = '#';\n  return (inputString) => {\n    const terms = [];\n    while (inputString.length) {\n      inputString = inputString.trim();\n      if (IS_EXPRESSION_END_RE.test(inputString)) {\n        break;\n      } else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n        const { nodes, remainingInput } = parseFunctionArguments(inputString);\n        inputString = remainingInput;\n        terms.push({\n          type: 'function',\n          name: { type: 'ident', value: 'calc' },\n          arguments: nodes,\n        });\n      } else if (IS_IDENT_RE.test(inputString)) {\n        const identParseResult = parseIdent(inputString);\n        const identNode = identParseResult.nodes[0];\n        inputString = identParseResult.remainingInput;\n        if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n          const { nodes, remainingInput } = parseFunctionArguments(inputString);\n          terms.push({ type: 'function', name: identNode, arguments: nodes });\n          inputString = remainingInput;\n        } else {\n          terms.push(identNode);\n        }\n      } else if (IS_OPERATOR_RE.test(inputString)) {\n        // Operators are always a single character, so just pluck them out:\n        terms.push({ type: 'operator', value: inputString[0] });\n        inputString = inputString.slice(1);\n      } else {\n        const { nodes, remainingInput } =\n          inputString[0] === HEX_FIRST_TOKEN\n            ? parseHex(inputString)\n            : parseNumber(inputString);\n        // The remaining string may not have had any meaningful content. Exit\n        // early if this is the case:\n        if (nodes.length === 0) {\n          break;\n        }\n        terms.push(nodes[0]);\n        inputString = remainingInput;\n      }\n    }\n    return {\n      nodes: [{ type: 'expression', terms }],\n      remainingInput: inputString,\n    };\n  };\n})();\n/**\n * An ident is something like a function name or the keyword \"auto\".\n */\nconst parseIdent = (() => {\n  const NOT_IDENT_RE = /[^a-z0-9_\\-\\u0240-\\uffff]/i;\n  return (inputString) => {\n    const match = inputString.match(NOT_IDENT_RE);\n    const ident =\n      match == null ? inputString : inputString.substr(0, match.index);\n    const remainingInput = match == null ? '' : inputString.substr(match.index);\n    return { nodes: [{ type: 'ident', value: ident }], remainingInput };\n  };\n})();\n/**\n * Parses a number. A number value can be expressed with an integer or\n * non-integer syntax, and usually includes a unit (but does not strictly\n * require one for our purposes).\n */\nconst parseNumber = (() => {\n  // @see https://www.w3.org/TR/css-syntax/#number-token-diagram\n  const VALUE_RE = /[\\+\\-]?(\\d+[\\.]\\d+|\\d+|[\\.]\\d+)([eE][\\+\\-]?\\d+)?/;\n  const UNIT_RE = /^[a-z%]+/i;\n  const ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;\n  return (inputString) => {\n    const valueMatch = inputString.match(VALUE_RE);\n    const value = valueMatch == null ? '0' : valueMatch[0];\n    inputString = value == null ? inputString : inputString.slice(value.length);\n    const unitMatch = inputString.match(UNIT_RE);\n    let unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;\n    const remainingInput =\n      unitMatch == null ? inputString : inputString.slice(unit.length);\n    if (unit != null && !ALLOWED_UNITS.test(unit)) {\n      unit = null;\n    }\n    return {\n      nodes: [\n        {\n          type: 'number',\n          number: parseFloat(value) || 0,\n          unit: unit,\n        },\n      ],\n      remainingInput,\n    };\n  };\n})();\n/**\n * Parses a hexidecimal-encoded color in 3, 6 or 8 digit form.\n */\nconst parseHex = (() => {\n  // TODO(cdata): right now we don't actually enforce the number of digits\n  const HEX_RE = /^[a-f0-9]*/i;\n  return (inputString) => {\n    inputString = inputString.slice(1).trim();\n    const hexMatch = inputString.match(HEX_RE);\n    const nodes = hexMatch == null ? [] : [{ type: 'hex', value: hexMatch[0] }];\n    return {\n      nodes,\n      remainingInput:\n        hexMatch == null ? inputString : inputString.slice(hexMatch[0].length),\n    };\n  };\n})();\n/**\n * Parses arguments passed to a function invokation (e.g., the expressions\n * within a matched set of parens).\n */\nconst parseFunctionArguments = (inputString) => {\n  const expressionNodes = [];\n  // Consume the opening paren\n  inputString = inputString.slice(1).trim();\n  while (inputString.length) {\n    const expressionParseResult = parseExpression(inputString);\n    expressionNodes.push(expressionParseResult.nodes[0]);\n    inputString = expressionParseResult.remainingInput.trim();\n    if (inputString[0] === ',') {\n      inputString = inputString.slice(1).trim();\n    } else if (inputString[0] === ')') {\n      // Consume the closing paren and stop parsing\n      inputString = inputString.slice(1);\n      break;\n    }\n  }\n  return { nodes: expressionNodes, remainingInput: inputString };\n};\nconst $visitedTypes = Symbol('visitedTypes');\n/**\n * An ASTWalker walks an array of ASTs such as the type produced by\n * parseExpressions and invokes a callback for a configured set of nodes that\n * the user wishes to \"visit\" during the walk.\n */\nclass ASTWalker {\n  constructor(visitedTypes) {\n    this[$visitedTypes] = visitedTypes;\n  }\n  /**\n   * Walk the given set of ASTs, and invoke the provided callback for nodes that\n   * match the filtered set that the ASTWalker was constructed with.\n   */\n  walk(ast, callback) {\n    const remaining = ast.slice();\n    while (remaining.length) {\n      const next = remaining.shift();\n      if (this[$visitedTypes].indexOf(next.type) > -1) {\n        callback(next);\n      }\n      switch (next.type) {\n        case 'expression':\n          remaining.unshift(...next.terms);\n          break;\n        case 'function':\n          remaining.unshift(next.name, ...next.arguments);\n          break;\n      }\n    }\n  }\n}\nconst ZERO = Object.freeze({ type: 'number', number: 0, unit: null });\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Ensures that a given number is expressed in radians. If the number is already\n * in radians, does nothing. If the value is in degrees, converts it to radians.\n * If the value has no specified unit, the unit is assumed to be radians. If the\n * value is not in radians or degrees, the value is resolved as 0 radians.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nconst degreesToRadians = (numberNode, fallbackRadianValue = 0) => {\n  let { number, unit } = numberNode;\n  if (!isFinite(number)) {\n    number = fallbackRadianValue;\n    unit = 'rad';\n  } else if (numberNode.unit === 'rad' || numberNode.unit == null) {\n    return numberNode;\n  }\n  const valueIsDegrees = unit === 'deg' && number != null;\n  const value = valueIsDegrees ? number : 0;\n  const radians = (value * Math.PI) / 180;\n  return { type: 'number', number: radians, unit: 'rad' };\n};\n/**\n * Converts a given length to meters. Currently supported input units are\n * meters, centimeters and millimeters.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nconst lengthToBaseMeters = (numberNode, fallbackMeterValue = 0) => {\n  let { number, unit } = numberNode;\n  if (!isFinite(number)) {\n    number = fallbackMeterValue;\n    unit = 'm';\n  } else if (numberNode.unit === 'm') {\n    return numberNode;\n  }\n  let scale;\n  switch (unit) {\n    default:\n      scale = 1;\n      break;\n    case 'cm':\n      scale = 1 / 100;\n      break;\n    case 'mm':\n      scale = 1 / 1000;\n      break;\n  }\n  const value = scale * number;\n  return { type: 'number', number: value, unit: 'm' };\n};\n/**\n * Normalizes the unit of a given input number so that it is expressed in a\n * preferred unit. For length nodes, the return value will be expressed in\n * meters. For angle nodes, the return value will be expressed in radians.\n *\n * Also takes a fallback number that is used when the number value is not a\n * valid number or when the unit of the given number cannot be normalized.\n */\nconst normalizeUnit = (() => {\n  const identity = (node) => node;\n  const unitNormalizers = {\n    rad: identity,\n    deg: degreesToRadians,\n    m: identity,\n    mm: lengthToBaseMeters,\n    cm: lengthToBaseMeters,\n  };\n  return (node, fallback = ZERO) => {\n    if (!isFinite(node.number)) {\n      node.number = fallback.number;\n      node.unit = fallback.unit;\n    }\n    const { unit } = node;\n    if (unit == null) {\n      return node;\n    }\n    const normalize = unitNormalizers[unit];\n    if (normalize == null) {\n      return fallback;\n    }\n    return normalize(node);\n  };\n})();\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The Hotspot object is a reference-counted slot. If decrement() returns true,\n * it should be removed from the tree so it can be garbage-collected.\n */\nclass Hotspot extends CSS2DObject {\n  constructor(config) {\n    super(document.createElement('div'));\n    this.normal = new Vector3(0, 1, 0);\n    this.initialized = false;\n    this.referenceCount = 1;\n    this.pivot = document.createElement('div');\n    this.slot = document.createElement('slot');\n    this.element.classList.add('annotation-wrapper');\n    this.slot.name = config.name;\n    this.element.appendChild(this.pivot);\n    this.pivot.appendChild(this.slot);\n    this.updatePosition(config.position);\n    this.updateNormal(config.normal);\n  }\n  get facingCamera() {\n    return !this.element.classList.contains('hide');\n  }\n  /**\n   * Sets the hotspot to be in the highly visible foreground state.\n   */\n  show() {\n    if (!this.facingCamera || !this.initialized) {\n      this.updateVisibility(true);\n    }\n  }\n  /**\n   * Sets the hotspot to be in the diminished background state.\n   */\n  hide() {\n    if (this.facingCamera || !this.initialized) {\n      this.updateVisibility(false);\n    }\n  }\n  /**\n   * Call this when adding elements to the same slot to keep track.\n   */\n  increment() {\n    this.referenceCount++;\n  }\n  /**\n   * Call this when removing elements from the slot; returns true when the slot\n   * is unused.\n   */\n  decrement() {\n    if (this.referenceCount > 0) {\n      --this.referenceCount;\n    }\n    return this.referenceCount === 0;\n  }\n  /**\n   * Change the position of the hotspot to the input string, in the same format\n   * as the data-position attribute.\n   */\n  updatePosition(position) {\n    if (position == null) return;\n    const positionNodes = parseExpressions(position)[0].terms;\n    for (let i = 0; i < 3; ++i) {\n      this.position.setComponent(i, normalizeUnit(positionNodes[i]).number);\n    }\n    this.updateMatrixWorld();\n  }\n  /**\n   * Change the hotspot's normal to the input string, in the same format as the\n   * data-normal attribute.\n   */\n  updateNormal(normal) {\n    if (normal == null) return;\n    const normalNodes = parseExpressions(normal)[0].terms;\n    for (let i = 0; i < 3; ++i) {\n      this.normal.setComponent(i, normalizeUnit(normalNodes[i]).number);\n    }\n  }\n  orient(radians) {\n    this.pivot.style.transform = `rotate(${radians}rad)`;\n  }\n  updateVisibility(show) {\n    // NOTE: IE11 doesn't support a second arg for classList.toggle\n    if (show) {\n      this.element.classList.remove('hide');\n    } else {\n      this.element.classList.add('hide');\n    }\n    // NOTE: ShadyDOM doesn't support slot.assignedElements, otherwise we could\n    // use that here.\n    this.slot.assignedNodes().forEach((node) => {\n      if (node.nodeType !== Node.ELEMENT_NODE) {\n        return;\n      }\n      const element = node;\n      // Visibility attribute can be configured per-node in the hotspot:\n      const visibilityAttribute = element.dataset.visibilityAttribute;\n      if (visibilityAttribute != null) {\n        const attributeName = `data-${visibilityAttribute}`;\n        // NOTE: IE11 doesn't support toggleAttribute\n        if (show) {\n          element.setAttribute(attributeName, '');\n        } else {\n          element.removeAttribute(attributeName);\n        }\n      }\n      element.dispatchEvent(\n        new CustomEvent('hotspot-visibility', {\n          detail: {\n            visible: show,\n          },\n        }),\n      );\n    });\n    this.initialized = true;\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Gets a scale value to perform inverse quantization of a vertex value\n * Reference:\n * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n * @param buffer A gltf vertex buffer\n * @returns A scale value based on KHR_mesh_quantization or 1 if the buffer is\n *     not quantized.\n */\nconst getNormalizedComponentScale = (buffer) => {\n  if (!buffer.normalized) {\n    return 1;\n  }\n  const array = buffer.array;\n  if (array instanceof Int8Array) {\n    return 1 / 127;\n  } else if (array instanceof Uint8Array) {\n    return 1 / 255;\n  } else if (array instanceof Int16Array) {\n    return 1 / 32767;\n  } else if (array instanceof Uint16Array) {\n    return 1 / 65535;\n  }\n  return 1;\n};\n/**\n * Performs a reduction across all the vertices of the input model and all its\n * children. The supplied function takes the reduced value and a vertex and\n * returns the newly reduced value. The value is initialized as zero.\n *\n * Adapted from Three.js, @see https://github.com/mrdoob/three.js/blob/7e0a78beb9317e580d7fa4da9b5b12be051c6feb/src/math/Box3.js#L241\n */\nconst reduceVertices = (model, func, initialValue) => {\n  let value = initialValue;\n  const vertex = new Vector3();\n  model.traverse((object) => {\n    let i, l;\n    object.updateWorldMatrix(false, false);\n    const geometry = object.geometry;\n    if (geometry !== undefined) {\n      if (geometry.isGeometry) {\n        const vertices = geometry.vertices;\n        for (i = 0, l = vertices.length; i < l; i++) {\n          vertex.copy(vertices[i]);\n          vertex.applyMatrix4(object.matrixWorld);\n          value = func(value, vertex);\n        }\n      } else if (geometry.isBufferGeometry) {\n        const { position } = geometry.attributes;\n        if (position !== undefined) {\n          const scale = getNormalizedComponentScale(position);\n          for (i = 0, l = position.count; i < l; i++) {\n            vertex.fromBufferAttribute(position, i);\n            vertex.multiplyScalar(scale);\n            vertex.applyMatrix4(object.matrixWorld);\n            value = func(value, vertex);\n          }\n        }\n      }\n    }\n  });\n  return value;\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Nothing within Offset of the bottom of the scene casts a shadow\n// (this is to avoid having a baked-in shadow plane cast its own shadow).\nconst OFFSET = 0.002;\n// The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6;\n// Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimesion multiplied\n// by this scale factor.\nconst ANIMATION_SCALING = 2;\n/**\n * The Shadow class creates a shadow that fits a given scene and follows a\n * target. This shadow will follow the scene without any updates needed so long\n * as the shadow and scene are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the scene's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\nclass Shadow extends DirectionalLight {\n  constructor(scene, softness, side) {\n    super();\n    this.shadowMaterial = new ShadowMaterial();\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.shadowScale = 1;\n    this.isAnimated = false;\n    this.side = 'bottom';\n    this.needsUpdate = false;\n    // We use the light only to cast a shadow, not to light the scene.\n    this.intensity = 0;\n    this.castShadow = true;\n    this.frustumCulled = false;\n    this.floor = new Mesh(new PlaneGeometry(), this.shadowMaterial);\n    this.floor.rotateX(-Math.PI / 2);\n    this.floor.receiveShadow = true;\n    this.floor.castShadow = false;\n    this.floor.frustumCulled = false;\n    this.add(this.floor);\n    scene.target.add(this);\n    this.target = scene.target;\n    this.setScene(scene, softness, side);\n  }\n  /**\n   * Update the shadow's size and position for a new scene. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n  setScene(scene, softness, side) {\n    this.side = side;\n    this.isAnimated = scene.animationNames.length > 0;\n    this.boundingBox.copy(scene.boundingBox);\n    this.size.copy(scene.size);\n    if (this.side === 'back') {\n      const { min, max } = this.boundingBox;\n      [min.y, min.z] = [min.z, min.y];\n      [max.y, max.z] = [max.z, max.y];\n      [this.size.y, this.size.z] = [this.size.z, this.size.y];\n      this.rotation.x = Math.PI / 2;\n      this.rotation.y = Math.PI;\n    } else {\n      this.rotation.x = 0;\n      this.rotation.y = 0;\n    }\n    const { boundingBox, size } = this;\n    if (this.isAnimated) {\n      const maxDimension = Math.max(size.x, size.y, size.z) * ANIMATION_SCALING;\n      size.y = maxDimension;\n      boundingBox.expandByVector(\n        size.subScalar(maxDimension).multiplyScalar(-0.5),\n      );\n      boundingBox.max.y = boundingBox.min.y + maxDimension;\n      size.set(maxDimension, maxDimension, maxDimension);\n    }\n    boundingBox.getCenter(this.floor.position);\n    const shadowOffset = boundingBox.max.y + size.y * OFFSET;\n    if (side === 'bottom') {\n      this.position.y = shadowOffset;\n      this.position.z = 0;\n    } else {\n      this.position.y = 0;\n      this.position.z = shadowOffset;\n    }\n    this.setSoftness(softness);\n  }\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n  setSoftness(softness) {\n    const resolution = Math.pow(\n      2,\n      LOG_MAX_RESOLUTION - softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION),\n    );\n    this.setMapSize(resolution);\n  }\n  /**\n   * Lower-level version of the above function.\n   */\n  setMapSize(maxMapSize) {\n    const { camera, mapSize, map } = this.shadow;\n    const { size, boundingBox } = this;\n    // This feels like a three.js bug; changing the mapSize has no effect unless\n    // the map is manually disposed of.\n    if (map != null) {\n      map.dispose();\n      this.shadow.map = null;\n    }\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n    const width = Math.floor(\n      size.x > size.z ? maxMapSize : (maxMapSize * size.x) / size.z,\n    );\n    const height = Math.floor(\n      size.x > size.z ? (maxMapSize * size.z) / size.x : maxMapSize,\n    );\n    mapSize.set(width, height);\n    // These pads account for the softening radius around the shadow.\n    const widthPad = (2.5 * size.x) / width;\n    const heightPad = (2.5 * size.z) / height;\n    camera.left = -boundingBox.max.x - widthPad;\n    camera.right = -boundingBox.min.x + widthPad;\n    camera.bottom = boundingBox.min.z - heightPad;\n    camera.top = boundingBox.max.z + heightPad;\n    this.setScaleAndOffset(this.shadowScale, 0);\n    this.floor.scale.set(size.x + 2 * widthPad, size.z + 2 * heightPad, 1);\n    this.needsUpdate = true;\n    this.shadow.needsUpdate = true;\n  }\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n  setIntensity(intensity) {\n    this.shadowMaterial.opacity = intensity;\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n  getIntensity() {\n    return this.shadowMaterial.opacity;\n  }\n  /**\n   * The shadow does not rotate with its parent transforms, so the rotation must\n   * be manually updated here if it rotates in world space. The input is its\n   * absolute orientation about the Y-axis (other rotations are not supported).\n   */\n  setRotation(radiansY) {\n    if (this.side !== 'bottom') {\n      // We don't support rotation about a horizontal axis yet.\n      this.shadow.camera.up.set(0, 1, 0);\n      this.shadow.updateMatrices(this);\n      return;\n    }\n    this.shadow.camera.up.set(Math.sin(radiansY), 0, Math.cos(radiansY));\n    this.shadow.updateMatrices(this);\n  }\n  /**\n   * The scale is also not inherited from parents, so it must be set here in\n   * accordance with any transforms. An offset can also be specified to move the\n   * shadow vertically relative to the bottom of the scene. Positive is up, so\n   * values are generally negative.\n   */\n  setScaleAndOffset(scale, offset) {\n    const sizeY = this.size.y;\n    const { camera } = this.shadow;\n    this.shadowScale = scale;\n    camera.near = 0;\n    camera.far = sizeY - offset / scale;\n    camera.updateProjectionMatrix();\n    camera.scale.setScalar(scale);\n    // Floor plane is up slightly from the bottom of the bounding box to avoid\n    // Z-fighting with baked-in shadows and to stay inside the shadow camera.\n    const shadowOffset = sizeY * OFFSET;\n    this.floor.position.y = 2 * shadowOffset - camera.far;\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_FOV_DEG = 45;\nconst DEFAULT_HALF_FOV = ((DEFAULT_FOV_DEG / 2) * Math.PI) / 180;\nconst SAFE_RADIUS_RATIO = Math.sin(DEFAULT_HALF_FOV);\nconst DEFAULT_TAN_FOV = Math.tan(DEFAULT_HALF_FOV);\nconst view = new Vector3();\nconst target = new Vector3();\nconst normalWorld = new Vector3();\nconst raycaster = new Raycaster();\nconst vector3$1 = new Vector3();\nconst ndc = new Vector2();\n/**\n * A THREE.Scene object that takes a Model and CanvasHTMLElement and\n * constructs a framed scene based off of the canvas dimensions.\n * Provides lights and cameras to be used in a renderer.\n */\nclass ModelScene extends Scene {\n  constructor({ canvas, element, width, height }) {\n    super();\n    this.context = null;\n    this.annotationRenderer = new CSS2DRenderer();\n    this.schemaElement = document.createElement('script');\n    this.width = 1;\n    this.height = 1;\n    this.aspect = 1;\n    this.renderCount = 0;\n    this.externalRenderer = null;\n    // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n    this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    this.xrCamera = null;\n    this.url = null;\n    this.target = new Object3D();\n    this.modelContainer = new Object3D();\n    this.animationNames = [];\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.idealCameraDistance = 0;\n    this.fieldOfViewAspect = 0;\n    this.framedFieldOfView = DEFAULT_FOV_DEG;\n    this.shadow = null;\n    this.shadowIntensity = 0;\n    this.shadowSoftness = 1;\n    this.exposure = 1;\n    this.canScale = true;\n    this.tightBounds = false;\n    this.isDirty = false;\n    this.goalTarget = new Vector3();\n    this.targetDamperX = new Damper();\n    this.targetDamperY = new Damper();\n    this.targetDamperZ = new Damper();\n    this._currentGLTF = null;\n    this.cancelPendingSourceChange = null;\n    this.animationsByName = new Map();\n    this.currentAnimationAction = null;\n    this.name = 'ModelScene';\n    this.element = element;\n    this.canvas = canvas;\n    // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n    this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    this.camera.name = 'MainCamera';\n    this.add(this.target);\n    this.setSize(width, height);\n    this.target.name = 'Target';\n    this.modelContainer.name = 'ModelContainer';\n    this.target.add(this.modelContainer);\n    this.mixer = new AnimationMixer(this.modelContainer);\n    const { domElement } = this.annotationRenderer;\n    const { style } = domElement;\n    style.display = 'none';\n    style.pointerEvents = 'none';\n    style.position = 'absolute';\n    style.top = '0';\n    this.element.shadowRoot.querySelector('.default').appendChild(domElement);\n    this.schemaElement.setAttribute('type', 'application/ld+json');\n  }\n  /**\n   * Function to create the context lazily, as when there is only one\n   * <model-viewer> element, the renderer's 3D context can be displayed\n   * directly. This extra context is necessary to copy the renderings into when\n   * there are more than one.\n   */\n  createContext() {\n    this.context = this.canvas.getContext('2d');\n  }\n  getCamera() {\n    return this.xrCamera != null ? this.xrCamera : this.camera;\n  }\n  queueRender() {\n    this.isDirty = true;\n  }\n  shouldRender() {\n    return this.isDirty;\n  }\n  hasRendered() {\n    this.isDirty = false;\n  }\n  /**\n   * Pass in a THREE.Object3D to be controlled\n   * by this model.\n   */\n  async setObject(model) {\n    this.reset();\n    this.modelContainer.add(model);\n    await this.setupScene();\n  }\n  /**\n   * Sets the model via URL.\n   */\n  async setSource(url, progressCallback = () => {}) {\n    if (!url || url === this.url) {\n      progressCallback(1);\n      return;\n    }\n    this.reset();\n    this.url = url;\n    if (this.externalRenderer != null) {\n      const framingInfo = await this.externalRenderer.load(progressCallback);\n      this.idealCameraDistance = framingInfo.framedRadius / SAFE_RADIUS_RATIO;\n      this.fieldOfViewAspect = framingInfo.fieldOfViewAspect;\n      this.frameModel();\n      this.dispatchEvent({ type: 'model-load', url: this.url });\n      return;\n    }\n    // If we have pending work due to a previous source change in progress,\n    // cancel it so that we do not incur a race condition:\n    if (this.cancelPendingSourceChange != null) {\n      this.cancelPendingSourceChange();\n      this.cancelPendingSourceChange = null;\n    }\n    let gltf;\n    try {\n      gltf = await new Promise(async (resolve, reject) => {\n        this.cancelPendingSourceChange = () => reject();\n        try {\n          const result = await this.element[$renderer].loader.load(\n            url,\n            this.element,\n            progressCallback,\n          );\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    } catch (error) {\n      if (error == null) {\n        // Loading was cancelled, so silently return\n        return;\n      }\n      throw error;\n    }\n    this.reset();\n    this.url = url;\n    this._currentGLTF = gltf;\n    if (gltf != null) {\n      this.modelContainer.add(gltf.scene);\n    }\n    const { animations } = gltf;\n    const animationsByName = new Map();\n    const animationNames = [];\n    for (const animation of animations) {\n      animationsByName.set(animation.name, animation);\n      animationNames.push(animation.name);\n    }\n    this.animations = animations;\n    this.animationsByName = animationsByName;\n    this.animationNames = animationNames;\n    await this.setupScene();\n  }\n  async setupScene() {\n    this.updateBoundingBox();\n    let target = null;\n    if (this.tightBounds === true) {\n      await this.element.requestUpdate('cameraTarget');\n      target = this.getTarget();\n    }\n    this.updateFraming(target);\n    this.frameModel();\n    this.updateShadow();\n    this.setShadowIntensity(this.shadowIntensity);\n    this.dispatchEvent({ type: 'model-load', url: this.url });\n  }\n  reset() {\n    this.url = null;\n    this.queueRender();\n    if (this.shadow != null) {\n      this.shadow.setIntensity(0);\n    }\n    const gltf = this._currentGLTF;\n    // Remove all current children\n    if (gltf != null) {\n      for (const child of this.modelContainer.children) {\n        this.modelContainer.remove(child);\n      }\n      gltf.dispose();\n      this._currentGLTF = null;\n    }\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction = null;\n    }\n    this.mixer.stopAllAction();\n    this.mixer.uncacheRoot(this);\n  }\n  get currentGLTF() {\n    return this._currentGLTF;\n  }\n  /**\n   * Updates the ModelScene for a new container size in CSS pixels.\n   */\n  setSize(width, height) {\n    if (this.width === width && this.height === height) {\n      return;\n    }\n    this.width = Math.max(width, 1);\n    this.height = Math.max(height, 1);\n    this.annotationRenderer.setSize(width, height);\n    this.aspect = this.width / this.height;\n    this.frameModel();\n    if (this.externalRenderer != null) {\n      const dpr = resolveDpr();\n      this.externalRenderer.resize(width * dpr, height * dpr);\n    }\n    this.queueRender();\n  }\n  updateBoundingBox() {\n    this.target.remove(this.modelContainer);\n    if (this.tightBounds === true) {\n      const bound = (box, vertex) => {\n        return box.expandByPoint(vertex);\n      };\n      this.boundingBox = reduceVertices(this.modelContainer, bound, new Box3());\n    } else {\n      this.boundingBox.setFromObject(this.modelContainer);\n    }\n    this.boundingBox.getSize(this.size);\n    this.target.add(this.modelContainer);\n  }\n  /**\n   * Calculates the idealCameraDistance and fieldOfViewAspect that allows the 3D\n   * object to be framed tightly in a 2D window of any aspect ratio without\n   * clipping at any camera orbit. The camera's center target point can be\n   * optionally specified. If no center is specified, it defaults to the center\n   * of the bounding box, which means asymmetric models will tend to be tight on\n   * one side instead of both. Proper choice of center can correct this.\n   */\n  updateFraming(center = null) {\n    this.target.remove(this.modelContainer);\n    if (center == null) {\n      center = this.boundingBox.getCenter(new Vector3());\n    }\n    const radiusSquared = (value, vertex) => {\n      return Math.max(value, center.distanceToSquared(vertex));\n    };\n    const framedRadius = Math.sqrt(\n      reduceVertices(this.modelContainer, radiusSquared, 0),\n    );\n    this.idealCameraDistance = framedRadius / SAFE_RADIUS_RATIO;\n    const horizontalFov = (value, vertex) => {\n      vertex.sub(center);\n      const radiusXZ = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);\n      return Math.max(\n        value,\n        radiusXZ / (this.idealCameraDistance - Math.abs(vertex.y)),\n      );\n    };\n    this.fieldOfViewAspect =\n      reduceVertices(this.modelContainer, horizontalFov, 0) / DEFAULT_TAN_FOV;\n    this.target.add(this.modelContainer);\n  }\n  /**\n   * Set's the framedFieldOfView based on the aspect ratio of the window in\n   * order to keep the model fully visible at any camera orientation.\n   */\n  frameModel() {\n    const vertical =\n      DEFAULT_TAN_FOV * Math.max(1, this.fieldOfViewAspect / this.aspect);\n    this.framedFieldOfView = (2 * Math.atan(vertical) * 180) / Math.PI;\n  }\n  getNDC(clientX, clientY) {\n    if (this.xrCamera != null) {\n      ndc.set(clientX / window.screen.width, clientY / window.screen.height);\n    } else {\n      const rect = this.element.getBoundingClientRect();\n      ndc.set(\n        (clientX - rect.x) / this.width,\n        (clientY - rect.y) / this.height,\n      );\n    }\n    ndc.multiplyScalar(2).subScalar(1);\n    ndc.y *= -1;\n    return ndc;\n  }\n  /**\n   * Returns the size of the corresponding canvas element.\n   */\n  getSize() {\n    return { width: this.width, height: this.height };\n  }\n  /**\n   * Sets the point in model coordinates the model should orbit/pivot around.\n   */\n  setTarget(modelX, modelY, modelZ) {\n    this.goalTarget.set(-modelX, -modelY, -modelZ);\n  }\n  /**\n   * Set the decay time of, affects the speed of target transitions.\n   */\n  setTargetDamperDecayTime(decayMilliseconds) {\n    this.targetDamperX.setDecayTime(decayMilliseconds);\n    this.targetDamperY.setDecayTime(decayMilliseconds);\n    this.targetDamperZ.setDecayTime(decayMilliseconds);\n  }\n  /**\n   * Gets the point in model coordinates the model should orbit/pivot around.\n   */\n  getTarget() {\n    return vector3$1.copy(this.goalTarget).multiplyScalar(-1);\n  }\n  /**\n   * Shifts the model to the target point immediately instead of easing in.\n   */\n  jumpToGoal() {\n    this.updateTarget(SETTLING_TIME);\n  }\n  /**\n   * This should be called every frame with the frame delta to cause the target\n   * to transition to its set point.\n   */\n  updateTarget(delta) {\n    const goal = this.goalTarget;\n    const target = this.target.position;\n    if (!goal.equals(target)) {\n      const radius = this.idealCameraDistance;\n      let { x, y, z } = target;\n      x = this.targetDamperX.update(x, goal.x, delta, radius);\n      y = this.targetDamperY.update(y, goal.y, delta, radius);\n      z = this.targetDamperZ.update(z, goal.z, delta, radius);\n      this.target.position.set(x, y, z);\n      this.target.updateMatrixWorld();\n      this.setShadowRotation(this.yaw);\n      this.queueRender();\n    }\n  }\n  /**\n   * Yaw the +z (front) of the model toward the indicated world coordinates.\n   */\n  pointTowards(worldX, worldZ) {\n    const { x, z } = this.position;\n    this.yaw = Math.atan2(worldX - x, worldZ - z);\n  }\n  /**\n   * Yaw is the scene's orientation about the y-axis, around the rotation\n   * center.\n   */\n  set yaw(radiansY) {\n    this.rotation.y = radiansY;\n    this.updateMatrixWorld(true);\n    this.setShadowRotation(radiansY);\n    this.queueRender();\n  }\n  get yaw() {\n    return this.rotation.y;\n  }\n  set animationTime(value) {\n    this.mixer.setTime(value);\n  }\n  get animationTime() {\n    if (this.currentAnimationAction != null) {\n      return this.currentAnimationAction.time;\n    }\n    return 0;\n  }\n  get duration() {\n    if (\n      this.currentAnimationAction != null &&\n      this.currentAnimationAction.getClip()\n    ) {\n      return this.currentAnimationAction.getClip().duration;\n    }\n    return 0;\n  }\n  get hasActiveAnimation() {\n    return this.currentAnimationAction != null;\n  }\n  /**\n   * Plays an animation if there are any associated with the current model.\n   * Accepts an optional string name of an animation to play. If no name is\n   * provided, or if no animation is found by the given name, always falls back\n   * to playing the first animation.\n   */\n  playAnimation(name = null, crossfadeTime = 0) {\n    if (this._currentGLTF == null) {\n      return;\n    }\n    const { animations } = this;\n    if (animations == null || animations.length === 0) {\n      console.warn(\n        `Cannot play animation (model does not have any animations)`,\n      );\n      return;\n    }\n    let animationClip = null;\n    if (name != null) {\n      animationClip = this.animationsByName.get(name);\n    }\n    if (animationClip == null) {\n      animationClip = animations[0];\n    }\n    try {\n      const { currentAnimationAction: lastAnimationAction } = this;\n      const action = this.mixer.clipAction(animationClip, this);\n      this.currentAnimationAction = action;\n      if (this.element.paused) {\n        this.mixer.stopAllAction();\n      } else if (\n        lastAnimationAction != null &&\n        action !== lastAnimationAction\n      ) {\n        action.crossFadeFrom(lastAnimationAction, crossfadeTime, false);\n      }\n      action.enabled = true;\n      action.play();\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  stopAnimation() {\n    this.currentAnimationAction = null;\n    this.mixer.stopAllAction();\n  }\n  updateAnimation(step) {\n    this.mixer.update(step);\n  }\n  /**\n   * Call if the object has been changed in such a way that the shadow's shape\n   * has changed (not a rotation about the Y axis).\n   */\n  updateShadow() {\n    const shadow = this.shadow;\n    if (shadow != null) {\n      const side = this.element.arPlacement === 'wall' ? 'back' : 'bottom';\n      shadow.setScene(this, this.shadowSoftness, side);\n      shadow.setRotation(this.yaw);\n    }\n  }\n  /**\n   * Sets the shadow's intensity, lazily creating the shadow as necessary.\n   */\n  setShadowIntensity(shadowIntensity) {\n    this.shadowIntensity = shadowIntensity;\n    if (this._currentGLTF == null) {\n      return;\n    }\n    if (shadowIntensity <= 0 && this.shadow == null) {\n      return;\n    }\n    if (this.shadow == null) {\n      const side = this.element.arPlacement === 'wall' ? 'back' : 'bottom';\n      this.shadow = new Shadow(this, this.shadowSoftness, side);\n      this.shadow.setRotation(this.yaw);\n    }\n    this.shadow.setIntensity(shadowIntensity);\n  }\n  /**\n   * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n   * shadow's resolution. This involves reallocation, so it should not be\n   * changed frequently. Softer shadows are cheaper to render.\n   */\n  setShadowSoftness(softness) {\n    this.shadowSoftness = softness;\n    const shadow = this.shadow;\n    if (shadow != null) {\n      shadow.setSoftness(softness);\n    }\n  }\n  /**\n   * The shadow must be rotated manually to match any global rotation applied to\n   * this model. The input is the global orientation about the Y axis.\n   */\n  setShadowRotation(radiansY) {\n    const shadow = this.shadow;\n    if (shadow != null) {\n      shadow.setRotation(radiansY);\n    }\n  }\n  /**\n   * Call to check if the shadow needs an updated render; returns true if an\n   * update is needed and resets the state.\n   */\n  isShadowDirty() {\n    const shadow = this.shadow;\n    if (shadow == null) {\n      return false;\n    } else {\n      const { needsUpdate } = shadow;\n      shadow.needsUpdate = false;\n      return needsUpdate;\n    }\n  }\n  /**\n   * Shift the floor vertically from the bottom of the model's bounding box by\n   * offset (should generally be negative).\n   */\n  setShadowScaleAndOffset(scale, offset) {\n    const shadow = this.shadow;\n    if (shadow != null) {\n      shadow.setScaleAndOffset(scale, offset);\n    }\n  }\n  get raycaster() {\n    return raycaster;\n  }\n  /**\n   * This method returns the world position and model-space normal of the point\n   * on the mesh corresponding to the input pixel coordinates given relative to\n   * the model-viewer element. If the mesh is not hit, the result is null.\n   */\n  positionAndNormalFromPoint(ndcPosition, object = this) {\n    this.raycaster.setFromCamera(ndcPosition, this.getCamera());\n    const hits = this.raycaster.intersectObject(object, true);\n    if (hits.length === 0) {\n      return null;\n    }\n    const hit = hits[0];\n    if (hit.face == null) {\n      return null;\n    }\n    hit.face.normal.applyNormalMatrix(\n      new Matrix3().getNormalMatrix(hit.object.matrixWorld),\n    );\n    return { position: hit.point, normal: hit.face.normal };\n  }\n  /**\n   * The following methods are for operating on the set of Hotspot objects\n   * attached to the scene. These come from DOM elements, provided to slots by\n   * the Annotation Mixin.\n   */\n  addHotspot(hotspot) {\n    this.target.add(hotspot);\n    // This happens automatically in render(), but we do it early so that\n    // the slots appear in the shadow DOM and the elements get attached,\n    // allowing us to dispatch events on them.\n    this.annotationRenderer.domElement.appendChild(hotspot.element);\n  }\n  removeHotspot(hotspot) {\n    this.target.remove(hotspot);\n  }\n  /**\n   * Helper method to apply a function to all hotspots.\n   */\n  forHotspots(func) {\n    const { children } = this.target;\n    for (let i = 0, l = children.length; i < l; i++) {\n      const hotspot = children[i];\n      if (hotspot instanceof Hotspot) {\n        func(hotspot);\n      }\n    }\n  }\n  /**\n   * Update the CSS visibility of the hotspots based on whether their normals\n   * point toward the camera.\n   */\n  updateHotspots(viewerPosition) {\n    this.forHotspots((hotspot) => {\n      view.copy(viewerPosition);\n      target.setFromMatrixPosition(hotspot.matrixWorld);\n      view.sub(target);\n      normalWorld\n        .copy(hotspot.normal)\n        .transformDirection(this.target.matrixWorld);\n      if (view.dot(normalWorld) < 0) {\n        hotspot.hide();\n      } else {\n        hotspot.show();\n      }\n    });\n  }\n  /**\n   * Rotate all hotspots to an absolute orientation given by the input number of\n   * radians. Zero returns them to upright.\n   */\n  orientHotspots(radians) {\n    this.forHotspots((hotspot) => {\n      hotspot.orient(radians);\n    });\n  }\n  /**\n   * Set the rendering visibility of all hotspots. This is used to hide them\n   * during transitions and such.\n   */\n  setHotspotsVisibility(visible) {\n    this.forHotspots((hotspot) => {\n      hotspot.visible = visible;\n    });\n  }\n  updateSchema(src) {\n    var _a;\n    const { schemaElement, element } = this;\n    const { alt, poster, iosSrc } = element;\n    if (src != null) {\n      const encoding = [\n        {\n          '@type': 'MediaObject',\n          contentUrl: src,\n          encodingFormat:\n            ((_a = src.split('.').pop()) === null || _a === void 0\n              ? void 0\n              : _a.toLowerCase()) === 'gltf'\n              ? 'model/gltf+json'\n              : 'model/gltf-binary',\n        },\n      ];\n      if (iosSrc) {\n        encoding.push({\n          '@type': 'MediaObject',\n          contentUrl: iosSrc,\n          encodingFormat: 'model/vnd.usdz+zip',\n        });\n      }\n      const structuredData = {\n        '@context': 'http://schema.org/',\n        '@type': '3DModel',\n        image: poster !== null && poster !== void 0 ? poster : undefined,\n        name: alt !== null && alt !== void 0 ? alt : undefined,\n        encoding,\n      };\n      schemaElement.textContent = JSON.stringify(structuredData);\n      document.head.appendChild(schemaElement);\n    } else if (schemaElement.parentElement != null) {\n      schemaElement.parentElement.removeChild(schemaElement);\n    }\n  }\n}\n\n/**\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\n * enlarged to match the dimensions of the normal map.\n */\n\nconst _mipmapMaterial = _getMipmapMaterial();\n\nconst _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);\n\nconst _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);\n\nlet _tempTarget = null;\n\nlet _renderer = null;\n\nclass RoughnessMipmapper {\n  constructor(renderer) {\n    _renderer = renderer;\n\n    _renderer.compile(_mesh, _flatCamera);\n  }\n\n  generateMipmaps(material) {\n    if ('roughnessMap' in material === false) return;\n\n    const { roughnessMap, normalMap } = material;\n\n    if (\n      roughnessMap === null ||\n      normalMap === null ||\n      !roughnessMap.generateMipmaps ||\n      material.userData.roughnessUpdated\n    )\n      return;\n\n    material.userData.roughnessUpdated = true;\n\n    let width = Math.max(roughnessMap.image.width, normalMap.image.width);\n    let height = Math.max(roughnessMap.image.height, normalMap.image.height);\n\n    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height))\n      return;\n\n    const oldTarget = _renderer.getRenderTarget();\n\n    const autoClear = _renderer.autoClear;\n\n    _renderer.autoClear = false;\n\n    if (\n      _tempTarget === null ||\n      _tempTarget.width !== width ||\n      _tempTarget.height !== height\n    ) {\n      if (_tempTarget !== null) _tempTarget.dispose();\n\n      _tempTarget = new WebGLRenderTarget(width, height, {\n        depthBuffer: false,\n      });\n\n      _tempTarget.scissorTest = true;\n    }\n\n    if (\n      width !== roughnessMap.image.width ||\n      height !== roughnessMap.image.height\n    ) {\n      const params = {\n        wrapS: roughnessMap.wrapS,\n        wrapT: roughnessMap.wrapT,\n        magFilter: roughnessMap.magFilter,\n        minFilter: roughnessMap.minFilter,\n        depthBuffer: false,\n      };\n\n      const newRoughnessTarget = new WebGLRenderTarget(width, height, params);\n\n      newRoughnessTarget.texture.generateMipmaps = true;\n\n      // Setting the render target causes the memory to be allocated.\n\n      _renderer.setRenderTarget(newRoughnessTarget);\n\n      material.roughnessMap = newRoughnessTarget.texture;\n\n      if (material.metalnessMap == roughnessMap)\n        material.metalnessMap = material.roughnessMap;\n\n      if (material.aoMap == roughnessMap)\n        material.aoMap = material.roughnessMap;\n\n      // Copy UV transform parameters\n\n      material.roughnessMap.offset.copy(roughnessMap.offset);\n      material.roughnessMap.repeat.copy(roughnessMap.repeat);\n      material.roughnessMap.center.copy(roughnessMap.center);\n      material.roughnessMap.rotation = roughnessMap.rotation;\n\n      material.roughnessMap.matrixAutoUpdate = roughnessMap.matrixAutoUpdate;\n      material.roughnessMap.matrix.copy(roughnessMap.matrix);\n    }\n\n    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\n\n    _mipmapMaterial.uniforms.normalMap.value = normalMap;\n\n    const position = new Vector2(0, 0);\n\n    const texelSize = _mipmapMaterial.uniforms.texelSize.value;\n\n    for (\n      let mip = 0;\n      width >= 1 && height >= 1;\n      ++mip, width /= 2, height /= 2\n    ) {\n      // Rendering to a mip level is not allowed in webGL1. Instead we must set\n      // up a secondary texture to write the result to, then copy it back to the\n      // proper mipmap level.\n\n      texelSize.set(1.0 / width, 1.0 / height);\n\n      if (mip == 0) texelSize.set(0.0, 0.0);\n\n      _tempTarget.viewport.set(position.x, position.y, width, height);\n\n      _tempTarget.scissor.set(position.x, position.y, width, height);\n\n      _renderer.setRenderTarget(_tempTarget);\n\n      _renderer.render(_mesh, _flatCamera);\n\n      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\n\n      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\n    }\n\n    if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();\n\n    _renderer.setRenderTarget(oldTarget);\n\n    _renderer.autoClear = autoClear;\n  }\n\n  dispose() {\n    _mipmapMaterial.dispose();\n\n    _mesh.geometry.dispose();\n\n    if (_tempTarget != null) _tempTarget.dispose();\n  }\n}\n\nfunction _getMipmapMaterial() {\n  const shaderMaterial = new RawShaderMaterial({\n    uniforms: {\n      roughnessMap: { value: null },\n      normalMap: { value: null },\n      texelSize: { value: new Vector2(1, 1) },\n    },\n\n    vertexShader: /* glsl */ `\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t`,\n\n    fragmentShader: /* glsl */ `\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t`,\n\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n  });\n\n  shaderMaterial.type = 'RoughnessMipmapper';\n\n  return shaderMaterial;\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate$7 =\n  (undefined && undefined.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === 'object' && typeof undefined === 'function')\n      r = undefined(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nconst BASE_OPACITY = 0.1;\nconst DEFAULT_SHADOW_INTENSITY = 0.0;\nconst DEFAULT_SHADOW_SOFTNESS = 1.0;\nconst DEFAULT_EXPOSURE = 1.0;\nconst $currentEnvironmentMap = Symbol('currentEnvironmentMap');\nconst $applyEnvironmentMap = Symbol('applyEnvironmentMap');\nconst $updateEnvironment = Symbol('updateEnvironment');\nconst $cancelEnvironmentUpdate = Symbol('cancelEnvironmentUpdate');\nconst $onPreload = Symbol('onPreload');\nconst EnvironmentMixin = (ModelViewerElement) => {\n  var _a, _b, _c;\n  class EnvironmentModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.environmentImage = null;\n      this.skyboxImage = null;\n      this.shadowIntensity = DEFAULT_SHADOW_INTENSITY;\n      this.shadowSoftness = DEFAULT_SHADOW_SOFTNESS;\n      this.exposure = DEFAULT_EXPOSURE;\n      this[_a] = null;\n      this[_b] = null;\n      this[_c] = (event) => {\n        if (event.element === this) {\n          this[$updateEnvironment]();\n        }\n      };\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      this[$renderer].loader.addEventListener('preload', this[$onPreload]);\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$renderer].loader.removeEventListener('preload', this[$onPreload]);\n    }\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('shadowIntensity')) {\n        this[$scene].setShadowIntensity(this.shadowIntensity * BASE_OPACITY);\n        this[$needsRender]();\n      }\n      if (changedProperties.has('shadowSoftness')) {\n        this[$scene].setShadowSoftness(this.shadowSoftness);\n        this[$needsRender]();\n      }\n      if (changedProperties.has('exposure')) {\n        this[$scene].exposure = this.exposure;\n        this[$needsRender]();\n      }\n      if (\n        (changedProperties.has('environmentImage') ||\n          changedProperties.has('skyboxImage')) &&\n        this[$shouldAttemptPreload]()\n      ) {\n        this[$updateEnvironment]();\n      }\n    }\n    [((_a = $currentEnvironmentMap),\n    (_b = $cancelEnvironmentUpdate),\n    (_c = $onPreload),\n    $onModelLoad)]() {\n      super[$onModelLoad]();\n      if (this[$currentEnvironmentMap] != null) {\n        this[$applyEnvironmentMap](this[$currentEnvironmentMap]);\n      }\n    }\n    async [$updateEnvironment]() {\n      const { skyboxImage, environmentImage } = this;\n      if (this[$cancelEnvironmentUpdate] != null) {\n        this[$cancelEnvironmentUpdate]();\n        this[$cancelEnvironmentUpdate] = null;\n      }\n      const { textureUtils } = this[$renderer];\n      if (textureUtils == null) {\n        return;\n      }\n      try {\n        const { environmentMap, skybox } = await new Promise(\n          async (resolve, reject) => {\n            const texturesLoad = textureUtils.generateEnvironmentMapAndSkybox(\n              deserializeUrl(skyboxImage),\n              environmentImage,\n              { progressTracker: this[$progressTracker] },\n            );\n            this[$cancelEnvironmentUpdate] = () => reject(texturesLoad);\n            resolve(await texturesLoad);\n          },\n        );\n        if (skybox != null) {\n          // When using the same environment and skybox, use the environment as\n          // it gives HDR filtering.\n          this[$scene].background =\n            skybox.name === environmentMap.name ? environmentMap : skybox;\n        } else {\n          this[$scene].background = null;\n        }\n        this[$applyEnvironmentMap](environmentMap);\n        this[$scene].dispatchEvent({ type: 'envmap-update' });\n      } catch (errorOrPromise) {\n        if (errorOrPromise instanceof Error) {\n          this[$applyEnvironmentMap](null);\n          throw errorOrPromise;\n        }\n      }\n    }\n    /**\n     * Sets the Model to use the provided environment map,\n     * or `null` if the Model should remove its' environment map.\n     */\n    [$applyEnvironmentMap](environmentMap) {\n      if (this[$scene].environment === environmentMap) {\n        return;\n      }\n      this[$currentEnvironmentMap] = environmentMap;\n      this[$scene].environment = this[$currentEnvironmentMap];\n      this.dispatchEvent(new CustomEvent('environment-change'));\n      this[$needsRender]();\n    }\n  }\n  __decorate$7(\n    [property({ type: String, attribute: 'environment-image' })],\n    EnvironmentModelViewerElement.prototype,\n    'environmentImage',\n    void 0,\n  );\n  __decorate$7(\n    [property({ type: String, attribute: 'skybox-image' })],\n    EnvironmentModelViewerElement.prototype,\n    'skyboxImage',\n    void 0,\n  );\n  __decorate$7(\n    [property({ type: Number, attribute: 'shadow-intensity' })],\n    EnvironmentModelViewerElement.prototype,\n    'shadowIntensity',\n    void 0,\n  );\n  __decorate$7(\n    [property({ type: Number, attribute: 'shadow-softness' })],\n    EnvironmentModelViewerElement.prototype,\n    'shadowSoftness',\n    void 0,\n  );\n  __decorate$7(\n    [\n      property({\n        type: Number,\n      }),\n    ],\n    EnvironmentModelViewerElement.prototype,\n    'exposure',\n    void 0,\n  );\n  return EnvironmentModelViewerElement;\n};\n\nclass SessionLightProbe {\n  constructor(\n    xrLight,\n    renderer,\n    lightProbe,\n    environmentEstimation,\n    estimationStartCallback,\n  ) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n\n    const session = renderer.xr.getSession();\n\n    // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n\n      const gl = renderer.getContext();\n\n      // Ensure that we have any extensions needed to use the preferred cube map format.\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection();\n      });\n    }\n\n    // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n    session.requestAnimationFrame(this.frameCallback);\n  }\n\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(\n      this.xrLight.environment,\n    );\n\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n      }\n    }\n  }\n\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return;\n    }\n\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(\n        lightEstimate.sphericalHarmonicsCoefficients,\n      );\n      this.xrLight.lightProbe.intensity = 1.0;\n\n      // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n      const intensityScalar = Math.max(\n        1.0,\n        Math.max(\n          lightEstimate.primaryLightIntensity.x,\n          Math.max(\n            lightEstimate.primaryLightIntensity.y,\n            lightEstimate.primaryLightIntensity.z,\n          ),\n        ),\n      );\n\n      this.xrLight.directionalLight.color.setRGB(\n        lightEstimate.primaryLightIntensity.x / intensityScalar,\n        lightEstimate.primaryLightIntensity.y / intensityScalar,\n        lightEstimate.primaryLightIntensity.z / intensityScalar,\n      );\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(\n        lightEstimate.primaryLightDirection,\n      );\n\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n}\n\nclass XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super();\n\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight);\n\n    // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n    this.environment = null;\n\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession();\n\n      if ('requestLightProbe' in session) {\n        session\n          .requestLightProbe({\n            reflectionFormat: session.preferredReflectionFormat,\n          })\n          .then((probe) => {\n            sessionLightProbe = new SessionLightProbe(\n              this,\n              renderer,\n              probe,\n              environmentEstimation,\n              () => {\n                estimationStarted = true;\n\n                // Fired to indicate that the estimated lighting values are now being updated.\n                this.dispatchEvent({ type: 'estimationstart' });\n              },\n            );\n          });\n      }\n    });\n\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({ type: 'estimationend' });\n      }\n    });\n\n    // Done inline to provide access to sessionLightProbe.\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n\n      this.environment = null;\n    };\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst RADIUS = 0.2;\nconst LINE_WIDTH = 0.03;\nconst MAX_OPACITY = 0.75;\nconst SEGMENTS = 12;\nconst DELTA_PHI = Math.PI / (2 * SEGMENTS);\nconst vector2 = new Vector2();\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\nconst addCorner = (vertices, cornerX, cornerY) => {\n  let phi =\n    cornerX > 0\n      ? cornerY > 0\n        ? 0\n        : -Math.PI / 2\n      : cornerY > 0\n      ? Math.PI / 2\n      : Math.PI;\n  for (let i = 0; i <= SEGMENTS; ++i) {\n    vertices.push(\n      cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi),\n      cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi),\n      0,\n      cornerX + RADIUS * Math.cos(phi),\n      cornerY + RADIUS * Math.sin(phi),\n      0,\n    );\n    phi += DELTA_PHI;\n  }\n};\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a scene. It is purposely larger than the scene's bounding box by RADIUS on\n * all sides so that small scenes are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\nclass PlacementBox extends Mesh {\n  constructor(scene, side) {\n    const geometry = new BufferGeometry();\n    const triangles = [];\n    const vertices = [];\n    const { size, boundingBox } = scene;\n    const x = size.x / 2;\n    const y = (side === 'back' ? size.y : size.z) / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n    const numVertices = vertices.length / 3;\n    for (let i = 0; i < numVertices - 2; i += 2) {\n      triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);\n    }\n    const i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n    super(geometry);\n    this.side = side;\n    const material = this.material;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    this.goalOpacity = 0;\n    this.opacityDamper = new Damper();\n    this.hitPlane = new Mesh(\n      new PlaneGeometry(2 * (x + RADIUS), 2 * (y + RADIUS)),\n    );\n    this.hitPlane.visible = false;\n    this.add(this.hitPlane);\n    boundingBox.getCenter(this.position);\n    switch (side) {\n      case 'bottom':\n        this.rotateX(-Math.PI / 2);\n        this.shadowHeight = boundingBox.min.y;\n        this.position.y = this.shadowHeight;\n        break;\n      case 'back':\n        this.shadowHeight = boundingBox.min.z;\n        this.position.z = this.shadowHeight;\n    }\n    scene.target.add(this);\n  }\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n  getHit(scene, screenX, screenY) {\n    vector2.set(screenX, -screenY);\n    this.hitPlane.visible = true;\n    const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n    this.hitPlane.visible = false;\n    return hitResult == null ? null : hitResult.position;\n  }\n  getExpandedHit(scene, screenX, screenY) {\n    this.hitPlane.scale.set(1000, 1000, 1000);\n    const hitResult = this.getHit(scene, screenX, screenY);\n    this.hitPlane.scale.set(1, 1, 1);\n    return hitResult;\n  }\n  /**\n   * Offset the height of the box relative to the bottom of the scene. Positive\n   * is up, so generally only negative values are used.\n   */\n  set offsetHeight(offset) {\n    if (this.side === 'back') {\n      this.position.z = this.shadowHeight + offset;\n    } else {\n      this.position.y = this.shadowHeight + offset;\n    }\n  }\n  get offsetHeight() {\n    if (this.side === 'back') {\n      return this.position.z - this.shadowHeight;\n    } else {\n      return this.position.y - this.shadowHeight;\n    }\n  }\n  /**\n   * Set the box's visibility; it will fade in and out.\n   */\n  set show(visible) {\n    this.goalOpacity = visible ? MAX_OPACITY : 0;\n  }\n  /**\n   * Call on each frame with the frame delta to fade the box.\n   */\n  updateOpacity(delta) {\n    const material = this.material;\n    material.opacity = this.opacityDamper.update(\n      material.opacity,\n      this.goalOpacity,\n      delta,\n      1,\n    );\n    this.visible = material.opacity > 0;\n  }\n  /**\n   * Call this to clean up Three's cache when you remove the box.\n   */\n  dispose() {\n    var _a;\n    const { geometry, material } = this.hitPlane;\n    geometry.dispose();\n    material.dispose();\n    this.geometry.dispose();\n    this.material.dispose();\n    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.remove(this);\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// number of initial null pose XRFrames allowed before we post not-tracking\nconst INIT_FRAMES = 30;\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.3;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\nconst SCALE_SNAP_HIGH = 1.3;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\n// For automatic dynamic viewport scaling, don't let the scale drop below this\n// limit.\nconst MIN_VIEWPORT_SCALE = 0.25;\n// Furthest away you can move an object (meters).\nconst MAX_DISTANCE = 10;\nconst ARStatus = {\n  NOT_PRESENTING: 'not-presenting',\n  SESSION_STARTED: 'session-started',\n  OBJECT_PLACED: 'object-placed',\n  FAILED: 'failed',\n};\nconst ARTracking = {\n  TRACKING: 'tracking',\n  NOT_TRACKING: 'not-tracking',\n};\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nconst camera = new PerspectiveCamera(45, 1, 0.1, 100);\nclass ARRenderer extends EventDispatcher {\n  constructor(renderer) {\n    super();\n    this.renderer = renderer;\n    this.currentSession = null;\n    this.placeOnWall = false;\n    this.placementBox = null;\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.oldBackground = null;\n    this.oldEnvironment = null;\n    this.frame = null;\n    this.initialHitSource = null;\n    this.transientHitTestSource = null;\n    this.inputSource = null;\n    this._presentedScene = null;\n    this.resolveCleanup = null;\n    this.exitWebXRButtonContainer = null;\n    this.overlay = null;\n    this.xrLight = null;\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.oldTarget = new Vector3();\n    this.oldFramedFieldOfView = 45;\n    this.placementComplete = false;\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.lastDragPosition = new Vector3();\n    this.firstRatio = 0;\n    this.lastAngle = 0;\n    this.goalPosition = new Vector3();\n    this.goalYaw = 0;\n    this.goalScale = 1;\n    this.xDamper = new Damper();\n    this.yDamper = new Damper();\n    this.zDamper = new Damper();\n    this.yawDamper = new Damper();\n    this.scaleDamper = new Damper();\n    this.onExitWebXRButtonContainerClick = () => this.stopPresenting();\n    this.onUpdateScene = () => {\n      if (this.placementBox != null && this.isPresenting) {\n        this.placementBox.dispose();\n        this.placementBox = new PlacementBox(\n          this.presentedScene,\n          this.placeOnWall ? 'back' : 'bottom',\n        );\n      }\n    };\n    this.onSelectStart = (event) => {\n      const hitSource = this.transientHitTestSource;\n      if (hitSource == null) {\n        return;\n      }\n      const fingers = this.frame.getHitTestResultsForTransientInput(hitSource);\n      const scene = this.presentedScene;\n      const box = this.placementBox;\n      if (fingers.length === 1) {\n        this.inputSource = event.inputSource;\n        const { axes } = this.inputSource.gamepad;\n        const hitPosition = box.getHit(this.presentedScene, axes[0], axes[1]);\n        box.show = true;\n        if (hitPosition != null) {\n          this.isTranslating = true;\n          this.lastDragPosition.copy(hitPosition);\n        } else if (this.placeOnWall === false) {\n          this.isRotating = true;\n          this.lastAngle = axes[0] * ROTATION_RATE;\n        }\n      } else if (fingers.length === 2) {\n        box.show = true;\n        this.isTwoFingering = true;\n        const { separation } = this.fingerPolar(fingers);\n        this.firstRatio = separation / scene.scale.x;\n      }\n    };\n    this.onSelectEnd = () => {\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = false;\n      this.inputSource = null;\n      this.goalPosition.y +=\n        this.placementBox.offsetHeight * this.presentedScene.scale.x;\n      this.placementBox.show = false;\n    };\n    this.threeRenderer = renderer.threeRenderer;\n    this.threeRenderer.xr.enabled = true;\n  }\n  async resolveARSession() {\n    assertIsArCandidate();\n    const session = await navigator.xr.requestSession('immersive-ar', {\n      requiredFeatures: ['hit-test'],\n      optionalFeatures: ['dom-overlay', 'light-estimation'],\n      domOverlay: { root: this.overlay },\n    });\n    this.threeRenderer.xr.setReferenceSpaceType('local');\n    await this.threeRenderer.xr.setSession(session);\n    this.threeRenderer.xr.cameraAutoUpdate = false;\n    return session;\n  }\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this._presentedScene;\n  }\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation() {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr.isSessionSupported('immersive-ar');\n    } catch (error) {\n      console.warn('Request to present in WebXR denied:');\n      console.warn(error);\n      console.warn('Falling back to next ar-mode');\n      return false;\n    }\n  }\n  /**\n   * Present a scene in AR\n   */\n  async present(scene, environmentEstimation = false) {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n    let waitForAnimationFrame = new Promise((resolve, _reject) => {\n      requestAnimationFrame(() => resolve());\n    });\n    scene.setHotspotsVisibility(false);\n    scene.queueRender();\n    // Render a frame to turn off the hotspots\n    await waitForAnimationFrame;\n    // This sets isPresenting to true\n    this._presentedScene = scene;\n    this.overlay = scene.element.shadowRoot.querySelector('div.default');\n    if (environmentEstimation === true) {\n      this.xrLight = new XREstimatedLight(this.threeRenderer);\n      this.xrLight.addEventListener('estimationstart', () => {\n        if (!this.isPresenting || this.xrLight == null) {\n          return;\n        }\n        const scene = this.presentedScene;\n        scene.add(this.xrLight);\n        this.oldEnvironment = scene.environment;\n        scene.environment = this.xrLight.environment;\n      });\n    }\n    const currentSession = await this.resolveARSession();\n    currentSession.addEventListener(\n      'end',\n      () => {\n        this.postSessionCleanup();\n      },\n      { once: true },\n    );\n    const exitButton = scene.element.shadowRoot.querySelector(\n      '.slot.exit-webxr-ar-button',\n    );\n    exitButton.classList.add('enabled');\n    exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);\n    this.exitWebXRButtonContainer = exitButton;\n    const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.turntableRotation = scene.yaw;\n    this.goalYaw = scene.yaw;\n    this.goalScale = 1;\n    this.oldBackground = scene.background;\n    scene.background = null;\n    this.oldShadowIntensity = scene.shadowIntensity;\n    scene.setShadowIntensity(0);\n    this.oldTarget.copy(scene.getTarget());\n    this.oldFramedFieldOfView = scene.framedFieldOfView;\n    scene.addEventListener('model-load', this.onUpdateScene);\n    const radians = (HIT_ANGLE_DEG * Math.PI) / 180;\n    const ray =\n      this.placeOnWall === true\n        ? undefined\n        : new XRRay(new DOMPoint(0, 0, 0), {\n            x: 0,\n            y: -Math.sin(radians),\n            z: -Math.cos(radians),\n          });\n    currentSession\n      .requestHitTestSource({ space: viewerRefSpace, offsetRay: ray })\n      .then((hitTestSource) => {\n        this.initialHitSource = hitTestSource;\n      });\n    this.currentSession = currentSession;\n    this.placementBox = new PlacementBox(\n      scene,\n      this.placeOnWall ? 'back' : 'bottom',\n    );\n    this.placementComplete = false;\n    this.lastTick = performance.now();\n    this.dispatchEvent({ type: 'status', status: ARStatus.SESSION_STARTED });\n  }\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n    const cleanupPromise = new Promise((resolve) => {\n      this.resolveCleanup = resolve;\n    });\n    try {\n      await this.currentSession.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end WebXR AR session');\n      console.warn(error);\n      this.postSessionCleanup();\n    }\n  }\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting() {\n    return this.presentedScene != null;\n  }\n  get target() {\n    return this.oldTarget;\n  }\n  updateTarget() {\n    const scene = this.presentedScene;\n    if (scene != null) {\n      const target = scene.getTarget();\n      this.oldTarget.copy(target);\n      if (this.placeOnWall) {\n        // Move the scene's target to the center of the back of the model's\n        // bounding box.\n        target.z = scene.boundingBox.min.z;\n      } else {\n        // Move the scene's target to the model's floor height.\n        target.y = scene.boundingBox.min.y;\n      }\n      scene.setTarget(target.x, target.y, target.z);\n    }\n  }\n  postSessionCleanup() {\n    const session = this.currentSession;\n    if (session != null) {\n      session.removeEventListener('selectstart', this.onSelectStart);\n      session.removeEventListener('selectend', this.onSelectEnd);\n      this.currentSession = null;\n    }\n    const scene = this.presentedScene;\n    if (scene != null) {\n      const { element } = scene;\n      if (this.xrLight != null) {\n        scene.remove(this.xrLight);\n        if (this.oldEnvironment != null) {\n          scene.environment = this.oldEnvironment;\n          this.oldEnvironment = null;\n        }\n        this.xrLight.dispose();\n        this.xrLight = null;\n      }\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      scene.setShadowScaleAndOffset(1, 0);\n      const yaw = this.turntableRotation;\n      if (yaw != null) {\n        scene.yaw = yaw;\n      }\n      const intensity = this.oldShadowIntensity;\n      if (intensity != null) {\n        scene.setShadowIntensity(intensity);\n      }\n      const background = this.oldBackground;\n      if (background != null) {\n        scene.background = background;\n      }\n      const point = this.oldTarget;\n      scene.setTarget(point.x, point.y, point.z);\n      scene.framedFieldOfView = this.oldFramedFieldOfView;\n      scene.xrCamera = null;\n      scene.removeEventListener('model-load', this.onUpdateScene);\n      scene.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element.requestUpdate('maxCameraOrbit');\n      element[$onResize](element.getBoundingClientRect());\n    }\n    // Force the Renderer to update its size\n    this.renderer.height = 0;\n    const exitButton = this.exitWebXRButtonContainer;\n    if (exitButton != null) {\n      exitButton.classList.remove('enabled');\n      exitButton.removeEventListener(\n        'click',\n        this.onExitWebXRButtonContainerClick,\n      );\n      this.exitWebXRButtonContainer = null;\n    }\n    const hitSource = this.transientHitTestSource;\n    if (hitSource != null) {\n      hitSource.cancel();\n      this.transientHitTestSource = null;\n    }\n    const hitSourceInitial = this.initialHitSource;\n    if (hitSourceInitial != null) {\n      hitSourceInitial.cancel();\n      this.initialHitSource = null;\n    }\n    if (this.placementBox != null) {\n      this.placementBox.dispose();\n      this.placementBox = null;\n    }\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.oldBackground = null;\n    this._presentedScene = null;\n    this.frame = null;\n    this.inputSource = null;\n    this.overlay = null;\n    if (this.resolveCleanup != null) {\n      this.resolveCleanup();\n    }\n    this.dispatchEvent({ type: 'status', status: ARStatus.NOT_PRESENTING });\n  }\n  updateView(view) {\n    const scene = this.presentedScene;\n    const xr = this.threeRenderer.xr;\n    xr.updateCamera(camera);\n    scene.xrCamera = xr.getCamera();\n    const { elements } = scene.getCamera().matrixWorld;\n    scene.orientHotspots(Math.atan2(elements[1], elements[5]));\n    if (!this.initialized) {\n      this.placeInitially();\n      this.initialized = true;\n    }\n    // Use automatic dynamic viewport scaling if supported.\n    if (view.requestViewportScale && view.recommendedViewportScale) {\n      const scale = view.recommendedViewportScale;\n      view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));\n    }\n    const layer = this.currentSession.renderState.baseLayer;\n    const viewport = layer.getViewport(view);\n    this.threeRenderer.setViewport(\n      viewport.x,\n      viewport.y,\n      viewport.width,\n      viewport.height,\n    );\n  }\n  placeInitially() {\n    const scene = this.presentedScene;\n    const { position, element } = scene;\n    const xrCamera = scene.getCamera();\n    const { width, height } = this.overlay.getBoundingClientRect();\n    scene.setSize(width, height);\n    xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();\n    const { theta, radius } = element.getCameraOrbit();\n    // Orient model to match the 3D camera view\n    const cameraDirection = xrCamera.getWorldDirection(vector3);\n    scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;\n    this.goalYaw = scene.yaw;\n    position\n      .copy(xrCamera.position)\n      .add(cameraDirection.multiplyScalar(radius));\n    this.updateTarget();\n    const target = scene.getTarget();\n    position.add(target).sub(this.oldTarget);\n    this.goalPosition.copy(position);\n    scene.setHotspotsVisibility(true);\n    const { session } = this.frame;\n    session.addEventListener('selectstart', this.onSelectStart);\n    session.addEventListener('selectend', this.onSelectEnd);\n    session\n      .requestHitTestSourceForTransientInput({ profile: 'generic-touchscreen' })\n      .then((hitTestSource) => {\n        this.transientHitTestSource = hitTestSource;\n      });\n  }\n  getTouchLocation() {\n    const { axes } = this.inputSource.gamepad;\n    let location = this.placementBox.getExpandedHit(\n      this.presentedScene,\n      axes[0],\n      axes[1],\n    );\n    if (location != null) {\n      vector3.copy(location).sub(this.presentedScene.getCamera().position);\n      if (vector3.length() > MAX_DISTANCE) return null;\n    }\n    return location;\n  }\n  getHitPoint(hitResult) {\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = hitResult.getPose(refSpace);\n    if (pose == null) {\n      return null;\n    }\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n    if (this.placeOnWall === true) {\n      // Orient the model to the wall's normal vector.\n      this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);\n    }\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up for floor placement; opposite for wall placement.\n    return hitMatrix.elements[5] > 0.75 !== this.placeOnWall\n      ? hitPosition.setFromMatrixPosition(hitMatrix)\n      : null;\n  }\n  moveToFloor(frame) {\n    const hitSource = this.initialHitSource;\n    if (hitSource == null) {\n      return;\n    }\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n    const hit = hitTestResults[0];\n    const hitPoint = this.getHitPoint(hit);\n    if (hitPoint == null) {\n      return;\n    }\n    this.placementBox.show = true;\n    // If the user is translating, let the finger hit-ray take precedence and\n    // ignore this hit result.\n    if (!this.isTranslating) {\n      if (this.placeOnWall) {\n        this.goalPosition.copy(hitPoint);\n      } else {\n        this.goalPosition.y = hitPoint.y;\n      }\n    }\n    hitSource.cancel();\n    this.initialHitSource = null;\n    this.dispatchEvent({ type: 'status', status: ARStatus.OBJECT_PLACED });\n  }\n  fingerPolar(fingers) {\n    const fingerOne = fingers[0].inputSource.gamepad.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    const angle = Math.atan2(deltaY, deltaX);\n    let deltaYaw = this.lastAngle - angle;\n    if (deltaYaw > Math.PI) {\n      deltaYaw -= 2 * Math.PI;\n    } else if (deltaYaw < -Math.PI) {\n      deltaYaw += 2 * Math.PI;\n    }\n    this.lastAngle = angle;\n    return {\n      separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n      deltaYaw: deltaYaw,\n    };\n  }\n  processInput(frame) {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene;\n    const scale = scene.scale.x;\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this.isTwoFingering) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this.isTwoFingering = false;\n      } else {\n        const { separation, deltaYaw } = this.fingerPolar(fingers);\n        if (this.placeOnWall === false) {\n          this.goalYaw += deltaYaw;\n        }\n        if (scene.canScale) {\n          const scale = separation / this.firstRatio;\n          this.goalScale =\n            scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW ? 1 : scale;\n        }\n      }\n      return;\n    } else if (fingers.length === 2) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = true;\n      const { separation } = this.fingerPolar(fingers);\n      this.firstRatio = separation / scale;\n      return;\n    }\n    if (this.isRotating) {\n      const angle = this.inputSource.gamepad.axes[0] * ROTATION_RATE;\n      this.goalYaw += angle - this.lastAngle;\n      this.lastAngle = angle;\n    } else if (this.isTranslating) {\n      fingers.forEach((finger) => {\n        if (finger.inputSource !== this.inputSource) {\n          return;\n        }\n        let hit = null;\n        if (finger.results.length > 0) {\n          hit = this.getHitPoint(finger.results[0]);\n        }\n        if (hit == null) {\n          hit = this.getTouchLocation();\n        }\n        if (hit == null) {\n          return;\n        }\n        this.goalPosition.sub(this.lastDragPosition);\n        if (this.placeOnWall === false) {\n          const offset = hit.y - this.lastDragPosition.y;\n          // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n          if (offset < 0) {\n            this.placementBox.offsetHeight = offset / scale;\n            this.presentedScene.setShadowScaleAndOffset(scale, offset);\n            // Interpolate hit ray up to drag plane\n            const cameraPosition = vector3.copy(scene.getCamera().position);\n            const alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n        }\n        this.goalPosition.add(hit);\n        this.lastDragPosition.copy(hit);\n      });\n    }\n  }\n  moveScene(delta) {\n    const scene = this.presentedScene;\n    const { position, yaw, idealCameraDistance: radius } = scene;\n    const goal = this.goalPosition;\n    const oldScale = scene.scale.x;\n    const box = this.placementBox;\n    if (!goal.equals(position) || this.goalScale !== oldScale) {\n      let { x, y, z } = position;\n      x = this.xDamper.update(x, goal.x, delta, radius);\n      y = this.yDamper.update(y, goal.y, delta, radius);\n      z = this.zDamper.update(z, goal.z, delta, radius);\n      position.set(x, y, z);\n      const newScale = this.scaleDamper.update(\n        oldScale,\n        this.goalScale,\n        delta,\n        1,\n      );\n      scene.scale.set(newScale, newScale, newScale);\n      if (!this.isTranslating) {\n        const offset = goal.y - y;\n        if (this.placementComplete && this.placeOnWall === false) {\n          box.offsetHeight = offset / newScale;\n          scene.setShadowScaleAndOffset(newScale, offset);\n        } else if (offset === 0) {\n          this.placementComplete = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n        }\n      }\n    }\n    box.updateOpacity(delta);\n    scene.updateTarget(delta);\n    // yaw must be updated last, since this also updates the shadow position.\n    scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI);\n  }\n  /**\n   * Only public to make it testable.\n   */\n  onWebXRFrame(time, frame) {\n    this.frame = frame;\n    ++this.frames;\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = frame.getViewerPose(refSpace);\n    if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {\n      this.tracking = false;\n      this.dispatchEvent({ type: 'tracking', status: ARTracking.NOT_TRACKING });\n    }\n    const scene = this.presentedScene;\n    if (pose == null || scene == null || !scene.element[$sceneIsReady]()) {\n      this.threeRenderer.clear();\n      return;\n    }\n    if (this.tracking === false) {\n      this.tracking = true;\n      this.dispatchEvent({ type: 'tracking', status: ARTracking.TRACKING });\n    }\n    // WebXR may return multiple views, i.e. for headset AR. This\n    // isn't really supported at this point, but make a best-effort\n    // attempt to render other views also, using the first view\n    // as the main viewpoint.\n    let isFirstView = true;\n    for (const view of pose.views) {\n      this.updateView(view);\n      if (isFirstView) {\n        this.moveToFloor(frame);\n        this.processInput(frame);\n        const delta = time - this.lastTick;\n        this.moveScene(delta);\n        this.renderer.preRender(scene, time, delta);\n        this.lastTick = time;\n      }\n      // TODO: This is a workaround for a Chrome bug, which should be fixed\n      // soon: https://bugs.chromium.org/p/chromium/issues/detail?id=1184085\n      const gl = this.threeRenderer.getContext();\n      gl.depthMask(false);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n      gl.depthMask(true);\n      this.threeRenderer.render(scene, scene.getCamera());\n      isFirstView = false;\n    }\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This Debugger exposes internal details of the <model-viewer> rendering\n * substructure so that external tools can more easily inspect and operate on\n * them.\n *\n * It also activates shader debugging on the associated GL context. Shader\n * debugging trades performance for useful error information, so it is not\n * recommended to activate this unless needed.\n */\nclass Debugger {\n  constructor(renderer) {\n    // Force WebGL shader debugging on:\n    renderer.threeRenderer.debug = { checkShaderErrors: true };\n    // Announce debug details at microtask timing to give the `Renderer`\n    // constructor time to complete its initialization, just to be on the safe\n    // side:\n    Promise.resolve().then(() => {\n      self.dispatchEvent(\n        new CustomEvent('model-viewer-renderer-debug', {\n          detail: {\n            renderer,\n            THREE: {\n              ShaderMaterial,\n              Texture: Texture$1,\n              Mesh,\n              Scene,\n              PlaneBufferGeometry: PlaneGeometry,\n              OrthographicCamera,\n              WebGLRenderTarget,\n            },\n          },\n        }),\n      );\n    });\n  }\n  addScene(scene) {\n    self.dispatchEvent(\n      new CustomEvent('model-viewer-scene-added-debug', { detail: { scene } }),\n    );\n  }\n  removeScene(scene) {\n    self.dispatchEvent(\n      new CustomEvent('model-viewer-scene-removed-debug', {\n        detail: { scene },\n      }),\n    );\n  }\n}\n\nfunction clone(source) {\n  const sourceLookup = new Map();\n  const cloneLookup = new Map();\n\n  const clone = source.clone();\n\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n\n  return clone;\n}\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst $prepared = Symbol('prepared');\nconst $prepare = Symbol('prepare');\nconst $preparedGLTF = Symbol('preparedGLTF');\nconst $clone = Symbol('clone');\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\nclass GLTFInstance {\n  constructor(preparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n  static prepare(source) {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n    if (source[$prepared]) {\n      return source;\n    }\n    const prepared = this[$prepare](source);\n    // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n    prepared[$prepared] = true;\n    return prepared;\n  }\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n  static [$prepare](source) {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const { scene } = source;\n    const scenes = [scene];\n    return Object.assign(Object.assign({}, source), { scene, scenes });\n  }\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n  /**\n   * Creates and returns a copy of this instance.\n   */\n  clone() {\n    const GLTFInstanceConstructor = this.constructor;\n    const clonedGLTF = this[$clone]();\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n  dispose() {\n    this.scenes.forEach((scene) => {\n      scene.traverse((object) => {\n        if (!object.isMesh) {\n          return;\n        }\n        const mesh = object;\n        const materials = Array.isArray(mesh.material)\n          ? mesh.material\n          : [mesh.material];\n        materials.forEach((material) => {\n          // Explicitly dispose any textures assigned to this material\n          for (const propertyName in material) {\n            const propertyValue = material[propertyName];\n            if (propertyValue instanceof Texture$1) {\n              propertyValue.dispose();\n            }\n          }\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n  [$clone]() {\n    const source = this[$preparedGLTF];\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n    const scene = clone(this.scene);\n    cloneVariantMaterials(scene, this.scene);\n    const scenes = [scene];\n    const userData = source.userData ? Object.assign({}, source.userData) : {};\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes,\n      userData,\n    });\n  }\n}\n// Variant materials and original material instances are stored under\n// object.userData.variantMaterials/originalMaterial.\n// Three.js Object3D.clone() doesn't clone Three.js objects under\n// .userData so this function is a workaround.\nconst cloneVariantMaterials = (dst, src) => {\n  traversePair(dst, src, (dst, src) => {\n    if (src.userData.variantMaterials !== undefined) {\n      dst.userData.variantMaterials = new Map(src.userData.variantMaterials);\n    }\n    if (src.userData.originalMaterial !== undefined) {\n      dst.userData.originalMaterial = src.userData.originalMaterial;\n    }\n  });\n};\nconst traversePair = (obj1, obj2, callback) => {\n  callback(obj1, obj2);\n  // Assume obj1 and obj2 have the same tree structure\n  for (let i = 0; i < obj1.children.length; i++) {\n    traversePair(obj1.children[i], obj2.children[i], callback);\n  }\n};\n\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\nclass CorrelatedSceneGraph {\n  constructor(threeGLTF, gltf, threeObjectMap, gltfElementMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n  static from(threeGLTF, upstreamCorrelatedSceneGraph) {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](\n        threeGLTF,\n        upstreamCorrelatedSceneGraph,\n      );\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n  static [$correlateOriginalThreeGLTF](threeGLTF) {\n    const gltf = threeGLTF.parser.json;\n    const associations = threeGLTF.parser.associations;\n    const gltfElementMap = new Map();\n    const defaultMaterial = { name: 'Default' };\n    const defaultReference = { type: 'materials', index: -1 };\n    for (const threeMaterial of associations.keys()) {\n      // Note: GLTFLoader creates a \"default\" material that has no\n      // corresponding glTF element in the case that no materials are\n      // specified in the source glTF. In this case we append a default\n      // material to allow this to be operated upon.\n      if (\n        threeMaterial instanceof Material$1 &&\n        associations.get(threeMaterial) == null\n      ) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n        threeMaterial.name = defaultMaterial.name;\n        associations.set(threeMaterial, { materials: defaultReference.index });\n      }\n    }\n    // Creates a reverse look up map (gltf-object to Three-object)\n    for (const [threeObject, gltfMappings] of associations) {\n      if (gltfMappings) {\n        const objWithUserData = threeObject;\n        objWithUserData.userData = objWithUserData.userData || {};\n        objWithUserData.userData.associations = gltfMappings;\n      }\n      for (const mapping in gltfMappings) {\n        if (mapping != null && mapping !== 'primitives') {\n          const type = mapping;\n          const elementArray = gltf[type] || [];\n          const gltfElement = elementArray[gltfMappings[type]];\n          if (gltfElement == null) {\n            // TODO: Maybe throw here...\n            continue;\n          }\n          let threeObjects = gltfElementMap.get(gltfElement);\n          if (threeObjects == null) {\n            threeObjects = new Set();\n            gltfElementMap.set(gltfElement, threeObjects);\n          }\n          threeObjects.add(threeObject);\n        }\n      }\n    }\n    return new CorrelatedSceneGraph(\n      threeGLTF,\n      gltf,\n      associations,\n      gltfElementMap,\n    );\n  }\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedSceneGraph instance.\n   */\n  static [$correlateCloneThreeGLTF](\n    cloneThreeGLTF,\n    upstreamCorrelatedSceneGraph,\n  ) {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap = new Map();\n    const cloneGLTFElementMap = new Map();\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](\n        originalThreeGLTF.scenes[i],\n        cloneThreeGLTF.scenes[i],\n        (object, cloneObject) => {\n          const elementReference =\n            upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n          if (elementReference == null) {\n            return;\n          }\n          for (const mapping in elementReference) {\n            if (mapping != null && mapping !== 'primitives') {\n              const type = mapping;\n              const index = elementReference[type];\n              const cloneElement = cloneGLTF[type][index];\n              const mappings = cloneThreeObjectMap.get(cloneObject) || {};\n              mappings[type] = index;\n              cloneThreeObjectMap.set(cloneObject, mappings);\n              const cloneObjects =\n                cloneGLTFElementMap.get(cloneElement) || new Set();\n              cloneObjects.add(cloneObject);\n              cloneGLTFElementMap.set(cloneElement, cloneObjects);\n            }\n          }\n        },\n      );\n    }\n    return new CorrelatedSceneGraph(\n      cloneThreeGLTF,\n      cloneGLTF,\n      cloneThreeObjectMap,\n      cloneGLTFElementMap,\n    );\n  }\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a\n   * callback for each Object3D or Material encountered, including the initial\n   * scene. Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n  static [$parallelTraverseThreeScene](sceneOne, sceneTwo, callback) {\n    const isMesh = (object) => {\n      return object.isMesh;\n    };\n    const traverse = (a, b) => {\n      callback(a, b);\n      if (a.isObject3D) {\n        if (isMesh(a)) {\n          if (Array.isArray(a.material)) {\n            for (let i = 0; i < a.material.length; ++i) {\n              traverse(a.material[i], b.material[i]);\n            }\n          } else {\n            traverse(a.material, b.material);\n          }\n        }\n        for (let i = 0; i < a.children.length; ++i) {\n          traverse(a.children[i], b.children[i]);\n        }\n      }\n    };\n    traverse(sceneOne, sceneTwo);\n  }\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n  get threeGLTF() {\n    return this[$threeGLTF];\n  }\n  /**\n   * The in-memory deserialized source glTF.\n   */\n  get gltf() {\n    return this[$gltf];\n  }\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n  get gltfElementMap() {\n    return this[$gltfElementMap];\n  }\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n  get threeObjectMap() {\n    return this[$threeObjectMap];\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst $cloneAndPatchMaterial = Symbol('cloneAndPatchMaterial');\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nclass ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  static [$prepare](source) {\n    const prepared = super[$prepare](source);\n    if (prepared[$correlatedSceneGraph] == null) {\n      prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n    }\n    const { scene } = prepared;\n    const nullSphere = new Sphere(undefined, Infinity);\n    scene.traverse((node) => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the skysphere\n      node.renderOrder = 1000;\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      const mesh = node;\n      if (mesh.isMesh) {\n        mesh.castShadow = true;\n        if (mesh.isSkinnedMesh) {\n          // Akin to disablig frustum culling above, we have to also manually\n          // disable the bounds to make raycasting correct for skinned meshes.\n          mesh.geometry.boundingSphere = nullSphere;\n          // The bounding box is set in GLTFLoader by the accessor bounds, which\n          // are not updated with animation.\n          mesh.geometry.boundingBox = null;\n        }\n      }\n    });\n    return prepared;\n  }\n  get correlatedSceneGraph() {\n    return this[$preparedGLTF][$correlatedSceneGraph];\n  }\n  /**\n   * @override\n   */\n  [$clone]() {\n    const clone = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map();\n    clone.scene.traverse((node) => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // environment maps.\n      if (node.isMesh) {\n        const mesh = node;\n        if (Array.isArray(mesh.material)) {\n          mesh.material = mesh.material.map((material) =>\n            this[$cloneAndPatchMaterial](material, sourceUUIDToClonedMaterial),\n          );\n        } else if (mesh.material != null) {\n          mesh.material = this[$cloneAndPatchMaterial](\n            mesh.material,\n            sourceUUIDToClonedMaterial,\n          );\n        }\n      }\n    });\n    // Cross-correlate the scene graph by relying on information in the\n    // current scene graph; without this step, relationships between the\n    // Three.js object graph and the glTF scene graph will be lost.\n    clone[$correlatedSceneGraph] = CorrelatedSceneGraph.from(\n      clone,\n      this.correlatedSceneGraph,\n    );\n    return clone;\n  }\n  /**\n   * Creates a clone of the given material, and applies a patch to the\n   * shader program.\n   */\n  [$cloneAndPatchMaterial](material, sourceUUIDToClonedMaterial) {\n    // If we already cloned this material (determined by tracking the UUID of\n    // source materials that have been cloned), then return that previously\n    // cloned instance:\n    if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n      return sourceUUIDToClonedMaterial.get(material.uuid);\n    }\n    const clone = material.clone();\n    if (material.map != null) {\n      clone.map = material.map.clone();\n      clone.map.needsUpdate = true;\n    }\n    if (material.normalMap != null) {\n      clone.normalMap = material.normalMap.clone();\n      clone.normalMap.needsUpdate = true;\n    }\n    if (material.emissiveMap != null) {\n      clone.emissiveMap = material.emissiveMap.clone();\n      clone.emissiveMap.needsUpdate = true;\n    }\n    // Clones the roughnessMap if it exists.\n    let roughnessMap = null;\n    if (material.roughnessMap != null) {\n      roughnessMap = material.roughnessMap.clone();\n    }\n    // Assigns the roughnessMap to the cloned material and generates mipmaps.\n    if (roughnessMap != null) {\n      roughnessMap.needsUpdate = true;\n      clone.roughnessMap = roughnessMap;\n      // Generates mipmaps from the clone of the roughnessMap.\n      const { threeRenderer, roughnessMipmapper } = Renderer.singleton;\n      // XR must be disabled while doing offscreen rendering or it will\n      // clobber the camera.\n      const { enabled } = threeRenderer.xr;\n      threeRenderer.xr.enabled = false;\n      const { image } = clone.roughnessMap;\n      roughnessMipmapper.generateMipmaps(clone);\n      clone.roughnessMap.image = image;\n      threeRenderer.xr.enabled = enabled;\n    }\n    // Checks if roughnessMap and metalnessMap share the same texture and\n    // either clones or assigns.\n    if (material.roughnessMap === material.metalnessMap) {\n      clone.metalnessMap = roughnessMap;\n    } else if (material.metalnessMap != null) {\n      clone.metalnessMap = material.metalnessMap.clone();\n      clone.metalnessMap.needsUpdate = true;\n    }\n    // Checks if roughnessMap and aoMap share the same texture and\n    // either clones or assigns.\n    if (material.roughnessMap === material.aoMap) {\n      clone.aoMap = roughnessMap;\n    } else if (material.aoMap != null) {\n      clone.aoMap = material.aoMap.clone();\n      clone.aoMap.needsUpdate = true;\n    }\n    // This makes shadows better for non-manifold meshes\n    clone.shadowSide = FrontSide;\n    sourceUUIDToClonedMaterial.set(material.uuid, clone);\n    return clone;\n  }\n}\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n\n    this.type = HalfFloatType;\n  }\n\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n  parse(buffer) {\n    const /* return codes for rgbe routines */\n      //RGBE_RETURN_SUCCESS = 0,\n      RGBE_RETURN_FAILURE = -1,\n      /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n      rgbe_write_error = 2,\n      rgbe_format_error = 3,\n      rgbe_memory_error = 4,\n      rgbe_error = function (rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n            break;\n          case rgbe_write_error:\n            console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n            break;\n          case rgbe_format_error:\n            console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n            break;\n          default:\n          case rgbe_memory_error:\n            console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n        }\n\n        return RGBE_RETURN_FAILURE;\n      },\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n      RGBE_VALID_FORMAT = 2,\n      RGBE_VALID_DIMENSIONS = 4,\n      NEWLINE = '\\n',\n      fgets = function (buffer, lineLimit, consume) {\n        const chunkSize = 128;\n\n        lineLimit = !lineLimit ? 1024 : lineLimit;\n        let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(\n            null,\n            new Uint16Array(buffer.subarray(p, p + chunkSize)),\n          );\n\n        while (\n          0 > (i = chunk.indexOf(NEWLINE)) &&\n          len < lineLimit &&\n          p < buffer.byteLength\n        ) {\n          s += chunk;\n          len += chunk.length;\n          p += chunkSize;\n          chunk += String.fromCharCode.apply(\n            null,\n            new Uint16Array(buffer.subarray(p, p + chunkSize)),\n          );\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n          if (false !== consume) buffer.pos += len + i + 1;\n          return s + chunk.slice(0, i);\n        }\n\n        return false;\n      },\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function (buffer) {\n        // regexes to parse header info fields\n        const magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n          header = {\n            valid: 0 /* indicate which fields are valid */,\n\n            string: '' /* the actual header string */,\n\n            comments: '' /* comments found in header */,\n\n            programtype:\n              'RGBE' /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */,\n\n            format: '' /* RGBE format, default 32-bit_rle_rgbe */,\n\n            gamma: 1.0 /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */,\n\n            exposure: 1.0 /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */,\n\n            width: 0,\n            height: 0 /* image dimensions, width/height */,\n          };\n\n        let line, match;\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          return rgbe_error(rgbe_read_error, 'no header found');\n        }\n\n        /* if you want to require the magic token then uncomment the next line */\n        if (!(match = line.match(magic_token_re))) {\n          return rgbe_error(rgbe_format_error, 'bad initial token');\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE;\n        header.programtype = match[1];\n        header.string += line + '\\n';\n\n        while (true) {\n          line = fgets(buffer);\n          if (false === line) break;\n          header.string += line + '\\n';\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n';\n            continue; // comment line\n          }\n\n          if ((match = line.match(gamma_re))) {\n            header.gamma = parseFloat(match[1], 10);\n          }\n\n          if ((match = line.match(exposure_re))) {\n            header.exposure = parseFloat(match[1], 10);\n          }\n\n          if ((match = line.match(format_re))) {\n            header.valid |= RGBE_VALID_FORMAT;\n            header.format = match[1]; //'32-bit_rle_rgbe';\n          }\n\n          if ((match = line.match(dimensions_re))) {\n            header.valid |= RGBE_VALID_DIMENSIONS;\n            header.height = parseInt(match[1], 10);\n            header.width = parseInt(match[2], 10);\n          }\n\n          if (\n            header.valid & RGBE_VALID_FORMAT &&\n            header.valid & RGBE_VALID_DIMENSIONS\n          )\n            break;\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          return rgbe_error(rgbe_format_error, 'missing format specifier');\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          return rgbe_error(rgbe_format_error, 'missing image size specifier');\n        }\n\n        return header;\n      },\n      RGBE_ReadPixels_RLE = function (buffer, w, h) {\n        const scanline_width = w;\n\n        if (\n          // run length encoding is not allowed so read flat\n          scanline_width < 8 ||\n          scanline_width > 0x7fff ||\n          // this file is not run length encoded\n          2 !== buffer[0] ||\n          2 !== buffer[1] ||\n          buffer[2] & 0x80\n        ) {\n          // return the flat buffer\n          return new Uint8Array(buffer);\n        }\n\n        if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {\n          return rgbe_error(rgbe_format_error, 'wrong scanline width');\n        }\n\n        const data_rgba = new Uint8Array(4 * w * h);\n\n        if (!data_rgba.length) {\n          return rgbe_error(\n            rgbe_memory_error,\n            'unable to allocate buffer space',\n          );\n        }\n\n        let offset = 0,\n          pos = 0;\n\n        const ptr_end = 4 * scanline_width;\n        const rgbeStart = new Uint8Array(4);\n        const scanline_buffer = new Uint8Array(ptr_end);\n        let num_scanlines = h;\n\n        // read in each successive scanline\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            return rgbe_error(rgbe_read_error);\n          }\n\n          rgbeStart[0] = buffer[pos++];\n          rgbeStart[1] = buffer[pos++];\n          rgbeStart[2] = buffer[pos++];\n          rgbeStart[3] = buffer[pos++];\n\n          if (\n            2 != rgbeStart[0] ||\n            2 != rgbeStart[1] ||\n            ((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width\n          ) {\n            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n          }\n\n          // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n          let ptr = 0,\n            count;\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++];\n            const isEncodedRun = count > 128;\n            if (isEncodedRun) count -= 128;\n\n            if (0 === count || ptr + count > ptr_end) {\n              return rgbe_error(rgbe_format_error, 'bad scanline data');\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              const byteValue = buffer[pos++];\n              for (let i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue;\n              }\n              //ptr += count;\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n              ptr += count;\n              pos += count;\n            }\n          }\n\n          // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n          const l = scanline_width; //scanline_buffer.byteLength;\n          for (let i = 0; i < l; i++) {\n            let off = 0;\n            data_rgba[offset] = scanline_buffer[i + off];\n            off += scanline_width; //1;\n            data_rgba[offset + 1] = scanline_buffer[i + off];\n            off += scanline_width; //1;\n            data_rgba[offset + 2] = scanline_buffer[i + off];\n            off += scanline_width; //1;\n            data_rgba[offset + 3] = scanline_buffer[i + off];\n            offset += 4;\n          }\n\n          num_scanlines--;\n        }\n\n        return data_rgba;\n      };\n\n    const RGBEByteToRGBFloat = function (\n      sourceArray,\n      sourceOffset,\n      destArray,\n      destOffset,\n    ) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0;\n\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    const RGBEByteToRGBHalf = function (\n      sourceArray,\n      sourceOffset,\n      destArray,\n      destOffset,\n    ) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0;\n\n      // clamping to 65504, the maximum representable value in float16\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(\n        Math.min(sourceArray[sourceOffset + 0] * scale, 65504),\n      );\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(\n        Math.min(sourceArray[sourceOffset + 1] * scale, 65504),\n      );\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(\n        Math.min(sourceArray[sourceOffset + 2] * scale, 65504),\n      );\n    };\n\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      const w = rgbe_header_info.width,\n        h = rgbe_header_info.height,\n        image_rgba_data = RGBE_ReadPixels_RLE(\n          byteArray.subarray(byteArray.pos),\n          w,\n          h,\n        );\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        let data, format, type;\n        let numElements;\n\n        switch (this.type) {\n          case UnsignedByteType:\n            data = image_rgba_data;\n            format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n            type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            numElements = image_rgba_data.length / 4;\n            const floatArray = new Float32Array(numElements * 3);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            data = floatArray;\n            format = RGBFormat;\n            type = FloatType;\n            break;\n\n          case HalfFloatType:\n            numElements = image_rgba_data.length / 4;\n            const halfArray = new Uint16Array(numElements * 3);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\n            }\n\n            data = halfArray;\n            format = RGBFormat;\n            type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type,\n        };\n      }\n    }\n\n    return null;\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\n\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass EnvironmentScene extends Scene {\n  constructor() {\n    super();\n    this.position.y = -3.5;\n    const geometry = new BoxGeometry();\n    geometry.deleteAttribute('uv');\n    const roomMaterial = new MeshStandardMaterial({\n      metalness: 0,\n      side: BackSide,\n    });\n    const boxMaterial = new MeshStandardMaterial({ metalness: 0 });\n    const mainLight = new PointLight(0xffffff, 500.0, 28, 2);\n    mainLight.position.set(0.418, 16.199, 0.3);\n    this.add(mainLight);\n    const room = new Mesh(geometry, roomMaterial);\n    room.position.set(-0.757, 13.219, 0.717);\n    room.scale.set(31.713, 28.305, 28.591);\n    this.add(room);\n    const box1 = new Mesh(geometry, boxMaterial);\n    box1.position.set(-10.906, 2.009, 1.846);\n    box1.rotation.set(0, -0.195, 0);\n    box1.scale.set(2.328, 7.905, 4.651);\n    this.add(box1);\n    const box2 = new Mesh(geometry, boxMaterial);\n    box2.position.set(-5.607, -0.754, -0.758);\n    box2.rotation.set(0, 0.994, 0);\n    box2.scale.set(1.97, 1.534, 3.955);\n    this.add(box2);\n    const box3 = new Mesh(geometry, boxMaterial);\n    box3.position.set(6.167, 0.857, 7.803);\n    box3.rotation.set(0, 0.561, 0);\n    box3.scale.set(3.927, 6.285, 3.687);\n    this.add(box3);\n    const box4 = new Mesh(geometry, boxMaterial);\n    box4.position.set(-2.017, 0.018, 6.124);\n    box4.rotation.set(0, 0.333, 0);\n    box4.scale.set(2.002, 4.566, 2.064);\n    this.add(box4);\n    const box5 = new Mesh(geometry, boxMaterial);\n    box5.position.set(2.291, -0.756, -2.621);\n    box5.rotation.set(0, -0.286, 0);\n    box5.scale.set(1.546, 1.552, 1.496);\n    this.add(box5);\n    const box6 = new Mesh(geometry, boxMaterial);\n    box6.position.set(-2.193, -0.369, -5.547);\n    box6.rotation.set(0, 0.516, 0);\n    box6.scale.set(3.875, 3.487, 2.986);\n    this.add(box6);\n    // -x right\n    const light1 = new Mesh(geometry, this.createAreaLightMaterial(50));\n    light1.position.set(-16.116, 14.37, 8.208);\n    light1.scale.set(0.1, 2.428, 2.739);\n    this.add(light1);\n    // -x left\n    const light2 = new Mesh(geometry, this.createAreaLightMaterial(50));\n    light2.position.set(-16.109, 18.021, -8.207);\n    light2.scale.set(0.1, 2.425, 2.751);\n    this.add(light2);\n    // +x\n    const light3 = new Mesh(geometry, this.createAreaLightMaterial(17));\n    light3.position.set(14.904, 12.198, -1.832);\n    light3.scale.set(0.15, 4.265, 6.331);\n    this.add(light3);\n    // +z\n    const light4 = new Mesh(geometry, this.createAreaLightMaterial(43));\n    light4.position.set(-0.462, 8.89, 14.52);\n    light4.scale.set(4.38, 5.441, 0.088);\n    this.add(light4);\n    // -z\n    const light5 = new Mesh(geometry, this.createAreaLightMaterial(20));\n    light5.position.set(3.235, 11.486, -12.541);\n    light5.scale.set(2.5, 2.0, 0.1);\n    this.add(light5);\n    // +y\n    const light6 = new Mesh(geometry, this.createAreaLightMaterial(100));\n    light6.position.set(0.0, 20.0, 0.0);\n    light6.scale.set(1.0, 0.1, 1.0);\n    this.add(light6);\n  }\n  createAreaLightMaterial(intensity) {\n    const material = new MeshBasicMaterial();\n    material.color.setScalar(intensity);\n    return material;\n  }\n}\n\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass EnvironmentSceneAlt extends Scene {\n  constructor() {\n    super();\n    this.position.y = -3.5;\n    const geometry = new BoxGeometry();\n    geometry.deleteAttribute('uv');\n    const roomMaterial = new MeshStandardMaterial({\n      metalness: 0,\n      side: BackSide,\n    });\n    const boxMaterial = new MeshStandardMaterial({ metalness: 0 });\n    const mainLight = new PointLight(0xffffff, 400.0, 28, 2);\n    mainLight.position.set(0.5, 14.0, 0.5);\n    this.add(mainLight);\n    const room = new Mesh(geometry, roomMaterial);\n    room.position.set(0.0, 13.2, 0.0);\n    room.scale.set(31.5, 28.5, 31.5);\n    this.add(room);\n    const box1 = new Mesh(geometry, boxMaterial);\n    box1.position.set(-10.906, -1.0, 1.846);\n    box1.rotation.set(0, -0.195, 0);\n    box1.scale.set(2.328, 7.905, 4.651);\n    this.add(box1);\n    const box2 = new Mesh(geometry, boxMaterial);\n    box2.position.set(-5.607, -0.754, -0.758);\n    box2.rotation.set(0, 0.994, 0);\n    box2.scale.set(1.97, 1.534, 3.955);\n    this.add(box2);\n    const box3 = new Mesh(geometry, boxMaterial);\n    box3.position.set(6.167, -0.16, 7.803);\n    box3.rotation.set(0, 0.561, 0);\n    box3.scale.set(3.927, 6.285, 3.687);\n    this.add(box3);\n    const box4 = new Mesh(geometry, boxMaterial);\n    box4.position.set(-2.017, 0.018, 6.124);\n    box4.rotation.set(0, 0.333, 0);\n    box4.scale.set(2.002, 4.566, 2.064);\n    this.add(box4);\n    const box5 = new Mesh(geometry, boxMaterial);\n    box5.position.set(2.291, -0.756, -2.621);\n    box5.rotation.set(0, -0.286, 0);\n    box5.scale.set(1.546, 1.552, 1.496);\n    this.add(box5);\n    const box6 = new Mesh(geometry, boxMaterial);\n    box6.position.set(-2.193, -0.369, -5.547);\n    box6.rotation.set(0, 0.516, 0);\n    box6.scale.set(3.875, 3.487, 2.986);\n    this.add(box6);\n    // -x_left\n    const light1 = new Mesh(geometry, this.createAreaLightMaterial(80));\n    light1.position.set(-14.0, 10.0, 8.0);\n    light1.scale.set(0.1, 2.5, 2.5);\n    this.add(light1);\n    // -x_right\n    const light2 = new Mesh(geometry, this.createAreaLightMaterial(80));\n    light2.position.set(-14.0, 14.0, -4.0);\n    light2.scale.set(0.1, 2.5, 2.5);\n    this.add(light2);\n    // +x only on light\n    const light3 = new Mesh(geometry, this.createAreaLightMaterial(23));\n    light3.position.set(14.0, 12.0, 0.0);\n    light3.scale.set(0.1, 5.0, 5.0);\n    this.add(light3);\n    // +z\n    const light4 = new Mesh(geometry, this.createAreaLightMaterial(16));\n    light4.position.set(0.0, 9.0, 14.0);\n    light4.scale.set(5.0, 5.0, 0.1);\n    this.add(light4);\n    // -z right\n    const light5 = new Mesh(geometry, this.createAreaLightMaterial(80));\n    light5.position.set(7.0, 8.0, -14.0);\n    light5.scale.set(2.5, 2.5, 0.1);\n    this.add(light5);\n    // -z left\n    const light6 = new Mesh(geometry, this.createAreaLightMaterial(80));\n    light6.position.set(-7.0, 16.0, -14.0);\n    light6.scale.set(2.5, 2.5, 0.1);\n    this.add(light6);\n    // +y\n    const light7 = new Mesh(geometry, this.createAreaLightMaterial(1));\n    light7.position.set(0.0, 20.0, 0.0);\n    light7.scale.set(0.1, 0.1, 0.1);\n    this.add(light7);\n  }\n  createAreaLightMaterial(intensity) {\n    const material = new MeshBasicMaterial();\n    material.color.setScalar(intensity);\n    return material;\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\nhdrLoader.setDataType(HalfFloatType);\nclass TextureUtils extends EventDispatcher {\n  constructor(threeRenderer) {\n    super();\n    this.threeRenderer = threeRenderer;\n    this.generatedEnvironmentMap = null;\n    this.generatedEnvironmentMapAlt = null;\n    this.skyboxCache = new Map();\n    this.blurMaterial = null;\n    this.blurScene = null;\n  }\n  async load(url, progressCallback = () => {}) {\n    try {\n      const isHDR = HDR_FILE_RE.test(url);\n      const loader = isHDR ? hdrLoader : ldrLoader;\n      const texture = await new Promise((resolve, reject) =>\n        loader.load(\n          url,\n          resolve,\n          (event) => {\n            progressCallback((event.loaded / event.total) * 0.9);\n          },\n          reject,\n        ),\n      );\n      progressCallback(1.0);\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n      if (!isHDR) {\n        texture.encoding = GammaEncoding;\n      }\n      return texture;\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(\n    skyboxUrl = null,\n    environmentMap = null,\n    options = {},\n  ) {\n    const { progressTracker } = options;\n    const updateGenerationProgress =\n      progressTracker != null ? progressTracker.beginActivity() : () => {};\n    const useAltEnvironment = environmentMap === 'neutral';\n    if (useAltEnvironment === true) {\n      environmentMap = null;\n    }\n    const environmentMapUrl = deserializeUrl(environmentMap);\n    try {\n      let skyboxLoads = Promise.resolve(null);\n      let environmentMapLoads;\n      // If we have a skybox URL, attempt to load it as a cubemap\n      if (!!skyboxUrl) {\n        skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressTracker);\n      }\n      if (!!environmentMapUrl) {\n        // We have an available environment map URL\n        environmentMapLoads = this.loadEquirectFromUrl(\n          environmentMapUrl,\n          progressTracker,\n        );\n      } else if (!!skyboxUrl) {\n        // Fallback to deriving the environment map from an available skybox\n        environmentMapLoads = this.loadEquirectFromUrl(\n          skyboxUrl,\n          progressTracker,\n        );\n      } else {\n        // Fallback to generating the environment map\n        environmentMapLoads =\n          useAltEnvironment === true\n            ? this.loadGeneratedEnvironmentMapAlt()\n            : this.loadGeneratedEnvironmentMap();\n      }\n      let [environmentMap, skybox] = await Promise.all([\n        environmentMapLoads,\n        skyboxLoads,\n      ]);\n      if (environmentMap == null) {\n        throw new Error('Failed to load environment map.');\n      }\n      return { environmentMap, skybox };\n    } finally {\n      updateGenerationProgress(1.0);\n    }\n  }\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  async loadEquirectFromUrl(url, progressTracker) {\n    if (!this.skyboxCache.has(url)) {\n      const progressCallback = progressTracker\n        ? progressTracker.beginActivity()\n        : () => {};\n      const skyboxMapLoads = this.load(url, progressCallback);\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n    return this.skyboxCache.get(url);\n  }\n  async GenerateEnvironmentMap(scene, name) {\n    await timePasses();\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      encoding: LinearEncoding,\n      depthBuffer: true,\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n    // These hacks are to work around the three.js PMREM not being applied to\n    // generated cube maps, and the coordinate flip not getting applied\n    // automatically.\n    generatedEnvironmentMap.isRenderTargetTexture = false;\n    generatedEnvironmentMap.images = [1, 1, 1, 1, 1, 1];\n    scene.scale.setComponent(0, -1);\n    const outputEncoding = renderer.outputEncoding;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n    cubeCamera.update(renderer, scene);\n    await this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n    return generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  async loadGeneratedEnvironmentMap() {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap = this.GenerateEnvironmentMap(\n        new EnvironmentScene(),\n        'default',\n      );\n    }\n    return this.generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  async loadGeneratedEnvironmentMapAlt() {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(\n        new EnvironmentSceneAlt(),\n        'neutral',\n      );\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n  async blurCubemap(cubeTarget, sigma) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n  async halfblur(targetIn, targetOut, sigmaRadians, direction) {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians)\n      ? Math.PI / (2 * pixels)\n      : (2 * Math.PI) / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians)\n      ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels)\n      : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(\n        `sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`,\n      );\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp((-x * x) / 2);\n      weights.push(weight);\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    const blurUniforms = this.blurMaterial.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene);\n  }\n  getBlurShader(maxSamples) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n      name: 'SphericalGaussianBlur',\n      defines: { n: maxSamples },\n      uniforms: {\n        envMap: { value: null },\n        samples: { value: 1 },\n        weights: { value: weights },\n        latitudinal: { value: false },\n        dTheta: { value: 0 },\n        poleAxis: { value: poleAxis },\n      },\n      vertexShader: /* glsl */ `\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n      fragmentShader: /* glsl */ `\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide,\n    });\n    return shaderMaterial;\n  }\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 18;\nconst HIGH_FRAME_DURATION_MS = 26;\nconst MAX_AVG_CHANGE_MS = 2;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nconst DEFAULT_POWER_PREFERENCE = 'high-performance';\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transfering of\n * the texture.\n */\nclass Renderer extends EventDispatcher {\n  constructor(options) {\n    super();\n    this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.width = 0;\n    this.height = 0;\n    this.dpr = 1;\n    this.debugger = null;\n    this.scenes = new Set();\n    this.multipleScenesVisible = false;\n    this.scaleStep = 0;\n    this.lastStep = DEFAULT_LAST_STEP;\n    this.avgFrameDuration =\n      (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    this.onWebGLContextLost = (event) => {\n      this.dispatchEvent({ type: 'contextlost', sourceEvent: event });\n    };\n    this.onWebGLContextRestored = () => {\n      var _a;\n      (_a = this.textureUtils) === null || _a === void 0\n        ? void 0\n        : _a.dispose();\n      this.textureUtils = new TextureUtils(this.threeRenderer);\n      this.roughnessMipmapper = new RoughnessMipmapper(this.threeRenderer);\n      for (const scene of this.scenes) {\n        scene.element[$updateEnvironment]();\n      }\n      this.threeRenderer.shadowMap.needsUpdate = true;\n    };\n    this.dpr = resolveDpr();\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference,\n        preserveDrawingBuffer: true,\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.outputEncoding = GammaEncoding;\n      this.threeRenderer.physicallyCorrectLights = true;\n      this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n      this.threeRenderer.shadowMap.enabled = true;\n      this.threeRenderer.shadowMap.type = PCFSoftShadowMap;\n      this.threeRenderer.shadowMap.autoUpdate = false;\n      this.debugger = !!options.debug ? new Debugger(this) : null;\n      this.threeRenderer.debug = { checkShaderErrors: !!this.debugger };\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils = this.canRender\n      ? new TextureUtils(this.threeRenderer)\n      : null;\n    this.roughnessMipmapper = new RoughnessMipmapper(this.threeRenderer);\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener(\n      'webglcontextrestored',\n      this.onWebGLContextRestored,\n    );\n    this.updateRendererSize();\n    this.lastTick = performance.now();\n    this.avgFrameDuration = 0;\n  }\n  static get singleton() {\n    return this._singleton;\n  }\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n    this._singleton = new Renderer({\n      powerPreference:\n        (self.ModelViewerElement || {}).powerPreference ||\n        DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode(),\n    });\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n  set minScale(scale) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  updateRendererSize() {\n    const dpr = resolveDpr();\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const { element } = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    if (this.canRender) {\n      this.threeRenderer.setSize(width * dpr, height * dpr, false);\n    }\n    // Expand the canvas size to make up for shrinking the viewport.\n    const scale = this.scaleFactor;\n    const widthCSS = width / scale;\n    const heightCSS = height / scale;\n    // The canvas element must by styled outside of three due to the offscreen\n    // canvas not being directly stylable.\n    this.canvas3D.style.width = `${widthCSS}px`;\n    this.canvas3D.style.height = `${heightCSS}px`;\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const { canvas } = scene;\n      canvas.width = Math.round(width * dpr);\n      canvas.height = Math.round(height * dpr);\n      canvas.style.width = `${widthCSS}px`;\n      canvas.style.height = `${heightCSS}px`;\n      scene.queueRender();\n    }\n  }\n  updateRendererScale() {\n    const scaleStep = this.scaleStep;\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (\n      this.avgFrameDuration < LOW_FRAME_DURATION_MS &&\n      this.scaleStep > 0\n    ) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n    if (scaleStep == this.scaleStep) {\n      return;\n    }\n    const scale = this.scaleFactor;\n    this.avgFrameDuration =\n      (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    const width = this.width / scale;\n    const height = this.height / scale;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n    for (const scene of this.scenes) {\n      const { style } = scene.canvas;\n      style.width = `${width}px`;\n      style.height = `${height}px`;\n      scene.queueRender();\n    }\n  }\n  registerScene(scene) {\n    this.scenes.add(scene);\n    const { canvas } = scene;\n    const scale = this.scaleFactor;\n    canvas.width = Math.round(this.width * this.dpr);\n    canvas.height = Math.round(this.height * this.dpr);\n    canvas.style.width = `${this.width / scale}px`;\n    canvas.style.height = `${this.height / scale}px`;\n    if (this.multipleScenesVisible) {\n      canvas.classList.add('show');\n    }\n    scene.queueRender();\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time, frame) =>\n        this.render(time, frame),\n      );\n    }\n    if (this.debugger != null) {\n      this.debugger.addScene(scene);\n    }\n  }\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n    if (this.debugger != null) {\n      this.debugger.removeScene(scene);\n    }\n  }\n  displayCanvas(scene) {\n    return this.multipleScenesVisible ? scene.element[$canvas] : this.canvas3D;\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  selectCanvas() {\n    let visibleScenes = 0;\n    let visibleCanvas = null;\n    for (const scene of this.scenes) {\n      const { element } = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n        visibleCanvas = scene.canvas;\n      }\n    }\n    if (visibleCanvas == null) {\n      return;\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n    const { canvas3D } = this;\n    if (\n      multipleScenesVisible === this.multipleScenesVisible &&\n      (multipleScenesVisible ||\n        canvas3D.parentElement === visibleCanvas.parentElement)\n    ) {\n      return;\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n    if (multipleScenesVisible) {\n      canvas3D.classList.remove('show');\n    }\n    for (const scene of this.scenes) {\n      if (scene.externalRenderer != null) {\n        continue;\n      }\n      const canvas = scene.element[$canvas];\n      if (multipleScenesVisible) {\n        canvas.classList.add('show');\n        scene.queueRender();\n      } else if (scene.canvas === visibleCanvas) {\n        scene.canvas.parentElement.appendChild(canvas3D);\n        canvas3D.classList.add('show');\n        canvas.classList.remove('show');\n        scene.queueRender();\n      }\n    }\n  }\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  orderedScenes() {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n  get isPresenting() {\n    return this.arRenderer.isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene, t, delta) {\n    const { element, exposure } = scene;\n    element[$tick](t, delta);\n    const exposureIsNumber =\n      typeof exposure === 'number' && !self.isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n    if (scene.isShadowDirty()) {\n      this.threeRenderer.shadowMap.needsUpdate = true;\n    }\n  }\n  render(t, frame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n    this.avgFrameDuration += clamp(\n      DURATION_DECAY * (delta - this.avgFrameDuration),\n      -MAX_AVG_CHANGE_MS,\n      MAX_AVG_CHANGE_MS,\n    );\n    this.selectCanvas();\n    this.updateRendererSize();\n    this.updateRendererScale();\n    const { dpr, scaleFactor } = this;\n    for (const scene of this.orderedScenes()) {\n      const { element } = scene;\n      if (!element.modelIsVisible && scene.renderCount > 0) {\n        continue;\n      }\n      this.preRender(scene, t, delta);\n      if (!scene.shouldRender()) {\n        continue;\n      }\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const { matrix, projectionMatrix } = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements,\n        });\n        continue;\n      }\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n      // We avoid using the Three.js PixelRatio and handle it ourselves here so\n      // that we can do proper rounding and avoid white boundary pixels.\n      const width = Math.min(\n        Math.ceil(scene.width * scaleFactor * dpr),\n        this.canvas3D.width,\n      );\n      const height = Math.min(\n        Math.ceil(scene.height * scaleFactor * dpr),\n        this.canvas3D.height,\n      );\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(\n        0,\n        Math.floor(this.height * dpr) - height,\n        width,\n        height,\n      );\n      this.threeRenderer.render(scene, scene.camera);\n      if (this.multipleScenesVisible) {\n        if (scene.context == null) {\n          scene.createContext();\n        }\n        const context2D = scene.context;\n        context2D.clearRect(0, 0, width, height);\n        context2D.drawImage(\n          this.canvas3D,\n          0,\n          0,\n          width,\n          height,\n          0,\n          0,\n          width,\n          height,\n        );\n      }\n      scene.hasRendered();\n      if (element.loaded) {\n        ++scene.renderCount;\n      }\n    }\n  }\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n    if (this.roughnessMipmapper != null) {\n      this.roughnessMipmapper.dispose();\n    }\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n    this.canvas3D.removeEventListener(\n      'webglcontextlost',\n      this.onWebGLContextLost,\n    );\n    this.canvas3D.removeEventListener(\n      'webglcontextrestored',\n      this.onWebGLContextRestored,\n    );\n    return elements;\n  }\n}\nRenderer._singleton = new Renderer({\n  powerPreference:\n    (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n  debug: isDebugMode(),\n});\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts a base64 string which represents a data url\n * into a Blob of the same contents.\n */\nconst dataUrlToBlob = async (base64DataUrl) => {\n  return new Promise((resolve, reject) => {\n    const sliceSize = 512;\n    const typeMatch = base64DataUrl.match(/data:(.*);/);\n    if (!typeMatch) {\n      return reject(new Error(`${base64DataUrl} is not a valid data Url`));\n    }\n    const type = typeMatch[1];\n    const base64 = base64DataUrl.replace(/data:image\\/\\w+;base64,/, '');\n    const byteCharacters = atob(base64);\n    const byteArrays = [];\n    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {\n      const slice = byteCharacters.slice(offset, offset + sliceSize);\n      const byteNumbers = new Array(slice.length);\n      for (let i = 0; i < slice.length; i++) {\n        byteNumbers[i] = slice.charCodeAt(i);\n      }\n      const byteArray = new Uint8Array(byteNumbers);\n      byteArrays.push(byteArray);\n    }\n    resolve(new Blob(byteArrays, { type }));\n  });\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a$8, _b$7;\nconst $ongoingActivities = Symbol('ongoingActivities');\nconst $announceTotalProgress = Symbol('announceTotalProgress');\nconst $eventDelegate = Symbol('eventDelegate');\nconst ACTIVITY_PROGRESS_WEIGHT = 0.5;\n/**\n * ProgressTracker is an event emitter that helps to track the ongoing progress\n * of many simultaneous actions.\n *\n * ProgressTracker reports progress activity in the form of a progress event.\n * The event.detail.totalProgress value indicates the elapsed progress of all\n * activities being tracked by the ProgressTracker.\n *\n * The value of totalProgress is a number that progresses from 0 to 1. The\n * ProgressTracker allows for the lazy accumulation of tracked actions, so the\n * total progress represents a abstract, non-absolute progress towards the\n * completion of all currently tracked events.\n *\n * When all currently tracked activities are finished, the ProgressTracker\n * emits one final progress event and then resets the list of its currently\n * tracked activities. This means that from an observer's perspective,\n * ongoing activities will accumulate and collectively contribute to the notion\n * of total progress until all currently tracked ongoing activities have\n * completed.\n */\nclass ProgressTracker {\n  constructor() {\n    // NOTE(cdata): This eventDelegate hack is a quick trick to let us get the\n    // EventTarget interface without implementing or requiring a full polyfill. We\n    // should remove this once EventTarget is inheritable everywhere.\n    this[_a$8] = document.createDocumentFragment();\n    // NOTE(cdata): We declare each of these methods independently here so that we\n    // can inherit the correct types from EventTarget's interface. Maybe there is\n    // a better way to do this dynamically so that we don't repeat ourselves?\n    this.addEventListener = (...args) =>\n      this[$eventDelegate].addEventListener(...args);\n    this.removeEventListener = (...args) =>\n      this[$eventDelegate].removeEventListener(...args);\n    this.dispatchEvent = (...args) =>\n      this[$eventDelegate].dispatchEvent(...args);\n    this[_b$7] = new Set();\n  }\n  /**\n   * The total number of activities currently being tracked.\n   */\n  get ongoingActivityCount() {\n    return this[$ongoingActivities].size;\n  }\n  /**\n   * Registers a new activity to be tracked by the progress tracker. The method\n   * returns a special callback that should be invoked whenever new progress is\n   * ready to be reported. The progress should be reported as a value between 0\n   * and 1, where 0 would represent the beginning of the action and 1 would\n   * represent its completion.\n   *\n   * There is no built-in notion of a time-out for ongoing activities, so once\n   * an ongoing activity is begun, it is up to the consumer of this API to\n   * update the progress until that activity is no longer ongoing.\n   *\n   * Progress is only allowed to move forward for any given activity. If a lower\n   * progress is reported than the previously reported progress, it will be\n   * ignored.\n   */\n  beginActivity() {\n    const activity = { progress: 0 };\n    this[$ongoingActivities].add(activity);\n    if (this.ongoingActivityCount === 1) {\n      // Announce the first progress event (which should always be 0 / 1\n      // total progress):\n      this[$announceTotalProgress]();\n    }\n    return (progress) => {\n      let nextProgress;\n      nextProgress = Math.max(clamp(progress, 0, 1), activity.progress);\n      if (nextProgress !== activity.progress) {\n        activity.progress = nextProgress;\n        this[$announceTotalProgress]();\n      }\n      return activity.progress;\n    };\n  }\n  [((_a$8 = $eventDelegate),\n  (_b$7 = $ongoingActivities),\n  $announceTotalProgress)]() {\n    let totalProgress = 0;\n    let statusCount = 0;\n    let completedActivities = 0;\n    for (const activity of this[$ongoingActivities]) {\n      const { progress } = activity;\n      const compoundWeight =\n        ACTIVITY_PROGRESS_WEIGHT / Math.pow(2, statusCount++);\n      totalProgress += progress * compoundWeight;\n      if (progress === 1.0) {\n        completedActivities++;\n      }\n    }\n    if (completedActivities === this.ongoingActivityCount) {\n      totalProgress = 1.0;\n      this[$ongoingActivities].clear();\n    }\n    this.dispatchEvent(\n      new CustomEvent('progress', { detail: { totalProgress } }),\n    );\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate$6 =\n  (undefined && undefined.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === 'object' && typeof undefined === 'function')\n      r = undefined(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nvar _a$7, _b$6, _c$3, _d$2, _e, _f, _g, _h, _j, _k;\nconst CLEAR_MODEL_TIMEOUT_MS = 1000;\nconst FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;\nconst ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;\nconst UNSIZED_MEDIA_WIDTH = 300;\nconst UNSIZED_MEDIA_HEIGHT = 150;\nconst blobCanvas = document.createElement('canvas');\nconst $fallbackResizeHandler = Symbol('fallbackResizeHandler');\nconst $defaultAriaLabel = Symbol('defaultAriaLabel');\nconst $resizeObserver = Symbol('resizeObserver');\nconst $clearModelTimeout = Symbol('clearModelTimeout');\nconst $onContextLost = Symbol('onContextLost');\nconst $loaded = Symbol('loaded');\nconst $updateSize = Symbol('updateSize');\nconst $intersectionObserver = Symbol('intersectionObserver');\nconst $isElementInViewport = Symbol('isElementInViewport');\nconst $announceModelVisibility = Symbol('announceModelVisibility');\nconst $ariaLabel = Symbol('ariaLabel');\nconst $loadedTime = Symbol('loadedTime');\nconst $updateSource = Symbol('updateSource');\nconst $markLoaded = Symbol('markLoaded');\nconst $container = Symbol('container');\nconst $userInputElement = Symbol('input');\nconst $canvas = Symbol('canvas');\nconst $scene = Symbol('scene');\nconst $needsRender = Symbol('needsRender');\nconst $tick = Symbol('tick');\nconst $onModelLoad = Symbol('onModelLoad');\nconst $onResize = Symbol('onResize');\nconst $renderer = Symbol('renderer');\nconst $progressTracker = Symbol('progressTracker');\nconst $getLoaded = Symbol('getLoaded');\nconst $getModelIsVisible = Symbol('getModelIsVisible');\nconst $shouldAttemptPreload = Symbol('shouldAttemptPreload');\nconst $sceneIsReady = Symbol('sceneIsReady');\nconst $hasTransitioned = Symbol('hasTransitioned');\nconst toVector3D = (v) => {\n  return {\n    x: v.x,\n    y: v.y,\n    z: v.z,\n    toString() {\n      return `${this.x}m ${this.y}m ${this.z}m`;\n    },\n  };\n};\n/**\n * Definition for a basic <model-viewer> element.\n */\nclass ModelViewerElementBase extends UpdatingElement {\n  /**\n   * Creates a new ModelViewerElement.\n   */\n  constructor() {\n    super();\n    this.alt = null;\n    this.src = null;\n    this[_a$7] = false;\n    this[_b$6] = false;\n    this[_c$3] = 0;\n    this[_d$2] = null;\n    this[_e] = debounce(() => {\n      const boundingRect = this.getBoundingClientRect();\n      this[$updateSize](boundingRect);\n    }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);\n    this[_f] = debounce((oldVisibility) => {\n      const newVisibility = this.modelIsVisible;\n      if (newVisibility !== oldVisibility) {\n        this.dispatchEvent(\n          new CustomEvent('model-visibility', {\n            detail: { visible: newVisibility },\n          }),\n        );\n      }\n    }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);\n    this[_g] = null;\n    this[_h] = null;\n    this[_j] = new ProgressTracker();\n    this[_k] = (event) => {\n      this.dispatchEvent(\n        new CustomEvent('error', {\n          detail: { type: 'webglcontextlost', sourceError: event.sourceEvent },\n        }),\n      );\n    };\n    this.attachShadow({ mode: 'open' });\n    const shadowRoot = this.shadowRoot;\n    makeTemplate(shadowRoot);\n    this[$container] = shadowRoot.querySelector('.container');\n    this[$userInputElement] = shadowRoot.querySelector('.userInput');\n    this[$canvas] = shadowRoot.querySelector('canvas');\n    this[$defaultAriaLabel] =\n      this[$userInputElement].getAttribute('aria-label');\n    // Because of potential race conditions related to invoking the constructor\n    // we only use the bounding rect to set the initial size if the element is\n    // already connected to the document:\n    let width, height;\n    if (this.isConnected) {\n      const rect = this.getBoundingClientRect();\n      width = rect.width;\n      height = rect.height;\n    } else {\n      width = UNSIZED_MEDIA_WIDTH;\n      height = UNSIZED_MEDIA_HEIGHT;\n    }\n    // Create the underlying ModelScene.\n    this[$scene] = new ModelScene({\n      canvas: this[$canvas],\n      element: this,\n      width,\n      height,\n    });\n    this[$scene].addEventListener('model-load', async (event) => {\n      this[$markLoaded]();\n      this[$onModelLoad]();\n      // Give loading async tasks a chance to complete.\n      await timePasses();\n      this.dispatchEvent(\n        new CustomEvent('load', { detail: { url: event.url } }),\n      );\n    });\n    // Update initial size on microtask timing so that subclasses have a\n    // chance to initialize\n    Promise.resolve().then(() => {\n      this[$updateSize](this.getBoundingClientRect());\n    });\n    if (HAS_RESIZE_OBSERVER) {\n      // Set up a resize observer so we can scale our canvas\n      // if our <model-viewer> changes\n      this[$resizeObserver] = new ResizeObserver((entries) => {\n        // Don't resize anything if in AR mode; otherwise the canvas\n        // scaling to fullscreen on entering AR will clobber the flat/2d\n        // dimensions of the element.\n        if (this[$renderer].isPresenting) {\n          return;\n        }\n        for (let entry of entries) {\n          if (entry.target === this) {\n            this[$updateSize](entry.contentRect);\n          }\n        }\n      });\n    }\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver] = new IntersectionObserver(\n        (entries) => {\n          for (let entry of entries) {\n            if (entry.target === this) {\n              const oldVisibility = this.modelIsVisible;\n              this[$isElementInViewport] = entry.isIntersecting;\n              this[$announceModelVisibility](oldVisibility);\n              if (this[$isElementInViewport] && !this[$sceneIsReady]()) {\n                this[$updateSource]();\n              }\n            }\n          }\n        },\n        {\n          root: null,\n          // We used to have margin here, but it was causing animated models below\n          // the fold to steal the frame budget. Weirder still, it would also\n          // cause input events to be swallowed, sometimes for seconds on the\n          // model above the fold, but only when the animated model was completely\n          // below. Setting this margin to zero fixed it.\n          rootMargin: '0px',\n          threshold: 0,\n        },\n      );\n    } else {\n      // If there is no intersection obsever, then all models should be visible\n      // at all times:\n      this[$isElementInViewport] = true;\n    }\n  }\n  static get is() {\n    return 'model-viewer';\n  }\n  /** @export */\n  static set modelCacheSize(value) {\n    CachingGLTFLoader[$evictionPolicy].evictionThreshold = value;\n  }\n  /** @export */\n  static get modelCacheSize() {\n    return CachingGLTFLoader[$evictionPolicy].evictionThreshold;\n  }\n  /** @export */\n  static set minimumRenderScale(value) {\n    if (value > 1) {\n      console.warn(\n        '<model-viewer> minimumRenderScale has been clamped to a maximum value of 1.',\n      );\n    }\n    if (value <= 0) {\n      console.warn(\n        '<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25.',\n      );\n    }\n    Renderer.singleton.minScale = value;\n  }\n  /** @export */\n  static get minimumRenderScale() {\n    return Renderer.singleton.minScale;\n  }\n  /** @export */\n  get loaded() {\n    return this[$getLoaded]();\n  }\n  get [((_a$7 = $isElementInViewport),\n  (_b$6 = $loaded),\n  (_c$3 = $loadedTime),\n  (_d$2 = $clearModelTimeout),\n  (_e = $fallbackResizeHandler),\n  (_f = $announceModelVisibility),\n  (_g = $resizeObserver),\n  (_h = $intersectionObserver),\n  (_j = $progressTracker),\n  $renderer)]() {\n    return Renderer.singleton;\n  }\n  /** @export */\n  get modelIsVisible() {\n    return this[$getModelIsVisible]();\n  }\n  connectedCallback() {\n    super.connectedCallback && super.connectedCallback();\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].observe(this);\n    } else {\n      self.addEventListener('resize', this[$fallbackResizeHandler]);\n    }\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].observe(this);\n    }\n    const renderer = this[$renderer];\n    renderer.addEventListener('contextlost', this[$onContextLost]);\n    renderer.registerScene(this[$scene]);\n    if (this[$clearModelTimeout] != null) {\n      self.clearTimeout(this[$clearModelTimeout]);\n      this[$clearModelTimeout] = null;\n      // Force an update in case the model has been evicted from our GLTF cache\n      // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate\n      this.requestUpdate('src', null);\n    }\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback && super.disconnectedCallback();\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].unobserve(this);\n    } else {\n      self.removeEventListener('resize', this[$fallbackResizeHandler]);\n    }\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].unobserve(this);\n    }\n    const renderer = this[$renderer];\n    renderer.removeEventListener('contextlost', this[$onContextLost]);\n    renderer.unregisterScene(this[$scene]);\n    this[$clearModelTimeout] = self.setTimeout(() => {\n      this[$scene].reset();\n    }, CLEAR_MODEL_TIMEOUT_MS);\n  }\n  updated(changedProperties) {\n    super.updated(changedProperties);\n    // NOTE(cdata): If a property changes from values A -> B -> A in the space\n    // of a microtask, LitElement/UpdatingElement will notify of a change even\n    // though the value has effectively not changed, so we need to check to make\n    // sure that the value has actually changed before changing the loaded flag.\n    if (changedProperties.has('src')) {\n      if (this.src == null) {\n        this[$loaded] = false;\n        this[$loadedTime] = 0;\n        this[$scene].reset();\n      } else if (this.src !== this[$scene].url) {\n        this[$loaded] = false;\n        this[$loadedTime] = 0;\n        this[$updateSource]();\n      }\n    }\n    if (changedProperties.has('alt')) {\n      const ariaLabel = this.alt == null ? this[$defaultAriaLabel] : this.alt;\n      this[$userInputElement].setAttribute('aria-label', ariaLabel);\n    }\n  }\n  /** @export */\n  toDataURL(type, encoderOptions) {\n    return this[$renderer]\n      .displayCanvas(this[$scene])\n      .toDataURL(type, encoderOptions);\n  }\n  /** @export */\n  async toBlob(options) {\n    const mimeType = options ? options.mimeType : undefined;\n    const qualityArgument = options ? options.qualityArgument : undefined;\n    const idealAspect = options ? options.idealAspect : undefined;\n    const { width, height, fieldOfViewAspect, aspect } = this[$scene];\n    const { dpr, scaleFactor } = this[$renderer];\n    let outputWidth = width * scaleFactor * dpr;\n    let outputHeight = height * scaleFactor * dpr;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (idealAspect === true) {\n      if (fieldOfViewAspect > aspect) {\n        const oldHeight = outputHeight;\n        outputHeight = Math.round(outputWidth / fieldOfViewAspect);\n        offsetY = (oldHeight - outputHeight) / 2;\n      } else {\n        const oldWidth = outputWidth;\n        outputWidth = Math.round(outputHeight * fieldOfViewAspect);\n        offsetX = (oldWidth - outputWidth) / 2;\n      }\n    }\n    blobCanvas.width = outputWidth;\n    blobCanvas.height = outputHeight;\n    try {\n      return new Promise(async (resolve, reject) => {\n        blobCanvas\n          .getContext('2d')\n          .drawImage(\n            this[$renderer].displayCanvas(this[$scene]),\n            offsetX,\n            offsetY,\n            outputWidth,\n            outputHeight,\n            0,\n            0,\n            outputWidth,\n            outputHeight,\n          );\n        if (blobCanvas.msToBlob) {\n          // NOTE: msToBlob only returns image/png\n          // so ensure mimeType is not specified (defaults to image/png)\n          // or is image/png, otherwise fallback to using toDataURL on IE.\n          if (!mimeType || mimeType === 'image/png') {\n            return resolve(blobCanvas.msToBlob());\n          }\n        }\n        if (!blobCanvas.toBlob) {\n          return resolve(\n            await dataUrlToBlob(\n              blobCanvas.toDataURL(mimeType, qualityArgument),\n            ),\n          );\n        }\n        blobCanvas.toBlob(\n          (blob) => {\n            if (!blob) {\n              return reject(new Error('Unable to retrieve canvas blob'));\n            }\n            resolve(blob);\n          },\n          mimeType,\n          qualityArgument,\n        );\n      });\n    } finally {\n      this[$updateSize]({ width, height });\n    }\n  }\n  registerRenderer(renderer) {\n    this[$scene].externalRenderer = renderer;\n  }\n  unregisterRenderer() {\n    this[$scene].externalRenderer = null;\n  }\n  get [$ariaLabel]() {\n    return this.alt == null || this.alt === 'null'\n      ? this[$defaultAriaLabel]\n      : this.alt;\n  }\n  // NOTE(cdata): Although this may seem extremely redundant, it is required in\n  // order to support overloading when TypeScript is compiled to ES5\n  // @see https://github.com/Polymer/lit-element/pull/745\n  // @see https://github.com/microsoft/TypeScript/issues/338\n  [$getLoaded]() {\n    return this[$loaded];\n  }\n  // @see [$getLoaded]\n  [$getModelIsVisible]() {\n    return this.loaded && this[$isElementInViewport];\n  }\n  [$hasTransitioned]() {\n    return this.modelIsVisible;\n  }\n  [$shouldAttemptPreload]() {\n    return !!this.src && this[$isElementInViewport];\n  }\n  [$sceneIsReady]() {\n    return this[$loaded];\n  }\n  /**\n   * Called on initialization and when the resize observer fires.\n   */\n  [$updateSize]({ width, height }) {\n    this[$container].style.width = `${width}px`;\n    this[$container].style.height = `${height}px`;\n    this[$onResize]({ width: parseFloat(width), height: parseFloat(height) });\n  }\n  [$tick](_time, _delta) {}\n  [$markLoaded]() {\n    if (this[$loaded]) {\n      return;\n    }\n    this[$loaded] = true;\n    this[$loadedTime] = performance.now();\n  }\n  [$needsRender]() {\n    this[$scene].queueRender();\n  }\n  [$onModelLoad]() {}\n  [$onResize](e) {\n    this[$scene].setSize(e.width, e.height);\n  }\n  /**\n   * Parses the element for an appropriate source URL and\n   * sets the views to use the new model based off of the `preload`\n   * attribute.\n   */\n  async [((_k = $onContextLost), $updateSource)]() {\n    if (this.loaded || !this[$shouldAttemptPreload]()) {\n      return;\n    }\n    const updateSourceProgress = this[$progressTracker].beginActivity();\n    const source = this.src;\n    try {\n      await this[$scene].setSource(source, (progress) =>\n        updateSourceProgress(progress * 0.8),\n      );\n      const detail = { url: source };\n      this.dispatchEvent(new CustomEvent('preload', { detail }));\n    } catch (error) {\n      this.dispatchEvent(new CustomEvent('error', { detail: error }));\n    } finally {\n      updateSourceProgress(0.9);\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          updateSourceProgress(1.0);\n        });\n      });\n    }\n  }\n}\n__decorate$6(\n  [property({ type: String })],\n  ModelViewerElementBase.prototype,\n  'alt',\n  void 0,\n);\n__decorate$6(\n  [property({ type: String })],\n  ModelViewerElementBase.prototype,\n  'src',\n  void 0,\n);\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate$5 =\n  (undefined && undefined.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === 'object' && typeof undefined === 'function')\n      r = undefined(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nconst MILLISECONDS_PER_SECOND = 1000.0;\nconst $changeAnimation = Symbol('changeAnimation');\nconst $paused = Symbol('paused');\nconst AnimationMixin = (ModelViewerElement) => {\n  var _a;\n  class AnimationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.autoplay = false;\n      this.animationName = undefined;\n      this.animationCrossfadeDuration = 300;\n      this[_a] = true;\n    }\n    /**\n     * Returns an array\n     */\n    get availableAnimations() {\n      if (this.loaded) {\n        return this[$scene].animationNames;\n      }\n      return [];\n    }\n    get duration() {\n      return this[$scene].duration;\n    }\n    get paused() {\n      return this[$paused];\n    }\n    get currentTime() {\n      return this[$scene].animationTime;\n    }\n    set currentTime(value) {\n      this[$scene].animationTime = value;\n      this[$renderer].threeRenderer.shadowMap.needsUpdate = true;\n      this[$needsRender]();\n    }\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n      this[$paused] = true;\n      this[$renderer].threeRenderer.shadowMap.autoUpdate = false;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n    play() {\n      if (this[$paused] && this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$renderer].threeRenderer.shadowMap.autoUpdate = true;\n        if (!this[$scene].hasActiveAnimation) {\n          this[$changeAnimation]();\n        }\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n    [((_a = $paused), $onModelLoad)]() {\n      super[$onModelLoad]();\n      this[$paused] = true;\n      if (this.autoplay) {\n        this[$changeAnimation]();\n        this.play();\n      }\n    }\n    [$tick](_time, delta) {\n      super[$tick](_time, delta);\n      if (\n        this[$paused] ||\n        (!this[$hasTransitioned]() && !this[$renderer].isPresenting)\n      ) {\n        return;\n      }\n      this[$scene].updateAnimation(delta / MILLISECONDS_PER_SECOND);\n      this[$needsRender]();\n    }\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n    async [$updateSource]() {\n      // If we are loading a new model, we need to stop the animation of\n      // the current one (if any is playing). Otherwise, we might lose\n      // the reference to the scene root and running actions start to\n      // throw exceptions and/or behave in unexpected ways:\n      this[$scene].stopAnimation();\n      return super[$updateSource]();\n    }\n    [$changeAnimation]() {\n      this[$scene].playAnimation(\n        this.animationName,\n        this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND,\n      );\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n  }\n  __decorate$5(\n    [property({ type: Boolean })],\n    AnimationModelViewerElement.prototype,\n    'autoplay',\n    void 0,\n  );\n  __decorate$5(\n    [property({ type: String, attribute: 'animation-name' })],\n    AnimationModelViewerElement.prototype,\n    'animationName',\n    void 0,\n  );\n  __decorate$5(\n    [property({ type: Number, attribute: 'animation-crossfade-duration' })],\n    AnimationModelViewerElement.prototype,\n    'animationCrossfadeDuration',\n    void 0,\n  );\n  return AnimationModelViewerElement;\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot');\nconst worldToModel = new Matrix4();\nconst worldToModelNormal = new Matrix3();\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\nconst AnnotationMixin = (ModelViewerElement) => {\n  var _a, _b, _c;\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Map();\n      this[_b] = (mutations) => {\n        mutations.forEach((mutation) => {\n          // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n          // only has addedNodes and removedNodes (and no other details).\n          if (\n            !(mutation instanceof MutationRecord) ||\n            mutation.type === 'childList'\n          ) {\n            mutation.addedNodes.forEach((node) => {\n              this[$addHotspot](node);\n            });\n            mutation.removedNodes.forEach((node) => {\n              this[$removeHotspot](node);\n            });\n            this[$needsRender]();\n          }\n        });\n      };\n      this[_c] = new MutationObserver(this[$mutationCallback]);\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n      const { ShadyDOM } = self;\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, { childList: true });\n      } else {\n        this[$observer] = ShadyDOM.observeChildren(\n          this,\n          this[$mutationCallback],\n        );\n      }\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      const { ShadyDOM } = self;\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n    [((_a = $hotspotMap), (_b = $mutationCallback), (_c = $observer), $tick)](\n      time,\n      delta,\n    ) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const { annotationRenderer } = scene;\n      const camera = scene.getCamera();\n      if (scene.shouldRender()) {\n        scene.updateHotspots(camera.position);\n        annotationRenderer.domElement.style.display = '';\n        annotationRenderer.render(scene, camera);\n      }\n    }\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n    updateHotspot(config) {\n      const hotspot = this[$hotspotMap].get(config.name);\n      if (hotspot == null) {\n        return;\n      }\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n      this[$needsRender]();\n    }\n    /**\n     * This method returns the model position and normal of the point on the\n     * mesh corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The position and normal are returned as strings in\n     * the format suitable for putting in a hotspot's data-position and\n     * data-normal attributes. If the mesh is not hit, the result is null.\n     */\n    positionAndNormalFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n      const hit = scene.positionAndNormalFromPoint(ndcPosition);\n      if (hit == null) {\n        return null;\n      }\n      worldToModel.copy(scene.target.matrixWorld).invert();\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      worldToModelNormal.getNormalMatrix(worldToModel);\n      const normal = toVector3D(\n        hit.normal.applyNormalMatrix(worldToModelNormal),\n      );\n      return { position: position, normal: normal };\n    }\n    [$addHotspot](node) {\n      if (\n        !(node instanceof HTMLElement && node.slot.indexOf('hotspot') === 0)\n      ) {\n        return;\n      }\n      let hotspot = this[$hotspotMap].get(node.slot);\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal,\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].addHotspot(hotspot);\n      }\n      this[$scene].queueRender();\n    }\n    [$removeHotspot](node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n      const hotspot = this[$hotspotMap].get(node.slot);\n      if (!hotspot) {\n        return;\n      }\n      if (hotspot.decrement()) {\n        this[$scene].removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n      }\n      this[$scene].queueRender();\n    }\n  }\n  return AnnotationModelViewerElement;\n};\n\n/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\nversion 0.6.9\n*/\nvar durl = function (c) {\n  return URL.createObjectURL(new Blob([c], { type: 'text/javascript' }));\n};\ntry {\n  URL.revokeObjectURL(durl(''));\n} catch (e) {\n  // We're in Deno or a very old browser\n  durl = function (c) {\n    return 'data:application/javascript;charset=UTF-8,' + encodeURI(c);\n  };\n}\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array,\n  u16 = Uint16Array,\n  u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([\n  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n  5, 5, 0, /* unused */ 0, 0, /* impossible */ 0,\n]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([\n  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n  11, 12, 12, 13, 13, /* unused */ 0, 0,\n]);\n// code length index map\nvar clim = new u8([\n  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,\n]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n  var b = new u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  // numbers here are at max 18 bits\n  var r = new u32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = ((j - b[i]) << 5) | i;\n    }\n  }\n  return [b, r];\n};\nvar _a$6 = freb(fleb, 2),\n  fl = _a$6[0],\n  revfl = _a$6[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\n(fl[28] = 258), (revfl[258] = 28);\nvar _b$5 = freb(fdeb, 0),\n  revfd = _b$5[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  var x = ((i & 0xaaaa) >>> 1) | ((i & 0x5555) << 1);\n  x = ((x & 0xcccc) >>> 2) | ((x & 0x3333) << 2);\n  x = ((x & 0xf0f0) >>> 4) | ((x & 0x0f0f) << 4);\n  rev[i] = (((x & 0xff00) >>> 8) | ((x & 0x00ff) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function (cd, mb, r) {\n  var s = cd.length;\n  // index\n  var i = 0;\n  // u16 \"map\": index -> # of codes with bit length = index\n  var l = new u16(mb);\n  // length of cd must be 288 (total # of codes)\n  for (; i < s; ++i) ++l[cd[i] - 1];\n  // u16 \"map\": index -> minimum code for bit length = index\n  var le = new u16(mb);\n  for (i = 0; i < mb; ++i) {\n    le[i] = (le[i - 1] + l[i - 1]) << 1;\n  }\n  var co;\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb);\n    // bits to remove for reverser\n    var rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        var sv = (i << 4) | cd[i];\n        // free bits\n        var r_1 = mb - cd[i];\n        // start value\n        var v = le[cd[i] - 1]++ << r_1;\n        // m is end value\n        for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n      }\n    }\n  }\n  return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i) flt[i] = 8;\nfor (var i = 144; i < 256; ++i) flt[i] = 9;\nfor (var i = 256; i < 280; ++i) flt[i] = 7;\nfor (var i = 280; i < 288; ++i) flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i) fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0);\n// get end of byte\nvar shft = function (p) {\n  return ((p / 8) | 0) + (p & 7 && 1);\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length;\n  // can't use .constructor in case user-supplied\n  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n  v <<= p & 7;\n  var o = (p / 8) | 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n  v <<= p & 7;\n  var o = (p / 8) | 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n  d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n  // Need extra info to make a tree\n  var t = [];\n  for (var i = 0; i < d.length; ++i) {\n    if (d[i]) t.push({ s: i, f: d[i] });\n  }\n  var s = t.length;\n  var t2 = t.slice();\n  if (!s) return [et, 0];\n  if (s == 1) {\n    var v = new u8(t[0].s + 1);\n    v[t[0].s] = 1;\n    return [v, 1];\n  }\n  t.sort(function (a, b) {\n    return a.f - b.f;\n  });\n  // after i2 reaches last ind, will be stopped\n  // freq must be greater than largest possible number of symbols\n  t.push({ s: -1, f: 25001 });\n  var l = t[0],\n    r = t[1],\n    i0 = 0,\n    i1 = 1,\n    i2 = 2;\n  t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n  // efficient algorithm from UZIP.js\n  // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n  // symbols that combined have high freq, will start processing i2 (high-freq,\n  // non-composite) symbols instead\n  // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n  while (i1 != s - 1) {\n    l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n    t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n  }\n  var maxSym = t2[0].s;\n  for (var i = 1; i < s; ++i) {\n    if (t2[i].s > maxSym) maxSym = t2[i].s;\n  }\n  // code lengths\n  var tr = new u16(maxSym + 1);\n  // max bits in tree\n  var mbt = ln(t[i1 - 1], tr, 0);\n  if (mbt > mb) {\n    // more algorithms from UZIP.js\n    // TODO: find out how this code works (debt)\n    //  ind    debt\n    var i = 0,\n      dt = 0;\n    //    left            cost\n    var lft = mbt - mb,\n      cst = 1 << lft;\n    t2.sort(function (a, b) {\n      return tr[b.s] - tr[a.s] || a.f - b.f;\n    });\n    for (; i < s; ++i) {\n      var i2_1 = t2[i].s;\n      if (tr[i2_1] > mb) {\n        dt += cst - (1 << (mbt - tr[i2_1]));\n        tr[i2_1] = mb;\n      } else break;\n    }\n    dt >>>= lft;\n    while (dt > 0) {\n      var i2_2 = t2[i].s;\n      if (tr[i2_2] < mb) dt -= 1 << (mb - tr[i2_2]++ - 1);\n      else ++i;\n    }\n    for (; i >= 0 && dt; --i) {\n      var i2_3 = t2[i].s;\n      if (tr[i2_3] == mb) {\n        --tr[i2_3];\n        ++dt;\n      }\n    }\n    mbt = mb;\n  }\n  return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n  return n.s == -1\n    ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n    : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n  var s = c.length;\n  // Note that the semicolon was intentional\n  while (s && !c[--s]);\n  var cl = new u16(++s);\n  //  ind      num         streak\n  var cli = 0,\n    cln = c[0],\n    cls = 1;\n  var w = function (v) {\n    cl[cli++] = v;\n  };\n  for (var i = 1; i <= s; ++i) {\n    if (c[i] == cln && i != s) ++cls;\n    else {\n      if (!cln && cls > 2) {\n        for (; cls > 138; cls -= 138) w(32754);\n        if (cls > 2) {\n          w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n          cls = 0;\n        }\n      } else if (cls > 3) {\n        w(cln), --cls;\n        for (; cls > 6; cls -= 6) w(8304);\n        if (cls > 2) w(((cls - 3) << 5) | 8208), (cls = 0);\n      }\n      while (cls--) w(cln);\n      cls = 1;\n      cln = c[i];\n    }\n  }\n  return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n  var l = 0;\n  for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];\n  return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n  // no need to write 00 as type: TypedArray defaults to 0\n  var s = dat.length;\n  var o = shft(pos + 2);\n  out[o] = s & 255;\n  out[o + 1] = s >>> 8;\n  out[o + 2] = out[o] ^ 255;\n  out[o + 3] = out[o + 1] ^ 255;\n  for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];\n  return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n  wbits(out, p++, final);\n  ++lf[256];\n  var _a = hTree(lf, 15),\n    dlt = _a[0],\n    mlb = _a[1];\n  var _b = hTree(df, 15),\n    ddt = _b[0],\n    mdb = _b[1];\n  var _c = lc(dlt),\n    lclt = _c[0],\n    nlc = _c[1];\n  var _d = lc(ddt),\n    lcdt = _d[0],\n    ndc = _d[1];\n  var lcfreq = new u16(19);\n  for (var i = 0; i < lclt.length; ++i) lcfreq[lclt[i] & 31]++;\n  for (var i = 0; i < lcdt.length; ++i) lcfreq[lcdt[i] & 31]++;\n  var _e = hTree(lcfreq, 7),\n    lct = _e[0],\n    mlcb = _e[1];\n  var nlcc = 19;\n  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n  var flen = (bl + 5) << 3;\n  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n  var dtlen =\n    clen(lf, dlt) +\n    clen(df, ddt) +\n    eb +\n    14 +\n    3 * nlcc +\n    clen(lcfreq, lct) +\n    (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n  if (flen <= ftlen && flen <= dtlen)\n    return wfblk(out, p, dat.subarray(bs, bs + bl));\n  var lm, ll, dm, dl;\n  wbits(out, p, 1 + (dtlen < ftlen)), (p += 2);\n  if (dtlen < ftlen) {\n    (lm = hMap(dlt, mlb, 0)), (ll = dlt), (dm = hMap(ddt, mdb, 0)), (dl = ddt);\n    var llm = hMap(lct, mlcb, 0);\n    wbits(out, p, nlc - 257);\n    wbits(out, p + 5, ndc - 1);\n    wbits(out, p + 10, nlcc - 4);\n    p += 14;\n    for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);\n    p += 3 * nlcc;\n    var lcts = [lclt, lcdt];\n    for (var it = 0; it < 2; ++it) {\n      var clct = lcts[it];\n      for (var i = 0; i < clct.length; ++i) {\n        var len = clct[i] & 31;\n        wbits(out, p, llm[len]), (p += lct[len]);\n        if (len > 15)\n          wbits(out, p, (clct[i] >>> 5) & 127), (p += clct[i] >>> 12);\n      }\n    }\n  } else {\n    (lm = flm), (ll = flt), (dm = fdm), (dl = fdt);\n  }\n  for (var i = 0; i < li; ++i) {\n    if (syms[i] > 255) {\n      var len = (syms[i] >>> 18) & 31;\n      wbits16(out, p, lm[len + 257]), (p += ll[len + 257]);\n      if (len > 7) wbits(out, p, (syms[i] >>> 23) & 31), (p += fleb[len]);\n      var dst = syms[i] & 31;\n      wbits16(out, p, dm[dst]), (p += dl[dst]);\n      if (dst > 3) wbits16(out, p, (syms[i] >>> 5) & 8191), (p += fdeb[dst]);\n    } else {\n      wbits16(out, p, lm[syms[i]]), (p += ll[syms[i]]);\n    }\n  }\n  wbits16(out, p, lm[256]);\n  return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([\n  65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632,\n]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n  var s = dat.length;\n  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n  // writing to this writes to the output buffer\n  var w = o.subarray(pre, o.length - post);\n  var pos = 0;\n  if (!lvl || s < 8) {\n    for (var i = 0; i <= s; i += 65535) {\n      // end\n      var e = i + 65535;\n      if (e < s) {\n        // write full block\n        pos = wfblk(w, pos, dat.subarray(i, e));\n      } else {\n        // write final block\n        w[i] = lst;\n        pos = wfblk(w, pos, dat.subarray(i, s));\n      }\n    }\n  } else {\n    var opt = deo[lvl - 1];\n    var n = opt >>> 13,\n      c = opt & 8191;\n    var msk_1 = (1 << plvl) - 1;\n    //    prev 2-byte val map    curr 2-byte val map\n    var prev = new u16(32768),\n      head = new u16(msk_1 + 1);\n    var bs1_1 = Math.ceil(plvl / 3),\n      bs2_1 = 2 * bs1_1;\n    var hsh = function (i) {\n      return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1;\n    };\n    // 24576 is an arbitrary number of maximum symbols per block\n    // 424 buffer for last block\n    var syms = new u32(25000);\n    // length/literal freq   distance freq\n    var lf = new u16(288),\n      df = new u16(32);\n    //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n    var lc_1 = 0,\n      eb = 0,\n      i = 0,\n      li = 0,\n      wi = 0,\n      bs = 0;\n    for (; i < s; ++i) {\n      // hash value\n      // deopt when i > s - 3 - at end, deopt acceptable\n      var hv = hsh(i);\n      // index mod 32768    previous index mod\n      var imod = i & 32767,\n        pimod = head[hv];\n      prev[imod] = pimod;\n      head[hv] = imod;\n      // We always should modify head and prev, but only add symbols if\n      // this data is not yet processed (\"wait\" for wait index)\n      if (wi <= i) {\n        // bytes remaining\n        var rem = s - i;\n        if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n          (li = lc_1 = eb = 0), (bs = i);\n          for (var j = 0; j < 286; ++j) lf[j] = 0;\n          for (var j = 0; j < 30; ++j) df[j] = 0;\n        }\n        //  len    dist   chain\n        var l = 2,\n          d = 0,\n          ch_1 = c,\n          dif = (imod - pimod) & 32767;\n        if (rem > 2 && hv == hsh(i - dif)) {\n          var maxn = Math.min(n, rem) - 1;\n          var maxd = Math.min(32767, i);\n          // max possible length\n          // not capped at dif because decompressors implement \"rolling\" index population\n          var ml = Math.min(258, rem);\n          while (dif <= maxd && --ch_1 && imod != pimod) {\n            if (dat[i + l] == dat[i + l - dif]) {\n              var nl = 0;\n              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n              if (nl > l) {\n                (l = nl), (d = dif);\n                // break out early when we reach \"nice\" (we are satisfied enough)\n                if (nl > maxn) break;\n                // now, find the rarest 2-byte sequence within this\n                // length of literals and search for that instead.\n                // Much faster than just using the start\n                var mmd = Math.min(dif, nl - 2);\n                var md = 0;\n                for (var j = 0; j < mmd; ++j) {\n                  var ti = (i - dif + j + 32768) & 32767;\n                  var pti = prev[ti];\n                  var cd = (ti - pti + 32768) & 32767;\n                  if (cd > md) (md = cd), (pimod = ti);\n                }\n              }\n            }\n            // check the previous match\n            (imod = pimod), (pimod = prev[imod]);\n            dif += (imod - pimod + 32768) & 32767;\n          }\n        }\n        // d will be nonzero only when a match was found\n        if (d) {\n          // store both dist and len data in one Uint32\n          // Make sure this is recognized as a len/dist with 28th bit (2^28)\n          syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n          var lin = revfl[l] & 31,\n            din = revfd[d] & 31;\n          eb += fleb[lin] + fdeb[din];\n          ++lf[257 + lin];\n          ++df[din];\n          wi = i + l;\n          ++lc_1;\n        } else {\n          syms[li++] = dat[i];\n          ++lf[dat[i]];\n        }\n      }\n    }\n    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n    // this is the easiest way to avoid needing to maintain state\n    if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n  }\n  return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n  var t = new u32(256);\n  for (var i = 0; i < 256; ++i) {\n    var c = i,\n      k = 9;\n    while (--k) c = (c & 1 && 0xedb88320) ^ (c >>> 1);\n    t[i] = c;\n  }\n  return t;\n})();\n// CRC32\nvar crc = function () {\n  var c = -1;\n  return {\n    p: function (d) {\n      // closures have awful performance\n      var cr = c;\n      for (var i = 0; i < d.length; ++i)\n        cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n      c = cr;\n    },\n    d: function () {\n      return ~c;\n    },\n  };\n};\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n  return dflt(\n    dat,\n    opt.level == null ? 6 : opt.level,\n    opt.mem == null\n      ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5)\n      : 12 + opt.mem,\n    pre,\n    post,\n    !st,\n  );\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n  var o = {};\n  for (var k in a) o[k] = a[k];\n  for (var k in b) o[k] = b[k];\n  return o;\n};\n// write bytes\nvar wbytes = function (d, b, v) {\n  for (; v; ++b) (d[b] = v), (v >>>= 8);\n};\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nfunction deflateSync(data, opts) {\n  return dopt(data, opts || {}, 0, 0);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n  for (var k in d) {\n    var val = d[k],\n      n = p + k;\n    if (val instanceof u8) t[n] = [val, o];\n    else if (Array.isArray(val)) t[n] = [val[0], mrg(o, val[1])];\n    else fltn(val, n + '/', t, o);\n  }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n  td.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {}\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nfunction strToU8(str, latin1) {\n  if (latin1) {\n    var ar_1 = new u8(str.length);\n    for (var i = 0; i < str.length; ++i) ar_1[i] = str.charCodeAt(i);\n    return ar_1;\n  }\n  if (te) return te.encode(str);\n  var l = str.length;\n  var ar = new u8(str.length + (str.length >> 1));\n  var ai = 0;\n  var w = function (v) {\n    ar[ai++] = v;\n  };\n  for (var i = 0; i < l; ++i) {\n    if (ai + 5 > ar.length) {\n      var n = new u8(ai + 8 + ((l - i) << 1));\n      n.set(ar);\n      ar = n;\n    }\n    var c = str.charCodeAt(i);\n    if (c < 128 || latin1) w(c);\n    else if (c < 2048) w(192 | (c >> 6)), w(128 | (c & 63));\n    else if (c > 55295 && c < 57344)\n      (c = (65536 + (c & (1023 << 10))) | (str.charCodeAt(++i) & 1023)),\n        w(240 | (c >> 18)),\n        w(128 | ((c >> 12) & 63)),\n        w(128 | ((c >> 6) & 63)),\n        w(128 | (c & 63));\n    else w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n  }\n  return slc(ar, 0, ai);\n}\n// extra field length\nvar exfl = function (ex) {\n  var le = 0;\n  if (ex) {\n    for (var k in ex) {\n      var l = ex[k].length;\n      if (l > 65535) throw 'extra field too long';\n      le += l + 4;\n    }\n  }\n  return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n  var fl = fn.length,\n    ex = f.extra,\n    col = co && co.length;\n  var exl = exfl(ex);\n  wbytes(d, b, ce != null ? 0x2014b50 : 0x4034b50), (b += 4);\n  if (ce != null) (d[b++] = 20), (d[b++] = f.os);\n  (d[b] = 20), (b += 2); // spec compliance? what's that?\n  (d[b++] = (f.flag << 1) | (c == null && 8)), (d[b++] = u && 8);\n  (d[b++] = f.compression & 255), (d[b++] = f.compression >> 8);\n  var dt = new Date(f.mtime == null ? Date.now() : f.mtime),\n    y = dt.getFullYear() - 1980;\n  if (y < 0 || y > 119) throw 'date not in range 1980-2099';\n  wbytes(\n    d,\n    b,\n    (y << 25) |\n      ((dt.getMonth() + 1) << 21) |\n      (dt.getDate() << 16) |\n      (dt.getHours() << 11) |\n      (dt.getMinutes() << 5) |\n      (dt.getSeconds() >>> 1),\n  ),\n    (b += 4);\n  if (c != null) {\n    wbytes(d, b, f.crc);\n    wbytes(d, b + 4, c);\n    wbytes(d, b + 8, f.size);\n  }\n  wbytes(d, b + 12, fl);\n  wbytes(d, b + 14, exl), (b += 16);\n  if (ce != null) {\n    wbytes(d, b, col);\n    wbytes(d, b + 6, f.attrs);\n    wbytes(d, b + 10, ce), (b += 14);\n  }\n  d.set(fn, b);\n  b += fl;\n  if (exl) {\n    for (var k in ex) {\n      var exf = ex[k],\n        l = exf.length;\n      wbytes(d, b, +k);\n      wbytes(d, b + 2, l);\n      d.set(exf, b + 4), (b += 4 + l);\n    }\n  }\n  if (col) d.set(co, b), (b += col);\n  return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n  wbytes(o, b, 0x6054b50); // skip disk\n  wbytes(o, b + 8, c);\n  wbytes(o, b + 10, c);\n  wbytes(o, b + 12, d);\n  wbytes(o, b + 16, e);\n};\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nfunction zipSync(data, opts) {\n  if (!opts) opts = {};\n  var r = {};\n  var files = [];\n  fltn(data, '', r, opts);\n  var o = 0;\n  var tot = 0;\n  for (var fn in r) {\n    var _a = r[fn],\n      file = _a[0],\n      p = _a[1];\n    var compression = p.level == 0 ? 0 : 8;\n    var f = strToU8(fn),\n      s = f.length;\n    var com = p.comment,\n      m = com && strToU8(com),\n      ms = m && m.length;\n    var exl = exfl(p.extra);\n    if (s > 65535) throw 'filename too long';\n    var d = compression ? deflateSync(file, p) : file,\n      l = d.length;\n    var c = crc();\n    c.p(file);\n    files.push(\n      mrg(p, {\n        size: file.length,\n        crc: c.d(),\n        c: d,\n        f: f,\n        m: m,\n        u: s != fn.length || (m && com.length != ms),\n        o: o,\n        compression: compression,\n      }),\n    );\n    o += 30 + s + exl + l;\n    tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n  }\n  var out = new u8(tot + 22),\n    oe = o,\n    cdl = tot - o;\n  for (var i = 0; i < files.length; ++i) {\n    var f = files[i];\n    wzh(out, f.o, f, f.f, f.u, f.c.length);\n    var badd = 30 + f.f.length + exfl(f.extra);\n    out.set(f.c, f.o + badd);\n    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m),\n      (o += 16 + badd + (f.m ? f.m.length : 0));\n  }\n  wzf(out, o, files.length, cdl, oe);\n  return out;\n}\n\nclass USDZExporter {\n  async parse(scene) {\n    const files = {};\n    const modelFileName = 'model.usda';\n\n    // model file should be first in USDZ archive so we init it here\n    files[modelFileName] = null;\n\n    let output = buildHeader();\n\n    const materials = {};\n    const textures = {};\n\n    scene.traverseVisible((object) => {\n      if (object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n\n        const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd';\n\n        if (!(geometryFileName in files)) {\n          const meshObject = buildMeshObject(geometry);\n          files[geometryFileName] = buildUSDFileAsString(meshObject);\n        }\n\n        if (!(material.uuid in materials)) {\n          materials[material.uuid] = material;\n        }\n\n        output += buildXform(object, geometry, material);\n      }\n    });\n\n    output += buildMaterials(materials, textures);\n\n    files[modelFileName] = strToU8(output);\n    output = null;\n\n    for (const id in textures) {\n      const texture = textures[id];\n      const color = id.split('_')[1];\n      const isRGBA = texture.format === 1023;\n\n      const canvas = imageToCanvas(texture.image, color);\n      const blob = await new Promise((resolve) =>\n        canvas.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1),\n      );\n\n      files[`textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}`] =\n        new Uint8Array(await blob.arrayBuffer());\n    }\n\n    // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n    let offset = 0;\n\n    for (const filename in files) {\n      const file = files[filename];\n      const headerSize = 34 + filename.length;\n\n      offset += headerSize;\n\n      const offsetMod64 = offset & 63;\n\n      if (offsetMod64 !== 4) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n\n        files[filename] = [file, { extra: { 12345: padding } }];\n      }\n\n      offset = file.length;\n    }\n\n    return zipSync(files, { level: 0 });\n  }\n}\n\nfunction imageToCanvas(image, color) {\n  if (\n    (typeof HTMLImageElement !== 'undefined' &&\n      image instanceof HTMLImageElement) ||\n    (typeof HTMLCanvasElement !== 'undefined' &&\n      image instanceof HTMLCanvasElement) ||\n    (typeof OffscreenCanvas !== 'undefined' &&\n      image instanceof OffscreenCanvas) ||\n    (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)\n  ) {\n    const scale = 1024 / Math.max(image.width, image.height);\n\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n\n    const context = canvas.getContext('2d');\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n\n    if (color !== undefined) {\n      const hex = parseInt(color, 16);\n\n      const r = ((hex >> 16) & 255) / 255;\n      const g = ((hex >> 8) & 255) / 255;\n      const b = (hex & 255) / 255;\n\n      const imagedata = context.getImageData(0, 0, canvas.width, canvas.height);\n      const data = imagedata.data;\n\n      for (let i = 0; i < data.length; i += 4) {\n        data[i + 0] = data[i + 0] * r;\n        data[i + 1] = data[i + 1] * g;\n        data[i + 2] = data[i + 2] * b;\n      }\n\n      context.putImageData(imagedata, 0, 0);\n    }\n\n    return canvas;\n  }\n}\n\n//\n\nconst PRECISION = 7;\n\nfunction buildHeader() {\n  return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n\n`;\n}\n\nfunction buildUSDFileAsString(dataToInsert) {\n  let output = buildHeader();\n  output += dataToInsert;\n  return strToU8(output);\n}\n\n// Xform\n\nfunction buildXform(object, geometry, material) {\n  const name = 'Object_' + object.id;\n  const transform = buildMatrix(object.matrixWorld);\n\n  if (object.matrixWorld.determinant() < 0) {\n    console.warn(\n      'THREE.USDZExporter: USDZ does not support negative scales',\n      object,\n    );\n  }\n\n  return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    rel material:binding = </Materials/Material_${material.id}>\n}\n\n`;\n}\n\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(\n    array,\n    4,\n  )}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\n\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${\n    array[offset + 3]\n  })`;\n}\n\n// Mesh\n\nfunction buildMeshObject(geometry) {\n  const mesh = buildMesh(geometry);\n  return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`;\n}\n\nfunction buildMesh(geometry) {\n  const name = 'Geometry';\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n\n  return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n}\n\nfunction buildMeshVertexCount(geometry) {\n  const count =\n    geometry.index !== null\n      ? geometry.index.array.length\n      : geometry.attributes.position.count;\n\n  return Array(count / 3)\n    .fill(3)\n    .join(', ');\n}\n\nfunction buildMeshVertexIndices(geometry) {\n  if (geometry.index !== null) {\n    return geometry.index.array.join(', ');\n  }\n\n  const array = [];\n  const length = geometry.attributes.position.count;\n\n  for (let i = 0; i < length; i++) {\n    array.push(i);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 3) {\n    array.push(\n      `(${data[i + 0].toPrecision(PRECISION)}, ${data[i + 1].toPrecision(\n        PRECISION,\n      )}, ${data[i + 2].toPrecision(PRECISION)})`,\n    );\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector2Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: UVs missing.');\n    return Array(count).fill('(0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 2) {\n    array.push(\n      `(${data[i + 0].toPrecision(PRECISION)}, ${\n        1 - data[i + 1].toPrecision(PRECISION)\n      })`,\n    );\n  }\n\n  return array.join(', ');\n}\n\n// Materials\n\nfunction buildMaterials(materials, textures) {\n  const array = [];\n\n  for (const uuid in materials) {\n    const material = materials[uuid];\n\n    array.push(buildMaterial(material, textures));\n  }\n\n  return `def \"Materials\"\n{\n${array.join('')}\n}\n\n`;\n}\n\nfunction buildMaterial(material, textures) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n  const pad = '            ';\n  const inputs = [];\n  const samplers = [];\n\n  function buildTexture(texture, mapType, color) {\n    const id = texture.id + (color ? '_' + color.getHexString() : '');\n    const isRGBA = texture.format === 1023;\n\n    textures[id] = texture;\n\n    return `\n        def Shader \"Transform2d_${mapType}\" (\n            sdrMetadata = {\n                string role = \"math\"\n            }\n        )\n        {\n            uniform token info:id = \"UsdTransform2d\"\n            float2 inputs:in.connect = </Materials/Material_${\n              material.id\n            }/uvReader_st.outputs:result>\n            float2 inputs:scale = ${buildVector2(texture.repeat)}\n            float2 inputs:translation = ${buildVector2(texture.offset)}\n            float2 outputs:result\n        }\n\n        def Shader \"Texture_${texture.id}_${mapType}\"\n        {\n            uniform token info:id = \"UsdUVTexture\"\n            asset inputs:file = @textures/Texture_${id}.${\n      isRGBA ? 'png' : 'jpg'\n    }@\n            float2 inputs:st.connect = </Materials/Material_${\n              material.id\n            }/Transform2d_${mapType}.outputs:result>\n            token inputs:wrapS = \"repeat\"\n            token inputs:wrapT = \"repeat\"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }`;\n  }\n\n  if (material.map !== null) {\n    inputs.push(\n      `${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`,\n    );\n\n    samplers.push(buildTexture(material.map, 'diffuse', material.color));\n  } else {\n    inputs.push(\n      `${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`,\n    );\n  }\n\n  if (material.emissiveMap !== null) {\n    inputs.push(\n      `${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`,\n    );\n\n    samplers.push(buildTexture(material.emissiveMap, 'emissive'));\n  } else if (material.emissive.getHex() > 0) {\n    inputs.push(\n      `${pad}color3f inputs:emissiveColor = ${buildColor(material.emissive)}`,\n    );\n  }\n\n  if (material.normalMap !== null) {\n    inputs.push(\n      `${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`,\n    );\n\n    samplers.push(buildTexture(material.normalMap, 'normal'));\n  }\n\n  if (material.aoMap !== null) {\n    inputs.push(\n      `${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`,\n    );\n\n    samplers.push(buildTexture(material.aoMap, 'occlusion'));\n  }\n\n  if (material.roughnessMap !== null && material.roughness === 1) {\n    inputs.push(\n      `${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`,\n    );\n\n    samplers.push(buildTexture(material.roughnessMap, 'roughness'));\n  } else {\n    inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n  }\n\n  if (material.metalnessMap !== null && material.metalness === 1) {\n    inputs.push(\n      `${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`,\n    );\n\n    samplers.push(buildTexture(material.metalnessMap, 'metallic'));\n  } else {\n    inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n  }\n\n  if (material.alphaMap !== null) {\n    inputs.push(\n      `${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.alphaMap.id}_opacity.outputs:r>`,\n    );\n    inputs.push(`${pad}float inputs:opacityThreshold = 0.0001`);\n\n    samplers.push(buildTexture(material.alphaMap, 'opacity'));\n  } else {\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n  }\n\n  if (material.isMeshPhysicalMaterial) {\n    inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n    inputs.push(\n      `${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`,\n    );\n    inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n  }\n\n  return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${\n          material.id\n        }/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${\n              material.id\n            }.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${samplers.join('\\n')}\n\n    }\n`;\n}\n\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\n\nfunction buildVector2(vector) {\n  return `(${vector.x}, ${vector.y})`;\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * For our purposes, an enumeration is a fixed set of CSS-expression-compatible\n * names. When serialized, a selected subset of the members may be specified as\n * whitespace-separated strings. An enumeration deserializer is a function that\n * parses a serialized subset of an enumeration and returns any members that are\n * found as a Set.\n *\n * The following example will produce a deserializer for the days of the\n * week:\n *\n * const deserializeDaysOfTheWeek = enumerationDeserializer([\n *   'Monday',\n *   'Tuesday',\n *   'Wednesday',\n *   'Thursday',\n *   'Friday',\n *   'Saturday',\n *   'Sunday'\n * ]);\n */\nconst enumerationDeserializer = (allowedNames) => (valueString) => {\n  try {\n    const expressions = parseExpressions(valueString);\n    const names = (expressions.length ? expressions[0].terms : [])\n      .filter((valueNode) => valueNode && valueNode.type === 'ident')\n      .map((valueNode) => valueNode.value)\n      .filter((name) => allowedNames.indexOf(name) > -1);\n    // NOTE(cdata): IE11 does not support constructing a Set directly from\n    // an iterable, so we need to manually add all the items:\n    const result = new Set();\n    for (const name of names) {\n      result.add(name);\n    }\n    return result;\n  } catch (_error) {}\n  return new Set();\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate$4 =\n  (undefined && undefined.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === 'object' && typeof undefined === 'function')\n      r = undefined(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nlet isWebXRBlocked = false;\nlet isSceneViewerBlocked = false;\nconst noArViewerSigil = '#model-viewer-no-ar-fallback';\nconst deserializeARModes = enumerationDeserializer([\n  'quick-look',\n  'scene-viewer',\n  'webxr',\n  'none',\n]);\nconst DEFAULT_AR_MODES = 'webxr scene-viewer';\nconst ARMode = {\n  QUICK_LOOK: 'quick-look',\n  SCENE_VIEWER: 'scene-viewer',\n  WEBXR: 'webxr',\n  NONE: 'none',\n};\nconst $arButtonContainer = Symbol('arButtonContainer');\nconst $enterARWithWebXR = Symbol('enterARWithWebXR');\nconst $openSceneViewer = Symbol('openSceneViewer');\nconst $openIOSARQuickLook = Symbol('openIOSARQuickLook');\nconst $canActivateAR = Symbol('canActivateAR');\nconst $arMode = Symbol('arMode');\nconst $arModes = Symbol('arModes');\nconst $arAnchor = Symbol('arAnchor');\nconst $preload = Symbol('preload');\nconst $onARButtonContainerClick = Symbol('onARButtonContainerClick');\nconst $onARStatus = Symbol('onARStatus');\nconst $onARTracking = Symbol('onARTracking');\nconst $onARTap = Symbol('onARTap');\nconst $selectARMode = Symbol('selectARMode');\nconst $triggerLoad = Symbol('triggerLoad');\nconst ARMixin = (ModelViewerElement) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  class ARModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.ar = false;\n      this.arScale = 'auto';\n      this.arPlacement = 'floor';\n      this.arModes = DEFAULT_AR_MODES;\n      this.iosSrc = null;\n      this.xrEnvironment = false;\n      this[_a] = false;\n      // TODO: Add this to the shadow root as part of this mixin's\n      // implementation:\n      this[_b] = this.shadowRoot.querySelector('.ar-button');\n      this[_c] = document.createElement('a');\n      this[_d] = new Set();\n      this[_e] = ARMode.NONE;\n      this[_f] = false;\n      this[_g] = (event) => {\n        event.preventDefault();\n        this.activateAR();\n      };\n      this[_h] = ({ status }) => {\n        if (\n          status === ARStatus.NOT_PRESENTING ||\n          this[$renderer].arRenderer.presentedScene === this[$scene]\n        ) {\n          this.setAttribute('ar-status', status);\n          this.dispatchEvent(\n            new CustomEvent('ar-status', { detail: { status } }),\n          );\n          if (status === ARStatus.NOT_PRESENTING) {\n            this.removeAttribute('ar-tracking');\n          } else if (status === ARStatus.SESSION_STARTED) {\n            this.setAttribute('ar-tracking', ARTracking.TRACKING);\n          }\n        }\n      };\n      this[_j] = ({ status }) => {\n        this.setAttribute('ar-tracking', status);\n        this.dispatchEvent(\n          new CustomEvent('ar-tracking', { detail: { status } }),\n        );\n      };\n      this[_k] = (event) => {\n        if (event.data == '_apple_ar_quicklook_button_tapped') {\n          this.dispatchEvent(new CustomEvent('quick-look-button-tapped'));\n        }\n      };\n    }\n    get canActivateAR() {\n      return this[$arMode] !== ARMode.NONE;\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      this[$renderer].arRenderer.addEventListener('status', this[$onARStatus]);\n      this.setAttribute('ar-status', ARStatus.NOT_PRESENTING);\n      this[$renderer].arRenderer.addEventListener(\n        'tracking',\n        this[$onARTracking],\n      );\n      this[$arAnchor].addEventListener('message', this[$onARTap]);\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$renderer].arRenderer.removeEventListener(\n        'status',\n        this[$onARStatus],\n      );\n      this[$renderer].arRenderer.removeEventListener(\n        'tracking',\n        this[$onARTracking],\n      );\n      this[$arAnchor].removeEventListener('message', this[$onARTap]);\n    }\n    async update(changedProperties) {\n      super.update(changedProperties);\n      if (changedProperties.has('arScale')) {\n        this[$scene].canScale = this.arScale !== 'fixed';\n      }\n      if (changedProperties.has('arPlacement')) {\n        this[$scene].updateShadow();\n        this[$needsRender]();\n      }\n      if (\n        !changedProperties.has('ar') &&\n        !changedProperties.has('arModes') &&\n        !changedProperties.has('iosSrc')\n      ) {\n        return;\n      }\n      if (changedProperties.has('arModes')) {\n        this[$arModes] = deserializeARModes(this.arModes);\n      }\n      this[$selectARMode]();\n    }\n    /**\n     * Activates AR. Note that for any mode that is not WebXR-based, this\n     * method most likely has to be called synchronous from a user\n     * interaction handler. Otherwise, attempts to activate modes that\n     * require user interaction will most likely be ignored.\n     */\n    async activateAR() {\n      switch (this[$arMode]) {\n        case ARMode.QUICK_LOOK:\n          this[$openIOSARQuickLook]();\n          break;\n        case ARMode.WEBXR:\n          await this[$enterARWithWebXR]();\n          break;\n        case ARMode.SCENE_VIEWER:\n          this[$openSceneViewer]();\n          break;\n        default:\n          console.warn(\n            'No AR Mode can be activated. This is probably due to missing \\\nconfiguration or device capabilities',\n          );\n          break;\n      }\n    }\n    async [((_a = $canActivateAR),\n    (_b = $arButtonContainer),\n    (_c = $arAnchor),\n    (_d = $arModes),\n    (_e = $arMode),\n    (_f = $preload),\n    (_g = $onARButtonContainerClick),\n    (_h = $onARStatus),\n    (_j = $onARTracking),\n    (_k = $onARTap),\n    $selectARMode)]() {\n      this[$arMode] = ARMode.NONE;\n      if (this.ar) {\n        if (this.src != null) {\n          for (const value of this[$arModes]) {\n            if (\n              value === 'webxr' &&\n              IS_WEBXR_AR_CANDIDATE &&\n              !isWebXRBlocked &&\n              (await this[$renderer].arRenderer.supportsPresentation())\n            ) {\n              this[$arMode] = ARMode.WEBXR;\n              break;\n            }\n            if (\n              value === 'scene-viewer' &&\n              IS_SCENEVIEWER_CANDIDATE &&\n              !isSceneViewerBlocked\n            ) {\n              this[$arMode] = ARMode.SCENE_VIEWER;\n              break;\n            }\n            if (value === 'quick-look' && IS_AR_QUICKLOOK_CANDIDATE) {\n              this[$arMode] = ARMode.QUICK_LOOK;\n              break;\n            }\n          }\n        }\n        // The presence of ios-src overrides the absence of quick-look\n        // ar-mode.\n        if (\n          !this.canActivateAR &&\n          this.iosSrc != null &&\n          IS_AR_QUICKLOOK_CANDIDATE\n        ) {\n          this[$arMode] = ARMode.QUICK_LOOK;\n        }\n      }\n      if (this.canActivateAR) {\n        this[$arButtonContainer].classList.add('enabled');\n        this[$arButtonContainer].addEventListener(\n          'click',\n          this[$onARButtonContainerClick],\n        );\n      } else if (this[$arButtonContainer].classList.contains('enabled')) {\n        this[$arButtonContainer].removeEventListener(\n          'click',\n          this[$onARButtonContainerClick],\n        );\n        this[$arButtonContainer].classList.remove('enabled');\n        // If AR went from working to not, notify the element.\n        const status = ARStatus.FAILED;\n        this.setAttribute('ar-status', status);\n        this.dispatchEvent(\n          new CustomEvent('ar-status', { detail: { status } }),\n        );\n      }\n    }\n    async [$enterARWithWebXR]() {\n      console.log('Attempting to present in AR with WebXR...');\n      await this[$triggerLoad]();\n      try {\n        this[$arButtonContainer].removeEventListener(\n          'click',\n          this[$onARButtonContainerClick],\n        );\n        const { arRenderer } = this[$renderer];\n        arRenderer.placeOnWall = this.arPlacement === 'wall';\n        await arRenderer.present(this[$scene], this.xrEnvironment);\n      } catch (error) {\n        console.warn('Error while trying to present in AR with WebXR');\n        console.error(error);\n        await this[$renderer].arRenderer.stopPresenting();\n        isWebXRBlocked = true;\n        console.warn('Falling back to next ar-mode');\n        await this[$selectARMode]();\n        this.activateAR();\n      } finally {\n        this[$selectARMode]();\n      }\n    }\n    async [$triggerLoad]() {\n      if (!this.loaded) {\n        this[$preload] = true;\n        this[$updateSource]();\n        await waitForEvent(this, 'load');\n        this[$preload] = false;\n      }\n    }\n    [$shouldAttemptPreload]() {\n      return super[$shouldAttemptPreload]() || this[$preload];\n    }\n    /**\n     * Takes a URL and a title string, and attempts to launch Scene Viewer on\n     * the current device.\n     */\n    [$openSceneViewer]() {\n      const location = self.location.toString();\n      const locationUrl = new URL(location);\n      const modelUrl = new URL(this.src, location);\n      const params = new URLSearchParams(modelUrl.search);\n      locationUrl.hash = noArViewerSigil;\n      // modelUrl can contain title/link/sound etc.\n      params.set('mode', 'ar_preferred');\n      if (!params.has('disable_occlusion')) {\n        params.set('disable_occlusion', 'true');\n      }\n      if (this.arScale === 'fixed') {\n        params.set('resizable', 'false');\n      }\n      if (this.arPlacement === 'wall') {\n        params.set('enable_vertical_placement', 'true');\n      }\n      if (params.has('sound')) {\n        const soundUrl = new URL(params.get('sound'), location);\n        params.set('sound', soundUrl.toString());\n      }\n      if (params.has('link')) {\n        const linkUrl = new URL(params.get('link'), location);\n        params.set('link', linkUrl.toString());\n      }\n      const intent = `intent://arvr.google.com/scene-viewer/1.0?${\n        params.toString() + '&file=' + encodeURIComponent(modelUrl.toString())\n      }#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(\n        locationUrl.toString(),\n      )};end;`;\n      const undoHashChange = () => {\n        if (self.location.hash === noArViewerSigil) {\n          isSceneViewerBlocked = true;\n          // The new history will be the current URL with a new hash.\n          // Go back one step so that we reset to the expected URL.\n          // NOTE(cdata): this should not invoke any browser-level navigation\n          // because hash-only changes modify the URL in-place without\n          // navigating:\n          self.history.back();\n          console.warn('Error while trying to present in AR with Scene Viewer');\n          console.warn('Falling back to next ar-mode');\n          this[$selectARMode]();\n          // Would be nice to activateAR() here, but webXR fails due to not\n          // seeing a user activation.\n        }\n      };\n      self.addEventListener('hashchange', undoHashChange, { once: true });\n      this[$arAnchor].setAttribute('href', intent);\n      console.log('Attempting to present in AR with Scene Viewer...');\n      this[$arAnchor].click();\n    }\n    /**\n     * Takes a URL to a USDZ file and sets the appropriate fields so that\n     * Safari iOS can intent to their AR Quick Look.\n     */\n    async [$openIOSARQuickLook]() {\n      const generateUsdz = !this.iosSrc;\n      this[$arButtonContainer].classList.remove('enabled');\n      const objectURL = generateUsdz ? await this.prepareUSDZ() : this.iosSrc;\n      const modelUrl = new URL(objectURL, self.location.toString());\n      if (this.arScale === 'fixed') {\n        if (modelUrl.hash) {\n          modelUrl.hash += '&';\n        }\n        modelUrl.hash += 'allowsContentScaling=0';\n      }\n      const anchor = this[$arAnchor];\n      anchor.setAttribute('rel', 'ar');\n      const img = document.createElement('img');\n      anchor.appendChild(img);\n      anchor.setAttribute('href', modelUrl.toString());\n      if (generateUsdz) {\n        anchor.setAttribute('download', 'model.usdz');\n      }\n      console.log('Attempting to present in AR with Quick Look...');\n      anchor.click();\n      anchor.removeChild(img);\n      if (generateUsdz) {\n        URL.revokeObjectURL(objectURL);\n      }\n      this[$arButtonContainer].classList.add('enabled');\n    }\n    async prepareUSDZ() {\n      const updateSourceProgress = this[$progressTracker].beginActivity();\n      await this[$triggerLoad]();\n      const scene = this[$scene];\n      const shadow = scene.shadow;\n      let visible = false;\n      // Remove shadow from export\n      if (shadow != null) {\n        visible = shadow.visible;\n        shadow.visible = false;\n      }\n      updateSourceProgress(0.2);\n      const exporter = new USDZExporter();\n      const arraybuffer = await exporter.parse(scene.modelContainer);\n      const blob = new Blob([arraybuffer], {\n        type: 'model/vnd.usdz+zip',\n      });\n      const url = URL.createObjectURL(blob);\n      updateSourceProgress(1);\n      if (shadow != null) {\n        shadow.visible = visible;\n      }\n      return url;\n    }\n  }\n  __decorate$4(\n    [property({ type: Boolean, attribute: 'ar' })],\n    ARModelViewerElement.prototype,\n    'ar',\n    void 0,\n  );\n  __decorate$4(\n    [property({ type: String, attribute: 'ar-scale' })],\n    ARModelViewerElement.prototype,\n    'arScale',\n    void 0,\n  );\n  __decorate$4(\n    [property({ type: String, attribute: 'ar-placement' })],\n    ARModelViewerElement.prototype,\n    'arPlacement',\n    void 0,\n  );\n  __decorate$4(\n    [property({ type: String, attribute: 'ar-modes' })],\n    ARModelViewerElement.prototype,\n    'arModes',\n    void 0,\n  );\n  __decorate$4(\n    [property({ type: String, attribute: 'ios-src' })],\n    ARModelViewerElement.prototype,\n    'iosSrc',\n    void 0,\n  );\n  __decorate$4(\n    [property({ type: Boolean, attribute: 'xr-environment' })],\n    ARModelViewerElement.prototype,\n    'xrEnvironment',\n    void 0,\n  );\n  return ARModelViewerElement;\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a$5, _b$4, _c$2;\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\nclass Evaluator {\n  constructor() {\n    this[_a$5] = null;\n  }\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n  static evaluatableFor(node, basis = ZERO) {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node, basis);\n      }\n      return node;\n    }\n    switch (node.name.value) {\n      case 'calc':\n        return new CalcEvaluator(node, basis);\n      case 'env':\n        return new EnvEvaluator(node);\n    }\n    return ZERO;\n  }\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n  static evaluate(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n    return evaluatable;\n  }\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n  static isConstant(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n    return true;\n  }\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n  static applyIntrinsics(evaluated, intrinsics) {\n    const { basis, keywords } = intrinsics;\n    const { auto } = keywords;\n    return basis.map((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];\n      // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n      let evaluatedNode = evaluated[index]\n        ? evaluated[index]\n        : autoSubstituteNode;\n      // Any ident node is considered a keyword:\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value;\n        // Substitute any keywords for concrete values first:\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      }\n      // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      }\n      // For percentages, we always apply the percentage to the basis value:\n      if (evaluatedNode.unit === '%') {\n        return numberNode(\n          (evaluatedNode.number / 100) * basisNode.number,\n          basisNode.unit,\n        );\n      }\n      // Otherwise, normalize whatever we have:\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode);\n      // If the normalized units do not match, return the basis as a fallback:\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      }\n      // Finally, return the evaluated node with intrinsics applied:\n      return evaluatedNode;\n    });\n  }\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n  get isConstant() {\n    return false;\n  }\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n  evaluate() {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n    return this[$lastValue];\n  }\n}\n_a$5 = $lastValue;\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\nclass PercentageEvaluator extends Evaluator {\n  constructor(percentage, basis) {\n    super();\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n  get isConstant() {\n    return true;\n  }\n  [$evaluate]() {\n    return numberNode(\n      (this[$percentage].number / 100) * this[$basis].number,\n      this[$basis].unit,\n    );\n  }\n}\nconst $identNode = Symbol('identNode');\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\nclass EnvEvaluator extends Evaluator {\n  constructor(envFunction) {\n    super();\n    this[_b$4] = null;\n    const identNode = envFunction.arguments.length\n      ? envFunction.arguments[0].terms[0]\n      : null;\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n  get isConstant() {\n    return false;\n  }\n  [((_b$4 = $identNode), $evaluate)]() {\n    if (this[$identNode] != null) {\n      switch (this[$identNode].value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(\n            document.body.scrollHeight,\n            document.body.offsetHeight,\n            document.documentElement.clientHeight,\n            document.documentElement.scrollHeight,\n            document.documentElement.offsetHeight,\n          );\n          const scrollY =\n            verticalScrollPosition / (verticalScrollMax - window.innerHeight) ||\n            0;\n          return { type: 'number', number: scrollY, unit: null };\n      }\n    }\n    return ZERO;\n  }\n}\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evalutor');\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nclass CalcEvaluator extends Evaluator {\n  constructor(calcFunction, basis = ZERO) {\n    super();\n    this[_c$2] = null;\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n    const terms = calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms = [];\n    while (terms.length) {\n      const term = terms.shift();\n      if (secondOrderTerms.length > 0) {\n        const previousTerm = secondOrderTerms[secondOrderTerms.length - 1];\n        if (\n          previousTerm.type === 'operator' &&\n          IS_MULTIPLICATION_RE.test(previousTerm.value)\n        ) {\n          const operator = secondOrderTerms.pop();\n          const leftValue = secondOrderTerms.pop();\n          if (leftValue == null) {\n            return;\n          }\n          secondOrderTerms.push(\n            new OperatorEvaluator(\n              operator,\n              Evaluator.evaluatableFor(leftValue, basis),\n              Evaluator.evaluatableFor(term, basis),\n            ),\n          );\n          continue;\n        }\n      }\n      secondOrderTerms.push(\n        term.type === 'operator' ? term : Evaluator.evaluatableFor(term, basis),\n      );\n    }\n    while (secondOrderTerms.length > 2) {\n      const [left, operator, right] = secondOrderTerms.splice(0, 3);\n      if (operator.type !== 'operator') {\n        return;\n      }\n      secondOrderTerms.unshift(\n        new OperatorEvaluator(\n          operator,\n          Evaluator.evaluatableFor(left, basis),\n          Evaluator.evaluatableFor(right, basis),\n        ),\n      );\n    }\n    // There should only be one combined evaluator at this point:\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0];\n    }\n  }\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]);\n  }\n  [((_c$2 = $evaluator), $evaluate)]() {\n    return this[$evaluator] != null\n      ? Evaluator.evaluate(this[$evaluator])\n      : ZERO;\n  }\n}\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nclass OperatorEvaluator extends Evaluator {\n  constructor(operator, left, right) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n  get isConstant() {\n    return (\n      Evaluator.isConstant(this[$left]) && Evaluator.isConstant(this[$right])\n    );\n  }\n  [$evaluate]() {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const { number: leftValue, unit: leftUnit } = leftNode;\n    const { number: rightValue, unit: rightUnit } = rightNode;\n    // Disallow operations for mismatched normalized units e.g., m and rad:\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    }\n    // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n    const unit = leftUnit || rightUnit;\n    let value;\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n      case '-':\n        value = leftValue - rightValue;\n        break;\n      case '/':\n        value = leftValue / rightValue;\n        break;\n      case '*':\n        value = leftValue * rightValue;\n        break;\n      default:\n        return ZERO;\n    }\n    return { type: 'number', number: value, unit };\n  }\n}\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\nclass StyleEvaluator extends Evaluator {\n  constructor(expressions, intrinsics) {\n    super();\n    this[$intrinsics] = intrinsics;\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n    this[$evaluatables] = intrinsics.basis.map((basisNode, index) => {\n      const term = terms[index];\n      if (term == null) {\n        return { type: 'ident', value: 'auto' };\n      }\n      if (term.type === 'ident') {\n        return term;\n      }\n      return Evaluator.evaluatableFor(term, basisNode);\n    });\n  }\n  get isConstant() {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map((evaluatable) =>\n      Evaluator.evaluate(evaluatable),\n    );\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics]).map(\n      (numberNode) => numberNode.number,\n    );\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a$4, _b$3, _c$1, _d$1;\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance anlyses) as well as potential memory leaks.\n */\nclass ScrollObserver {\n  constructor(callback) {\n    this[$scrollCallback] = callback;\n  }\n  static [$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n  static [((_a$4 = $instances), $activateListener)]() {\n    window.addEventListener('scroll', this[$notifyInstances], {\n      passive: true,\n    });\n  }\n  static [$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n    ScrollObserver[$instances].add(this);\n  }\n  /**\n   * Stop listening for scroll events.\n   */\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n  [$notify]() {\n    this[$scrollCallback]();\n  }\n}\nScrollObserver[_a$4] = new Set();\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\nconst $onScroll = Symbol('onScroll');\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\nclass StyleEffector {\n  constructor(callback) {\n    this[_b$3] = {};\n    this[_c$1] = new ASTWalker(['function']);\n    this[_d$1] = () => {\n      this[$computeStyleCallback]({ relatedState: 'window-scroll' });\n    };\n    this[$computeStyleCallback] = callback;\n  }\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n  observeEffectsFor(ast) {\n    const newDependencies = {};\n    const oldDependencies = this[$dependencies];\n    this[$astWalker].walk(ast, (functionNode) => {\n      const { name } = functionNode;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n      if (\n        name.value !== 'env' ||\n        firstTerm == null ||\n        firstTerm.type !== 'ident'\n      ) {\n        return;\n      }\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer =\n              'window-scroll' in oldDependencies\n                ? oldDependencies['window-scroll']\n                : new ScrollObserver(this[$onScroll]);\n            observer.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n          break;\n      }\n    });\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState];\n      observer.disconnect();\n    }\n    this[$dependencies] = newDependencies;\n  }\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer = this[$dependencies][environmentState];\n      observer.disconnect();\n    }\n  }\n}\n(_b$3 = $dependencies), (_c$1 = $astWalker), (_d$1 = $onScroll);\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The @style decorator is responsible for coordinating the conversion of a\n * CSS-like string property value into numbers that can be applied to\n * lower-level constructs. It also can optionally manage the lifecycle of a\n * StyleEffector which allows automatic updates for styles that use env() or\n * var() functions.\n *\n * The decorator is configured with Intrinsics and the property key for a\n * method that handles updates. The named update handler is invoked with the\n * result of parsing and evaluating the raw property string value. The format of\n * the evaluated result is derived from the basis of the configured Intrinsics,\n * and is always an array of numbers of fixed length.\n *\n * NOTE: This decorator depends on the property updating mechanism defined by\n * UpdatingElement as exported by the lit-element module. That means it *must*\n * be used in conjunction with the @property decorator, or equivalent\n * JavaScript.\n *\n * Supported configurations are:\n *\n *  - `intrinsics`: An Intrinsics struct that describes how to interpret a\n * serialized style attribute. For more detail on intrinsics see\n * ./styles/evaluators.ts\n *  - `updateHandler`: A string or Symbol that is the key of a method to be\n * invoked with the result of parsing and evaluating a serialized style string.\n *  - `observeEffects`: Optional, if set to true then styles that use env() will\n * cause their update handlers to be invoked every time the corresponding\n * environment variable changes (even if the style attribute itself remains\n * static).\n */\nconst style = (config) => {\n  const observeEffects = config.observeEffects || false;\n  const getIntrinsics =\n    config.intrinsics instanceof Function\n      ? config.intrinsics\n      : () => config.intrinsics;\n  return (proto, propertyName) => {\n    const originalUpdated = proto.updated;\n    const originalConnectedCallback = proto.connectedCallback;\n    const originalDisconnectedCallback = proto.disconnectedCallback;\n    const $styleEffector = Symbol(`${propertyName}StyleEffector`);\n    const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);\n    const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);\n    const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);\n    Object.defineProperties(proto, {\n      [$styleEffector]: { value: null, writable: true },\n      [$styleEvaluator]: { value: null, writable: true },\n      [$updateEvaluator]: {\n        value: function () {\n          const ast = parseExpressions(this[propertyName]);\n          this[$styleEvaluator] = new StyleEvaluator(ast, getIntrinsics(this));\n          if (this[$styleEffector] == null && observeEffects) {\n            this[$styleEffector] = new StyleEffector(() =>\n              this[$evaluateAndSync](),\n            );\n          }\n          if (this[$styleEffector] != null) {\n            this[$styleEffector].observeEffectsFor(ast);\n          }\n        },\n      },\n      [$evaluateAndSync]: {\n        value: function () {\n          if (this[$styleEvaluator] == null) {\n            return;\n          }\n          const result = this[$styleEvaluator].evaluate();\n          // @see https://github.com/microsoft/TypeScript/pull/30769\n          // @see https://github.com/Microsoft/TypeScript/issues/1863\n          this[config.updateHandler](result);\n        },\n      },\n      updated: {\n        value: function (changedProperties) {\n          // Always invoke updates to styles first. This gives a class that\n          // uses this decorator the opportunity to override the effect, or\n          // respond to it, in its own implementation of `updated`.\n          if (changedProperties.has(propertyName)) {\n            this[$updateEvaluator]();\n            this[$evaluateAndSync]();\n          }\n          originalUpdated.call(this, changedProperties);\n        },\n      },\n      connectedCallback: {\n        value: function () {\n          originalConnectedCallback.call(this);\n          this.requestUpdate(propertyName, this[propertyName]);\n        },\n      },\n      disconnectedCallback: {\n        value: function () {\n          originalDisconnectedCallback.call(this);\n          if (this[$styleEffector] != null) {\n            this[$styleEffector].dispose();\n            this[$styleEffector] = null;\n          }\n        },\n      },\n    });\n  };\n};\n\n/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_OPTIONS = Object.freeze({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: Math.PI / 8,\n  maximumPolarAngle: Math.PI - Math.PI / 8,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  interactionPolicy: 'always-allow',\n  touchAction: 'pan-y',\n});\n// Constants\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\nconst KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n};\nconst ChangeSource = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none',\n};\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\nclass SmoothControls extends EventDispatcher {\n  constructor(camera, element) {\n    super();\n    this.camera = camera;\n    this.element = element;\n    this.sensitivity = 1;\n    this._interactionEnabled = false;\n    this._disableZoom = false;\n    this.isUserChange = false;\n    this.isUserPointing = false;\n    // Internal orbital position state\n    this.spherical = new Spherical();\n    this.goalSpherical = new Spherical();\n    this.thetaDamper = new Damper();\n    this.phiDamper = new Damper();\n    this.radiusDamper = new Damper();\n    this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView);\n    this.goalLogFov = this.logFov;\n    this.fovDamper = new Damper();\n    // Pointer state\n    this.touchMode = null;\n    this.lastPointerPosition = {\n      clientX: 0,\n      clientY: 0,\n    };\n    this.touchDecided = false;\n    this.onMouseMove = (event) => {\n      this.handleSinglePointerMove(event);\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n    };\n    this.onTouchMove = (event) => {\n      if (this.touchMode !== null) {\n        this.touchMode(event);\n        if (this.touchMode !== null && event.cancelable) {\n          event.preventDefault();\n        }\n      }\n    };\n    this.touchModeZoom = (event) => {\n      const { targetTouches } = event;\n      if (this.lastTouches.length > 1 && targetTouches.length > 1) {\n        const lastTouchDistance = this.twoTouchDistance(\n          this.lastTouches[0],\n          this.lastTouches[1],\n        );\n        const touchDistance = this.twoTouchDistance(\n          targetTouches[0],\n          targetTouches[1],\n        );\n        const deltaZoom =\n          (ZOOM_SENSITIVITY * (lastTouchDistance - touchDistance)) / 10.0;\n        this.userAdjustOrbit(0, 0, deltaZoom);\n        this.lastTouches = targetTouches;\n      }\n    };\n    this.touchModeRotate = (event) => {\n      const { targetTouches } = event;\n      const { touchAction } = this._options;\n      if (!this.touchDecided && touchAction !== 'none') {\n        this.touchDecided = true;\n        const { clientX, clientY } = targetTouches[0];\n        const dx = Math.abs(clientX - this.lastPointerPosition.clientX);\n        const dy = Math.abs(clientY - this.lastPointerPosition.clientY);\n        // If motion is mostly vertical, assume scrolling is the intent.\n        if (\n          (touchAction === 'pan-y' && dy > dx) ||\n          (touchAction === 'pan-x' && dx > dy)\n        ) {\n          this.touchMode = null;\n          return;\n        }\n      }\n      this.handleSinglePointerMove(targetTouches[0]);\n      this.lastTouches = targetTouches;\n    };\n    this.onMouseDown = (event) => {\n      this.onPointerDown(() => {\n        self.addEventListener('mousemove', this.onMouseMove);\n        self.addEventListener('mouseup', this.onMouseUp, { once: true });\n        this.handleSinglePointerDown(event);\n      });\n    };\n    this.onTouchStart = (event) => {\n      this.onPointerDown(() => {\n        const { targetTouches, changedTouches, touches } = event;\n        if (targetTouches.length === changedTouches.length) {\n          this.touchMode = null;\n          this.touchDecided = false;\n        }\n        if (targetTouches.length === touches.length) {\n          this.onTouchChange(event);\n        }\n      });\n    };\n    this.onMouseUp = (_event) => {\n      self.removeEventListener('mousemove', this.onMouseMove);\n      this.onPointerUp();\n    };\n    this.onTouchEnd = (event) => {\n      if (event.targetTouches.length > 0 && this.touchMode !== null) {\n        this.onTouchChange(event);\n      }\n      this.onPointerUp();\n    };\n    this.onWheel = (event) => {\n      if (!this.canInteract) {\n        return;\n      }\n      const deltaZoom =\n        (event.deltaY * (event.deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY) /\n        30;\n      this.userAdjustOrbit(0, 0, deltaZoom);\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n    };\n    this.onKeyDown = (event) => {\n      // We track if the key is actually one we respond to, so as not to\n      // accidentally clober unrelated key inputs when the <model-viewer> has\n      // focus.\n      let relevantKey = false;\n      switch (event.keyCode) {\n        case KeyCode.PAGE_UP:\n          relevantKey = true;\n          this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY);\n          break;\n        case KeyCode.PAGE_DOWN:\n          relevantKey = true;\n          this.userAdjustOrbit(0, 0, -1 * ZOOM_SENSITIVITY);\n          break;\n        case KeyCode.UP:\n          relevantKey = true;\n          this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);\n          break;\n        case KeyCode.DOWN:\n          relevantKey = true;\n          this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);\n          break;\n        case KeyCode.LEFT:\n          relevantKey = true;\n          this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n          break;\n        case KeyCode.RIGHT:\n          relevantKey = true;\n          this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);\n          break;\n      }\n      if (relevantKey && event.cancelable) {\n        event.preventDefault();\n      }\n    };\n    this._options = Object.assign({}, DEFAULT_OPTIONS);\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n  get interactionEnabled() {\n    return this._interactionEnabled;\n  }\n  enableInteraction() {\n    if (this._interactionEnabled === false) {\n      const { element } = this;\n      element.addEventListener('mousedown', this.onMouseDown);\n      if (!this._disableZoom) {\n        element.addEventListener('wheel', this.onWheel);\n      }\n      element.addEventListener('keydown', this.onKeyDown);\n      element.addEventListener('touchstart', this.onTouchStart, {\n        passive: true,\n      });\n      element.addEventListener('touchmove', this.onTouchMove, {\n        passive: false,\n      });\n      element.addEventListener('touchend', this.onTouchEnd);\n      this.element.style.cursor = 'grab';\n      this._interactionEnabled = true;\n      this.updateTouchActionStyle();\n    }\n  }\n  disableInteraction() {\n    if (this._interactionEnabled === true) {\n      const { element } = this;\n      self.removeEventListener('mousemove', this.onMouseMove);\n      element.removeEventListener('mousedown', this.onMouseDown);\n      if (!this._disableZoom) {\n        element.removeEventListener('wheel', this.onWheel);\n      }\n      element.removeEventListener('keydown', this.onKeyDown);\n      element.removeEventListener('touchstart', this.onTouchStart);\n      element.removeEventListener('touchmove', this.onTouchMove);\n      self.removeEventListener('mouseup', this.onMouseUp);\n      element.removeEventListener('touchend', this.onTouchEnd);\n      element.style.cursor = '';\n      this.touchMode = null;\n      this._interactionEnabled = false;\n      this.updateTouchActionStyle();\n    }\n  }\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n  get options() {\n    return this._options;\n  }\n  set disableZoom(disable) {\n    if (this._disableZoom != disable) {\n      this._disableZoom = disable;\n      if (disable === true) {\n        this.element.removeEventListener('wheel', this.onWheel);\n      } else {\n        this.element.addEventListener('wheel', this.onWheel);\n      }\n      this.updateTouchActionStyle();\n    }\n  }\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n  getCameraSpherical(target = new Spherical()) {\n    return target.copy(this.spherical);\n  }\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n  getFieldOfView() {\n    return this.camera.fov;\n  }\n  /**\n   * Configure the _options of the controls. Configured _options will be\n   * merged with whatever _options have already been configured for this\n   * controls instance.\n   */\n  applyOptions(_options) {\n    Object.assign(this._options, _options);\n    // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this.goalLogFov));\n  }\n  /**\n   * Sets the near and far planes of the camera.\n   */\n  updateNearFar(nearPlane, farPlane) {\n    this.camera.near = Math.max(nearPlane, farPlane / 1000);\n    this.camera.far = farPlane;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Sets the aspect ratio of the camera\n   */\n  updateAspect(aspect) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening _options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n  setOrbit(\n    goalTheta = this.goalSpherical.theta,\n    goalPhi = this.goalSpherical.phi,\n    goalRadius = this.goalSpherical.radius,\n  ) {\n    const {\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n      minimumPolarAngle,\n      maximumPolarAngle,\n      minimumRadius,\n      maximumRadius,\n    } = this._options;\n    const { theta, phi, radius } = this.goalSpherical;\n    const nextTheta = clamp(\n      goalTheta,\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n    );\n    if (!isFinite(minimumAzimuthalAngle) && !isFinite(maximumAzimuthalAngle)) {\n      this.spherical.theta =\n        this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;\n    }\n    const nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n    const nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n    this.goalSpherical.theta = nextTheta;\n    this.goalSpherical.phi = nextPhi;\n    this.goalSpherical.radius = nextRadius;\n    this.goalSpherical.makeSafe();\n    this.isUserChange = false;\n    return true;\n  }\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n  setRadius(radius) {\n    this.goalSpherical.radius = radius;\n    this.setOrbit();\n  }\n  /**\n   * Sets the goal field of view for the camera\n   */\n  setFieldOfView(fov) {\n    const { minimumFieldOfView, maximumFieldOfView } = this._options;\n    fov = clamp(fov, minimumFieldOfView, maximumFieldOfView);\n    this.goalLogFov = Math.log(fov);\n  }\n  /**\n   * Sets the smoothing decay time.\n   */\n  setDamperDecayTime(decayMilliseconds) {\n    this.thetaDamper.setDecayTime(decayMilliseconds);\n    this.phiDamper.setDecayTime(decayMilliseconds);\n    this.radiusDamper.setDecayTime(decayMilliseconds);\n    this.fovDamper.setDecayTime(decayMilliseconds);\n  }\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n  adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    const { theta, phi, radius } = this.goalSpherical;\n    const {\n      minimumRadius,\n      maximumRadius,\n      minimumFieldOfView,\n      maximumFieldOfView,\n    } = this._options;\n    const dTheta = this.spherical.theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta =\n      theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n    const deltaRatio =\n      deltaZoom === 0\n        ? 0\n        : ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) /\n          (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) -\n            this.goalLogFov);\n    const goalRadius =\n      radius +\n      deltaZoom *\n        Math.min(\n          isFinite(deltaRatio) ? deltaRatio : Infinity,\n          maximumRadius - minimumRadius,\n        );\n    this.setOrbit(goalTheta, goalPhi, goalRadius);\n    if (deltaZoom !== 0) {\n      const goalLogFov = this.goalLogFov + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n    }\n  }\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n  update(_time, delta) {\n    if (this.isStationary()) {\n      return;\n    }\n    const { maximumPolarAngle, maximumRadius } = this._options;\n    const dTheta = this.spherical.theta - this.goalSpherical.theta;\n    if (\n      Math.abs(dTheta) > Math.PI &&\n      !isFinite(this._options.minimumAzimuthalAngle) &&\n      !isFinite(this._options.maximumAzimuthalAngle)\n    ) {\n      this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n    this.spherical.theta = this.thetaDamper.update(\n      this.spherical.theta,\n      this.goalSpherical.theta,\n      delta,\n      Math.PI,\n    );\n    this.spherical.phi = this.phiDamper.update(\n      this.spherical.phi,\n      this.goalSpherical.phi,\n      delta,\n      maximumPolarAngle,\n    );\n    this.spherical.radius = this.radiusDamper.update(\n      this.spherical.radius,\n      this.goalSpherical.radius,\n      delta,\n      maximumRadius,\n    );\n    this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);\n    this.moveCamera();\n  }\n  updateTouchActionStyle() {\n    const { style } = this.element;\n    if (this._interactionEnabled) {\n      const { touchAction } = this._options;\n      if (this._disableZoom && touchAction !== 'none') {\n        style.touchAction = 'manipulation';\n      } else {\n        style.touchAction = touchAction;\n      }\n    } else {\n      style.touchAction = '';\n    }\n  }\n  isStationary() {\n    return (\n      this.goalSpherical.theta === this.spherical.theta &&\n      this.goalSpherical.phi === this.spherical.phi &&\n      this.goalSpherical.radius === this.spherical.radius &&\n      this.goalLogFov === this.logFov\n    );\n  }\n  moveCamera() {\n    // Derive the new camera position from the updated spherical:\n    this.spherical.makeSafe();\n    this.camera.position.setFromSpherical(this.spherical);\n    this.camera.setRotationFromEuler(\n      new Euler(\n        this.spherical.phi - Math.PI / 2,\n        this.spherical.theta,\n        0,\n        'YXZ',\n      ),\n    );\n    if (this.camera.fov !== Math.exp(this.logFov)) {\n      this.camera.fov = Math.exp(this.logFov);\n      this.camera.updateProjectionMatrix();\n    }\n    const source = this.isUserChange\n      ? ChangeSource.USER_INTERACTION\n      : ChangeSource.NONE;\n    this.dispatchEvent({ type: 'change', source });\n  }\n  get canInteract() {\n    if (this._options.interactionPolicy == 'allow-when-focused') {\n      const rootNode = this.element.getRootNode();\n      return rootNode.activeElement === this.element;\n    }\n    return this._options.interactionPolicy === 'always-allow';\n  }\n  userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    this.adjustOrbit(\n      deltaTheta * this.sensitivity,\n      deltaPhi * this.sensitivity,\n      deltaZoom,\n    );\n    this.isUserChange = true;\n    // Always make sure that an initial event is triggered in case there is\n    // contention between user interaction and imperative changes. This initial\n    // event will give external observers that chance to observe that\n    // interaction occurred at all:\n    this.dispatchEvent({\n      type: 'change',\n      source: ChangeSource.USER_INTERACTION,\n    });\n  }\n  // Wraps to bewteen -pi and pi\n  wrapAngle(radians) {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n  pixelLengthToSphericalAngle(pixelLength) {\n    return (2 * Math.PI * pixelLength) / this.element.clientHeight;\n  }\n  twoTouchDistance(touchOne, touchTwo) {\n    const { clientX: xOne, clientY: yOne } = touchOne;\n    const { clientX: xTwo, clientY: yTwo } = touchTwo;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n  handleSinglePointerMove(pointer) {\n    const { clientX, clientY } = pointer;\n    const deltaTheta = this.pixelLengthToSphericalAngle(\n      clientX - this.lastPointerPosition.clientX,\n    );\n    const deltaPhi = this.pixelLengthToSphericalAngle(\n      clientY - this.lastPointerPosition.clientY,\n    );\n    this.lastPointerPosition.clientX = clientX;\n    this.lastPointerPosition.clientY = clientY;\n    if (this.isUserPointing === false) {\n      this.isUserPointing = true;\n      this.dispatchEvent({\n        type: 'pointer-change-start',\n        pointer: Object.assign({}, pointer),\n      });\n    }\n    this.userAdjustOrbit(deltaTheta, deltaPhi, 0);\n  }\n  onPointerDown(fn) {\n    if (!this.canInteract) {\n      return;\n    }\n    this.isUserPointing = false;\n    fn();\n  }\n  onTouchChange(event) {\n    const { targetTouches } = event;\n    switch (targetTouches.length) {\n      default:\n      case 1:\n        this.touchMode = this.touchModeRotate;\n        this.handleSinglePointerDown(targetTouches[0]);\n        break;\n      case 2:\n        this.touchMode =\n          this._disableZoom || (this.touchDecided && this.touchMode === null)\n            ? null\n            : this.touchModeZoom;\n        this.touchDecided = true;\n        break;\n    }\n    this.lastTouches = targetTouches;\n  }\n  handleSinglePointerDown(pointer) {\n    this.lastPointerPosition.clientX = pointer.clientX;\n    this.lastPointerPosition.clientY = pointer.clientY;\n    this.element.style.cursor = 'grabbing';\n  }\n  onPointerUp() {\n    this.element.style.cursor = 'grab';\n    if (this.isUserPointing) {\n      this.dispatchEvent({\n        type: 'pointer-change-end',\n        pointer: Object.assign({}, this.lastPointerPosition),\n      });\n    }\n  }\n}\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Adapted from https://gist.github.com/gre/1650294\nconst easeInOutQuad = (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);\n/**\n * Creates a TimingFunction that uses a given ease to interpolate between\n * two configured number values.\n */\nconst interpolate =\n  (start, end, ease = easeInOutQuad) =>\n  (time) =>\n    start + (end - start) * ease(time);\n/**\n * Creates a TimingFunction that interpolates through a weighted list\n * of other TimingFunctions (\"tracks\"). Tracks are interpolated in order, and\n * allocated a percentage of the total time based on their relative weight.\n */\nconst sequence = (tracks, weights) => {\n  const totalWeight = weights.reduce((total, weight) => total + weight, 0);\n  const ratios = weights.map((weight) => weight / totalWeight);\n  return (time) => {\n    let start = 0;\n    let ratio = Infinity;\n    let track = () => 0;\n    for (let i = 0; i < ratios.length; ++i) {\n      ratio = ratios[i];\n      track = tracks[i];\n      if (time <= start + ratio) {\n        break;\n      }\n      start += ratio;\n    }\n    return track((time - start) / ratio);\n  };\n};\n/**\n * Creates a \"timeline\" TimingFunction out of an initial value and a series of\n * Keyframes. The timeline function accepts value from 0-1 and returns the\n * current value based on keyframe interpolation across the total number of\n * frames. Frames are only used to indicate the relative length of each keyframe\n * transition, so interpolated values will be computed for fractional frames.\n */\nconst timeline = (initialValue, keyframes) => {\n  const tracks = [];\n  const weights = [];\n  let lastValue = initialValue;\n  for (let i = 0; i < keyframes.length; ++i) {\n    const keyframe = keyframes[i];\n    const { value, frames } = keyframe;\n    const ease = keyframe.ease || easeInOutQuad;\n    const track = interpolate(lastValue, value, ease);\n    tracks.push(track);\n    weights.push(frames);\n    lastValue = value;\n  }\n  return sequence(tracks, weights);\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate$3 =\n  (undefined && undefined.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === 'object' && typeof undefined === 'function')\n      r = undefined(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n// NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/google/model-viewer/issues/839\nconst PROMPT_ANIMATION_TIME = 5000;\n// For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the keyframe.\nconst wiggle = timeline(0, [\n  { frames: 5, value: -1 },\n  { frames: 1, value: -1 },\n  { frames: 8, value: 1 },\n  { frames: 1, value: 1 },\n  { frames: 5, value: 0 },\n  { frames: 18, value: 0 },\n]);\nconst fade = timeline(0, [\n  { frames: 1, value: 1 },\n  { frames: 5, value: 1 },\n  { frames: 1, value: 0 },\n  { frames: 6, value: 0 },\n]);\nconst DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\nconst MINIMUM_RADIUS_RATIO = 1.1 * SAFE_RADIUS_RATIO;\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\nconst DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nconst INTERACTION_PROMPT =\n  'Use mouse, touch or arrow keys to control the camera!';\nconst InteractionPromptStrategy = {\n  AUTO: 'auto',\n  WHEN_FOCUSED: 'when-focused',\n  NONE: 'none',\n};\nconst InteractionPromptStyle = {\n  BASIC: 'basic',\n  WIGGLE: 'wiggle',\n};\nconst InteractionPolicy = {\n  ALWAYS_ALLOW: 'always-allow',\n  WHEN_FOCUSED: 'allow-when-focused',\n};\nconst TouchAction = {\n  PAN_Y: 'pan-y',\n  PAN_X: 'pan-x',\n  NONE: 'none',\n};\nconst fieldOfViewIntrinsics = (element) => {\n  return {\n    basis: [\n      numberNode((element[$zoomAdjustedFieldOfView] * Math.PI) / 180, 'rad'),\n    ],\n    keywords: { auto: [null] },\n  };\n};\nconst minFieldOfViewIntrinsics = {\n  basis: [degreesToRadians(numberNode(25, 'deg'))],\n  keywords: { auto: [null] },\n};\nconst maxFieldOfViewIntrinsics = (element) => {\n  const scene = element[$scene];\n  return {\n    basis: [degreesToRadians(numberNode(45, 'deg'))],\n    keywords: { auto: [numberNode(scene.framedFieldOfView, 'deg')] },\n  };\n};\nconst cameraOrbitIntrinsics = (() => {\n  const defaultTerms = parseExpressions(DEFAULT_CAMERA_ORBIT)[0].terms;\n  const theta = normalizeUnit(defaultTerms[0]);\n  const phi = normalizeUnit(defaultTerms[1]);\n  return (element) => {\n    const radius = element[$scene].idealCameraDistance;\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: { auto: [null, null, numberNode(105, '%')] },\n    };\n  };\n})();\nconst minCameraOrbitIntrinsics = (element) => {\n  const radius = MINIMUM_RADIUS_RATIO * element[$scene].idealCameraDistance;\n  return {\n    basis: [\n      numberNode(-Infinity, 'rad'),\n      numberNode(Math.PI / 8, 'rad'),\n      numberNode(radius, 'm'),\n    ],\n    keywords: { auto: [null, null, null] },\n  };\n};\nconst maxCameraOrbitIntrinsics = (element) => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n  return {\n    basis: [\n      numberNode(Infinity, 'rad'),\n      numberNode(Math.PI - Math.PI / 8, 'rad'),\n      numberNode(defaultRadius, 'm'),\n    ],\n    keywords: { auto: [null, null, null] },\n  };\n};\nconst cameraTargetIntrinsics = (element) => {\n  const center = element[$scene].boundingBox.getCenter(new Vector3());\n  return {\n    basis: [\n      numberNode(center.x, 'm'),\n      numberNode(center.y, 'm'),\n      numberNode(center.z, 'm'),\n    ],\n    keywords: { auto: [null, null, null] },\n  };\n};\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\nconst $controls = Symbol('controls');\nconst $promptElement = Symbol('promptElement');\nconst $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\nconst $onBlur = Symbol('onBlur');\nconst $onFocus = Symbol('onFocus');\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\nconst $focusedTime = Symbol('focusedTime');\nconst $zoomAdjustedFieldOfView = Symbol('zoomAdjustedFieldOfView');\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\nconst $initialized = Symbol('initialized');\nconst $maintainThetaPhi = Symbol('maintainThetaPhi');\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\nconst ControlsMixin = (ModelViewerElement) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;\n  class ControlsModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.cameraControls = false;\n      this.cameraOrbit = DEFAULT_CAMERA_ORBIT;\n      this.cameraTarget = DEFAULT_CAMERA_TARGET;\n      this.fieldOfView = DEFAULT_FIELD_OF_VIEW;\n      this.minCameraOrbit = 'auto';\n      this.maxCameraOrbit = 'auto';\n      this.minFieldOfView = 'auto';\n      this.maxFieldOfView = 'auto';\n      this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n      this.interactionPromptStyle = InteractionPromptStyle.WIGGLE;\n      this.interactionPrompt = InteractionPromptStrategy.AUTO;\n      this.interactionPolicy = InteractionPolicy.ALWAYS_ALLOW;\n      this.orbitSensitivity = 1;\n      this.touchAction = TouchAction.PAN_Y;\n      this.disableZoom = false;\n      this.interpolationDecay = DECAY_MILLISECONDS;\n      this.bounds = 'legacy';\n      this[_a] = this.shadowRoot.querySelector('.interaction-prompt');\n      this[_b] = this.shadowRoot.querySelector(\n        '.interaction-prompt > .animated-container',\n      );\n      this[_c] = Infinity;\n      this[_d] = 0;\n      this[_e] = Infinity;\n      this[_f] = false;\n      this[_g] = false;\n      this[_h] = new SmoothControls(\n        this[$scene].camera,\n        this[$userInputElement],\n      );\n      this[_j] = 0;\n      this[_k] = new Spherical();\n      this[_l] = false;\n      this[_m] = false;\n      this[_o] = false;\n      this[_p] = () => {\n        const input = this[$userInputElement];\n        if (!isFinite(this[$focusedTime])) {\n          this[$focusedTime] = performance.now();\n        }\n        // NOTE(cdata): On every re-focus, we switch the aria-label back to\n        // the original, non-prompt label if appropriate. If the user has\n        // already interacted, they no longer need to hear the prompt.\n        // Otherwise, they will hear it again after the idle prompt threshold\n        // has been crossed.\n        const ariaLabel = this[$ariaLabel];\n        if (input.getAttribute('aria-label') !== ariaLabel) {\n          input.setAttribute('aria-label', ariaLabel);\n        }\n        if (\n          this.interactionPrompt === InteractionPromptStrategy.WHEN_FOCUSED &&\n          !this[$userHasInteracted]\n        ) {\n          this[$waitingToPromptUser] = true;\n        }\n      };\n      this[_q] = () => {\n        if (this.interactionPrompt !== InteractionPromptStrategy.WHEN_FOCUSED) {\n          return;\n        }\n        this[$waitingToPromptUser] = false;\n        this[$promptElement].classList.remove('visible');\n        this[$promptElementVisibleTime] = Infinity;\n        this[$focusedTime] = Infinity;\n      };\n      this[_r] = ({ source }) => {\n        this[$updateAria]();\n        this[$needsRender]();\n        if (source === ChangeSource.USER_INTERACTION) {\n          this[$userHasInteracted] = true;\n          this[$deferInteractionPrompt]();\n        }\n        this.dispatchEvent(\n          new CustomEvent('camera-change', { detail: { source } }),\n        );\n      };\n      this[_s] = (event) => {\n        if (event.type === 'pointer-change-start') {\n          this[$container].classList.add('pointer-tumbling');\n        } else {\n          this[$container].classList.remove('pointer-tumbling');\n        }\n      };\n    }\n    getCameraOrbit() {\n      const { theta, phi, radius } = this[$lastSpherical];\n      return {\n        theta,\n        phi,\n        radius,\n        toString() {\n          return `${this.theta}rad ${this.phi}rad ${this.radius}m`;\n        },\n      };\n    }\n    getCameraTarget() {\n      return toVector3D(\n        this[$renderer].isPresenting\n          ? this[$renderer].arRenderer.target\n          : this[$scene].getTarget(),\n      );\n    }\n    getFieldOfView() {\n      return this[$controls].getFieldOfView();\n    }\n    // Provided so user code does not have to parse these from attributes.\n    getMinimumFieldOfView() {\n      return this[$controls].options.minimumFieldOfView;\n    }\n    getMaximumFieldOfView() {\n      return this[$controls].options.maximumFieldOfView;\n    }\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] =\n        this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n        this.cameraControls;\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      this[$controls].addEventListener('change', this[$onChange]);\n      this[$controls].addEventListener(\n        'pointer-change-start',\n        this[$onPointerChange],\n      );\n      this[$controls].addEventListener(\n        'pointer-change-end',\n        this[$onPointerChange],\n      );\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$controls].removeEventListener('change', this[$onChange]);\n      this[$controls].removeEventListener(\n        'pointer-change-start',\n        this[$onPointerChange],\n      );\n      this[$controls].removeEventListener(\n        'pointer-change-end',\n        this[$onPointerChange],\n      );\n    }\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      const controls = this[$controls];\n      const input = this[$userInputElement];\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n          input.addEventListener('focus', this[$onFocus]);\n          input.addEventListener('blur', this[$onBlur]);\n        } else {\n          input.removeEventListener('focus', this[$onFocus]);\n          input.removeEventListener('blur', this[$onBlur]);\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n      }\n      if (changedProperties.has('disableZoom')) {\n        controls.disableZoom = this.disableZoom;\n      }\n      if (changedProperties.has('bounds')) {\n        this[$scene].tightBounds = this.bounds === 'tight';\n      }\n      if (\n        changedProperties.has('interactionPrompt') ||\n        changedProperties.has('cameraControls') ||\n        changedProperties.has('src')\n      ) {\n        if (\n          this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n          this.cameraControls &&\n          !this[$userHasInteracted]\n        ) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptElement].classList.toggle(\n          'wiggle',\n          this.interactionPromptStyle === InteractionPromptStyle.WIGGLE,\n        );\n      }\n      if (changedProperties.has('interactionPolicy')) {\n        const interactionPolicy = this.interactionPolicy;\n        controls.applyOptions({ interactionPolicy });\n      }\n      if (changedProperties.has('touchAction')) {\n        const touchAction = this.touchAction;\n        controls.applyOptions({ touchAction });\n        controls.updateTouchActionStyle();\n      }\n      if (changedProperties.has('orbitSensitivity')) {\n        controls.sensitivity = this.orbitSensitivity;\n      }\n      if (changedProperties.has('interpolationDecay')) {\n        controls.setDamperDecayTime(this.interpolationDecay);\n        this[$scene].setTargetDamperDecayTime(this.interpolationDecay);\n      }\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          controls.jumpToGoal();\n          this[$scene].jumpToGoal();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n    async updateFraming() {\n      const scene = this[$scene];\n      const oldFramedFieldOfView = scene.framedFieldOfView;\n      await this.requestUpdate('cameraTarget');\n      scene.updateFraming(\n        this.bounds === 'tight' ? scene.getTarget() : undefined,\n      );\n      scene.frameModel();\n      const newFramedFieldOfView = scene.framedFieldOfView;\n      const zoom = this[$controls].getFieldOfView() / oldFramedFieldOfView;\n      this[$zoomAdjustedFieldOfView] = newFramedFieldOfView * zoom;\n      this[$maintainThetaPhi] = true;\n      this.requestUpdate('maxFieldOfView');\n      this.requestUpdate('fieldOfView');\n      this.requestUpdate('minCameraOrbit');\n      this.requestUpdate('maxCameraOrbit');\n      await this.requestUpdate('cameraOrbit');\n    }\n    [((_a = $promptElement),\n    (_b = $promptAnimatedContainer),\n    (_c = $focusedTime),\n    (_d = $lastPromptOffset),\n    (_e = $promptElementVisibleTime),\n    (_f = $userHasInteracted),\n    (_g = $waitingToPromptUser),\n    (_h = $controls),\n    (_j = $zoomAdjustedFieldOfView),\n    (_k = $lastSpherical),\n    (_l = $jumpCamera),\n    (_m = $initialized),\n    (_o = $maintainThetaPhi),\n    $syncFieldOfView)](style) {\n      this[$controls].setFieldOfView((style[0] * 180) / Math.PI);\n    }\n    [$syncCameraOrbit](style) {\n      if (this[$maintainThetaPhi]) {\n        const { theta, phi } = this.getCameraOrbit();\n        style[0] = theta;\n        style[1] = phi;\n        this[$maintainThetaPhi] = false;\n      }\n      this[$controls].setOrbit(style[0], style[1], style[2]);\n    }\n    [$syncMinCameraOrbit](style) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2],\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncMaxCameraOrbit](style) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2],\n      });\n      this[$updateCameraForRadius](style[2]);\n      this.jumpCameraToGoal();\n    }\n    [$syncMinFieldOfView](style) {\n      this[$controls].applyOptions({\n        minimumFieldOfView: (style[0] * 180) / Math.PI,\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncMaxFieldOfView](style) {\n      this[$controls].applyOptions({\n        maximumFieldOfView: (style[0] * 180) / Math.PI,\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncCameraTarget](style) {\n      const [x, y, z] = style;\n      this[$scene].setTarget(x, y, z);\n      this[$renderer].arRenderer.updateTarget();\n    }\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n      if (this[$renderer].isPresenting || !this[$hasTransitioned]()) {\n        return;\n      }\n      const now = performance.now();\n      if (this[$waitingToPromptUser]) {\n        const thresholdTime =\n          this.interactionPrompt === InteractionPromptStrategy.AUTO\n            ? this[$loadedTime]\n            : this[$focusedTime];\n        if (\n          this.loaded &&\n          now > thresholdTime + this.interactionPromptThreshold\n        ) {\n          this[$userInputElement].setAttribute(\n            'aria-label',\n            INTERACTION_PROMPT,\n          );\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n          this[$promptElement].classList.add('visible');\n        }\n      }\n      if (\n        isFinite(this[$promptElementVisibleTime]) &&\n        this.interactionPromptStyle === InteractionPromptStyle.WIGGLE\n      ) {\n        const scene = this[$scene];\n        const animationTime =\n          ((now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME) % 1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n        if (offset !== this[$lastPromptOffset]) {\n          const xOffset = offset * scene.width * 0.05;\n          const deltaTheta =\n            ((offset - this[$lastPromptOffset]) * Math.PI) / 16;\n          this[\n            $promptAnimatedContainer\n          ].style.transform = `translateX(${xOffset}px)`;\n          this[$controls].adjustOrbit(deltaTheta, 0, 0);\n          this[$lastPromptOffset] = offset;\n        }\n      }\n      this[$controls].update(time, delta);\n      this[$scene].updateTarget(delta);\n    }\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n    [$updateCameraForRadius](radius) {\n      const { idealCameraDistance } = this[$scene];\n      const maximumRadius = Math.max(idealCameraDistance, radius);\n      const near = 0;\n      const far = 2 * maximumRadius;\n      this[$controls].updateNearFar(near, far);\n    }\n    [$updateAria]() {\n      // NOTE(cdata): It is possible that we might want to record the\n      // last spherical when the label actually changed. Right now, the\n      // side-effect the current implementation is that we will only\n      // announce the first view change that occurs after the element\n      // becomes focused.\n      const { theta: lastTheta, phi: lastPhi } = this[$lastSpherical];\n      const { theta, phi } = this[$controls].getCameraSpherical(\n        this[$lastSpherical],\n      );\n      const rootNode = this.getRootNode();\n      // Only change the aria-label if <model-viewer> is currently focused:\n      if (rootNode != null && rootNode.activeElement === this) {\n        const lastAzimuthalQuadrant =\n          (4 + Math.floor(((lastTheta % TAU) + QUARTER_PI) / HALF_PI)) % 4;\n        const azimuthalQuadrant =\n          (4 + Math.floor(((theta % TAU) + QUARTER_PI) / HALF_PI)) % 4;\n        const lastPolarTrient = Math.floor(lastPhi / THIRD_PI);\n        const polarTrient = Math.floor(phi / THIRD_PI);\n        if (\n          azimuthalQuadrant !== lastAzimuthalQuadrant ||\n          polarTrient !== lastPolarTrient\n        ) {\n          const azimuthalQuadrantLabel =\n            AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n          const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n          const ariaLabel = `View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`;\n          this[$userInputElement].setAttribute('aria-label', ariaLabel);\n        }\n      }\n    }\n    [$onResize](event) {\n      const controls = this[$controls];\n      const oldFramedFieldOfView = this[$scene].framedFieldOfView;\n      // The super of $onResize will update the scene's framedFieldOfView, so we\n      // compare the before and after to calculate the proper zoom.\n      super[$onResize](event);\n      const newFramedFieldOfView = this[$scene].framedFieldOfView;\n      const zoom = controls.getFieldOfView() / oldFramedFieldOfView;\n      this[$zoomAdjustedFieldOfView] = newFramedFieldOfView * zoom;\n      controls.updateAspect(this[$scene].aspect);\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.jumpCameraToGoal();\n    }\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      const { framedFieldOfView } = this[$scene];\n      this[$zoomAdjustedFieldOfView] = framedFieldOfView;\n      if (this[$initialized]) {\n        this[$maintainThetaPhi] = true;\n      } else {\n        this[$initialized] = true;\n      }\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n  }\n  (_p = $onFocus), (_q = $onBlur), (_r = $onChange), (_s = $onPointerChange);\n  __decorate$3(\n    [property({ type: Boolean, attribute: 'camera-controls' })],\n    ControlsModelViewerElement.prototype,\n    'cameraControls',\n    void 0,\n  );\n  __decorate$3(\n    [\n      style({\n        intrinsics: cameraOrbitIntrinsics,\n        observeEffects: true,\n        updateHandler: $syncCameraOrbit,\n      }),\n      property({\n        type: String,\n        attribute: 'camera-orbit',\n        hasChanged: () => true,\n      }),\n    ],\n    ControlsModelViewerElement.prototype,\n    'cameraOrbit',\n    void 0,\n  );\n  __decorate$3(\n    [\n      style({\n        intrinsics: cameraTargetIntrinsics,\n        observeEffects: true,\n        updateHandler: $syncCameraTarget,\n      }),\n      property({\n        type: String,\n        attribute: 'camera-target',\n        hasChanged: () => true,\n      }),\n    ],\n    ControlsModelViewerElement.prototype,\n    'cameraTarget',\n    void 0,\n  );\n  __decorate$3(\n    [\n      style({\n        intrinsics: fieldOfViewIntrinsics,\n        observeEffects: true,\n        updateHandler: $syncFieldOfView,\n      }),\n      property({\n        type: String,\n        attribute: 'field-of-view',\n        hasChanged: () => true,\n      }),\n    ],\n    ControlsModelViewerElement.prototype,\n    'fieldOfView',\n    void 0,\n  );\n  __decorate$3(\n    [\n      style({\n        intrinsics: minCameraOrbitIntrinsics,\n        updateHandler: $syncMinCameraOrbit,\n      }),\n      property({\n        type: String,\n        attribute: 'min-camera-orbit',\n        hasChanged: () => true,\n      }),\n    ],\n    ControlsModelViewerElement.prototype,\n    'minCameraOrbit',\n    void 0,\n  );\n  __decorate$3(\n    [\n      style({\n        intrinsics: maxCameraOrbitIntrinsics,\n        updateHandler: $syncMaxCameraOrbit,\n      }),\n      property({\n        type: String,\n        attribute: 'max-camera-orbit',\n        hasChanged: () => true,\n      }),\n    ],\n    ControlsModelViewerElement.prototype,\n    'maxCameraOrbit',\n    void 0,\n  );\n  __decorate$3(\n    [\n      style({\n        intrinsics: minFieldOfViewIntrinsics,\n        updateHandler: $syncMinFieldOfView,\n      }),\n      property({\n        type: String,\n        attribute: 'min-field-of-view',\n        hasChanged: () => true,\n      }),\n    ],\n    ControlsModelViewerElement.prototype,\n    'minFieldOfView',\n    void 0,\n  );\n  __decorate$3(\n    [\n      style({\n        intrinsics: maxFieldOfViewIntrinsics,\n        updateHandler: $syncMaxFieldOfView,\n      }),\n      property({\n        type: String,\n        attribute: 'max-field-of-view',\n        hasChanged: () => true,\n      }),\n    ],\n    ControlsModelViewerElement.prototype,\n    'maxFieldOfView',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: Number, attribute: 'interaction-prompt-threshold' })],\n    ControlsModelViewerElement.prototype,\n    'interactionPromptThreshold',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: String, attribute: 'interaction-prompt-style' })],\n    ControlsModelViewerElement.prototype,\n    'interactionPromptStyle',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: String, attribute: 'interaction-prompt' })],\n    ControlsModelViewerElement.prototype,\n    'interactionPrompt',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: String, attribute: 'interaction-policy' })],\n    ControlsModelViewerElement.prototype,\n    'interactionPolicy',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: Number, attribute: 'orbit-sensitivity' })],\n    ControlsModelViewerElement.prototype,\n    'orbitSensitivity',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: String, attribute: 'touch-action' })],\n    ControlsModelViewerElement.prototype,\n    'touchAction',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: Boolean, attribute: 'disable-zoom' })],\n    ControlsModelViewerElement.prototype,\n    'disableZoom',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: Number, attribute: 'interpolation-decay' })],\n    ControlsModelViewerElement.prototype,\n    'interpolationDecay',\n    void 0,\n  );\n  __decorate$3(\n    [property({ type: String, attribute: 'bounds' })],\n    ControlsModelViewerElement.prototype,\n    'bounds',\n    void 0,\n  );\n  return ControlsModelViewerElement;\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a$3, _b$2;\nconst INITIAL_STATUS_ANNOUNCEMENT =\n  'This page includes one or more 3D models that are loading';\nconst FINISHED_LOADING_ANNOUNCEMENT = 'All 3D models in the page have loaded';\nconst UPDATE_STATUS_DEBOUNCE_MS = 100;\nconst $modelViewerStatusInstance = Symbol('modelViewerStatusInstance');\nconst $updateStatus = Symbol('updateStatus');\n/**\n * The LoadingStatusAnnouncer manages announcements of loading status across\n * all <model-viewer> elements in the document at any given time. As new\n * <model-viewer> elements are connected to the document, they are registered\n * with a LoadingStatusAnnouncer singleton. As they are disconnected, the are\n * also unregistered. Announcements are made to indicate the following\n * conditions:\n *\n *  1. There are <model-viewer> elements that have yet to finish loading\n *  2. All <model-viewer> elements in the page have finished attempting to load\n */\nclass LoadingStatusAnnouncer extends EventDispatcher {\n  constructor() {\n    super();\n    /**\n     * The \"status\" instance is the <model-viewer> instance currently designated\n     * to announce the loading status of all <model-viewer> elements in the\n     * document at any given time. It might change as <model-viewer> elements are\n     * attached or detached over time.\n     */\n    this[_a$3] = null;\n    this.registeredInstanceStatuses = new Map();\n    this.loadingPromises = [];\n    /**\n     * This element is a node that floats around the document as the status\n     * instance changes (see above). It is a singleton that represents the loading\n     * status for all <model-viewer> elements currently in the page. It has its\n     * role attribute set to \"status\", which causes screen readers to announce\n     * any changes to its text content.\n     *\n     * @see https://www.w3.org/TR/wai-aria-1.1/#status\n     */\n    this.statusElement = document.createElement('p');\n    this.statusUpdateInProgress = false;\n    this[_b$2] = debounce(() => this.updateStatus(), UPDATE_STATUS_DEBOUNCE_MS);\n    const { statusElement } = this;\n    const { style } = statusElement;\n    statusElement.setAttribute('role', 'status');\n    statusElement.classList.add('screen-reader-only');\n    style.top = style.left = '0';\n    style.pointerEvents = 'none';\n  }\n  /**\n   * Register a <model-viewer> element with the announcer. If it is not yet\n   * loaded, its loading status will be tracked by the announcer.\n   */\n  registerInstance(modelViewer) {\n    if (this.registeredInstanceStatuses.has(modelViewer)) {\n      return;\n    }\n    let onUnregistered = () => {};\n    const loadShouldBeMeasured =\n      modelViewer.loaded === false && !!modelViewer.src;\n    const loadAttemptCompletes = new Promise((resolve) => {\n      if (!loadShouldBeMeasured) {\n        resolve();\n        return;\n      }\n      const resolveHandler = () => {\n        resolve();\n        modelViewer.removeEventListener('load', resolveHandler);\n        modelViewer.removeEventListener('error', resolveHandler);\n      };\n      modelViewer.addEventListener('load', resolveHandler);\n      modelViewer.addEventListener('error', resolveHandler);\n      onUnregistered = resolveHandler;\n    });\n    this.registeredInstanceStatuses.set(modelViewer, { onUnregistered });\n    this.loadingPromises.push(loadAttemptCompletes);\n    if (this.modelViewerStatusInstance == null) {\n      this.modelViewerStatusInstance = modelViewer;\n    }\n  }\n  /**\n   * Unregister a <model-viewer> element with the announcer. Its loading status\n   * will no longer be tracked by the announcer.\n   */\n  unregisterInstance(modelViewer) {\n    if (!this.registeredInstanceStatuses.has(modelViewer)) {\n      return;\n    }\n    const statuses = this.registeredInstanceStatuses;\n    const instanceStatus = statuses.get(modelViewer);\n    statuses.delete(modelViewer);\n    instanceStatus.onUnregistered();\n    if (this.modelViewerStatusInstance === modelViewer) {\n      this.modelViewerStatusInstance =\n        statuses.size > 0 ? getFirstMapKey(statuses) : null;\n    }\n  }\n  get modelViewerStatusInstance() {\n    return this[$modelViewerStatusInstance];\n  }\n  set modelViewerStatusInstance(value) {\n    const currentInstance = this[$modelViewerStatusInstance];\n    if (currentInstance === value) {\n      return;\n    }\n    const { statusElement } = this;\n    if (value != null && value.shadowRoot != null) {\n      value.shadowRoot.appendChild(statusElement);\n    } else if (statusElement.parentNode != null) {\n      statusElement.parentNode.removeChild(statusElement);\n    }\n    this[$modelViewerStatusInstance] = value;\n    this[$updateStatus]();\n  }\n  async updateStatus() {\n    if (this.statusUpdateInProgress || this.loadingPromises.length === 0) {\n      return;\n    }\n    this.statusElement.textContent = INITIAL_STATUS_ANNOUNCEMENT;\n    this.statusUpdateInProgress = true;\n    this.dispatchEvent({ type: 'initial-status-announced' });\n    while (this.loadingPromises.length) {\n      const { loadingPromises } = this;\n      this.loadingPromises = [];\n      await Promise.all(loadingPromises);\n    }\n    this.statusElement.textContent = FINISHED_LOADING_ANNOUNCEMENT;\n    this.statusUpdateInProgress = false;\n    this.dispatchEvent({ type: 'finished-loading-announced' });\n  }\n}\n(_a$3 = $modelViewerStatusInstance), (_b$2 = $updateStatus);\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate$2 =\n  (undefined && undefined.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === 'object' && typeof undefined === 'function')\n      r = undefined(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nconst PROGRESS_BAR_UPDATE_THRESHOLD = 100;\nconst PROGRESS_MASK_BASE_OPACITY = 0.2;\nconst DEFAULT_DRACO_DECODER_LOCATION =\n  'https://www.gstatic.com/draco/versioned/decoders/1.4.1/';\nconst DEFAULT_KTX2_TRANSCODER_LOCATION =\n  'https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/';\nconst SPACE_KEY = 32;\nconst ENTER_KEY = 13;\nconst RevealStrategy = {\n  AUTO: 'auto',\n  INTERACTION: 'interaction',\n  MANUAL: 'manual',\n};\nconst LoadingStrategy = {\n  AUTO: 'auto',\n  LAZY: 'lazy',\n  EAGER: 'eager',\n};\nconst PosterDismissalSource = {\n  INTERACTION: 'interaction',\n};\nconst loadingStatusAnnouncer = new LoadingStatusAnnouncer();\nconst $defaultProgressBarElement = Symbol('defaultProgressBarElement');\nconst $defaultProgressMaskElement = Symbol('defaultProgressMaskElement');\nconst $posterContainerElement = Symbol('posterContainerElement');\nconst $defaultPosterElement = Symbol('defaultPosterElement');\nconst $posterDismissalSource = Symbol('posterDismissalSource');\nconst $hidePoster = Symbol('hidePoster');\nconst $modelIsRevealed = Symbol('modelIsRevealed');\nconst $updateProgressBar = Symbol('updateProgressBar');\nconst $lastReportedProgress = Symbol('lastReportedProgress');\nconst $transitioned = Symbol('transitioned');\nconst $onTransitionEnd = Symbol('onTransitionEnd');\nconst $ariaLabelCallToAction = Symbol('ariaLabelCallToAction');\nconst $onClick = Symbol('onClick');\nconst $onKeydown = Symbol('onKeydown');\nconst $onProgress = Symbol('onProgress');\n/**\n * LoadingMixin implements features related to lazy loading, as well as\n * presentation details related to the pre-load / pre-render presentation of a\n * <model-viewer>\n *\n * This mixin implements support for models with DRACO-compressed meshes.\n * The DRACO decoder will be loaded on-demand if a glTF that uses the DRACO mesh\n * compression extension is encountered.\n *\n * By default, the DRACO decoder will be loaded from a Google CDN. It is\n * possible to customize where the decoder is loaded from by defining a global\n * configuration option for `<model-viewer>` like so:\n *\n * ```html\n * <script>\n * self.ModelViewerElement = self.ModelViewerElement || {};\n * self.ModelViewerElement.dracoDecoderLocation =\n *     'http://example.com/location/of/draco/decoder/files/';\n * </script>\n * ```\n *\n * Note that the above configuration strategy must be performed *before* the\n * first `<model-viewer>` element is created in the browser. The configuration\n * can be done anywhere, but the easiest way to ensure it is done at the right\n * time is to do it in the `<head>` of the HTML document. This is the\n * recommended way to set the location because it is most compatible with\n * scenarios where the `<model-viewer>` library is lazily loaded.\n *\n * If you absolutely have to set the DRACO decoder location *after* the first\n * `<model-viewer>` element is created, you can do it this way:\n *\n * ```html\n * <script>\n * const ModelViewerElement = customElements.get('model-viewer');\n * ModelViewerElement.dracoDecoderLocation =\n *     'http://example.com/location/of/draco/decoder/files/';\n * </script>\n * ```\n *\n * Note that the above configuration approach will not work until *after*\n * `<model-viewer>` is defined in the browser. Also note that this configuration\n * *must* be set *before* the first DRACO model is fully loaded.\n *\n * It is recommended that users who intend to take advantage of DRACO mesh\n * compression consider whether or not it is acceptable for their use case to\n * have code side-loaded from a Google CDN. If it is not acceptable, then the\n * location must be customized before loading any DRACO models in order to cause\n * the decoder to be loaded from an alternative, acceptable location.\n */\nconst LoadingMixin = (ModelViewerElement) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n  class LoadingModelViewerElement extends ModelViewerElement {\n    constructor(...args) {\n      super(...args);\n      /**\n       * A URL pointing to the image to use as a poster in scenarios where the\n       * <model-viewer> is not ready to reveal a rendered model to the viewer.\n       */\n      this.poster = null;\n      /**\n       * An enumerable attribute describing under what conditions the\n       * <model-viewer> should reveal a model to the viewer.\n       *\n       * The default value is \"auto\". The only supported alternative values are\n       * \"interaction\" and \"manual\".\n       */\n      this.reveal = RevealStrategy.AUTO;\n      /**\n       * An enumerable attribute describing under what conditions the\n       * <model-viewer> should preload a model.\n       *\n       * The default value is \"auto\". The only supported alternative values are\n       * \"lazy\" and \"eager\". Auto is equivalent to lazy, which loads the model\n       * when it is near the viewport for reveal = \"auto\", and when interacted\n       * with for reveal = \"interaction\". Eager loads the model immediately.\n       */\n      this.loading = LoadingStrategy.AUTO;\n      /**\n       * Generates a 3D model schema https://schema.org/3DModel associated with\n       * the loaded src and inserts it into the header of the page for search\n       * engines to crawl.\n       */\n      this.generateSchema = false;\n      /**\n       * If you're using a seamless poster as generated by toBlob({idealAspect:\n       * true}) with --poster-color transparent (which is recommended), then set\n       * this attribute to true to turn off the poster's transition. This keeps\n       * the shadow from blinking and the transition is no longer necessary since\n       * the poster matches the rendering.\n       */\n      this.seamlessPoster = false;\n      this[_a] = false;\n      this[_b] = false;\n      this[_c] = 0;\n      this[_d] = null;\n      // TODO: Add this to the shadow root as part of this mixin's\n      // implementation:\n      this[_e] = this.shadowRoot.querySelector('.slot.poster');\n      this[_f] = this.shadowRoot.querySelector('#default-poster');\n      this[_g] = this.shadowRoot.querySelector('#default-progress-bar > .bar');\n      this[_h] = this.shadowRoot.querySelector('#default-progress-bar > .mask');\n      this[_j] = this[$defaultPosterElement].getAttribute('aria-label');\n      this[_k] = throttle((progress) => {\n        const parentNode = this[$defaultProgressBarElement].parentNode;\n        requestAnimationFrame(() => {\n          this[$defaultProgressMaskElement].style.opacity = `${\n            (1.0 - progress) * PROGRESS_MASK_BASE_OPACITY\n          }`;\n          this[\n            $defaultProgressBarElement\n          ].style.transform = `scaleX(${progress})`;\n          if (progress === 0) {\n            // NOTE(cdata): We remove and re-append the progress bar in this\n            // condition so that the progress bar does not appear to\n            // transition backwards from the right when we reset to 0 (or\n            // otherwise <1) progress after having already reached 1 progress\n            // previously.\n            parentNode.removeChild(this[$defaultProgressBarElement]);\n            parentNode.appendChild(this[$defaultProgressBarElement]);\n          }\n          // NOTE(cdata): IE11 does not properly respect the second parameter\n          // of classList.toggle, which this implementation originally used.\n          // @see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865865/\n          if (progress === 1.0) {\n            this[$defaultProgressBarElement].classList.add('hide');\n          } else {\n            this[$defaultProgressBarElement].classList.remove('hide');\n          }\n        });\n      }, PROGRESS_BAR_UPDATE_THRESHOLD);\n      this[_l] = () => {\n        if (this.reveal === RevealStrategy.MANUAL) {\n          return;\n        }\n        this.dismissPoster();\n      };\n      this[_m] = (event) => {\n        if (this.reveal === RevealStrategy.MANUAL) {\n          return;\n        }\n        switch (event.keyCode) {\n          // NOTE(cdata): Links and buttons can typically be activated with\n          // both spacebar and enter to produce a synthetic click action\n          case SPACE_KEY:\n          case ENTER_KEY:\n            this.dismissPoster();\n            break;\n        }\n      };\n      this[_o] = (event) => {\n        const progress = event.detail.totalProgress;\n        this[$lastReportedProgress] = Math.max(\n          progress,\n          this[$lastReportedProgress],\n        );\n        if (progress === 1.0) {\n          this[$updateProgressBar].flush();\n          if (\n            this[$sceneIsReady]() &&\n            (this[$posterDismissalSource] != null ||\n              this.reveal === RevealStrategy.AUTO)\n          ) {\n            this[$hidePoster]();\n          }\n        }\n        this[$updateProgressBar](progress);\n        this.dispatchEvent(\n          new CustomEvent('progress', { detail: { totalProgress: progress } }),\n        );\n      };\n      this[_p] = () => {\n        this[$transitioned] = true;\n        const root = this.getRootNode();\n        // If the <model-viewer> is still focused, forward the focus to\n        // the canvas that has just been revealed\n        if (root && root.activeElement === this) {\n          this[$userInputElement].focus();\n        }\n        // Ensure that the poster is no longer focusable or visible to\n        // screen readers\n        const defaultPosterElement = this[$defaultPosterElement];\n        defaultPosterElement.setAttribute('aria-hidden', 'true');\n        defaultPosterElement.tabIndex = -1;\n        this.dispatchEvent(new CustomEvent('poster-dismissed'));\n      };\n      const ModelViewerElement = self.ModelViewerElement || {};\n      const dracoDecoderLocation =\n        ModelViewerElement.dracoDecoderLocation ||\n        DEFAULT_DRACO_DECODER_LOCATION;\n      CachingGLTFLoader.setDRACODecoderLocation(dracoDecoderLocation);\n      const ktx2TranscoderLocation =\n        ModelViewerElement.ktx2TranscoderLocation ||\n        DEFAULT_KTX2_TRANSCODER_LOCATION;\n      CachingGLTFLoader.setKTX2TranscoderLocation(ktx2TranscoderLocation);\n      if (ModelViewerElement.meshoptDecoderLocation) {\n        CachingGLTFLoader.setMeshoptDecoderLocation(\n          ModelViewerElement.meshoptDecoderLocation,\n        );\n      }\n    }\n    static set dracoDecoderLocation(value) {\n      CachingGLTFLoader.setDRACODecoderLocation(value);\n    }\n    static get dracoDecoderLocation() {\n      return CachingGLTFLoader.getDRACODecoderLocation();\n    }\n    static set ktx2TranscoderLocation(value) {\n      CachingGLTFLoader.setKTX2TranscoderLocation(value);\n    }\n    static get ktx2TranscoderLocation() {\n      return CachingGLTFLoader.getKTX2TranscoderLocation();\n    }\n    static set meshoptDecoderLocation(value) {\n      CachingGLTFLoader.setMeshoptDecoderLocation(value);\n    }\n    static get meshoptDecoderLocation() {\n      return CachingGLTFLoader.getMeshoptDecoderLocation();\n    }\n    /**\n     * If provided, the callback will be passed each resource URL before a\n     * request is sent. The callback may return the original URL, or a new URL\n     * to override loading behavior. This behavior can be used to load assets\n     * from .ZIP files, drag-and-drop APIs, and Data URIs.\n     */\n    static mapURLs(callback) {\n      Renderer.singleton.loader[$loader].manager.setURLModifier(callback);\n    }\n    /**\n     * Dismisses the poster, causing the model to load and render if\n     * necessary. This is currently effectively the same as interacting with\n     * the poster via user input.\n     */\n    dismissPoster() {\n      if (this[$sceneIsReady]()) {\n        this[$hidePoster]();\n      } else {\n        this[$posterDismissalSource] = PosterDismissalSource.INTERACTION;\n        this[$updateSource]();\n      }\n    }\n    /**\n     * Displays the poster, hiding the 3D model. If this is called after the 3D\n     * model has been revealed, then it will behave as though\n     * reveal='interaction', being dismissed either by a user click or a call to\n     * dismissPoster().\n     */\n    showPoster() {\n      const posterContainerElement = this[$posterContainerElement];\n      const defaultPosterElement = this[$defaultPosterElement];\n      defaultPosterElement.removeAttribute('tabindex');\n      defaultPosterElement.removeAttribute('aria-hidden');\n      posterContainerElement.classList.add('show');\n      const oldVisibility = this.modelIsVisible;\n      this[$modelIsRevealed] = false;\n      this[$announceModelVisibility](oldVisibility);\n      this[$transitioned] = false;\n    }\n    /**\n     * Returns the model's bounding box dimensions in meters, independent of\n     * turntable rotation.\n     */\n    getDimensions() {\n      return toVector3D(this[$scene].size);\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      // Fired when a user first clicks the model element. Used to\n      // change the visibility of a poster image, or start loading\n      // a model.\n      this[$posterContainerElement].addEventListener('click', this[$onClick]);\n      this[$posterContainerElement].addEventListener(\n        'keydown',\n        this[$onKeydown],\n      );\n      this[$progressTracker].addEventListener('progress', this[$onProgress]);\n      loadingStatusAnnouncer.registerInstance(this);\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$posterContainerElement].removeEventListener(\n        'click',\n        this[$onClick],\n      );\n      this[$posterContainerElement].removeEventListener(\n        'keydown',\n        this[$onKeydown],\n      );\n      this[$progressTracker].removeEventListener('progress', this[$onProgress]);\n      loadingStatusAnnouncer.unregisterInstance(this);\n    }\n    async updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('poster') && this.poster != null) {\n        this[\n          $defaultPosterElement\n        ].style.backgroundImage = `url(${this.poster})`;\n      }\n      if (changedProperties.has('alt')) {\n        this[$defaultPosterElement].setAttribute(\n          'aria-label',\n          `${this[$ariaLabel]}. ${this[$ariaLabelCallToAction]}`,\n        );\n      }\n      if (changedProperties.has('reveal') || changedProperties.has('loading')) {\n        this[$updateSource]();\n      }\n      if (changedProperties.has('generateSchema')) {\n        if (this.generateSchema === true) {\n          this[$scene].updateSchema(this.src);\n        } else {\n          this[$scene].updateSchema(null);\n        }\n      }\n      if (changedProperties.has('seamlessPoster')) {\n        if (this.seamlessPoster === true) {\n          this[$posterContainerElement].classList.add('quick');\n        } else {\n          this[$posterContainerElement].classList.remove('quick');\n        }\n      }\n    }\n    [((_a = $modelIsRevealed),\n    (_b = $transitioned),\n    (_c = $lastReportedProgress),\n    (_d = $posterDismissalSource),\n    (_e = $posterContainerElement),\n    (_f = $defaultPosterElement),\n    (_g = $defaultProgressBarElement),\n    (_h = $defaultProgressMaskElement),\n    (_j = $ariaLabelCallToAction),\n    (_k = $updateProgressBar),\n    (_l = $onClick),\n    (_m = $onKeydown),\n    (_o = $onProgress),\n    $shouldAttemptPreload)]() {\n      return (\n        !!this.src &&\n        (this[$posterDismissalSource] != null ||\n          this.loading === LoadingStrategy.EAGER ||\n          (this.reveal === RevealStrategy.AUTO && this[$isElementInViewport]))\n      );\n    }\n    [$sceneIsReady]() {\n      const { src } = this;\n      return (\n        !!src && super[$sceneIsReady]() && this[$lastReportedProgress] === 1.0\n      );\n    }\n    [((_p = $onTransitionEnd), $hidePoster)]() {\n      this[$posterDismissalSource] = null;\n      const posterContainerElement = this[$posterContainerElement];\n      if (posterContainerElement.classList.contains('show')) {\n        const oldVisibility = this.modelIsVisible;\n        this[$modelIsRevealed] = true;\n        this[$announceModelVisibility](oldVisibility);\n        requestAnimationFrame(() => {\n          posterContainerElement.classList.remove('show');\n          if (this.seamlessPoster === true) {\n            this[$onTransitionEnd]();\n          } else {\n            // We might need to forward focus to our internal canvas, but that\n            // cannot happen until the poster has completely transitioned away\n            posterContainerElement.addEventListener(\n              'transitionend',\n              this[$onTransitionEnd],\n              { once: true },\n            );\n          }\n        });\n      } else {\n        this[$transitioned] = true;\n      }\n    }\n    [$getModelIsVisible]() {\n      return super[$getModelIsVisible]() && this[$modelIsRevealed];\n    }\n    [$hasTransitioned]() {\n      return super[$hasTransitioned]() && this[$transitioned];\n    }\n    async [$updateSource]() {\n      this[$lastReportedProgress] = 0;\n      if (this.generateSchema === true) {\n        this[$scene].updateSchema(this.src);\n      }\n      if (\n        this[$scene].currentGLTF == null ||\n        this.src == null ||\n        !this[$shouldAttemptPreload]()\n      ) {\n        // Don't show the poster when switching models.\n        this.showPoster();\n      }\n      await super[$updateSource]();\n    }\n  }\n  __decorate$2(\n    [property({ type: String })],\n    LoadingModelViewerElement.prototype,\n    'poster',\n    void 0,\n  );\n  __decorate$2(\n    [property({ type: String })],\n    LoadingModelViewerElement.prototype,\n    'reveal',\n    void 0,\n  );\n  __decorate$2(\n    [property({ type: String })],\n    LoadingModelViewerElement.prototype,\n    'loading',\n    void 0,\n  );\n  __decorate$2(\n    [property({ type: Boolean, attribute: 'generate-schema' })],\n    LoadingModelViewerElement.prototype,\n    'generateSchema',\n    void 0,\n  );\n  __decorate$2(\n    [property({ type: Boolean, attribute: 'seamless-poster' })],\n    LoadingModelViewerElement.prototype,\n    'seamlessPoster',\n    void 0,\n  );\n  return LoadingModelViewerElement;\n};\n\nclass GLTFExporter {\n  constructor() {\n    this.pluginCallbacks = [];\n\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  parse(input, onDone, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497,\n};\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] =\n  WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] =\n  WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] =\n  WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights',\n};\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546c67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return (\n    array1.length === array2.length &&\n    array1.every(function (element, index) {\n      return element === array2[index];\n    })\n  );\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(text).buffer;\n  }\n\n  const array = new Uint8Array(new ArrayBuffer(text.length));\n\n  for (let i = 0, il = text.length; i < il; i++) {\n    const value = text.charCodeAt(i);\n\n    // Replacing multi-byte character with space(0x20).\n    array[i] = value > 0xff ? 0x20 : value;\n  }\n\n  return array.buffer;\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(\n    matrix.elements,\n    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n  );\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY),\n  };\n\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);\n        else if (a === 1) value = attribute.getY(i);\n        else if (a === 2) value = attribute.getZ(i);\n        else if (a === 3) value = attribute.getW(i);\n      }\n\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n\n  return output;\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n\n    return array.buffer;\n  }\n\n  return arrayBuffer;\n}\n\nlet cachedCanvas = null;\n\n/**\n * Writer\n */\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n\n    this.uids = new Map();\n    this.uid = 0;\n\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter',\n      },\n    };\n\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map(),\n    };\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  write(input, onDone, options) {\n    this.options = Object.assign(\n      {},\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        truncateDrawRange: true,\n        embedImages: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false,\n      },\n      options,\n    );\n\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n\n    this.processInput(input);\n\n    const writer = this;\n\n    Promise.all(this.pending).then(function () {\n      const buffers = writer.buffers;\n      const json = writer.json;\n      const options = writer.options;\n      const extensionsUsed = writer.extensionsUsed;\n\n      // Merge buffers.\n      const blob = new Blob(buffers, { type: 'application/octet-stream' });\n\n      // Declare extensions.\n      const extensionsUsedList = Object.keys(extensionsUsed);\n\n      if (extensionsUsedList.length > 0)\n        json.extensionsUsed = extensionsUsedList;\n\n      // Update bytelength of the single buffer.\n      if (json.buffers && json.buffers.length > 0)\n        json.buffers[0].byteLength = blob.size;\n\n      if (options.binary === true) {\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n        reader.onloadend = function () {\n          // Binary chunk.\n          const binaryChunk = getPaddedArrayBuffer(reader.result);\n          const binaryChunkPrefix = new DataView(\n            new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES),\n          );\n          binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n          binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n\n          // JSON chunk.\n          const jsonChunk = getPaddedArrayBuffer(\n            stringToArrayBuffer(JSON.stringify(json)),\n            0x20,\n          );\n          const jsonChunkPrefix = new DataView(\n            new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES),\n          );\n          jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n          jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n\n          // GLB header.\n          const header = new ArrayBuffer(GLB_HEADER_BYTES);\n          const headerView = new DataView(header);\n          headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n          headerView.setUint32(4, GLB_VERSION, true);\n          const totalByteLength =\n            GLB_HEADER_BYTES +\n            jsonChunkPrefix.byteLength +\n            jsonChunk.byteLength +\n            binaryChunkPrefix.byteLength +\n            binaryChunk.byteLength;\n          headerView.setUint32(8, totalByteLength, true);\n\n          const glbBlob = new Blob(\n            [\n              header,\n              jsonChunkPrefix,\n              jsonChunk,\n              binaryChunkPrefix,\n              binaryChunk,\n            ],\n            { type: 'application/octet-stream' },\n          );\n\n          const glbReader = new window.FileReader();\n          glbReader.readAsArrayBuffer(glbBlob);\n          glbReader.onloadend = function () {\n            onDone(glbReader.result);\n          };\n        };\n      } else {\n        if (json.buffers && json.buffers.length > 0) {\n          const reader = new window.FileReader();\n          reader.readAsDataURL(blob);\n          reader.onloadend = function () {\n            const base64data = reader.result;\n            json.buffers[0].uri = base64data;\n            onDone(json);\n          };\n        } else {\n          onDone(json);\n        }\n      }\n    });\n  }\n\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] =\n            json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n\n        delete json.gltfExtensions;\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" +\n          object.name +\n          \"' \" +\n          \"won't be serialized because of JSON.stringify error - \" +\n          error.message,\n      );\n    }\n  }\n\n  /**\n   * Assign and return a temporal unique id for an object\n   * especially which doesn't have .uuid\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(object) {\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n\n    return this.uids.get(object);\n  }\n\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n\n    if (cache.attributesNormalized.has(normal)) return false;\n\n    const v = new Vector3();\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005)\n        return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n\n    if (cache.attributesNormalized.has(normal))\n      return cache.attributesNormalized.get(normal);\n\n    const attribute = normal.clone();\n    const v = new Vector3();\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n\n    cache.attributesNormalized.set(normal, attribute);\n\n    return attribute;\n  }\n\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n\n    if (!json.buffers) json.buffers = [{ byteLength: 0 }];\n\n    // All buffers are merged before export.\n    buffers.push(buffer);\n\n    return 0;\n  }\n\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n\n    if (!json.bufferViews) json.bufferViews = [];\n\n    // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n      componentSize = 1;\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n      componentSize = 2;\n    } else {\n      componentSize = 4;\n    }\n\n    const byteLength = getPaddedBufferSize(\n      count * attribute.itemSize * componentSize,\n    );\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);\n          else if (a === 1) value = attribute.getY(i);\n          else if (a === 2) value = attribute.getZ(i);\n          else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n\n        offset += componentSize;\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength,\n    };\n\n    if (target !== undefined) bufferViewDef.target = target;\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n\n    this.byteOffset += byteLength;\n\n    json.bufferViews.push(bufferViewDef);\n\n    // @TODO Merge bufferViews where possible.\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0,\n    };\n\n    return output;\n  }\n\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n\n    if (!json.bufferViews) json.bufferViews = [];\n\n    return new Promise(function (resolve) {\n      const reader = new window.FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function () {\n        const buffer = getPaddedArrayBuffer(reader.result);\n\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength,\n        };\n\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const options = this.options;\n    const json = this.json;\n\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      16: 'MAT4',\n    };\n\n    let componentType;\n\n    // Detect the component type of the attribute array (float, uint or ushort)\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\n        'THREE.GLTFExporter: Unsupported bufferAttribute component type.',\n      );\n    }\n\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count;\n\n    // @TODO Indexed buffer geometry with drawRange not supported yet\n    if (\n      options.truncateDrawRange &&\n      geometry !== undefined &&\n      geometry.index === null\n    ) {\n      const end = start + count;\n      const end2 =\n        geometry.drawRange.count === Infinity\n          ? attribute.count\n          : geometry.drawRange.start + geometry.drawRange.count;\n\n      start = Math.max(start, geometry.drawRange.start);\n      count = Math.min(end, end2) - start;\n\n      if (count < 0) count = 0;\n    }\n\n    // Skip creating an accessor if the attribute doesn't have data to export\n    if (count === 0) return null;\n\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n\n    // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n    if (geometry !== undefined) {\n      bufferViewTarget =\n        attribute === geometry.index\n          ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER\n          : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n\n    const bufferView = this.processBufferView(\n      attribute,\n      componentType,\n      start,\n      count,\n      bufferViewTarget,\n    );\n\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize],\n    };\n\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n\n    return json.accessors.push(accessorDef) - 1;\n  }\n\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n   * @param  {Boolean} flipY before writing out the image\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY) {\n    const writer = this;\n    const cache = writer.cache;\n    const json = writer.json;\n    const options = writer.options;\n    const pending = writer.pending;\n\n    if (!cache.images.has(image)) cache.images.set(image, {});\n\n    const cachedImages = cache.images.get(image);\n    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n    const key = mimeType + ':flipY/' + flipY.toString();\n\n    if (cachedImages[key] !== undefined) return cachedImages[key];\n\n    if (!json.images) json.images = [];\n\n    const imageDef = { mimeType: mimeType };\n\n    if (options.embedImages) {\n      const canvas = (cachedCanvas =\n        cachedCanvas || document.createElement('canvas'));\n\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n\n      const ctx = canvas.getContext('2d');\n\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n\n      if (\n        (typeof HTMLImageElement !== 'undefined' &&\n          image instanceof HTMLImageElement) ||\n        (typeof HTMLCanvasElement !== 'undefined' &&\n          image instanceof HTMLCanvasElement) ||\n        (typeof OffscreenCanvas !== 'undefined' &&\n          image instanceof OffscreenCanvas) ||\n        (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)\n      ) {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      } else {\n        if (format !== RGBAFormat && format !== RGBFormat) {\n          console.error(\n            'GLTFExporter: Only RGB and RGBA formats are supported.',\n          );\n        }\n\n        if (\n          image.width > options.maxTextureSize ||\n          image.height > options.maxTextureSize\n        ) {\n          console.warn(\n            'GLTFExporter: Image size is bigger than maxTextureSize',\n            image,\n          );\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n\n        if (format === RGBAFormat) {\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = image.data[i + 0];\n            data[i + 1] = image.data[i + 1];\n            data[i + 2] = image.data[i + 2];\n            data[i + 3] = image.data[i + 3];\n          }\n        } else {\n          for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {\n            data[i + 0] = image.data[j + 0];\n            data[i + 1] = image.data[j + 1];\n            data[i + 2] = image.data[j + 2];\n            data[i + 3] = 255;\n          }\n        }\n\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      }\n\n      if (options.binary === true) {\n        pending.push(\n          new Promise(function (resolve) {\n            canvas.toBlob(function (blob) {\n              writer\n                .processBufferViewImage(blob)\n                .then(function (bufferViewIndex) {\n                  imageDef.bufferView = bufferViewIndex;\n                  resolve();\n                });\n            }, mimeType);\n          }),\n        );\n      } else {\n        imageDef.uri = canvas.toDataURL(mimeType);\n      }\n    } else {\n      imageDef.uri = image.src;\n    }\n\n    const index = json.images.push(imageDef) - 1;\n    cachedImages[key] = index;\n    return index;\n  }\n\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n\n    if (!json.samplers) json.samplers = [];\n\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT],\n    };\n\n    return json.samplers.push(samplerDef) - 1;\n  }\n\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const cache = this.cache;\n    const json = this.json;\n\n    if (cache.textures.has(map)) return cache.textures.get(map);\n\n    if (!json.textures) json.textures = [];\n\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY),\n    };\n\n    if (map.name) textureDef.name = map.name;\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n\n    if (cache.materials.has(material)) return cache.materials.get(material);\n\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n\n    if (!json.materials) json.materials = [];\n\n    // @QUESTION Should we avoid including any attribute that has the default value?\n    const materialDef = { pbrMetallicRoughness: {} };\n\n    if (\n      material.isMeshStandardMaterial !== true &&\n      material.isMeshBasicMaterial !== true\n    ) {\n      console.warn(\n        'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.',\n      );\n    }\n\n    // pbrMetallicRoughness.baseColorFactor\n    const color = material.color.toArray().concat([material.opacity]);\n\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n\n    // pbrMetallicRoughness.metallicRoughnessTexture\n    if (material.metalnessMap || material.roughnessMap) {\n      if (material.metalnessMap === material.roughnessMap) {\n        const metalRoughMapDef = {\n          index: this.processTexture(material.metalnessMap),\n        };\n        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture =\n          metalRoughMapDef;\n      } else {\n        console.warn(\n          'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.',\n        );\n      }\n    }\n\n    // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n    if (material.map) {\n      const baseColorMapDef = { index: this.processTexture(material.map) };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n\n    if (material.emissive) {\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n      const emissive = material.emissive\n        .clone()\n        .multiplyScalar(material.emissiveIntensity);\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n      if (maxEmissiveComponent > 1) {\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\n\n        console.warn(\n          'THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited',\n        );\n      }\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = emissive.toArray();\n      }\n\n      // emissiveTexture\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n\n    // normalTexture\n    if (material.normalMap) {\n      const normalMapDef = { index: this.processTexture(material.normalMap) };\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n\n    // occlusionTexture\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: 1,\n      };\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n\n    // alphaMode\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n\n    // doubleSided\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n\n    this.serializeUserData(material, materialDef);\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':');\n\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n\n    const geometry = mesh.geometry;\n    let mode;\n\n    // Use the correct mode\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe\n        ? WEBGL_CONSTANTS.LINES\n        : WEBGL_CONSTANTS.TRIANGLES;\n    }\n\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error(\n        'THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.',\n      );\n    }\n\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n\n    // Conversion between attributes names in threejs and gltf spec\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv2: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0',\n    };\n\n    const originalNormal = geometry.getAttribute('normal');\n\n    if (\n      originalNormal !== undefined &&\n      !this.isNormalizedNormalAttribute(originalNormal)\n    ) {\n      console.warn(\n        'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.',\n      );\n\n      geometry.setAttribute(\n        'normal',\n        this.createNormalizedNormalAttribute(originalNormal),\n      );\n    }\n\n    // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n    let modifiedAttribute = null;\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.substr(0, 5) === 'morph') continue;\n\n      const attribute = geometry.attributes[attributeName];\n      attributeName =\n        nameConversion[attributeName] || attributeName.toUpperCase();\n\n      // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n      const validVertexAttributes =\n        /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n      if (!validVertexAttributes.test(attributeName))\n        attributeName = '_' + attributeName;\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(\n          this.getUID(attribute),\n        );\n        continue;\n      }\n\n      // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n      modifiedAttribute = null;\n      const array = attribute.array;\n\n      if (\n        attributeName === 'JOINTS_0' &&\n        !(array instanceof Uint16Array) &&\n        !(array instanceof Uint8Array)\n      ) {\n        console.warn(\n          'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.',\n        );\n        modifiedAttribute = new BufferAttribute(\n          new Uint16Array(array),\n          attribute.itemSize,\n          attribute.normalized,\n        );\n      }\n\n      const accessor = this.processAccessor(\n        modifiedAttribute || attribute,\n        geometry,\n      );\n\n      if (accessor !== null) {\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n\n    if (originalNormal !== undefined)\n      geometry.setAttribute('normal', originalNormal);\n\n    // Skip if no exportable attributes found\n    if (Object.keys(attributes).length === 0) return null;\n\n    // Morph targets\n    if (\n      mesh.morphTargetInfluences !== undefined &&\n      mesh.morphTargetInfluences.length > 0\n    ) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn(\n                'GLTFExporter: Only POSITION and NORMAL morph are supported.',\n              );\n              warned = true;\n            }\n\n            continue;\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n\n          // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n\n          if (cache.attributes.has(this.getUID(attribute))) {\n            target[gltfAttributeName] = cache.attributes.get(\n              this.getUID(attribute),\n            );\n            continue;\n          }\n\n          // Clones attribute not to override\n          const relativeAttribute = attribute.clone();\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              relativeAttribute.setXYZ(\n                j,\n                attribute.getX(j) - baseAttribute.getX(j),\n                attribute.getY(j) - baseAttribute.getY(j),\n                attribute.getZ(j) - baseAttribute.getZ(j),\n              );\n            }\n          }\n\n          target[gltfAttributeName] = this.processAccessor(\n            relativeAttribute,\n            geometry,\n          );\n          cache.attributes.set(\n            this.getUID(baseAttribute),\n            target[gltfAttributeName],\n          );\n        }\n\n        targets.push(target);\n\n        weights.push(mesh.morphTargetInfluences[i]);\n\n        if (mesh.morphTargetDictionary !== undefined)\n          targetNames.push(reverseDictionary[i]);\n      }\n\n      meshDef.weights = weights;\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material);\n\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial\n      ? geometry.groups\n      : [{ materialIndex: 0, start: undefined, count: undefined }];\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes,\n      };\n\n      this.serializeUserData(geometry, primitive);\n\n      if (targets.length > 0) primitive.targets = targets;\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count;\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(\n            geometry.index,\n            geometry,\n            groups[i].start,\n            groups[i].count,\n          );\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n\n        if (primitive.indices === null) delete primitive.indices;\n      }\n\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n\n      if (material !== null) primitive.material = material;\n\n      primitives.push(primitive);\n    }\n\n    meshDef.primitives = primitives;\n\n    if (!json.meshes) json.meshes = [];\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n\n    if (!json.cameras) json.cameras = [];\n\n    const isOrtho = camera.isOrthographicCamera;\n\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective',\n    };\n\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      };\n    }\n\n    // Question: Is saving \"type\" as name intentional?\n    if (camera.name !== '') cameraDef.name = camera.type;\n\n    return json.cameras.push(cameraDef) - 1;\n  }\n\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n\n    if (!json.animations) json.animations = [];\n\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(\n            trackBinding.objectIndex,\n          );\n        } else {\n          trackNode = undefined;\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn(\n          'THREE.GLTFExporter: Could not export animation track \"%s\".',\n          track.name,\n        );\n        return null;\n      }\n\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n\n      let interpolation;\n\n      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      if (\n        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ===\n        true\n      ) {\n        interpolation = 'CUBICSPLINE';\n\n        // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n\n      samplers.push({\n        input: this.processAccessor(\n          new BufferAttribute(track.times, inputItemSize),\n        ),\n        output: this.processAccessor(\n          new BufferAttribute(track.values, outputItemSize),\n        ),\n        interpolation: interpolation,\n      });\n\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty,\n        },\n      });\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels,\n    });\n\n    return json.animations.length - 1;\n  }\n\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n\n    const node = json.nodes[nodeMap.get(object)];\n\n    const skeleton = object.skeleton;\n\n    if (skeleton === undefined) return null;\n\n    const rootJoint = object.skeleton.bones[0];\n\n    if (rootJoint === undefined) return null;\n\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse\n        .multiply(object.bindMatrix)\n        .toArray(inverseBindMatrices, i * 16);\n    }\n\n    if (json.skins === undefined) json.skins = [];\n\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(\n        new BufferAttribute(inverseBindMatrices, 16),\n      ),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint),\n    });\n\n    const skinIndex = (node.skin = json.skins.length - 1);\n\n    return skinIndex;\n  }\n\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n\n    if (!json.nodes) json.nodes = [];\n\n    const nodeDef = {};\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n\n    // We don't export empty strings name because it represents no-name in Three.js.\n    if (object.name !== '') nodeDef.name = String(object.name);\n\n    this.serializeUserData(object, nodeDef);\n\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n\n    if (object.isSkinnedMesh) this.skins.push(object);\n\n    if (object.children.length > 0) {\n      const children = [];\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child);\n\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children;\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n\n    const sceneDef = {};\n\n    if (scene.name !== '') sceneDef.name = scene.name;\n\n    json.scenes.push(sceneDef);\n\n    const nodes = [];\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n\n    this.serializeUserData(scene, sceneDef);\n  }\n\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n\n    this.processScene(scene);\n  }\n\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n\n    input = input instanceof Array ? input : [input];\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n\n    const objectsWithoutScene = [];\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n\n    if (objectsWithoutScene.length > 0)\n      this.processObjects(objectsWithoutScene);\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n\n    if (\n      !light.isDirectionalLight &&\n      !light.isPointLight &&\n      !light.isSpotLight\n    ) {\n      console.warn(\n        'THREE.GLTFExporter: Only directional, point, and spot lights are supported.',\n        light,\n      );\n      return;\n    }\n\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n\n    const lightDef = {};\n\n    if (light.name) lightDef.name = light.name;\n\n    lightDef.color = light.color.toArray();\n\n    lightDef.intensity = light.intensity;\n\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light.isPointLight) {\n      lightDef.type = 'point';\n\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot';\n\n      if (light.distance > 0) lightDef.range = light.distance;\n\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle =\n        (light.penumbra - 1.0) * light.angle * -1.0;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn(\n        'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' +\n          'and expects light.decay=2.',\n      );\n    }\n\n    if (\n      light.target &&\n      (light.target.parent !== light ||\n        light.target.position.x !== 0 ||\n        light.target.position.y !== 0 ||\n        light.target.position.z !== -1)\n    ) {\n      console.warn(\n        'THREE.GLTFExporter: Light direction may be lost. For best results, ' +\n          'make light.target a child of the light with position 0,0,-1.',\n      );\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = { lights: [] };\n      extensionsUsed[this.name] = true;\n    }\n\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = { light: lights.length - 1 };\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n\n    extensionsUsed[this.name] = true;\n\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\nclass GLTFMaterialsPBRSpecularGlossiness {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n\n    const extensionDef = {};\n\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n      extensionDef.diffuseFactor =\n        materialDef.pbrMetallicRoughness.baseColorFactor;\n    }\n\n    const specularFactor = [1, 1, 1];\n    material.specular.toArray(specularFactor, 0);\n    extensionDef.specularFactor = specularFactor;\n    extensionDef.glossinessFactor = material.glossiness;\n\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n      extensionDef.diffuseTexture =\n        materialDef.pbrMetallicRoughness.baseColorTexture;\n    }\n\n    if (material.specularMap) {\n      const specularMapDef = {\n        index: writer.processTexture(material.specularMap),\n      };\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\n      extensionDef.specularGlossinessTexture = specularMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n\n    const extensionDef = {};\n\n    extensionDef.transmissionFactor = material.transmission;\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n      };\n      writer.applyTextureTransform(\n        transmissionMapDef,\n        material.transmissionMap,\n      );\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.thickness === 0) return;\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n\n    const extensionDef = {};\n\n    extensionDef.thicknessFactor = material.thickness;\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationTint.toArray();\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n    const valueSize = track.getValueSize();\n\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(\n      new track.ValueBufferType(valueSize),\n    );\n\n    let index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n\n      times[0] = time;\n      times.set(track.times, 1);\n\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(\n            track.values.slice((i + 1) * valueSize),\n            (i + 2) * valueSize,\n          );\n\n          index = i + 1;\n\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n\n    return index;\n  },\n\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(\n        sourceTrack.name,\n      );\n      const sourceTrackNode = PropertyBinding.findNode(\n        root,\n        sourceTrackBinding.nodeName,\n      );\n\n      if (\n        sourceTrackBinding.propertyName !== 'morphTargetInfluences' ||\n        sourceTrackBinding.propertyIndex === undefined\n      ) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if (\n        sourceTrack.createInterpolant !==\n          sourceTrack.InterpolantFactoryMethodDiscrete &&\n        sourceTrack.createInterpolant !==\n          sourceTrack.InterpolantFactoryMethodLinear\n      ) {\n        if (\n          sourceTrack.createInterpolant\n            .isInterpolantFactoryMethodGLTFCubicSpline\n        ) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error(\n            'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.',\n          );\n        }\n\n        console.warn(\n          'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.',\n        );\n\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex =\n        sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === undefined) {\n        throw new Error(\n          'THREE.GLTFExporter: Morph target name not found: ' +\n            sourceTrackBinding.propertyIndex,\n        );\n      }\n\n      let mergedTrack;\n\n      // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone();\n\n        const values = new mergedTrack.ValueBufferType(\n          targetCount * mergedTrack.times.length,\n        );\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n\n        // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n        mergedTrack.name =\n          (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n\n        continue;\n      }\n\n      const sourceInterpolant = sourceTrack.createInterpolant(\n        new sourceTrack.ValueBufferType(1),\n      );\n\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n\n      // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] =\n          sourceInterpolant.evaluate(mergedTrack.times[j]);\n      }\n\n      // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(\n          mergedTrack,\n          sourceTrack.times[j],\n        );\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] =\n          sourceTrack.values[j];\n      }\n    }\n\n    clip.tracks = tracks;\n\n    return clip;\n  },\n};\n\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param object {THREE.Object3D}\n * @return {boolean}\n */\nconst compatibleObject = (object) => {\n  // @TODO: Need properer variantMaterials format validation?\n  return (\n    object.material !== undefined && // easier than (!object.isMesh && !object.isLine &&\n    // !object.isPoints)\n    object.userData && // just in case\n    object.userData.variantMaterials &&\n    // Is this line costly?\n    !!Array.from(object.userData.variantMaterials.values()).filter((m) =>\n      compatibleMaterial(m.material),\n    )\n  );\n};\n/**\n * @param material {THREE.Material}\n * @return {boolean}\n */\nconst compatibleMaterial = (material) => {\n  // @TODO: support multi materials?\n  return material && material.isMaterial && !Array.isArray(material);\n};\nclass GLTFExporterMaterialsVariantsExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_variants';\n    this.variantNames = [];\n  }\n  beforeParse(objects) {\n    // Find all variant names and store them to the table\n    const variantNameSet = new Set();\n    for (const object of objects) {\n      object.traverse((o) => {\n        if (!compatibleObject(o)) {\n          return;\n        }\n        const variantMaterials = o.userData.variantMaterials;\n        for (const variantName of variantMaterials.keys()) {\n          const variantMaterial = variantMaterials.get(variantName);\n          // Ignore unloaded variant materials\n          if (compatibleMaterial(variantMaterial.material)) {\n            variantNameSet.add(variantName);\n          }\n        }\n      });\n    }\n    // We may want to sort?\n    variantNameSet.forEach((name) => this.variantNames.push(name));\n  }\n  writeMesh(mesh, meshDef) {\n    if (!compatibleObject(mesh)) {\n      return;\n    }\n    const userData = mesh.userData;\n    const variantMaterials = userData.variantMaterials;\n    const mappingTable = new Map();\n    for (const variantName of variantMaterials.keys()) {\n      const variantMaterialInstance =\n        variantMaterials.get(variantName).material;\n      if (!compatibleMaterial(variantMaterialInstance)) {\n        continue;\n      }\n      const variantIndex = this.variantNames.indexOf(variantName); // Shouldn't be -1\n      const materialIndex = this.writer.processMaterial(\n        variantMaterialInstance,\n      );\n      if (!mappingTable.has(materialIndex)) {\n        mappingTable.set(materialIndex, {\n          material: materialIndex,\n          variants: [],\n        });\n      }\n      mappingTable.get(materialIndex).variants.push(variantIndex);\n    }\n    const mappingsDef = Array.from(mappingTable.values())\n      .map((m) => {\n        return m.variants.sort((a, b) => a - b) && m;\n      })\n      .sort((a, b) => a.material - b.material);\n    if (mappingsDef.length === 0) {\n      return;\n    }\n    const originalMaterialIndex = compatibleMaterial(userData.originalMaterial)\n      ? this.writer.processMaterial(userData.originalMaterial)\n      : -1;\n    for (const primitiveDef of meshDef.primitives) {\n      // Override primitiveDef.material with original material.\n      if (originalMaterialIndex >= 0) {\n        primitiveDef.material = originalMaterialIndex;\n      }\n      primitiveDef.extensions = primitiveDef.extensions || {};\n      primitiveDef.extensions[this.name] = { mappings: mappingsDef };\n    }\n  }\n  afterParse() {\n    if (this.variantNames.length === 0) {\n      return;\n    }\n    const root = this.writer.json;\n    root.extensions = root.extensions || {};\n    const variantsDef = this.variantNames.map((n) => {\n      return { name: n };\n    });\n    root.extensions[this.name] = { variants: variantsDef };\n    this.writer.extensionsUsed[this.name] = true;\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst $correlatedObjects = Symbol('correlatedObjects');\nconst $sourceObject = Symbol('sourceObject');\nconst $onUpdate = Symbol('onUpdate');\n/**\n * A SerializableThreeDOMElement is the common primitive of all scene graph\n * elements that have been facaded in the host execution context. It adds\n * a common interface to these elements in support of convenient\n * serializability.\n */\nclass ThreeDOMElement {\n  constructor(onUpdate, element, correlatedObjects = null) {\n    this[$onUpdate] = onUpdate;\n    this[$sourceObject] = element;\n    this[$correlatedObjects] = correlatedObjects;\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst loader = new ImageLoader();\nconst quadMaterial = new MeshBasicMaterial();\nconst quad = new PlaneGeometry(2, 2);\nconst $threeTexture = Symbol('threeTexture');\n/**\n * Image facade implementation for Three.js textures\n */\nclass Image$1 extends ThreeDOMElement {\n  get [$threeTexture]() {\n    var _a;\n    console.assert(\n      this[$correlatedObjects] != null && this[$correlatedObjects].size > 0,\n      'Image correlated object is undefined',\n    );\n    return (_a = this[$correlatedObjects]) === null || _a === void 0\n      ? void 0\n      : _a.values().next().value;\n  }\n  constructor(onUpdate, texture, gltfImage) {\n    gltfImage =\n      gltfImage !== null && gltfImage !== void 0\n        ? gltfImage\n        : {\n            name: 'adhoc_image',\n            uri: texture && texture.image ? texture.image.src : 'adhoc_image',\n          };\n    super(onUpdate, gltfImage, new Set(texture ? [texture] : []));\n  }\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n  get uri() {\n    return this[$sourceObject].uri;\n  }\n  get bufferView() {\n    return this[$sourceObject].bufferView;\n  }\n  get type() {\n    return this.uri != null ? 'external' : 'embedded';\n  }\n  async setURI(uri) {\n    this[$sourceObject].uri = uri;\n    const image = await new Promise((resolve, reject) => {\n      loader.load(uri, resolve, undefined, reject);\n    });\n    const texture = this[$threeTexture];\n    texture.image = image;\n    texture.needsUpdate = true;\n    this[$onUpdate]();\n  }\n  async createThumbnail(width, height) {\n    const scene = new Scene();\n    quadMaterial.map = this[$threeTexture];\n    const mesh = new Mesh(quad, quadMaterial);\n    scene.add(mesh);\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const { threeRenderer } = Renderer.singleton;\n    const renderTarget = new WebGLRenderTarget(width, height);\n    threeRenderer.setRenderTarget(renderTarget);\n    threeRenderer.render(scene, camera);\n    threeRenderer.setRenderTarget(null);\n    const buffer = new Uint8Array(width * height * 4);\n    threeRenderer.readRenderTargetPixels(\n      renderTarget,\n      0,\n      0,\n      width,\n      height,\n      buffer,\n    );\n    blobCanvas.width = width;\n    blobCanvas.height = height;\n    const blobContext = blobCanvas.getContext('2d');\n    const imageData = blobContext.createImageData(width, height);\n    imageData.data.set(buffer);\n    blobContext.putImageData(imageData, 0, 0);\n    return new Promise(async (resolve, reject) => {\n      blobCanvas.toBlob((blob) => {\n        if (!blob) {\n          return reject('Failed to capture thumbnail.');\n        }\n        resolve(URL.createObjectURL(blob));\n      }, 'image/png');\n    });\n  }\n}\n\nvar Filter;\n(function (Filter) {\n  Filter[(Filter['Nearest'] = 9728)] = 'Nearest';\n  Filter[(Filter['Linear'] = 9729)] = 'Linear';\n  Filter[(Filter['NearestMipmapNearest'] = 9984)] = 'NearestMipmapNearest';\n  Filter[(Filter['LinearMipmapNearest'] = 9985)] = 'LinearMipmapNearest';\n  Filter[(Filter['NearestMipmapLinear'] = 9986)] = 'NearestMipmapLinear';\n  Filter[(Filter['LinearMipmapLinear'] = 9987)] = 'LinearMipmapLinear';\n})(Filter || (Filter = {}));\nvar Wrap;\n(function (Wrap) {\n  Wrap[(Wrap['ClampToEdge'] = 33071)] = 'ClampToEdge';\n  Wrap[(Wrap['MirroredRepeat'] = 33648)] = 'MirroredRepeat';\n  Wrap[(Wrap['Repeat'] = 10497)] = 'Repeat';\n})(Wrap || (Wrap = {}));\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst isMinFilter = (() => {\n  const minFilterValues = [\n    Filter.Nearest,\n    Filter.Linear,\n    Filter.NearestMipmapNearest,\n    Filter.LinearMipmapLinear,\n    Filter.NearestMipmapLinear,\n    Filter.LinearMipmapLinear,\n  ];\n  return (value) => minFilterValues.indexOf(value) > -1;\n})();\nconst isMagFilter = (() => {\n  const magFilterValues = [Filter.Nearest, Filter.Linear];\n  return (value) => magFilterValues.indexOf(value) > -1;\n})();\nconst isWrapMode = (() => {\n  const wrapModes = [Wrap.ClampToEdge, Wrap.MirroredRepeat, Wrap.Repeat];\n  return (value) => wrapModes.indexOf(value) > -1;\n})();\nconst isValidSamplerValue = (property, value) => {\n  switch (property) {\n    case 'minFilter':\n      return isMinFilter(value);\n    case 'magFilter':\n      return isMagFilter(value);\n    case 'wrapS':\n    case 'wrapT':\n      return isWrapMode(value);\n    default:\n      throw new Error(`Cannot configure property \"${property}\" on Sampler`);\n  }\n};\nconst $threeTextures = Symbol('threeTextures');\nconst $setProperty = Symbol('setProperty');\nconst $sourceSampler = Symbol('sourceSampler');\n/**\n * Sampler facade implementation for Three.js textures\n */\nclass Sampler extends ThreeDOMElement {\n  get [$threeTextures]() {\n    console.assert(\n      this[$correlatedObjects] != null && this[$correlatedObjects].size > 0,\n      'Sampler correlated object is undefined',\n    );\n    return this[$correlatedObjects];\n  }\n  get [$sourceSampler]() {\n    console.assert(this[$sourceObject] != null, 'Sampler source is undefined');\n    return this[$sourceObject];\n  }\n  constructor(onUpdate, texture, gltfSampler) {\n    gltfSampler =\n      gltfSampler !== null && gltfSampler !== void 0 ? gltfSampler : {};\n    // These defaults represent a convergence of glTF defaults for wrap mode and\n    // Three.js defaults for filters. Per glTF 2.0 spec, a renderer may choose\n    // its own defaults for filters.\n    // @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-sampler\n    // @see https://threejs.org/docs/#api/en/textures/Texture\n    if (gltfSampler.minFilter == null) {\n      gltfSampler.minFilter = texture\n        ? texture.minFilter\n        : Filter.LinearMipmapLinear;\n    }\n    if (gltfSampler.magFilter == null) {\n      gltfSampler.magFilter = texture ? texture.magFilter : Filter.Linear;\n    }\n    if (gltfSampler.wrapS == null) {\n      gltfSampler.wrapS = texture ? texture.wrapS : Wrap.Repeat;\n    }\n    if (gltfSampler.wrapT == null) {\n      gltfSampler.wrapT = texture ? texture.wrapT : Wrap.Repeat;\n    }\n    super(onUpdate, gltfSampler, new Set(texture ? [texture] : []));\n  }\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n  get minFilter() {\n    return this[$sourceSampler].minFilter;\n  }\n  get magFilter() {\n    return this[$sourceSampler].magFilter;\n  }\n  get wrapS() {\n    return this[$sourceSampler].wrapS;\n  }\n  get wrapT() {\n    return this[$sourceSampler].wrapT;\n  }\n  setMinFilter(filter) {\n    this[$setProperty]('minFilter', filter);\n  }\n  setMagFilter(filter) {\n    this[$setProperty]('magFilter', filter);\n  }\n  setWrapS(mode) {\n    this[$setProperty]('wrapS', mode);\n  }\n  setWrapT(mode) {\n    this[$setProperty]('wrapT', mode);\n  }\n  [$setProperty](property, value) {\n    const sampler = this[$sourceSampler];\n    if (sampler != null) {\n      if (isValidSamplerValue(property, value)) {\n        sampler[property] = value;\n        for (const texture of this[$threeTextures]) {\n          texture[property] = value;\n          texture.needsUpdate = true;\n        }\n      }\n      this[$onUpdate]();\n    }\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst $image = Symbol('image');\nconst $sampler = Symbol('sampler');\n/**\n * Material facade implementation for Three.js materials\n */\nclass Texture extends ThreeDOMElement {\n  constructor(\n    onUpdate,\n    threeTexture,\n    gltfTexture = null,\n    gltfSampler = null,\n    gltfImage = null,\n  ) {\n    super(\n      onUpdate,\n      gltfTexture ? gltfTexture : {},\n      new Set(threeTexture ? [threeTexture] : []),\n    );\n    this[$sampler] = new Sampler(onUpdate, threeTexture, gltfSampler);\n    this[$image] = new Image$1(onUpdate, threeTexture, gltfImage);\n  }\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n  get sampler() {\n    return this[$sampler];\n  }\n  get source() {\n    return this[$image];\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a$2;\nconst $texture = Symbol('texture');\nconst $materials$2 = Symbol('materials');\nconst $usage = Symbol('usage');\n// Defines what a texture will be used for.\nvar TextureUsage;\n(function (TextureUsage) {\n  TextureUsage[(TextureUsage['Base'] = 0)] = 'Base';\n  TextureUsage[(TextureUsage['MetallicRoughness'] = 1)] = 'MetallicRoughness';\n  TextureUsage[(TextureUsage['Normal'] = 2)] = 'Normal';\n  TextureUsage[(TextureUsage['Occlusion'] = 3)] = 'Occlusion';\n  TextureUsage[(TextureUsage['Emissive'] = 4)] = 'Emissive';\n})(TextureUsage || (TextureUsage = {}));\n/**\n * TextureInfo facade implementation for Three.js materials\n */\nclass TextureInfo {\n  constructor(onUpdate, usage, threeTexture, material, gltf, gltfTextureInfo) {\n    this[_a$2] = null;\n    // Creates image, sampler, and texture if valid texture info is provided.\n    if (gltfTextureInfo) {\n      const gltfTexture = gltf.textures\n        ? gltf.textures[gltfTextureInfo.index]\n        : null;\n      const sampler = gltfTexture\n        ? gltf.samplers\n          ? gltf.samplers[gltfTexture.sampler]\n          : null\n        : null;\n      const image = gltfTexture\n        ? gltf.images\n          ? gltf.images[gltfTexture.source]\n          : null\n        : null;\n      this[$texture] = new Texture(\n        onUpdate,\n        threeTexture,\n        gltfTexture,\n        sampler,\n        image,\n      );\n    }\n    this.onUpdate = onUpdate;\n    this[$materials$2] = material;\n    this[$usage] = usage;\n  }\n  get texture() {\n    return this[$texture];\n  }\n  setTexture(texture) {\n    const threeTexture = texture != null ? texture.source[$threeTexture] : null;\n    let encoding = sRGBEncoding;\n    this[$texture] = texture;\n    if (this[$materials$2]) {\n      for (const material of this[$materials$2]) {\n        switch (this[$usage]) {\n          case TextureUsage.Base:\n            material.map = threeTexture;\n            break;\n          case TextureUsage.MetallicRoughness:\n            encoding = LinearEncoding;\n            material.metalnessMap = threeTexture;\n            material.roughnessMap = threeTexture;\n            break;\n          case TextureUsage.Normal:\n            encoding = LinearEncoding;\n            material.normalMap = threeTexture;\n            break;\n          case TextureUsage.Occlusion:\n            encoding = LinearEncoding;\n            material.aoMap = threeTexture;\n            break;\n          case TextureUsage.Emissive:\n            material.emissiveMap = threeTexture;\n            break;\n        }\n        material.needsUpdate = true;\n      }\n    }\n    if (threeTexture) {\n      // Updates the encoding for the texture, affects all references.\n      threeTexture.encoding = encoding;\n    }\n    this.onUpdate();\n  }\n}\n_a$2 = $texture;\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst $threeMaterials = Symbol('threeMaterials');\nconst $baseColorTexture = Symbol('baseColorTexture');\nconst $metallicRoughnessTexture = Symbol('metallicRoughnessTexture');\n/**\n * PBR material properties facade implementation for Three.js materials\n */\nclass PBRMetallicRoughness extends ThreeDOMElement {\n  constructor(onUpdate, gltf, pbrMetallicRoughness, correlatedMaterials) {\n    super(onUpdate, pbrMetallicRoughness, correlatedMaterials);\n    // Assign glTF default values\n    if (pbrMetallicRoughness.baseColorFactor == null) {\n      pbrMetallicRoughness.baseColorFactor = [1, 1, 1, 1];\n    }\n    if (pbrMetallicRoughness.roughnessFactor == null) {\n      pbrMetallicRoughness.roughnessFactor = 1;\n    }\n    if (pbrMetallicRoughness.metallicFactor == null) {\n      pbrMetallicRoughness.metallicFactor = 1;\n    }\n    const {\n      baseColorTexture: gltfBaseColorTexture,\n      metallicRoughnessTexture: gltfMetallicRoughnessTexture,\n    } = pbrMetallicRoughness;\n    const { map, metalnessMap } = correlatedMaterials.values().next().value;\n    this[$baseColorTexture] = new TextureInfo(\n      onUpdate,\n      TextureUsage.Base,\n      map,\n      correlatedMaterials,\n      gltf,\n      gltfBaseColorTexture ? gltfBaseColorTexture : null,\n    );\n    this[$metallicRoughnessTexture] = new TextureInfo(\n      onUpdate,\n      TextureUsage.MetallicRoughness,\n      metalnessMap,\n      correlatedMaterials,\n      gltf,\n      gltfMetallicRoughnessTexture ? gltfMetallicRoughnessTexture : null,\n    );\n  }\n  get [$threeMaterials]() {\n    return this[$correlatedObjects];\n  }\n  get baseColorFactor() {\n    return this[$sourceObject].baseColorFactor;\n  }\n  get metallicFactor() {\n    return this[$sourceObject].metallicFactor;\n  }\n  get roughnessFactor() {\n    return this[$sourceObject].roughnessFactor;\n  }\n  get baseColorTexture() {\n    return this[$baseColorTexture];\n  }\n  get metallicRoughnessTexture() {\n    return this[$metallicRoughnessTexture];\n  }\n  setBaseColorFactor(rgba) {\n    for (const material of this[$threeMaterials]) {\n      material.color.fromArray(rgba);\n      material.opacity = rgba[3];\n    }\n    const pbrMetallicRoughness = this[$sourceObject];\n    pbrMetallicRoughness.baseColorFactor = rgba;\n    this[$onUpdate]();\n  }\n  setMetallicFactor(value) {\n    for (const material of this[$threeMaterials]) {\n      material.metalness = value;\n    }\n    const pbrMetallicRoughness = this[$sourceObject];\n    pbrMetallicRoughness.metallicFactor = value;\n    this[$onUpdate]();\n  }\n  setRoughnessFactor(value) {\n    for (const material of this[$threeMaterials]) {\n      material.roughness = value;\n    }\n    const pbrMetallicRoughness = this[$sourceObject];\n    pbrMetallicRoughness.roughnessFactor = value;\n    this[$onUpdate]();\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');\nconst $normalTexture = Symbol('normalTexture');\nconst $occlusionTexture = Symbol('occlusionTexture');\nconst $emissiveTexture = Symbol('emissiveTexture');\nconst $backingThreeMaterial = Symbol('backingThreeMaterial');\nconst $applyAlphaCutoff = Symbol('applyAlphaCutoff');\nconst $lazyLoadGLTFInfo = Symbol('lazyLoadGLTFInfo');\nconst $initialize = Symbol('initialize');\nconst $getLoadedMaterial = Symbol('getLoadedMaterial');\nconst $ensureMaterialIsLoaded = Symbol('ensureMaterialIsLoaded');\n/**\n * Material facade implementation for Three.js materials\n */\nclass Material extends ThreeDOMElement {\n  constructor(\n    onUpdate,\n    gltf,\n    gltfMaterial,\n    correlatedMaterials,\n    lazyLoadInfo = undefined,\n  ) {\n    super(onUpdate, gltfMaterial, correlatedMaterials);\n    if (lazyLoadInfo == null) {\n      this[$initialize](gltf);\n    } else {\n      this[$lazyLoadGLTFInfo] = lazyLoadInfo;\n    }\n  }\n  get [$backingThreeMaterial]() {\n    return this[$correlatedObjects].values().next().value;\n  }\n  [$initialize](gltf) {\n    const onUpdate = this[$onUpdate];\n    const gltfMaterial = this[$sourceObject];\n    const correlatedMaterials = this[$correlatedObjects];\n    if (\n      gltfMaterial.extensions &&\n      gltfMaterial.extensions['KHR_materials_pbrSpecularGlossiness']\n    ) {\n      console.warn(`Material ${gltfMaterial.name} uses a deprecated extension\n          \"KHR_materials_pbrSpecularGlossiness\", please use\n          \"pbrMetallicRoughness\" instead. Specular Glossiness materials are\n          currently supported for rendering, but not for our scene-graph API,\n          nor for auto-generation of USDZ for Quick Look.`);\n    }\n    if (gltfMaterial.pbrMetallicRoughness == null) {\n      gltfMaterial.pbrMetallicRoughness = {};\n    }\n    this[$pbrMetallicRoughness] = new PBRMetallicRoughness(\n      onUpdate,\n      gltf,\n      gltfMaterial.pbrMetallicRoughness,\n      correlatedMaterials,\n    );\n    if (gltfMaterial.emissiveFactor == null) {\n      gltfMaterial.emissiveFactor = [0, 0, 0];\n    }\n    if (gltfMaterial.doubleSided == null) {\n      gltfMaterial.doubleSided = false;\n    }\n    if (gltfMaterial.alphaMode == null) {\n      gltfMaterial.alphaMode = 'OPAQUE';\n    }\n    if (gltfMaterial.alphaCutoff == null) {\n      gltfMaterial.alphaCutoff = 0.5;\n    }\n    const {\n      normalTexture: gltfNormalTexture,\n      occlusionTexture: gltfOcculsionTexture,\n      emissiveTexture: gltfEmissiveTexture,\n    } = gltfMaterial;\n    const { normalMap, aoMap, emissiveMap } = correlatedMaterials\n      .values()\n      .next().value;\n    this[$normalTexture] = new TextureInfo(\n      onUpdate,\n      TextureUsage.Normal,\n      normalMap,\n      correlatedMaterials,\n      gltf,\n      gltfNormalTexture ? gltfNormalTexture : null,\n    );\n    this[$occlusionTexture] = new TextureInfo(\n      onUpdate,\n      TextureUsage.Occlusion,\n      aoMap,\n      correlatedMaterials,\n      gltf,\n      gltfOcculsionTexture ? gltfOcculsionTexture : null,\n    );\n    this[$emissiveTexture] = new TextureInfo(\n      onUpdate,\n      TextureUsage.Emissive,\n      emissiveMap,\n      correlatedMaterials,\n      gltf,\n      gltfEmissiveTexture ? gltfEmissiveTexture : null,\n    );\n  }\n  async [$getLoadedMaterial]() {\n    if (this[$lazyLoadGLTFInfo] != null) {\n      const { set, material } = await this[$lazyLoadGLTFInfo].doLazyLoad();\n      // Fills in the missing data.\n      this[$correlatedObjects] = set;\n      this[$initialize](this[$lazyLoadGLTFInfo].gltf);\n      // Releases lazy load info.\n      this[$lazyLoadGLTFInfo] = undefined;\n      // Redefines the method as a noop method.\n      this.ensureLoaded = async () => {};\n      return material;\n    }\n    return this[$correlatedObjects].values().next().value;\n  }\n  [$ensureMaterialIsLoaded]() {\n    if (this[$lazyLoadGLTFInfo] == null) {\n      return;\n    }\n    throw new Error(`Material \"${this.name}\" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`);\n  }\n  async ensureLoaded() {\n    await this[$getLoadedMaterial]();\n  }\n  get isLoaded() {\n    return this[$lazyLoadGLTFInfo] == null;\n  }\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n  get pbrMetallicRoughness() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrMetallicRoughness];\n  }\n  get normalTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$normalTexture];\n  }\n  get occlusionTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$occlusionTexture];\n  }\n  get emissiveTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$emissiveTexture];\n  }\n  get emissiveFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$sourceObject].emissiveFactor;\n  }\n  setEmissiveFactor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.emissive.fromArray(rgb);\n    }\n    this[$sourceObject].emissiveFactor = rgb;\n    this[$onUpdate]();\n  }\n  [$applyAlphaCutoff]() {\n    this[$ensureMaterialIsLoaded]();\n    const gltfMaterial = this[$sourceObject];\n    for (const material of this[$correlatedObjects]) {\n      material.alphaTest = gltfMaterial.alphaCutoff;\n      material.needsUpdate = true;\n    }\n  }\n  setAlphaCutoff(cutoff) {\n    this[$ensureMaterialIsLoaded]();\n    this[$sourceObject].alphaCutoff = cutoff;\n    this[$applyAlphaCutoff]();\n    this[$onUpdate]();\n  }\n  getAlphaCutoff() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$sourceObject].alphaCutoff;\n  }\n  setDoubleSided(doubleSided) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      // When double-sided is disabled gltf spec dictates that Back-Face culling\n      // must be disabled, in three.js parlance that would mean FrontSide\n      // rendering only.\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided\n      material.side = doubleSided ? DoubleSide : FrontSide;\n      material.needsUpdate = true;\n    }\n    this[$sourceObject].doubleSided = doubleSided;\n    this[$onUpdate]();\n  }\n  getDoubleSided() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$sourceObject].doubleSided;\n  }\n  setAlphaMode(alphaMode) {\n    this[$ensureMaterialIsLoaded]();\n    const enableTransparency = (material, enabled) => {\n      material.transparent = enabled;\n      material.depthWrite = !enabled;\n    };\n    this[$sourceObject].alphaMode = alphaMode;\n    for (const material of this[$correlatedObjects]) {\n      enableTransparency(material, alphaMode !== 'OPAQUE');\n      this[$applyAlphaCutoff]();\n      material.needsUpdate = true;\n    }\n    this[$onUpdate]();\n  }\n  getAlphaMode() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$sourceObject].alphaMode;\n  }\n}\n\nvar _a$1, _b$1;\nconst $materials$1 = Symbol('materials');\nconst $variantInfo = Symbol('variantInfo');\nconst $mesh = Symbol('mesh');\nconst $children = Symbol('children');\nconst $initialMaterialIdx = Symbol('initialMaterialIdx');\nconst $activeMaterialIdx = Symbol('activeMaterialIdx');\n// Defines the base level node methods and data.\nclass Node$1 {\n  constructor(name) {\n    this.name = '';\n    this[_a$1] = new Array();\n    this.name = name;\n  }\n}\n_a$1 = $children;\n// Represents a primitive in a glTF mesh.\nclass PrimitiveNode extends Node$1 {\n  constructor(mesh, mvMaterials, correlatedSceneGraph) {\n    super(mesh.name);\n    // Maps glTF material index number to a material that this primitive supports.\n    this[_b$1] = new Map();\n    this[$mesh] = mesh;\n    const { gltf, threeGLTF, threeObjectMap } = correlatedSceneGraph;\n    // Captures the primitive's initial material.\n    const materialMappings = threeObjectMap.get(mesh.material);\n    if (materialMappings.materials != null) {\n      this[$initialMaterialIdx] = this[$activeMaterialIdx] =\n        materialMappings.materials;\n    } else {\n      console.error(\n        `Primitive (${mesh.name}) missing initial material reference.`,\n      );\n    }\n    // Gets the mesh index from the node.\n    const meshMappings = threeObjectMap.get(mesh);\n    const meshIndex = meshMappings.meshes;\n    // The gltf mesh array to sample from.\n    const meshElementArray = gltf['meshes'] || [];\n    // List of primitives under the mesh.\n    const gltfPrimitives = meshElementArray[meshIndex].primitives || [];\n    for (const primitive of gltfPrimitives) {\n      // Maps the primitive default to a material.\n      if (primitive.material != null) {\n        this[$materials$1].set(\n          primitive.material,\n          mvMaterials[primitive.material],\n        );\n      } else {\n        const defaultIdx = mvMaterials.findIndex((mat) => {\n          return mat.name === 'Default';\n        });\n        if (defaultIdx >= 0) {\n          this[$materials$1].set(defaultIdx, mvMaterials[defaultIdx]);\n        } else {\n          console.warn('Primitive has no material!');\n        }\n      }\n      if (\n        primitive.extensions &&\n        primitive.extensions['KHR_materials_variants']\n      ) {\n        const variantsExtension =\n          primitive.extensions['KHR_materials_variants'];\n        const extensions = threeGLTF.parser.json.extensions;\n        const variantNames = extensions['KHR_materials_variants'].variants;\n        // Provides definition now that we know there are variants to\n        // support.\n        this[$variantInfo] = new Map();\n        for (const mapping of variantsExtension.mappings) {\n          // Maps variant indices to Materials.\n          this[$materials$1].set(\n            mapping.material,\n            mvMaterials[mapping.material],\n          );\n          for (const variant of mapping.variants) {\n            const { name } = variantNames[variant];\n            this[$variantInfo].set(name, {\n              material: mvMaterials[mapping.material],\n              index: mapping.material,\n            });\n          }\n        }\n      }\n    }\n  }\n  get mesh() {\n    return this[$mesh];\n  }\n  async setActiveMaterial(material) {\n    const mvMaterial = this[$materials$1].get(material);\n    if (mvMaterial != null) {\n      this.mesh.material = await mvMaterial[$getLoadedMaterial]();\n      this[$activeMaterialIdx] = material;\n    }\n    return this.mesh.material;\n  }\n  getActiveMaterial() {\n    return this[$materials$1].get(this[$activeMaterialIdx]);\n  }\n  async enableVariant(name) {\n    if (name == null) {\n      return this.setActiveMaterial(this[$initialMaterialIdx]);\n    }\n    if (this[$variantInfo] != null) {\n      const material = this[$variantInfo].get(name);\n      if (material != null) {\n        return this.setActiveMaterial(material.index);\n      }\n    }\n    return null;\n  }\n  async instantiateVariants() {\n    if (this[$variantInfo] == null) {\n      return;\n    }\n    for (const name of this[$variantInfo].keys()) {\n      if (this.mesh.userData.variantMaterials.get(name).material != null) {\n        continue;\n      }\n      const threeMaterial = await this.enableVariant(name);\n      if (threeMaterial != null) {\n        this.mesh.userData.variantMaterials.get(name).material = threeMaterial;\n      }\n    }\n  }\n  get variantInfo() {\n    return this[$variantInfo];\n  }\n}\n_b$1 = $materials$1;\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d;\nconst $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nconst $primitives = Symbol('primitives');\nconst $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nconst $switchVariant = Symbol('switchVariant');\nconst $threeScene = Symbol('threeScene');\nconst $materialsFromPoint = Symbol('materialsFromPoint');\nconst $materialFromPoint = Symbol('materialFromPoint');\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nclass LazyLoader {\n  constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {\n    this.gltf = gltf;\n    this.gltfElementMap = gltfElementMap;\n    this.mapKey = mapKey;\n    this.doLazyLoad = doLazyLoad;\n  }\n}\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nclass Model {\n  constructor(correlatedSceneGraph, onUpdate = () => {}) {\n    this[_a] = new Array();\n    this[_b] = new Array();\n    this[_c] = new Array();\n    this[_d] = new Array();\n    const { gltf, threeGLTF, gltfElementMap } = correlatedSceneGraph;\n    this[$threeScene] = threeGLTF.scene;\n    for (const [i, material] of gltf.materials.entries()) {\n      const correlatedMaterial = gltfElementMap.get(material);\n      if (correlatedMaterial != null) {\n        this[$materials].push(\n          new Material(onUpdate, gltf, material, correlatedMaterial),\n        );\n      } else {\n        const elementArray = gltf['materials'] || [];\n        const gltfMaterialDef = elementArray[i];\n        // Loads the three.js material.\n        const capturedMatIndex = i;\n        const materialLoadCallback = async () => {\n          const threeMaterial = await threeGLTF.parser.getDependency(\n            'material',\n            capturedMatIndex,\n          );\n          // Adds correlation, maps the variant gltf-def to the\n          // three material set containing the variant material.\n          const threeMaterialSet = new Set();\n          gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n          threeMaterialSet.add(threeMaterial);\n          return { set: threeMaterialSet, material: threeMaterial };\n        };\n        // Configures the material for lazy loading.\n        this[$materials].push(\n          new Material(\n            onUpdate,\n            gltf,\n            gltfMaterialDef,\n            correlatedMaterial,\n            new LazyLoader(\n              gltf,\n              gltfElementMap,\n              gltfMaterialDef,\n              materialLoadCallback,\n            ),\n          ),\n        );\n      }\n    }\n    // Creates a hierarchy of Nodes. Allows not just for switching which\n    // material is applied to a mesh but also exposes a way to provide API\n    // for switching materials and general assignment/modification.\n    // Prepares for scene iteration.\n    const parentMap = new Map();\n    const nodeStack = new Array();\n    for (const object of threeGLTF.scene.children) {\n      nodeStack.push(object);\n    }\n    // Walks the hierarchy and creates a node tree.\n    while (nodeStack.length > 0) {\n      const object = nodeStack.pop();\n      let node = null;\n      if (object instanceof Mesh) {\n        node = new PrimitiveNode(object, this.materials, correlatedSceneGraph);\n        this[$primitives].push(node);\n      } else {\n        node = new Node$1(object.name);\n      }\n      const parent = parentMap.get(object);\n      if (parent != null) {\n        parent[$children].push(node);\n      } else {\n        this[$roots].push(node);\n      }\n      this[$hierarchy].push(node);\n      for (const child of object.children) {\n        nodeStack.push(child);\n        parentMap.set(object, node);\n      }\n    }\n  }\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n  get materials() {\n    return this[$materials];\n  }\n  getMaterialByName(name) {\n    const matches = this[$materials].filter((material) => {\n      return material.name === name;\n    });\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    return null;\n  }\n  /**\n   * Intersects a ray with the Model and returns a list of materials whose\n   * objects were intersected.\n   */\n  [((_a = $materials),\n  (_b = $hierarchy),\n  (_c = $roots),\n  (_d = $primitives),\n  $materialsFromPoint)](raycaster) {\n    const hits = raycaster.intersectObject(this[$threeScene], true);\n    // Map the object hits to primitives and then to the active material of\n    // the primitive.\n    return hits.map((hit) => {\n      const found = this[$hierarchy].find((node) => {\n        if (node instanceof PrimitiveNode) {\n          const primitive = node;\n          if (primitive.mesh === hit.object) {\n            return true;\n          }\n        }\n        return false;\n      });\n      if (found != null) {\n        return found.getActiveMaterial();\n      }\n      return null;\n    });\n  }\n  /**\n   * Intersects a ray with the Model and returns the first material whose\n   * object was intersected.\n   */\n  [$materialFromPoint](raycaster) {\n    const materials = this[$materialsFromPoint](raycaster);\n    if (materials.length > 0) {\n      return materials[0];\n    }\n    return null;\n  }\n  /**\n   * Switches model variant to the variant name provided, or switches to\n   * default/initial materials if 'null' is provided.\n   */\n  async [$switchVariant](variantName) {\n    const promises = new Array();\n    for (const primitive of this[$primitives]) {\n      promises.push(primitive.enableVariant(variantName));\n    }\n    await Promise.all(promises);\n  }\n  async [$prepareVariantsForExport]() {\n    const promises = new Array();\n    for (const primitive of this[$primitives]) {\n      promises.push(primitive.instantiateVariants());\n    }\n    await Promise.all(promises);\n  }\n}\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate$1 =\n  (undefined && undefined.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === 'object' && typeof undefined === 'function')\n      r = undefined(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\nconst $currentGLTF = Symbol('currentGLTF');\nconst $model = Symbol('model');\nconst $variants = Symbol('variants');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $textureLoader = Symbol('textureLoader');\nconst $originalGltfJson = Symbol('originalGltfJson');\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nconst SceneGraphMixin = (ModelViewerElement) => {\n  var _a, _b, _c, _d, _e;\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = undefined;\n      this[_b] = null;\n      this[_c] = [];\n      this[_d] = new TextureLoader();\n      this[_e] = null;\n      this.variantName = null;\n      this.orientation = '0 0 0';\n      this.scale = '1 1 1';\n    }\n    // Scene-graph API:\n    /** @export */\n    get model() {\n      return this[$model];\n    }\n    get availableVariants() {\n      return this[$variants];\n    }\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n    [((_a = $model),\n    (_b = $currentGLTF),\n    (_c = $variants),\n    (_d = $textureLoader),\n    (_e = $originalGltfJson),\n    $getOnUpdateMethod)]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n    async createTexture(uri, type = 'image/png') {\n      const currentGLTF = this[$currentGLTF];\n      const texture = await new Promise((resolve) =>\n        this[$textureLoader].load(uri, resolve),\n      );\n      if (!currentGLTF || !texture) {\n        return null;\n      }\n      // Applies default settings.\n      texture.encoding = sRGBEncoding;\n      texture.wrapS = RepeatWrapping;\n      texture.wrapT = RepeatWrapping;\n      texture.flipY = false;\n      // This hack is because GLTFExporter checks if format is RGB vs RGBA to\n      // decide if it should save as JPEG vs PNG. However, TextureLoader sets\n      // format based on if the url ends in .jpg, which does not work for an\n      // ObjectURL like we're passing here. So, to keep from inflating all JPEGs\n      // to PNGs, we allow the user of the API to specify the type.\n      if (type === 'image/jpeg') {\n        texture.format = RGBFormat;\n      }\n      return new Texture(this[$getOnUpdateMethod](), texture);\n    }\n    async updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('variantName')) {\n        const threeGLTF = this[$currentGLTF];\n        const { variantName } = this;\n        if (threeGLTF != null) {\n          await this[$model][$switchVariant](variantName);\n          this[$needsRender]();\n          this.dispatchEvent(new CustomEvent('variant-applied'));\n        }\n      }\n      if (\n        changedProperties.has('orientation') ||\n        changedProperties.has('scale')\n      ) {\n        const { modelContainer } = this[$scene];\n        const orientation = parseExpressions(this.orientation)[0].terms;\n        const roll = normalizeUnit(orientation[0]).number;\n        const pitch = normalizeUnit(orientation[1]).number;\n        const yaw = normalizeUnit(orientation[2]).number;\n        modelContainer.quaternion.setFromEuler(\n          new Euler(pitch, yaw, roll, 'YXZ'),\n        );\n        const scale = parseExpressions(this.scale)[0].terms;\n        modelContainer.scale.set(\n          scale[0].number,\n          scale[1].number,\n          scale[2].number,\n        );\n        this[$scene].updateBoundingBox();\n        this[$scene].updateShadow();\n        this[$renderer].arRenderer.onUpdateScene();\n        this[$needsRender]();\n      }\n    }\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      this[$variants] = [];\n      const { currentGLTF } = this[$scene];\n      if (currentGLTF != null) {\n        const { correlatedSceneGraph } = currentGLTF;\n        if (\n          correlatedSceneGraph != null &&\n          currentGLTF !== this[$currentGLTF]\n        ) {\n          this[$model] = new Model(\n            correlatedSceneGraph,\n            this[$getOnUpdateMethod](),\n          );\n          this[$originalGltfJson] = JSON.parse(\n            JSON.stringify(correlatedSceneGraph.gltf),\n          );\n        }\n        // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n        if ('variants' in currentGLTF.userData) {\n          this[$variants] = currentGLTF.userData.variants.slice();\n          this.requestUpdate('variantName');\n        }\n      }\n      this[$currentGLTF] = currentGLTF;\n      // TODO: remove this event, as it is synonymous with the load event.\n      this.dispatchEvent(new CustomEvent('scene-graph-ready'));\n    }\n    /** @export */\n    async exportScene(options) {\n      const scene = this[$scene];\n      return new Promise(async (resolve) => {\n        // Defaults\n        const opts = {\n          binary: true,\n          onlyVisible: true,\n          maxTextureSize: Infinity,\n          forcePowerOfTwoTextures: false,\n          includeCustomExtensions: false,\n          embedImages: true,\n        };\n        Object.assign(opts, options);\n        // Not configurable\n        opts.animations = scene.animations;\n        opts.truncateDrawRange = true;\n        const shadow = scene.shadow;\n        let visible = false;\n        // Remove shadow from export\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n        await this[$model][$prepareVariantsForExport]();\n        const exporter = new GLTFExporter().register(\n          (writer) => new GLTFExporterMaterialsVariantsExtension(writer),\n        );\n        exporter.parse(\n          scene.modelContainer.children[0],\n          (gltf) => {\n            return resolve(\n              new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {\n                type: opts.binary\n                  ? 'application/octet-stream'\n                  : 'application/json',\n              }),\n            );\n          },\n          opts,\n        );\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n      });\n    }\n    materialFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcCoords = scene.getNDC(pixelX, pixelY);\n      scene.raycaster.setFromCamera(ndcCoords, scene.getCamera());\n      return this[$model][$materialFromPoint](scene.raycaster);\n    }\n  }\n  __decorate$1(\n    [property({ type: String, attribute: 'variant-name' })],\n    SceneGraphModelViewerElement.prototype,\n    'variantName',\n    void 0,\n  );\n  __decorate$1(\n    [property({ type: String, attribute: 'orientation' })],\n    SceneGraphModelViewerElement.prototype,\n    'orientation',\n    void 0,\n  );\n  __decorate$1(\n    [property({ type: String, attribute: 'scale' })],\n    SceneGraphModelViewerElement.prototype,\n    'scale',\n    void 0,\n  );\n  return SceneGraphModelViewerElement;\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate =\n  (undefined && undefined.__decorate) ||\n  function (decorators, target, key, desc) {\n    var c = arguments.length,\n      r =\n        c < 3\n          ? target\n          : desc === null\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\n          : desc,\n      d;\n    if (typeof Reflect === 'object' && typeof undefined === 'function')\n      r = undefined(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if ((d = decorators[i]))\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n// How much the model will rotate per\n// second in radians:\nconst DEFAULT_ROTATION_SPEED = Math.PI / 32;\nconst AUTO_ROTATE_DELAY_DEFAULT = 3000;\nconst rotationRateIntrinsics = {\n  basis: [degreesToRadians(numberNode(DEFAULT_ROTATION_SPEED, 'rad'))],\n  keywords: { auto: [null] },\n};\nconst $autoRotateStartTime = Symbol('autoRotateStartTime');\nconst $radiansPerSecond = Symbol('radiansPerSecond');\nconst $syncRotationRate = Symbol('syncRotationRate');\nconst $onCameraChange = Symbol('onCameraChange');\nconst StagingMixin = (ModelViewerElement) => {\n  var _a, _b, _c;\n  class StagingModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.autoRotate = false;\n      this.autoRotateDelay = AUTO_ROTATE_DELAY_DEFAULT;\n      this.rotationPerSecond = 'auto';\n      this[_a] = performance.now();\n      this[_b] = 0;\n      this[_c] = (event) => {\n        if (!this.autoRotate) {\n          return;\n        }\n        if (event.detail.source === 'user-interaction') {\n          this[$autoRotateStartTime] = performance.now();\n        }\n      };\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      this.addEventListener('camera-change', this[$onCameraChange]);\n      this[$autoRotateStartTime] = performance.now();\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.removeEventListener('camera-change', this[$onCameraChange]);\n      this[$autoRotateStartTime] = performance.now();\n    }\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('autoRotate')) {\n        this[$autoRotateStartTime] = performance.now();\n      }\n    }\n    [((_a = $autoRotateStartTime),\n    (_b = $radiansPerSecond),\n    $syncRotationRate)](style) {\n      this[$radiansPerSecond] = style[0];\n    }\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n      if (\n        !this.autoRotate ||\n        !this[$hasTransitioned]() ||\n        this[$renderer].isPresenting\n      ) {\n        return;\n      }\n      const rotationDelta = Math.min(\n        delta,\n        time - this[$autoRotateStartTime] - this.autoRotateDelay,\n      );\n      if (rotationDelta > 0) {\n        this[$scene].yaw =\n          this.turntableRotation +\n          this[$radiansPerSecond] * rotationDelta * 0.001;\n      }\n    }\n    get turntableRotation() {\n      return this[$scene].yaw;\n    }\n    resetTurntableRotation(theta = 0) {\n      this[$scene].yaw = theta;\n    }\n  }\n  _c = $onCameraChange;\n  __decorate(\n    [property({ type: Boolean, attribute: 'auto-rotate' })],\n    StagingModelViewerElement.prototype,\n    'autoRotate',\n    void 0,\n  );\n  __decorate(\n    [property({ type: Number, attribute: 'auto-rotate-delay' })],\n    StagingModelViewerElement.prototype,\n    'autoRotateDelay',\n    void 0,\n  );\n  __decorate(\n    [\n      style({\n        intrinsics: rotationRateIntrinsics,\n        updateHandler: $syncRotationRate,\n      }),\n      property({ type: String, attribute: 'rotation-per-second' }),\n    ],\n    StagingModelViewerElement.prototype,\n    'rotationPerSecond',\n    void 0,\n  );\n  return StagingModelViewerElement;\n};\n\n/**\n * This mixin function is designed to be applied to a class that inherits\n * from HTMLElement. It makes it easy for a custom element to coordinate with\n * the :focus-visible polyfill.\n *\n * NOTE(cdata): The code here was adapted from an example proposed with the\n * introduction of ShadowDOM support in the :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196\n * @param {Function} SuperClass The base class implementation to decorate with\n * implementation that coordinates with the :focus-visible polyfill\n */\nconst FocusVisiblePolyfillMixin = (SuperClass) => {\n  var _a;\n  const coordinateWithPolyfill = (instance) => {\n    // If there is no shadow root, there is no need to coordinate with\n    // the polyfill. If we already coordinated with the polyfill, we can\n    // skip subsequent invokcations:\n    if (\n      instance.shadowRoot == null ||\n      instance.hasAttribute('data-js-focus-visible')\n    ) {\n      return () => {};\n    }\n    // The polyfill might already be loaded. If so, we can apply it to\n    // the shadow root immediately:\n    if (self.applyFocusVisiblePolyfill) {\n      self.applyFocusVisiblePolyfill(instance.shadowRoot);\n    } else {\n      const coordinationHandler = () => {\n        self.applyFocusVisiblePolyfill(instance.shadowRoot);\n      };\n      // Otherwise, wait for the polyfill to be loaded lazily. It might\n      // never be loaded, but if it is then we can apply it to the\n      // shadow root at the appropriate time by waiting for the ready\n      // event:\n      self.addEventListener(\n        'focus-visible-polyfill-ready',\n        coordinationHandler,\n        { once: true },\n      );\n      return () => {\n        self.removeEventListener(\n          'focus-visible-polyfill-ready',\n          coordinationHandler,\n        );\n      };\n    }\n    return () => {};\n  };\n  const $endPolyfillCoordination = Symbol('endPolyfillCoordination');\n  // IE11 doesn't natively support custom elements or JavaScript class\n  // syntax The mixin implementation assumes that the user will take the\n  // appropriate steps to support both:\n  class FocusVisibleCoordinator extends SuperClass {\n    constructor() {\n      super(...arguments);\n      this[_a] = null;\n    }\n    // Attempt to coordinate with the polyfill when connected to the\n    // document:\n    connectedCallback() {\n      super.connectedCallback && super.connectedCallback();\n      if (this[$endPolyfillCoordination] == null) {\n        this[$endPolyfillCoordination] = coordinateWithPolyfill(this);\n      }\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback && super.disconnectedCallback();\n      // It's important to remove the polyfill event listener when we\n      // disconnect, otherwise we will leak the whole element via window:\n      if (this[$endPolyfillCoordination] != null) {\n        this[$endPolyfillCoordination]();\n        this[$endPolyfillCoordination] = null;\n      }\n    }\n  }\n  _a = $endPolyfillCoordination;\n  return FocusVisibleCoordinator;\n};\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Uncomment these lines to export PMREM textures in Glitch:\n// export {default as TextureUtils} from './three-components/TextureUtils';\n// export * from 'three';\nconst ModelViewerElement = AnnotationMixin(\n  SceneGraphMixin(\n    StagingMixin(\n      EnvironmentMixin(\n        ControlsMixin(\n          ARMixin(\n            LoadingMixin(\n              AnimationMixin(FocusVisiblePolyfillMixin(ModelViewerElementBase)),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\ncustomElements.define('model-viewer', ModelViewerElement);\n\nexport { ModelViewerElement };\n//# sourceMappingURL=model-viewer.js.map\n"],"names":["$d81ab295f1227915$var$isCEPolyfill","window","customElements","undefined","polyfillWrapFlushCallback","$d81ab295f1227915$var$removeNodes","container","start","end","n","nextSibling","removeChild","$d81ab295f1227915$var$marker","String","Math","random","slice","$d81ab295f1227915$var$nodeMarker","$d81ab295f1227915$var$markerRegex","RegExp","$d81ab295f1227915$var$Template","result1","element6","this","parts","element","nodesToRemove","stack","walker","document","createTreeWalker","content","lastPartIndex","index","partIndex","strings","values","length","node","nextNode","nodeType","hasAttributes","attributes","count","i","$d81ab295f1227915$var$endsWith","name","stringForPart","$d81ab295f1227915$var$lastAttributeNameRegex","exec","attributeLookupName","toLowerCase","attributeValue","getAttribute","removeAttribute","statics","split","push","type","tagName","currentNode","data","indexOf","parent","parentNode","lastIndex","insert","s","$d81ab295f1227915$var$createMarker","match","createTextNode","insertBefore","previousSibling","pop","str","suffix","$d81ab295f1227915$var$isTemplatePartActive","part","createComment","$d81ab295f1227915$var$removeNodesFromTemplate","template","$d81ab295f1227915$var$nextActiveIndexInTemplateParts","nodeIndex","removeCount","nodesToRemoveInTemplate","currentRemovingNode","has","forEach","$d81ab295f1227915$var$countNodes","startIndex","$d81ab295f1227915$var$directives","WeakMap","$d81ab295f1227915$var$isDirective","o","$d81ab295f1227915$var$noChange","$d81ab295f1227915$var$nothing","$d81ab295f1227915$var$TemplateInstance","template1","processor","options2","__parts","options","update","values2","setValue","part1","commit","_clone","fragment","cloneNode","importNode","nodeName","handleTextExpression","insertAfterNode","handleAttributeExpressions","adoptNode","upgrade","$d81ab295f1227915$var$policy","trustedTypes","createPolicy","createHTML","$d81ab295f1227915$var$commentMarker","$d81ab295f1227915$var$TemplateResult","strings5","values1","type1","processor1","getHTML","l","html","isCommentBinding","commentOpen","lastIndexOf","attributeMatch","substr","getTemplateElement","createElement","value","innerHTML","$d81ab295f1227915$var$isPrimitive","$d81ab295f1227915$var$isIterable","Array","isArray","Symbol","iterator","$d81ab295f1227915$var$AttributeCommitter","element1","name13","strings1","dirty","_createPart","$d81ab295f1227915$var$AttributePart","_getValue","v","text","t","setAttribute","committer","value8","directive","$d81ab295f1227915$var$NodePart","options1","__pendingValue","appendInto","container1","startNode","appendChild","endNode","ref","appendIntoPart","part2","__insert","insertAfterPart","ref1","value1","__commitText","__commitTemplateResult","Node","__commitNode","__commitIterable","clear","node1","value2","value3","valueAsString","value4","templateFactory","instance","value5","itemParts","itemPart","item","$d81ab295f1227915$var$BooleanAttributePart","element2","name1","strings2","Error","value6","$d81ab295f1227915$var$PropertyCommitter","element3","name2","strings3","super","single","$d81ab295f1227915$var$PropertyPart","$d81ab295f1227915$var$eventOptionsSupported","capture","addEventListener","removeEventListener","_e","$d81ab295f1227915$var$EventPart","element4","eventName1","eventContext","eventName","__boundHandleEvent","e","handleEvent","value7","newListener","oldListener","shouldRemoveListener","once","passive","shouldAddListener","__options","$d81ab295f1227915$var$getOptions","event2","call","$d81ab295f1227915$var$templateFactory","result","templateCache","$d81ab295f1227915$var$templateCaches","get","stringsArray","keyString","Map","set","key","join","$d81ab295f1227915$var$parts","$d81ab295f1227915$var$render$1","firstChild","Object","assign","$d81ab295f1227915$var$defaultTemplateProcessor","element5","name3","strings4","options4","prefix","options3","$d81ab295f1227915$var$html","$d81ab295f1227915$var$getTemplateCacheKey","scopeName","$d81ab295f1227915$var$compatibleShadyCSSVersion","ShadyCSS","prepareTemplateDom","console","warn","$d81ab295f1227915$var$shadyTemplateFactory","cacheKey","$d81ab295f1227915$var$TEMPLATE_TYPES","$d81ab295f1227915$var$shadyRenderSet","Set","$d81ab295f1227915$var$prepareTemplateStyles","renderedDOM","add","templateElement","styles","querySelectorAll","prepareTemplateStyles","condensedStyle","style","textContent","templates","from","$d81ab295f1227915$var$removeStylesFromLitTemplates","refNode","insertCount","walkerIndex","$d81ab295f1227915$var$insertNodeIntoTemplate","querySelector","nativeShadow","removes","JSCompiler_renameProperty","prop","_obj","$d81ab295f1227915$var$defaultConverter","toAttribute","Boolean","JSON","stringify","fromAttribute","Number","parse","$d81ab295f1227915$var$notEqual","old","$d81ab295f1227915$var$defaultPropertyDeclaration","attribute","converter","reflect","hasChanged","$d81ab295f1227915$var$UpdatingElement","HTMLElement","initialize","observedAttributes","finalize","_classProperties","p","attr","_attributeNameForProperty","_attributeToPropertyMap","static","hasOwnProperty","superProperties","getPrototypeOf","k","name4","options11","_ensureClassProperties","noAccessor","prototype","descriptor","getPropertyDescriptor","defineProperty","name5","key2","options5","oldValue","requestUpdateInternal","configurable","enumerable","name6","superCtor","props","properties","propKeys","getOwnPropertyNames","getOwnPropertySymbols","createProperty","name7","options6","value11","value9","options7","value10","options8","_updateState","_updatePromise","Promise","res","_enableUpdatingResolver","_changedProperties","_saveInstanceProperties","constructor","_v","_instanceProperties","_applyInstanceProperties","connectedCallback","enableUpdating","disconnectedCallback","attributeChangedCallback","name8","old1","value14","_attributeToProperty","_propertyToAttribute","name9","value12","options9","ctor","attrValue","_propertyValueToAttribute","name10","value13","propName","getPropertyOptions","_propertyValueFromAttribute","name11","options10","shouldRequestUpdate","_valueHasChanged","_reflectingProperties","_hasRequestedUpdate","_enqueueUpdate","requestUpdate","name12","oldValue1","updateComplete","async","performUpdate","hasUpdated","shouldUpdate","changedProperties","_markUpdated","firstUpdated","updated","_getUpdateComplete","getUpdateComplete","_changedProperties1","size","_changedProperties2","_changedProperties3","$d81ab295f1227915$var$standardProperty","kind","finisher","clazz","placement","initializer","$d81ab295f1227915$var$property","protoOrDescriptor","proto","$d81ab295f1227915$var$legacyProperty","$d81ab295f1227915$var$supportsAdoptingStyleSheets","ShadowRoot","Document","CSSStyleSheet","$d81ab295f1227915$var$constructionToken","$d81ab295f1227915$var$CSSResult","cssText1","safeToken","cssText","styleSheet","_styleSheet","replaceSync","toString","$d81ab295f1227915$var$renderNotImplemented","$d81ab295f1227915$var$LitElement","userStyles","getStyles","addStyles","set2","reduceRight","set1","styles1","unshift","_styles","map","cssRules","reduce","css","rule","_getUniqueStyles","renderRoot","createRenderRoot","adoptStyles","attachShadow","shadowRootOptions","adoptedStyleSheets","_needsShimAdoptedStyleSheets","ScopingShim","prepareAdoptedCssText","localName","styleElement","changedProperties1","templateResult","render","hasRendered","needsScoping","host","firstScopeRender","renderContainer","createDocumentFragment","delete","mode","$d81ab295f1227915$var$HAS_WEBXR_DEVICE_API","navigator","xr","self","XRSession","isSessionSupported","$d81ab295f1227915$var$HAS_WEBXR_HIT_TEST_API","requestHitTestSource","$d81ab295f1227915$var$HAS_RESIZE_OBSERVER","ResizeObserver","$d81ab295f1227915$var$HAS_INTERSECTION_OBSERVER","IntersectionObserver","$d81ab295f1227915$var$IS_WEBXR_AR_CANDIDATE","userAgent","vendor","opera","check","test","$d81ab295f1227915$var$IS_ANDROID","$d81ab295f1227915$var$IS_IOS","MSStream","platform","maxTouchPoints","$d81ab295f1227915$var$IS_AR_QUICKLOOK_CANDIDATE","tempAnchor","relList","supports","$d81ab295f1227915$var$IS_FIREFOX","$d81ab295f1227915$var$IS_OCULUS","$d81ab295f1227915$var$IS_SCENEVIEWER_CANDIDATE","$d81ab295f1227915$var$templateResult","$d81ab295f1227915$var$EventDispatcher","type6","listener","_listeners","listeners","hasEventListener","type2","listener1","type3","listener2","listenerArray","splice","event1","target","array","PI","i1","$d81ab295f1227915$var$_lut","$d81ab295f1227915$var$hasRandomUUID","crypto","$d81ab295f1227915$var$generateUUID","randomUUID","toUpperCase","d0","d1","d2","d3","$d81ab295f1227915$var$clamp$1","min","max","$d81ab295f1227915$var$euclideanModulo","m","$d81ab295f1227915$var$lerp","x","y","$d81ab295f1227915$var$isPowerOfTwo","$d81ab295f1227915$var$ceilPowerOfTwo","pow","ceil","log","LN2","$d81ab295f1227915$var$floorPowerOfTwo","floor","freeze","$d81ab295f1227915$var$DEG2RAD","$d81ab295f1227915$var$RAD2DEG","clamp","euclideanModulo","a1","a2","b1","b2","lambda","dt","exp","pingpong","abs","smoothstep","low","high","range","$d81ab295f1227915$var$_seed","degrees","radians","ceilPowerOfTwo","floorPowerOfTwo","q","a","b","c","order","cos","sin","c2","s2","c13","s13","c1_3","s1_3","c3_1","s3_1","x23","y24","width","value38","height","value15","x1","y1","scalar","x2","y2","index25","value16","getComponent","index1","clone","v47","v1","w15","addVectors","s16","a18","b20","v2","s1","v3","w1","subVectors","v4","scalar1","v5","divideScalar","scalar2","multiplyScalar","applyMatrix3","m32","elements","v6","v7","min8","max2","minVal","maxVal","min1","max1","round","v8","v9","sqrt","atan2","distanceToSquared","v10","v11","dx","dy","v12","length3","normalize","lerp","v13","alpha9","v112","v211","alpha1","v14","offset23","array4","offset1","attribute9","index2","offset2","getX","getY","center4","angle","isVector2","arguments","error","n11","n12","n13","n21","n22","n23","n31","n32","n33","te","m1","me","xAxis","yAxis","zAxis","setFromMatrix3Column","setFromMatrix4","m2","multiply","m3","multiplyMatrices","m4","be","ae","a12","a13","a21","a22","a23","a32","a33","b12","b13","b32","b33","a11","b22","b23","b11","b21","b31","a31","s3","d","f","g","h","t11","t12","t13","det","detInv","transpose","tmp","getNormalMatrix","matrix43","invert","r1","tx","ty","sx","sy","rotation","cx1","cy1","sx1","sy1","rotate","theta8","tx1","ty1","matrix9","array2","offset3","toArray","array3","offset4","fromArray","Infinity","createElementNS","isMatrix3","image2","src","HTMLCanvasElement","canvas","$d81ab295f1227915$var$_canvas","$d81ab295f1227915$var$createElementNS","getContext","ImageData","context","putImageData","drawImage","toDataURL","image1","$d81ab295f1227915$var$Texture$1","DEFAULT_IMAGE","mapping2","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format7","type4","anisotropy","encoding2","$d81ab295f1227915$var$textureId","uuid","image","mipmaps","mapping","format","internalFormat","offset","$d81ab295f1227915$var$Vector2","repeat","center","matrixAutoUpdate","matrix","$d81ab295f1227915$var$Matrix3","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","encoding","version","onUpdate","isRenderTargetTexture","setUvTransform","copy","source60","meta10","isRootObject","textures","output","metadata","generator","wrap","images","url","isDataTexture","$d81ab295f1227915$var$serializeImage","dispatchEvent","uv4","needsUpdate","value17","HTMLImageElement","ImageBitmap","getDataURL","isTexture","$d81ab295f1227915$var$Vector4","x3","y3","z20","w2","z","w","value18","value19","x4","y4","z1","w3","scalar3","x5","setY","y5","z2","setW","w4","index3","value20","index4","v15","v16","w5","s4","a3","b3","v17","s5","v18","w6","s6","a4","b4","v19","scalar4","applyMatrix4","m5","scalar5","q10","acos","m6","epsilon","epsilon2","m11","m12","m13","m21","m22","m23","m31","m33","xx","yy","zz","xy","xz","yz","v20","v21","min2","max8","minVal1","maxVal1","min3","max3","v22","manhattanLength","length1","v23","alpha2","v110","v24","alpha3","v25","array23","offset5","array5","offset6","attribute1","index5","offset7","getZ","getW","isVector4","$d81ab295f1227915$var$WebGLRenderTarget","width6","height6","options15","depth","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","texture2","width1","height1","depth3","dispose","source1","isWebGLRenderTarget","width2","height2","count3","width3","height3","depth1","il","source2","isWebGLMultipleRenderTargets","$d81ab295f1227915$var$WebGLMultisampleRenderTarget","width4","height4","options12","samples","source3","isWebGLMultisampleRenderTarget","$d81ab295f1227915$var$Quaternion","x6","y6","z3","w7","_x","_y","qa","qb","qm","t6","slerpQuaternions","dst2","dstOffset2","src0","srcOffset0","src1","srcOffset1","t1","y0","z0","w0","x0","dir","sqrSin","EPSILON","len","tDir","dst1","dstOffset1","src01","srcOffset01","src11","srcOffset11","value21","_onChangeCallback","value22","_z","value23","_w","value24","x7","y7","z4","w8","quaternion","euler","update3","isEuler","_order","c1","c3","setFromAxisAngle","axis7","angle1","halfAngle","setFromRotationMatrix","m7","trace","vFrom","vTo","r","dot","angleTo","q1","rotateTowards","q2","step","slerp","conjugate","v26","lengthSq","q3","p5","multiplyQuaternions","premultiply","q4","a5","b5","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","qb1","t2","cosHalfTheta","sqrSinHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","qa1","qb2","t3","u1","sqrt1u1","sqrtu1","u2","u3","quaternion1","array6","offset8","array7","offset9","attribute2","index6","_onChange","callback6","isQuaternion","x8","y8","z5","x9","y9","z6","scalar6","x10","y10","z7","index7","value25","index8","v27","v28","w9","addScalar","s7","a6","b6","v29","s8","v30","w10","s9","a7","b7","v31","w11","multiplyVectors","scalar7","a8","b8","applyEuler","euler1","applyQuaternion","$d81ab295f1227915$var$_quaternion$4","setFromEuler","axis1","angle2","m8","m9","m10","q5","qx","qy","qz","qw","ix","iy","iz","iw","camera2","matrixWorldInverse","projectionMatrix","camera1","projectionMatrixInverse","matrixWorld","v32","scalar8","v33","v34","max4","min4","minVal2","maxVal2","min5","max5","negate","v35","length2","v36","alpha4","lerpVectors","v111","v210","alpha5","cross","v37","w12","crossVectors","a9","b9","ax","ay","az","bx","by","bz","v38","denominator","planeNormal","$d81ab295f1227915$var$_vector$c","projectOnVector","sub","normal4","v39","theta","distanceTo","v40","v41","dz","v42","s10","setFromSphericalCoords","radius","phi","radius7","phi3","theta1","sinPhiRadius","setFromCylindrical","c8","setFromCylindricalCoords","radius1","theta2","y11","setFromMatrixColumn","sz","m14","index9","m15","index10","v43","array8","offset10","array9","offset11","attribute3","index11","offset12","u","isVector3","$d81ab295f1227915$var$Vector3","min6","max6","min7","max7","setFromArray","array10","minX","minY","minZ","maxY","maxZ","maxX","attribute4","setFromPoints","points9","makeEmpty","expandByPoint","center1","size2","halfSize","$d81ab295f1227915$var$_vector$b","object5","expandByObject","box12","target32","target1","point18","vector4","scalar9","object1","geometry","boundingBox","computeBoundingBox","$d81ab295f1227915$var$_box$3","union","children","point1","containsBox","box1","point2","target2","box2","sphere10","clampPoint","plane7","normal","constant","triangle","isEmpty","getCenter","$d81ab295f1227915$var$_center","$d81ab295f1227915$var$_extents","$d81ab295f1227915$var$_v0$2","$d81ab295f1227915$var$_v1$7","$d81ab295f1227915$var$_v2$3","$d81ab295f1227915$var$_f2","axes","$d81ab295f1227915$var$_f0","$d81ab295f1227915$var$_f1","$d81ab295f1227915$var$satForAxes","$d81ab295f1227915$var$_triangleNormal","point3","target3","point4","target4","getSize","intersect","box3","box4","matrix1","$d81ab295f1227915$var$_points","offset13","box5","equals","isBox3","$d81ab295f1227915$var$Box3","$d81ab295f1227915$var$_testAxis","v0","extents","j","p0","p1","p2","$d81ab295f1227915$var$Sphere","center2","radius2","center3","radius3","points1","optionalCenter","$d81ab295f1227915$var$_box$2","maxRadiusSq","sphere1","point5","point6","sphere2","radiusSum","box6","intersectsSphere","plane1","distanceToPoint","point7","target5","deltaLengthSq","target6","expandByScalar","matrix2","getMaxScaleOnAxis","offset14","point8","$d81ab295f1227915$var$_toPoint","missingRadiusHalf","sphere3","$d81ab295f1227915$var$_v1$6","$d81ab295f1227915$var$_toFarthestPoint","sphere4","origin","direction","direction1","origin1","ray2","target7","t4","lookAt","v44","t5","at","$d81ab295f1227915$var$_vector$a","point9","target8","directionDistance","point10","distanceSqToPoint","point11","v01","v113","optionalPointOnRay","optionalPointOnSegment","$d81ab295f1227915$var$_segCenter","segExtent","a01","$d81ab295f1227915$var$_segDir","b0","$d81ab295f1227915$var$_diff","s0","sqrDist","extDet","invDet","sphere5","target9","tca","thc","t0","sphere6","plane2","plane3","target10","distanceToPlane","intersectsPlane","plane4","distToPoint","box7","target11","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","box8","intersectBox","intersectTriangle","a10","b10","backfaceCulling","target12","$d81ab295f1227915$var$_edge1","$d81ab295f1227915$var$_edge2","$d81ab295f1227915$var$_normal$1","sign","DdN","DdQxE2","DdE1xQ","QdN","matrix41","transformDirection","ray1","n111","n121","n131","n14","n211","n221","n231","n24","n311","n321","n331","n34","n41","n42","n43","n44","$d81ab295f1227915$var$Matrix4","m16","m17","m18","xAxis1","yAxis1","zAxis1","xAxis2","yAxis2","zAxis2","m19","scaleX","$d81ab295f1227915$var$_v1$5","scaleY","scaleZ","euler2","af","bf","ce","cf","de","df","ac","ad","bc","bd","q6","compose","$d81ab295f1227915$var$_zero","$d81ab295f1227915$var$_one","target13","up","eye","$d81ab295f1227915$var$_z","$d81ab295f1227915$var$_x","$d81ab295f1227915$var$_y","n1","m20","a14","a24","a34","a42","a43","a44","b14","b24","b34","b41","b42","b43","b44","a111","b111","a41","s11","determinant","setPosition","x11","y12","z8","t14","scale","v45","scaleXSq","scaleYSq","scaleZSq","x12","y13","z9","theta3","theta4","theta5","axis2","angle3","x13","y14","z10","yx","zx","zy","position2","quaternion2","scale2","wx","wy","wz","decompose","position1","quaternion3","scale1","$d81ab295f1227915$var$_m1$2","invSX","invSY","invSZ","left3","right3","top3","bottom3","near7","far7","left1","right1","top1","bottom1","near1","far1","matrix3","array11","offset15","array12","offset16","isMatrix4","$d81ab295f1227915$var$Euler","x14","y15","z11","order5","DefaultOrder","value26","value27","value28","value29","x15","y16","z12","order1","euler3","order2","update1","m221","asin","q7","order3","update2","$d81ab295f1227915$var$_matrix$1","makeRotationFromQuaternion","v46","order4","newOrder","$d81ab295f1227915$var$_quaternion$3","setFromQuaternion","euler4","array13","array14","offset17","optionalResult","callback1","RotationOrders","mask","channel","channel1","channel2","channel3","layers","$d81ab295f1227915$var$_removedEvent","$d81ab295f1227915$var$Object3D","$d81ab295f1227915$var$_object3DId","DefaultUp","position","modelViewMatrix","normalMatrix","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","$d81ab295f1227915$var$Layers","visible","castShadow","receiveShadow","frustumCulled","renderOrder","animations","userData","matrix5","updateMatrix","q8","axis3","angle4","euler5","q9","axis4","angle5","$d81ab295f1227915$var$_q1","axis5","angle6","rotateX","angle7","rotateOnAxis","$d81ab295f1227915$var$_xAxis","rotateY","angle8","$d81ab295f1227915$var$_yAxis","angle9","$d81ab295f1227915$var$_zAxis","translateOnAxis","axis6","distance4","$d81ab295f1227915$var$_v1$4","distance1","distance2","distance3","vector1","vector2","$d81ab295f1227915$var$_m1$1","x16","y17","z13","$d81ab295f1227915$var$_target","updateWorldMatrix","$d81ab295f1227915$var$_position$3","setFromMatrixPosition","isCamera","isLight","extractRotation","object2","isObject3D","remove","$d81ab295f1227915$var$_addedEvent","object3","object","object4","id1","getObjectByProperty","name21","name14","value30","target14","target15","$d81ab295f1227915$var$_scale$2","target16","$d81ab295f1227915$var$_quaternion$2","target17","callback2","traverse","callback3","traverseVisible","callback4","traverseAncestors","updateMatrixWorld","force","updateParents","updateChildren","toJSON","meta1","geometries","materials","shapes","skeletons","serialize","library","isInstancedMesh","instanceMatrix","instanceColor","isScene","background","isColor","environment","isMesh","isLine","isPoints","parameters","shape","isSkinnedMesh","bindMode","bindMatrix","skeleton","material","uuids","animation","extractFromCache","cache","recursive8","recursive1","source4","child","target18","$d81ab295f1227915$var$_v0$1","targetLengthSq","point12","c4","target19","$d81ab295f1227915$var$_v1$3","$d81ab295f1227915$var$_v2$2","dot00","dot01","dot02","dot11","dot12","denom","invDenom","point13","a15","b15","c5","getBarycoord","$d81ab295f1227915$var$_v3$1","point14","p13","p23","p33","uv12","uv22","uv3","target20","addScaledVector","a16","b16","c6","direction2","a17","b17","c7","setFromPointsAndIndices","points2","i0","i11","i2","setFromAttributeAndIndices","attribute5","i01","i12","i21","fromBufferAttribute","triangle1","getArea","getMidpoint","target21","getNormal","target22","$d81ab295f1227915$var$Triangle","getPlane","target23","setFromCoplanarPoints","point15","target24","getUV","point16","uv11","uv21","uv31","target25","containsPoint","point17","isFrontFacing","direction3","intersectsBox","box9","intersectsTriangle","closestPointToPoint","p4","target26","$d81ab295f1227915$var$_vab","$d81ab295f1227915$var$_vac","$d81ab295f1227915$var$_vap","$d81ab295f1227915$var$_vbp","d4","vc","$d81ab295f1227915$var$_vcp","d5","d6","vb","va","$d81ab295f1227915$var$_vbc","triangle2","$d81ab295f1227915$var$materialId","$d81ab295f1227915$var$Material$1","fog","blending","side","vertexColors","opacity","transparent","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","depthTest","depthWrite","stencilWriteMask","stencilFunc","stencilRef","stencilFuncMask","stencilFail","stencilZFail","stencilZPass","stencilWrite","clippingPlanes","clipIntersection","clipShadows","shadowSide","colorWrite","precision","polygonOffset","polygonOffsetFactor","dithering","alphaToCoverage","premultipliedAlpha","toneMapped","_alphaTest","alphaTest","value31","customProgramCacheKey","onBeforeCompile","values3","newValue","flatShading","currentValue","meta2","isRoot","data1","color","getHex","roughness","metalness","sheen","sheenTint","sheenRoughness","emissive","emissiveIntensity","specular","specularIntensity","specularTint","shininess","clearcoat","clearcoatRoughness","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","clearcoatNormalScale","matcap","alphaMap","lightMap","lightMapIntensity","aoMap","aoMapIntensity","bumpMap","bumpScale","normalMap","normalMapType","normalScale","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","emissiveMap","specularMap","specularIntensityMap","specularTintMap","envMap","combine","envMapIntensity","reflectivity","refractionRatio","gradientMap","transmission","transmissionMap","thickness","thicknessMap","attenuationDistance","attenuationTint","sizeAttenuation","polygonOffsetUnits","linewidth","dashSize","gapSize","wireframe","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","source5","srcPlanes","dstPlanes","value32","isMaterial","aquamarine","azure","burlywood","cadetblue","chocolate","coral","darkblue","darkcyan","darkkhaki","darkmagenta","darkviolet","deeppink","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","lightseagreen","mintcream","mistyrose","powderblue","rebeccapurple","red","rosybrown","steelblue","tan","teal","turquoise","violet","whitesmoke","yellow","$d81ab295f1227915$var$_hslB","$d81ab295f1227915$var$hue2rgb","$d81ab295f1227915$var$SRGBToLinear","r3","g2","b18","setRGB","value33","setHex","setStyle","scalar10","hex1","g1","b19","r2","s12","l4","h3","style2","handleAlpha","string","parseFloat","components","parseInt","setHSL","hex","charAt","setColorName","style1","$d81ab295f1227915$var$_colorKeywords","color12","color1","gammaFactor","color2","gammaFactor1","safeInverse","gammaFactor2","copyGammaToLinear","gammaFactor3","copyLinearToGamma","color3","copyLinearToSRGB","color4","$d81ab295f1227915$var$LinearToSRGB","copySRGBToLinear","getHexString","saturation","lightness","delta","hue","target27","h1","l1","getHSL","$d81ab295f1227915$var$_hslA","color5","s14","color6","color7","s15","color8","alpha6","color11","color21","alpha7","color9","alpha8","c9","array15","offset18","array16","offset19","attribute6","index12","normalized","NAMES","$d81ab295f1227915$var$MeshBasicMaterial","parameters2","$d81ab295f1227915$var$Color","source6","isMeshBasicMaterial","itemSize5","normalized5","array17","TypeError","usage","updateRange","value34","value35","source7","itemSize","attribute7","array18","colors","vectors","vector","vectors1","vectors2","m24","$d81ab295f1227915$var$_vector2$1","setXY","i3","l2","$d81ab295f1227915$var$_vector$9","setXYZ","m25","m26","applyNormalMatrix","m27","offset20","value36","index13","x17","index14","index15","y18","index16","index17","index18","z14","index19","index20","w13","index21","x18","y19","x19","y20","z15","index22","setXYZW","index23","x20","y21","z16","w14","onUpload","callback5","isBufferAttribute","$d81ab295f1227915$var$BufferAttribute","array19","itemSize1","normalized1","Uint16Array","array20","itemSize2","normalized2","Uint32Array","array21","itemSize3","normalized3","isFloat16BufferAttribute","array22","itemSize4","normalized4","Float32Array","$d81ab295f1227915$var$_vector$8","$d81ab295f1227915$var$BufferGeometry","$d81ab295f1227915$var$_id","morphAttributes","morphTargetsRelative","groups","boundingSphere","drawRange","index24","$d81ab295f1227915$var$arrayMax","$d81ab295f1227915$var$Uint32BufferAttribute","$d81ab295f1227915$var$Uint16BufferAttribute","name15","name16","attribute8","name17","name18","start2","count1","materialIndex1","materialIndex","start1","count2","matrix6","tangent","computeBoundingSphere","q11","$d81ab295f1227915$var$_m1","angle10","makeRotationX","angle11","makeRotationY","angle12","makeRotationZ","x21","y22","z17","makeTranslation","x22","y23","z18","makeScale","vector3","$d81ab295f1227915$var$_obj","$d81ab295f1227915$var$_offset","translate","points3","point","$d81ab295f1227915$var$Float32BufferAttribute","morphAttributesPosition","isGLBufferAttribute","setFromBufferAttribute","morphAttribute","$d81ab295f1227915$var$_box$1","isNaN","$d81ab295f1227915$var$_boxMorphTargets","i4","il1","i5","il2","jl","uv","positions","nVertices","tan2","vB","vC","uvA","uvB","uvC","sdir","tdir","uvs","i6","group","handleTriangle","indices","tmp2","n2","handleVertex","tan1","tangents","i7","il3","positionAttribute","normalAttribute","pA","pB","pC","nA","nB","nC","cb","ab","i8","il4","vA","i9","il5","normalizeNormals","merge","geometry2","offset21","isBufferGeometry","attributeArray1","attributeArray2","attributeOffset","normals","convertBufferAttribute","isInterleavedBufferAttribute","stride","indices1","newAttribute","name19","morphArray","i10","l3","addGroup","keys","hasMorphAttributes","key1","attributeArray","source8","setIndex","name20","$d81ab295f1227915$var$Ray","$d81ab295f1227915$var$_vB$1","$d81ab295f1227915$var$_vC$1","geometry1","material1","source9","morphTargetInfluences","morphTargetDictionary","ml","morphTargets","intersects5","$d81ab295f1227915$var$_sphere$3","raycaster1","ray","$d81ab295f1227915$var$_inverseMatrix$2","$d81ab295f1227915$var$_ray$2","intersection","morphPosition","uv2","groupMaterial","$d81ab295f1227915$var$checkBufferGeometryIntersection","faceIndex","face","influence","$d81ab295f1227915$var$_tempA","$d81ab295f1227915$var$_tempB","$d81ab295f1227915$var$_tempC","$d81ab295f1227915$var$_morphA","$d81ab295f1227915$var$_morphB","$d81ab295f1227915$var$_morphC","$d81ab295f1227915$var$_vA$1","boneTransform","$d81ab295f1227915$var$checkIntersection","raycaster","$d81ab295f1227915$var$_intersectionPoint","$d81ab295f1227915$var$_uvA$1","$d81ab295f1227915$var$_uvB$1","$d81ab295f1227915$var$_uvC$1","width5","height5","depth2","widthSegments","heightSegments","depthSegments","scope","vertices","numberOfVertices","groupStart","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","iy1","data2","$d81ab295f1227915$var$BoxGeometry","$d81ab295f1227915$var$cloneUniforms","dst","property","$d81ab295f1227915$var$mergeUniforms","uniforms","merged","$d81ab295f1227915$var$ShaderMaterial","parameters1","defines","vertexShader","fragmentShader","lights","clipping","extensions","derivatives","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","uniformsNeedUpdate","glslVersion","setValues","source10","meta3","isShaderMaterial","$d81ab295f1227915$var$Camera","recursive2","source11","getWorldDirection","target28","force1","updateParents1","updateChildren1","fov","aspect","near2","far2","zoom","near","far","focus","view","filmGauge","filmOffset","updateProjectionMatrix","source12","recursive3","focalLength1","vExtentSlope","getFilmHeight","atan","getEffectiveFOV","fullWidth","fullHeight","x26","y27","width9","height9","enabled","offsetX","offsetY","top","left","skew","getFilmWidth","makePerspective","meta4","isPerspectiveCamera","near3","far3","renderTarget1","isWebGLCubeRenderTarget","renderTarget","cameraPX","$d81ab295f1227915$var$PerspectiveCamera","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","scene1","renderer3","getRenderTarget","setRenderTarget","currentRenderTarget","currentXrEnabled","$d81ab295f1227915$var$CubeTexture","mapping1","wrapS1","wrapT1","magFilter1","minFilter1","format1","type5","anisotropy1","encoding1","value37","isCubeTexture","$d81ab295f1227915$var$WebGLCubeRenderTarget","size1","options13","dummy","isInteger","_needsFlipEnvMap","fromEquirectangularTexture","renderer1","texture1","shader","tEquirect","mesh","$d81ab295f1227915$var$Mesh","currentMinFilter","$d81ab295f1227915$var$CubeCamera","renderer2","color10","depth6","stencil1","$d81ab295f1227915$var$_vector1","$d81ab295f1227915$var$_vector2","$d81ab295f1227915$var$_normalMatrix","$d81ab295f1227915$var$Plane","normal1","normal2","constant1","setComponents","x24","y25","z19","w18","setFromNormalAndCoplanarPoint","normal3","point22","a19","c10","plane5","inverseNormalLength","point19","distanceToSphere","sphere7","projectPoint","point20","target29","intersectLine","line2","target30","intersectsLine","line1","startSign","endSign","box10","sphere8","coplanarPoint","target31","matrix7","optionalNormalMatrix","referencePoint","offset22","plane6","isPlane","$d81ab295f1227915$var$_sphere$2","$d81ab295f1227915$var$_vector$7","$d81ab295f1227915$var$Frustum","p02","p11","p21","p31","planes","p01","p12","p22","p32","p41","p51","frustum","setFromProjectionMatrix","m28","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsObject","object6","sprite","sphere9","negRadius","box11","plane","point21","$d81ab295f1227915$var$WebGLAnimation","animationLoop","requestId","onAnimationFrame","time","frame","requestAnimationFrame","isAnimating","cancelAnimationFrame","setAnimationLoop","callback","setContext","$d81ab295f1227915$var$WebGLAttributes","gl","capabilities","isWebGL2","buffers","deleteBuffer","buffer","bufferType","cached","bytesPerElement","elementSize","createBuffer","bindBuffer","bufferData","onUploadCallback","Float64Array","Int16Array","Int32Array","Int8Array","Uint8Array","Uint8ClampedArray","BYTES_PER_ELEMENT","bufferSubData","subarray","width7","height7","widthSegments1","heightSegments1","width_half","height_half","segment_width","segment_height","iy2","data3","$d81ab295f1227915$var$PlaneGeometry","alphamap_fragment","alphamap_pars_fragment","cube_uv_reflection_fragment","defaultnormal_vertex","lights_physical_pars_fragment","lights_fragment_begin","roughnessmap_fragment","roughnessmap_pars_fragment","uv2_vertex","worldpos_vertex","meshlambert_vert","meshlambert_frag","meshphysical_vert","meshphysical_frag","uvTransform","uv2Transform","envmap","ior","aomap","gradientmap","shadowBias","shadowNormalBias","shadowRadius","shadowMapSize","distance","coneCos","penumbraCos","decay","spotLightShadows","spotShadowMap","spotShadowMatrix","skyColor","diffuse","$d81ab295f1227915$var$UniformsLib","common","specularmap","lightmap","$d81ab295f1227915$var$ShaderChunk","meshbasic_vert","meshbasic_frag","emissivemap","bumpmap","normalmap","displacementmap","meshphong_vert","meshphong_frag","roughnessmap","metalnessmap","meshtoon_vert","meshtoon_frag","meshmatcap_vert","meshmatcap_frag","points","points_vert","points_frag","totalSize","linedashed_vert","linedashed_frag","depth_vert","depth_frag","meshnormal_vert","meshnormal_frag","sprite_vert","sprite_frag","t2D","background_vert","background_frag","cube","cube_vert","cube_frag","equirect_vert","equirect_frag","referencePosition","nearDistance","farDistance","distanceRGBA_vert","distanceRGBA_frag","shadow","shadow_vert","shadow_frag","$d81ab295f1227915$var$WebGLBackground","renderer","cubemaps","state","objects","clearColor","planeMesh","boxMesh","clearAlpha","currentBackground","currentBackgroundVersion","currentTonemapping","setClear","alpha","getClearColor","setClearColor","getClearAlpha","setClearAlpha","renderList","scene","forceClear","session","getSession","environmentBlendMode","autoClear","autoClearColor","autoClearDepth","autoClearStencil","$d81ab295f1227915$var$ShaderLib","deleteAttribute","onBeforeRender","camera","copyPosition","flipEnvMap","toneMapping","attributes1","getParameter","extension1","createBindingState","bindVertexArrayObject","vao","bindVertexArray","bindVertexArrayOES","deleteVertexArrayObject","deleteVertexArray","deleteVertexArrayOES","newAttributes","enabledAttributes","attributeDivisors","maxVertexAttributes","program","initAttributes","enableAttribute","enableAttributeAndDivisor","meshPerAttribute","currentState","enableVertexAttribArray","disableUnusedAttributes","disableVertexAttribArray","vertexAttribPointer","vertexAttribIPointer","reset","resetDefaultState","defaultState","programMap","bindingStates","id","stateMap","createVertexArray","createVertexArrayOES","getBindingState","updateBuffers","cachedAttributes","geometryAttributes","attributesNum","cachedAttribute","geometryAttribute","saveCache","isInstancedBufferGeometry","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","location","_maxInstanceCount","locationSize","i13","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","setupVertexAttributes","geometryId","programId","$d81ab295f1227915$var$WebGLBufferRenderer","info","setMode","drawArrays","renderInstances","primcount","extension","methodName","$d81ab295f1227915$var$WebGLCapabilities","maxAnisotropy","getMaxPrecision","getShaderPrecisionFormat","WebGL2RenderingContext","WebGL2ComputeRenderingContext","precision1","maxPrecision","logarithmicDepthBuffer","maxFragmentUniforms","vertexTextures","maxVertexTextures","floatFragmentTextures","getMaxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","maxTextures","maxTextureSize","maxCubemapSize","maxAttributes","maxVertexUniforms","maxVaryings","floatVertexTextures","maxSamples","$d81ab295f1227915$var$WebGLClipping","globalState","numGlobalPlanes","localClippingEnabled","renderingShadows","viewNormalMatrix","uniform","resetGlobalState","numPlanes","numIntersection","projectPlanes","dstOffset","skipTransform","nPlanes","dstArray","flatSize","viewMatrix","init","enableLocalClipping","beginShadows","endShadows","setState","useCache","materialProperties","nGlobal","lGlobal","clippingState","$d81ab295f1227915$var$WebGLCubeMaps","mapTextureMapping","onTextureDispose","event","physical","standard","transmissionSamplerSize","transmissionSamplerMap","left2","right2","top2","bottom2","near4","far4","source13","recursive4","right","bottom","setViewOffset","fullWidth1","fullHeight1","x25","y26","width8","height8","cx","cy","scaleW","scaleH","makeOrthographic","meta5","isOrthographicCamera","$d81ab295f1227915$var$RawShaderMaterial","parameters3","isRawShaderMaterial","$d81ab295f1227915$var$TOTAL_LODS","$d81ab295f1227915$var$LOD_MAX","$d81ab295f1227915$var$EXTRA_LOD_SIGMA","$d81ab295f1227915$var$ENCODINGS","$d81ab295f1227915$var$OrthographicCamera","$d81ab295f1227915$var$_lodPlanes","_sizeLods","$d81ab295f1227915$var$_sizeLods","_sigmas","$d81ab295f1227915$var$_sigmas","$d81ab295f1227915$var$_createPlanes","$d81ab295f1227915$var$PHI","$d81ab295f1227915$var$_axisDirections","$d81ab295f1227915$var$INV_PHI","renderer4","weights","latitudinal","dTheta","mipInt","poleAxis","$d81ab295f1227915$var$_getCommonVertexShader","$d81ab295f1227915$var$_getBlurShader","_blurMaterial","scene3","sigma2","near5","far5","$d81ab295f1227915$var$_oldTarget","_renderer","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","equirectangular","_fromTexture","cubemap","compileCubemapShader","_cubemapShader","$d81ab295f1227915$var$_getCubemapShader","_compileMaterial","_equirectShader","$d81ab295f1227915$var$_getEquirectShader","outputTarget","_pingPongRenderTarget","texture6","texture3","params","$d81ab295f1227915$var$_isLDR","$d81ab295f1227915$var$_createRenderTarget","material2","tmpMesh","compile","$d81ab295f1227915$var$_flatCamera$1","scene2","near6","far6","cubeUVRenderTarget4","cubeCamera","upSign","forwardSign","originalAutoClear","outputEncoding","$d81ab295f1227915$var$_clearColor","backgroundMaterial","backgroundBox","useSolidColor","col","$d81ab295f1227915$var$_setViewport","$d81ab295f1227915$var$SIZE_MAX","_setEncoding","texture4","_textureToCubeUV","texture5","cubeUVRenderTarget1","cubeUVRenderTarget2","sigma","cubeUVRenderTarget3","lodIn","lodOut","sigma1","poleAxis2","pingPongRenderTarget","_halfBlur","targetIn","targetOut","lodIn1","lodOut1","sigmaRadians","direction4","poleAxis1","blurMaterial","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","sigmaPixels","weight","sum","i15","outputSize","_lodPlanes","lod","sizeLod","texelSize","cubeFaces","positionSize","uvSize","faceIndexSize","coordinates","uv1","fill","inputEncoding","$d81ab295f1227915$var$_getEncodings","$d81ab295f1227915$var$WebGLCubeUVMaps","cubeUVmaps","cubemapUV","isEquirectMap","isCubeMap","isCubeTextureComplete","pmremGenerator","$d81ab295f1227915$var$PMREMGenerator","fromEquirectangular","fromCubemap","$d81ab295f1227915$var$WebGLExtensions","getExtension","$d81ab295f1227915$var$WebGLGeometries","wireframeAttributes","onGeometryDispose","releaseStatesOfGeometry","memory","updateWireframeAttribute","geometryIndex","geometryPosition","previousAttribute","name22","getWireframeAttribute","currentAttribute","$d81ab295f1227915$var$WebGLIndexedBufferRenderer","drawElements","$d81ab295f1227915$var$WebGLInfo","calls","triangles","lines","programs","autoReset","instanceCount","$d81ab295f1227915$var$DataTexture2DArray","data5","width10","height10","depth4","wrapR","$d81ab295f1227915$var$numericalSort","$d81ab295f1227915$var$absNumericalSort","$d81ab295f1227915$var$denormalize","morph","workInfluences","i16","objectInfluences","numberOfMorphTargets","entry","morphTextures","hasMorphNormals","morphNormals","numberOfVertexData","vertexDataStride","morphTarget","morphNormal","morphInfluencesSum","morphBaseInfluence","getUniforms","influences","influencesList","sort","i17","MAX_SAFE_INTEGER","i18","morphInfluences","hasAttribute","$d81ab295f1227915$var$WebGLObjects","onInstancedMeshDispose","instancedMesh","buffergeometry","updateMap","isDataTexture2DArray","$d81ab295f1227915$var$DataTexture3D","data4","width11","height11","depth5","isDataTexture3D","$d81ab295f1227915$var$emptyTexture","$d81ab295f1227915$var$emptyTexture2dArray","$d81ab295f1227915$var$emptyTexture3d","$d81ab295f1227915$var$flatten","nBlocks","blockSize","firstElem","$d81ab295f1227915$var$arrayCacheF32","$d81ab295f1227915$var$arraysEqual","$d81ab295f1227915$var$copyArray","$d81ab295f1227915$var$allocTexUnits","$d81ab295f1227915$var$arrayCacheI32","allocateTextureUnit","$d81ab295f1227915$var$setValueV1f","addr","$d81ab295f1227915$var$setValueV2f","uniform2f","uniform3f","uniform4f","$d81ab295f1227915$var$mat2array","$d81ab295f1227915$var$mat3array","$d81ab295f1227915$var$mat4array","$d81ab295f1227915$var$setValueV2i","unit","safeSetTexture2D","setTexture3D","safeSetTextureCube","$d81ab295f1227915$var$emptyCubeTexture","$d81ab295f1227915$var$setValueT2DArray1","uniform1i","setTexture2DArray","$d81ab295f1227915$var$setValueV2fArray","uniform2fv","$d81ab295f1227915$var$setValueV3fArray","uniform3fv","$d81ab295f1227915$var$setValueV4fArray","$d81ab295f1227915$var$setValueM2Array","$d81ab295f1227915$var$setValueM3Array","uniformMatrix3fv","$d81ab295f1227915$var$setValueM4Array","uniformMatrix4fv","$d81ab295f1227915$var$setValueV1iArray","uniform1iv","$d81ab295f1227915$var$setValueV2iArray","uniform2iv","$d81ab295f1227915$var$setValueV3iArray","$d81ab295f1227915$var$setValueV4iArray","uniform4iv","$d81ab295f1227915$var$setValueV1uiArray","uniform1uiv","$d81ab295f1227915$var$setValueV2uiArray","$d81ab295f1227915$var$setValueV3uiArray","$d81ab295f1227915$var$setValueV4uiArray","$d81ab295f1227915$var$setValueT1Array","units","$d81ab295f1227915$var$setValueT6Array","$d81ab295f1227915$var$SingleUniform","activeInfo","$d81ab295f1227915$var$setValueV3f","$d81ab295f1227915$var$setValueV4f","$d81ab295f1227915$var$setValueM2","$d81ab295f1227915$var$setValueM3","$d81ab295f1227915$var$setValueM4","$d81ab295f1227915$var$setValueV1i","$d81ab295f1227915$var$setValueV3i","$d81ab295f1227915$var$setValueV4i","$d81ab295f1227915$var$setValueV1ui","$d81ab295f1227915$var$setValueV2ui","$d81ab295f1227915$var$setValueV3ui","$d81ab295f1227915$var$setValueV4ui","$d81ab295f1227915$var$setValueT1","$d81ab295f1227915$var$setValueT3D1","$d81ab295f1227915$var$setValueT6","$d81ab295f1227915$var$getSingularSetter","$d81ab295f1227915$var$PureArrayUniform","$d81ab295f1227915$var$setValueV1fArray","$d81ab295f1227915$var$getPureArraySetter","$d81ab295f1227915$var$StructuredUniform","seq","updateCache","uniformObject","pathLength","path","$d81ab295f1227915$var$RePathPart","matchEnd","idIsIndex","subscript","$d81ab295f1227915$var$addUniform","next","$d81ab295f1227915$var$WebGLUniforms","getProgramParameter","getActiveUniform","getUniformLocation","createShader","setOptional","upload","seqWithValue","getShaderParameter","getShaderInfoLog","trim","errors","$d81ab295f1227915$var$addLineNumbers","getShaderSource","$d81ab295f1227915$var$getTexelDecodingFunction","functionName","$d81ab295f1227915$var$getEncodingComponents","toneMappingName","$d81ab295f1227915$var$replaceLightNums","replace","numDirLights","numSpotLights","numRectAreaLights","numPointLights","numHemiLights","numDirLightShadows","numSpotLightShadows","numPointLightShadows","$d81ab295f1227915$var$replaceClippingPlaneNums","numClippingPlanes","numClipIntersection","$d81ab295f1227915$var$includePattern","$d81ab295f1227915$var$includeReplacer","include","$d81ab295f1227915$var$resolveIncludes","$d81ab295f1227915$var$deprecatedUnrollLoopPattern","$d81ab295f1227915$var$unrollLoops","$d81ab295f1227915$var$unrollLoopPattern","$d81ab295f1227915$var$loopReplacer","$d81ab295f1227915$var$deprecatedLoopReplacer","snippet","$d81ab295f1227915$var$generatePrecision","precisionstring","$d81ab295f1227915$var$WebGLProgram","shadowMapTypeDefine","shadowMapType","$d81ab295f1227915$var$generateShadowMapTypeDefine","envMapTypeDefine","envMapMode","$d81ab295f1227915$var$generateEnvMapTypeDefine","envMapModeDefine","$d81ab295f1227915$var$generateEnvMapModeDefine","envMapBlendingDefine","$d81ab295f1227915$var$generateEnvMapBlendingDefine","gammaFactorDefine","extensionDerivatives","envMapCubeUV","tangentSpaceNormalMap","shaderID","extensionFragDepth","rendererExtensionFragDepth","extensionDrawBuffers","rendererExtensionDrawBuffers","extensionShaderTextureLOD","rendererExtensionShaderTextureLod","filter","$d81ab295f1227915$var$filterEmptyLine","$d81ab295f1227915$var$generateExtensions","chunks","$d81ab295f1227915$var$generateDefines","createProgram","prefixFragment","customDefines","prefixVertex","customExtensions","shaderName","instancing","instancingColor","supportsVertexTextures","maxBones","useFog","fogExp2","objectSpaceNormalMap","vertexTangents","vertexAlphas","vertexUvs","skinning","useVertexTexture","morphTargetsCount","uvsVertexOnly","doubleSided","flipSided","shadowMapEnabled","physicallyCorrectLights","$d81ab295f1227915$var$getToneMappingFunction","mapEncoding","matcapEncoding","envMapEncoding","emissiveMapEncoding","specularTintMapEncoding","lightMapEncoding","$d81ab295f1227915$var$getTexelEncodingFunction","depthPacking","versionString","$d81ab295f1227915$var$WebGLShader","fragmentGlsl","glVertexShader","glFragmentShader","bindAttribLocation","checkShaderErrors","getProgramInfoLog","$d81ab295f1227915$var$getShaderErrors","getError","programLog","vertexErrors","fragmentErrors","vertexLog","fragmentLog","haveDiagnostics","diagnostics","runnable","cachedUniforms","getActiveAttrib","getAttribLocation","$d81ab295f1227915$var$fetchAttributeLocations","releaseStatesOfProgram","$d81ab295f1227915$var$programIdCount","cubeuvmaps","shaderIDs","MeshDepthMaterial","MeshDistanceMaterial","MeshNormalMaterial","MeshBasicMaterial","getTextureEncodingFromMap","shadows","isMeshStandardMaterial","bones","nVertexUniforms","nVertexMatrices","getMaxBones","useClearcoat","isFogExp2","directional","spot","rectArea","hemi","directionalShadowMap","pointShadowMap","shadowMap","fragDepth","parameterNames","$d81ab295f1227915$var$UniformsUtils","pl","preexistingProgram","usedTimes","destroy","groupOrder","renderItemsIndex","opaque","transmissive","getNextRenderItem","renderItem","renderItems","defaultProgram","customOpaqueSort","customTransparentSort","$d81ab295f1227915$var$painterSortStable","$d81ab295f1227915$var$reversePainterSortStable","renderCallDepth","lists","list","$d81ab295f1227915$var$WebGLRenderList","light","groundColor","halfHeight","$d81ab295f1227915$var$shadowCastingLightsFirst","lightA","lightB","$d81ab295f1227915$var$WebGLLights","$d81ab295f1227915$var$UniformsCache","shadowCache","shadowCameraNear","shadowCameraFar","$d81ab295f1227915$var$ShadowUniformsCache","spotLength","rectAreaLength","i20","probe","numDirectionalShadows","numPointShadows","numSpotShadows","scaleFactor","i19","intensity","isAmbientLight","isLightProbe","sh","coefficients","isDirectionalLight","shadowUniforms","bias","normalBias","mapSize","directionalShadow","directionalLength","directionalShadowMatrix","isSpotLight","penumbra","spotShadow","isRectAreaLight","halfWidth","isPointLight","pointShadow","pointLength","pointShadowMatrix","isHemisphereLight","hemiLength","rectAreaLTC1","LTC_FLOAT_1","rectAreaLTC2","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","ambient","hash","$d81ab295f1227915$var$nextVersion","identity","matrix4","matrix42","$d81ab295f1227915$var$WebGLRenderState","lightsArray","shadowsArray","setupLights","setup","setupLightsView","setupView","pushLight","shadowLight","$d81ab295f1227915$var$WebGLRenderStates","renderStates","renderState","parameters5","source14","isMeshDepthMaterial","parameters4","source15","isMeshDistanceMaterial","$d81ab295f1227915$var$WebGLShadowMap","_objects","_capabilities","_frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterial","$d81ab295f1227915$var$MeshDepthMaterial","_distanceMaterial","$d81ab295f1227915$var$MeshDistanceMaterial","_materialCache","shadowMaterialVertical","shadow_pass","resolution","shadowMaterialHorizontal","HORIZONTAL_PASS","fullScreenTri","fullScreenMesh","blurSamples","renderBufferDirect","mapPass","getDepthMaterial","customMaterial","customDistanceMaterial","customDepthMaterial","keyA","keyB","materialsForVariant","cachedMaterial","renderObject","shadowCamera","kl","depthMaterial","autoUpdate","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","setBlending","setTest","setScissorTest","shadowFrameExtents","getFrameExtents","_maxTextureSize","isPointLightShadow","pars","viewportCount","getViewportCount","vp","getViewport","updateMatrices","getFrustum","VSMPass","locked","currentColorMask","currentColorClear","setMask","colorMask","setLocked","lock","currentDepthFunc","currentDepthClear","enable","disable","depthMask","currentDepthMask","setFunc","clearDepth","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZPass","currentStencilClear","stencilTest","stencilMask","currentStencilMask","currentStencilFunc","setOp","currentStencilZFail","stencilOp","stencil","clearStencil","currentBoundFramebuffers","glVersion","scissorParam","viewportParam","currentScissor","currentViewport","createTexture","texImage2D","emptyTextures","enabledCapabilities","equationToGL","MIN_EXT","MAX_EXT","currentBlendingEnabled","currentBlendEquation","currentBlendEquationAlpha","blendEquationSeparate","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","blendFuncSeparate","factorToGL","currentPremultipledAlpha","currentBlending","blendFunc","frontFace","cullFace","currentCullFace","setPolygonOffset","factor","currentPolygonOffsetFactor","currentPolygonOffsetUnits","webglSlot","currentTextureSlot","colorBuffer","framebuffer","xrFramebuffer","bindFramebuffer","useProgram","currentProgram","frontFaceCW","setFlipSided","setCullFace","setLineWidth","currentLineWidth","lineWidthAvailable","lineWidth","activeTexture","bindTexture","webglType","webglTexture","boundTexture","currentBoundTextures","unbindTexture","apply","texImage3D","currentFlipSided","_gl","utils","OffscreenCanvas","createCanvas","useOffscreenCanvas","resizeImage","needsPowerOfTwo","needsNewCanvas","maxSize","_canvas","isPowerOfTwo$1","textureNeedsGenerateMipmaps","supportsMips","generateMipmap","__maxMipLevel","log2","getInternalFormat","internalFormatName","glFormat","glType","filterFallback","__webglInit","textureProperties","__webglTexture","deallocateTexture","isVideoTexture","_videoTextures","onRenderTargetDispose","deleteTexture","renderTargetProperties","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__webglMultisampledFramebuffer","deleteFramebuffer","__webglColorRenderbuffer","__webglDepthRenderbuffer","i22","attachmentProperties","deallocateRenderTarget","slot","updateVideoTexture","__version","complete","uploadTexture","setTextureCube","isCompressedTexture","isCompressed","convert","glInternalFormat","cubeImage","mipmap","compressedTexImage2D","mipmapImage","uploadCubeTexture","wrappingToGL","filterToGL","setTextureParameters","textureType","texParameteri","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","initTexture","pixelStorei","textureNeedsPowerOfTwo","isDepthTexture","setupFrameBufferTexture","attachment","textureTarget","framebufferTexture2D","renderbuffer","isMultisample","getRenderTargetSamples","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","bindRenderbuffer","setupDepthRenderbuffer","isCube","webglDepthTexture","setupDepthTexture","createRenderbuffer","setupRenderBufferStorage","warnedTextureCube","textureUnits","textureUnit","resetTextureUnits","setTexture2D","setupRenderTarget","isMultipleRenderTargets","isRenderTarget3D","createFramebuffer","glTextureType","updateRenderTargetMipmap","updateMultisampleRenderTarget","blitFramebuffer","warnedTexture2D","HALF_FLOAT_OES","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","COMPRESSED_RGB8_ETC2","COMPRESSED_RGBA8_ETC2_EAC","UNSIGNED_INT_24_8_WEBGL","array26","cameras","isArrayCamera","$d81ab295f1227915$var$Group","isGroup","_targetRay","_grip","_hand","joints","inputState","pinching","hasLinearVelocity","linearVelocity","hasAngularVelocity","angularVelocity","getGripSpace","event3","inputSource2","frame1","referenceSpace","inputPose","gripPose","handPose","targetRay","grip","hand","inputSource1","visibilityState","getPose","targetRaySpace","transform","$d81ab295f1227915$var$_moveEvent","inputjoint","jointPose","getJointPose","jointName","joint","jointRadius","indexTip","thumbTip","distanceToPinch","threshold","handedness","gripSpace","renderer5","framebufferScaleFactor","referenceSpaceType","pose","glBinding","glFramebuffer","glProjLayer","glBaseLayer","glMultisampledFramebuffer","glColorRenderbuffer","glDepthRenderbuffer","xrFrame","depthStyle","clearStyle","controllers","inputSourcesMap","cameraL1","cameraR1","cameras1","cameraVR","$d81ab295f1227915$var$ArrayCamera","_currentDepthFar","onSessionEvent","controller","inputSource","onSessionEnd","disconnect","_currentDepthNear","bindXRFramebuffer","stop","isPresenting","onInputSourcesChange","inputSources","i23","removed","i24","added","cameraAutoUpdate","getController","$d81ab295f1227915$var$WebXRController","getTargetRaySpace","getControllerGrip","getHand","getHandSpace","setFramebufferScaleFactor","setReferenceSpaceType","getReferenceSpace","getBaseLayer","getBinding","getFrame","getContextAttributes","xrCompatible","makeXRCompatible","layerInit","antialias","XRWebGLLayer","updateRenderState","baseLayer","WebGLRenderingContext","depthFormat","projectionlayerInit","colorFormat","XRWebGLBinding","createProjectionLayer","textureWidth","textureHeight","requestReferenceSpace","cameraLPos","cameraRPos","updateCamera","depthNear","depthFar","i25","cameraL","cameraR","ipd","projL","projR","topFov","bottomFov","leftFov","rightFov","zOffset","xOffset","translateX","translateZ","setProjectionFromUnion","getCamera","getFoveation","fixedFoveation","setFoveation","foveation","onAnimationFrameCallback","getViewerPose","views","cameraVRNeedsUpdate","glSubImage","getViewSubImage","depthStencilTexture","colorTexture","invalidateFramebuffer","$d81ab295f1227915$var$WebGLMaterials","refreshUniformsCommon","maxMipLevel","uvScaleMap","uv2ScaleMap","refreshUniformsStandard","fogColor","isFog","fogNear","fogFar","fogDensity","density","pixelRatio","transmissionRenderTarget","isMeshLambertMaterial","refreshUniformsLambert","isMeshToonMaterial","refreshUniformsToon","isMeshPhongMaterial","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","isMeshMatcapMaterial","refreshUniformsMatcap","isMeshNormalMaterial","refreshUniformsNormal","isLineBasicMaterial","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","isSpriteMaterial","refreshUniformsSprites","isShadowMaterial","parameters6","display","$d81ab295f1227915$var$createCanvasElement","_context","_alpha","_depth","_stencil","_antialias","_premultipliedAlpha","_preserveDrawingBuffer","preserveDrawingBuffer","_powerPreference","powerPreference","_failIfMajorPerformanceCaveat","failIfMajorPerformanceCaveat","renderStateStack","domElement","debug","sortObjects","toneMappingExposure","_this","_isContextLost","_currentActiveCubeFace","_currentActiveMipmapLevel","_currentRenderTarget","_currentMaterialId","_pixelRatio","_opaqueSort","_transparentSort","_width","_height","_emptyScene","overrideMaterial","getTargetPixelRatio","textures1","renderLists","morphtargets","bufferRenderer","indexedBufferRenderer","contextNames","contextAttributes","contextName","onContextLost","onContextRestore","isWebGL1Renderer","shift","message","initGLContext","$d81ab295f1227915$var$WebGLUtils","$d81ab295f1227915$var$WebGLState","$d81ab295f1227915$var$WebGLProperties","$d81ab295f1227915$var$WebGLTextures","$d81ab295f1227915$var$WebGLBindingStates","$d81ab295f1227915$var$WebGLMorphtargets","programCache","$d81ab295f1227915$var$WebGLPrograms","$d81ab295f1227915$var$WebGLRenderLists","$d81ab295f1227915$var$WebXRManager","preventDefault","infoAutoReset","shadowMapAutoUpdate","shadowMapNeedsUpdate","onMaterialDispose","releaseProgram","releaseMaterialProgramReferences","forceContextLoss","loseContext","forceContextRestore","restoreContext","getPixelRatio","updateStyle","_currentViewport","setViewport","_scissor","_currentScissor","getScissorTest","_scissorTest","boolean","setOpaqueSort","method","bits","onXRSessionStart","onXRSessionEnd","_transmissionRenderTarget","hasPositions","hasNormals","hasUvs","hasColors","positionArray","normalArray","uvArray","setProgram","setMaterial","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","isLineSegments","isLineLoop","isSprite","currentRenderState","pushShadow","getProgram","projectObject","isLOD","intersectsSprite","_vector3","_projScreenMatrix","currentRenderList1","isImmediateRenderObject","renderScene","currentRenderList","opaqueObjects","transmissiveObjects","transparentObjects","needsAntialias","currentToneMapping","renderObjects","renderTransmissionPass","object7","renderBufferImmediate","renderObjectImmediate","getParameters","getProgramCacheKey","programCacheKey","lightsStateVersion","updateCommonMaterialProperties","onBuild","acquireProgram","needsLights","materialNeedsLights","ambientLightColor","lightProbe","directionalLights","directionalLightShadows","spotLights","rectAreaLights","ltc_1","ltc_2","pointLights","pointLightShadows","hemisphereLights","progUniforms","uniformsList","_clippingEnabled","_localClippingEnabled","_currentCamera","needsProgramChange","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","uCamPos","cameraPosition","boneTexture","computeBoneTexture","boneTextureSize","refreshFogUniforms","refreshMaterialUniforms","renderListStack","finish","onAfterRender","_currentScissorTest","_currentDrawBuffers","drawBuffersWEBGL","layer","framebufferTextureLayer","activeCubeFaceIndex","textureFormat","halfFloatSupportedByExt","checkFramebufferStatus","readPixels","copyFramebufferToTexture","level","levelScale","copyTexImage2D","copyTextureToTexture","srcTexture","dstTexture","texSubImage2D","compressedTexSubImage2D","copyTextureToTexture3D","sourceBox","glTarget","unpackRowLen","unpackImageHeight","unpackSkipPixels","unpackSkipRows","unpackSkipImages","texSubImage3D","compressedTexSubImage3D","resetState","$d81ab295f1227915$var$WebGLRenderer","__THREE_DEVTOOLS__","CustomEvent","detail","source16","recursive5","meta6","array24","stride1","value45","value39","source17","index110","attribute10","index26","value40","offset25","data10","arrayBuffers","_uuid","ib","setUsage","callback7","data6","isInterleavedBuffer","itemSize7","offset24","normalized7","interleavedBuffer","value41","m29","$d81ab295f1227915$var$_vector$6","m30","index42","x32","index27","y33","setZ","index28","z23","index29","w16","index30","index31","index32","index33","x27","y28","index34","index35","x28","y29","z21","index36","x29","y30","z22","w17","data7","interleavedBuffers","$d81ab295f1227915$var$InterleavedBufferAttribute","data8","$d81ab295f1227915$var$SpriteMaterial","source18","$d81ab295f1227915$var$_worldScale","$d81ab295f1227915$var$_mvPosition","$d81ab295f1227915$var$transformVertex","vertexPosition","mvPosition","$d81ab295f1227915$var$_rotatedPosition","$d81ab295f1227915$var$_alignedPosition","$d81ab295f1227915$var$_viewWorldMatrix","float32Array","$d81ab295f1227915$var$InterleavedBuffer","$d81ab295f1227915$var$_geometry","material10","raycaster5","intersects1","setFromMatrixScale","$d81ab295f1227915$var$_vA","$d81ab295f1227915$var$_vB","$d81ab295f1227915$var$_vC","$d81ab295f1227915$var$_uvC","$d81ab295f1227915$var$_intersectPoint","$d81ab295f1227915$var$_uvB","$d81ab295f1227915$var$_uvA","source19","bindMatrixInverse","skinWeight","force2","index37","target35","$d81ab295f1227915$var$_skinIndex","skinIndex","$d81ab295f1227915$var$_skinWeight","$d81ab295f1227915$var$_basePosition","boneIndex","$d81ab295f1227915$var$_matrix","boneInverses","$d81ab295f1227915$var$_vector$5","isBone","$d81ab295f1227915$var$DataTexture","data9","width15","height15","format2","type11","mapping7","wrapS2","wrapT2","magFilter2","minFilter2","anisotropy2","bones3","boneInverses1","boneMatrices","calculateInverses","inverse","bone","i26","il6","$d81ab295f1227915$var$_identityMatrix","$d81ab295f1227915$var$_offsetMatrix","$d81ab295f1227915$var$Skeleton","name23","fromJSON","json15","bones1","$d81ab295f1227915$var$Bone","boneInverse","$d81ab295f1227915$var$InstancedBufferAttribute","array25","itemSize6","normalized6","source21","geometry3","material4","count4","source22","getColorAt","index38","color23","index39","raycaster2","intersects2","raycastTimes","$d81ab295f1227915$var$_mesh$1","instanceId","getMatrixAt","$d81ab295f1227915$var$_instanceLocalMatrix","$d81ab295f1227915$var$_instanceWorldMatrix","raycast","$d81ab295f1227915$var$_instanceIntersects","index40","color13","setMatrixAt","index41","matrix8","linecap","linejoin","parameters7","source23","geometry4","material5","$d81ab295f1227915$var$LineBasicMaterial","updateMorphTargets","source24","lineDistances","$d81ab295f1227915$var$_start$1","$d81ab295f1227915$var$_end$1","isGeometry","raycaster3","intersects3","Line","$d81ab295f1227915$var$_sphere$1","$d81ab295f1227915$var$_inverseMatrix$1","localThreshold","localThresholdSq","vStart","vEnd","interSegment","interRay","$d81ab295f1227915$var$_ray$1","distanceSqToSegment","$d81ab295f1227915$var$_start","$d81ab295f1227915$var$_end","$d81ab295f1227915$var$Line","geometry5","material6","computeLineDistances","geometry6","material7","$d81ab295f1227915$var$PointsMaterial","parameters8","source25","$d81ab295f1227915$var$_inverseMatrix","geometry7","material8","source26","raycaster4","intersects4","Points","$d81ab295f1227915$var$_sphere","$d81ab295f1227915$var$_ray","$d81ab295f1227915$var$_position$2","$d81ab295f1227915$var$testPoint","intersects","intersectPoint","distanceToRay","rayPointDistanceSq","video","mapping3","wrapS3","wrapT3","magFilter3","minFilter3","format3","type7","anisotropy3","requestVideoFrameCallback","updateVideo","readyState","HAVE_CURRENT_DATA","mipmaps1","width12","height12","format4","type8","mapping4","wrapS4","wrapT4","magFilter4","minFilter4","anisotropy4","encoding3","canvas2","mapping5","wrapS5","wrapT5","magFilter5","minFilter5","format5","type9","anisotropy5","width13","height13","type10","mapping6","wrapS6","wrapT6","magFilter6","minFilter6","anisotropy6","format6","$d81ab295f1227915$var$Curve","arcLengthDivisions","getPoint","u5","optionalTarget16","getUtoTmapping","divisions8","getSpacedPoints","divisions1","getPointAt","lengths","getLengths","divisions2","cacheArcLengths","current","last","distance7","arcLengths","targetArcLength","comparison","lengthBefore","getTangent","t8","optionalTarget1","pt1","pt2","getTangentAt","optionalTarget2","segments","closed","binormals","vec","mat","MAX_VALUE","tz","i27","makeRotationAxis","source27","json1","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","t7","optionalTarget3","twoPi","deltaAngle","samePoints","source28","json2","isEllipseCurve","$d81ab295f1227915$var$ArcCurve","$d81ab295f1227915$var$EllipseCurve","aX1","aY1","aRadius","aStartAngle1","aEndAngle1","aClockwise1","$d81ab295f1227915$var$CubicPoly","c0","initCatmullRom","tension","initNonuniformCatmullRom","dt0","dt1","dt2","isArcCurve","$d81ab295f1227915$var$py","$d81ab295f1227915$var$pz","points4","closed1","curveType","t9","optionalTarget4","p3","intPoint","$d81ab295f1227915$var$tmp","$d81ab295f1227915$var$px","calc","source29","json3","$d81ab295f1227915$var$CatmullRom","$d81ab295f1227915$var$QuadraticBezierP1","$d81ab295f1227915$var$QuadraticBezierP2","$d81ab295f1227915$var$CubicBezierP1","$d81ab295f1227915$var$CubicBezierP2","$d81ab295f1227915$var$CubicBezierP3","isCatmullRomCurve3","t18","optionalTarget5","$d81ab295f1227915$var$CubicBezier","source30","json4","isCubicBezierCurve","v02","v114","v212","v310","t10","optionalTarget6","source31","json5","isCubicBezierCurve3","v115","v213","optionalTarget7","optionalTarget8","optionalTarget9","source32","json6","isLineCurve","$d81ab295f1227915$var$QuadraticBezierCurve","v03","v117","v215","optionalTarget12","$d81ab295f1227915$var$QuadraticBezier","source34","json8","isQuadraticBezierCurve","$d81ab295f1227915$var$QuadraticBezierCurve3","v04","v118","v216","t15","optionalTarget13","source35","json9","isQuadraticBezierCurve3","$d81ab295f1227915$var$SplineCurve","points5","t16","optionalTarget14","source36","json10","isSplineCurve","$d81ab295f1227915$var$CatmullRomCurve3","CubicBezierCurve","$d81ab295f1227915$var$CubicBezierCurve","$d81ab295f1227915$var$CubicBezierCurve3","LineCurve","$d81ab295f1227915$var$LineCurve","v214","v116","optionalTarget10","u4","optionalTarget11","source33","json7","$d81ab295f1227915$var$CurvePath","curves","autoClose","curve","endPoint","startPoint","t17","optionalTarget15","lens","getCurveLengths","updateArcLengths","cacheLengths","sums","getLength","divisions3","divisions4","isLineCurve3","pts","getPoints","source37","json11","$d81ab295f1227915$var$Curves","points6","points7","lineTo","y31","x30","y32","currentPoint","x31","aCPx","aCPy","aX2","aY2","aCP1x","aCP1y","aCP2x","aCP2y","aX3","aY3","npts","aStartAngle2","aEndAngle2","aClockwise2","aX4","aY4","aRadius1","aRadius2","aStartAngle3","aEndAngle3","aClockwise3","aX5","aY5","xRadius1","yRadius1","aStartAngle4","aEndAngle4","aClockwise4","aRotation1","aX6","aY6","xRadius2","yRadius2","aStartAngle5","aEndAngle5","aClockwise5","aRotation2","aX7","aY7","firstPoint","lastPoint","source38","json12","$d81ab295f1227915$var$Path","divisions5","holesPts","holes","divisions6","getPointsHoles","source39","hole","json13","holeIndices","dim","hasHoles","outerLen","outerNode","$d81ab295f1227915$var$linkedList","prev","invSize","queue","steiner","$d81ab295f1227915$var$getLeftmost","$d81ab295f1227915$var$compareX","$d81ab295f1227915$var$filterPoints","$d81ab295f1227915$var$eliminateHoles","clockwise","$d81ab295f1227915$var$signedArea","$d81ab295f1227915$var$insertNode","$d81ab295f1227915$var$equals","$d81ab295f1227915$var$area","ear","pass","$d81ab295f1227915$var$zOrder","nextZ","tail","numMerges","pSize","qSize","inSize","$d81ab295f1227915$var$indexCurve","$d81ab295f1227915$var$isEarHashed","$d81ab295f1227915$var$isEar","$d81ab295f1227915$var$splitEarcut","$d81ab295f1227915$var$earcutLinked","minTY","maxTX","maxTY","minTX","prevZ","$d81ab295f1227915$var$pointInTriangle","$d81ab295f1227915$var$cureLocalIntersections","$d81ab295f1227915$var$intersects","$d81ab295f1227915$var$locallyInside","$d81ab295f1227915$var$removeNode","$d81ab295f1227915$var$isValidDiagonal","$d81ab295f1227915$var$splitPolygon","$d81ab295f1227915$var$eliminateHole","hx","hy","mx","my","tanMin","$d81ab295f1227915$var$sectorContainsSector","$d81ab295f1227915$var$findHoleBridge","inside","px","py","$d81ab295f1227915$var$onSegment","$d81ab295f1227915$var$sign","num","$d81ab295f1227915$var$Node$2","an","bp","holes1","$d81ab295f1227915$var$removeDupEndPts","holeIndex","$d81ab295f1227915$var$addContour","$d81ab295f1227915$var$Earcut","i28","faces","contour","$d81ab295f1227915$var$ExtrudeGeometry","shapes2","$d81ab295f1227915$var$Shape","options14","verticesArray","i31","addShape","placeholder","curveSegments","steps","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","$d81ab295f1227915$var$WorldUVGenerator","amount","pt","vlen","flen","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","sf","v_trans_lensq","direction_eq","contourMovements","i33","contour3","j1","k1","holesMovements","oneHoleMovements","verticesMovements","concat","bs","i29","vert","scalePt2","extrudeByPath","splineTube","binormal","extrudePts","s17","i30","hl","ahole","sidewalls","layeroffset","sl","slen1","slen2","f4","addUV","f3","buildLidFaces","buildSideFaces","computeVertexNormals","$d81ab295f1227915$var$toJSON$1","data11","shapes1","geometryShapes","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","shapes4","i38","indexOffset","extractPoints","shapeVertices","shapeHoles","$d81ab295f1227915$var$ShapeUtils","isClockWise","reverse","i36","l6","vertex","i37","l7","$d81ab295f1227915$var$toJSON","data12","shapes3","$d81ab295f1227915$var$ShapeGeometry","$d81ab295f1227915$var$ShadowMaterial","parameters9","source40","parameters10","STANDARD","source41","$d81ab295f1227915$var$MeshStandardMaterial","$d81ab295f1227915$var$MeshPhysicalMaterial","parameters11","PHYSICAL","value42","value43","value44","source42","parameters12","source43","parameters13","source44","parameters14","source45","parameters15","source46","parameters16","MATCAP","source47","parameters17","source48","to","$d81ab295f1227915$var$AnimationUtils","isTypedArray","forceClone","ArrayBuffer","isView","DataView","times","nValues","srcOffset","jsonKeys","valuePropertyName","sourceClip","startFrame","endFrame","fps","clip","tracks","track","valueSize","getValueSize","convertArray","minStartTime","i39","i40","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","referenceOffset","referenceValueSize","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","targetOffset","targetValueSize","referenceValue","endIndex","arraySlice","interpolant","evaluate","resultBuffer","numTimes","valueStart","multiplyQuaternionsFlat","valueEnd","blendMode","$d81ab295f1227915$var$Interpolant","parameterPositions","sampleValues","sampleSize","_cachedIndex","settings","DefaultSettings_","t27","pp","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","validate_interval","t1global","beforeStart_","mid","intervalChanged_","interpolate_","getSettings_","copySampleValue_","index43","parameterPositions1","sampleValues1","sampleSize1","resultBuffer1","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","i110","t04","t113","iPrev","iNext","tPrev","tNext","halfDt","i111","t01","t19","t110","o1","o0","oP","oN","wP","wN","ppp","sP","sN","parameterPositions2","sampleValues2","sampleSize2","resultBuffer2","t02","t20","t111","i112","offset0","weight1","weight0","sampleValues3","sampleSize3","resultBuffer3","i113","name28","times1","values4","interpolation2","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","track1","json","trackType","getInterpolation","interpolation","result5","$d81ab295f1227915$var$DiscreteInterpolant","result2","$d81ab295f1227915$var$LinearInterpolant","result3","$d81ab295f1227915$var$CubicInterpolant","interpolation1","factoryMethod","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodSmooth","InterpolantFactoryMethodLinear","timeOffset","timeScale","startTime","endTime","nKeys","valid","prevTime","currTime","writeIndex","keep","smoothInterpolation","offsetP","offsetN","readOffset","writeOffset","TypedKeyframeTrack","$d81ab295f1227915$var$BooleanKeyframeTrack","$d81ab295f1227915$var$KeyframeTrack","$d81ab295f1227915$var$ColorKeyframeTrack","$d81ab295f1227915$var$NumberKeyframeTrack","$d81ab295f1227915$var$QuaternionLinearInterpolant","parameterPositions4","sampleValues4","sampleSize4","resultBuffer4","i114","t03","t21","t112","slerpFlat","$d81ab295f1227915$var$QuaternionKeyframeTrack","result4","$d81ab295f1227915$var$StringKeyframeTrack","$d81ab295f1227915$var$VectorKeyframeTrack","$d81ab295f1227915$var$AnimationClip","name24","duration","tracks1","json14","jsonTracks","frameTime","$d81ab295f1227915$var$parseKeyframeTrack","clip7","clipTracks","name25","morphTargetSequence","noLoop","numMorphTargets","getKeyframeOrder","sortedArray","objectOrClipArray","name26","clipArray","fps1","noLoop1","animationToMorphTargets","pattern","animationMorphTargets","clips","CreateFromMorphTargetSequence","bones2","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","addNonemptyTrack","validate","optimize","typeName","$d81ab295f1227915$var$getTrackTypeForValueTypeName","$d81ab295f1227915$var$Cache","files","file","onLoad8","onProgress12","onError8","urlModifier","isLoading","itemsLoaded","itemsTotal","handlers","onStart","itemEnd","onProgress","onLoad","itemError","onError","resolveURL","setURLModifier","addHandler","regex","loader","removeHandler","getHandler","global","manager","$d81ab295f1227915$var$DefaultLoadingManager","crossOrigin","withCredentials","resourcePath","requestHeader","load","url8","onProgress1","resolve","reject","value48","path6","setResourcePath","$d81ab295f1227915$var$FileLoader","$d81ab295f1227915$var$Loader","manager1","url1","onLoad1","onProgress2","onError1","itemStart","setTimeout","$d81ab295f1227915$var$loading","dataUriRegexResult","request","mimeType","isBase64","decodeURIComponent","atob","response","responseType","Blob","parser","DOMParser","parseFromString","XMLHttpRequest","open","callbacks","status","overrideMimeType","header","setRequestHeader","send","setResponseType","value46","value47","manager2","url2","onLoad2","onProgress3","onError2","onImageLoad","onImageError","$d81ab295f1227915$var$CubeTextureLoader","manager3","onLoad3","onProgress4","onError3","$d81ab295f1227915$var$ImageLoader","setCrossOrigin","setPath","loaded","loadTexture","urls1","$d81ab295f1227915$var$DataTextureLoader","manager4","url3","onLoad4","onProgress5","onError4","setWithCredentials","texData","mipmapCount","manager5","url4","onLoad5","onProgress6","onError5","color14","source49","meta7","$d81ab295f1227915$var$Light","intensity1","source50","camera4","_frameExtents","_viewportCount","_viewports","light3","shadowMatrix","$d81ab295f1227915$var$_lightPositionWorld$1","$d81ab295f1227915$var$_lookTarget$1","$d81ab295f1227915$var$_projScreenMatrix$1","viewportIndex","source51","$d81ab295f1227915$var$LightShadow","light1","source52","isSpotLightShadow","color15","intensity2","distance5","angle13","$d81ab295f1227915$var$SpotLightShadow","power","source53","_cubeDirections","_cubeUps","light2","viewportIndex1","$d81ab295f1227915$var$_lightPositionWorld","$d81ab295f1227915$var$_lookTarget","$d81ab295f1227915$var$_projScreenMatrix","color16","intensity3","distance6","decay1","$d81ab295f1227915$var$PointLightShadow","power1","source54","$d81ab295f1227915$var$PointLight","$d81ab295f1227915$var$DirectionalLightShadow","isDirectionalLightShadow","$d81ab295f1227915$var$DirectionalLight","color17","intensity4","source55","color18","intensity5","color19","intensity6","width14","height14","power2","source56","meta8","target33","normal8","coeff","normal5","target34","sh1","s19","s18","sh2","alpha10","sh3","sh4","array32","offset47","array27","offset26","normal6","shBasis","isSphericalHarmonics3","sh5","$d81ab295f1227915$var$SphericalHarmonics3","intensity7","source57","json18","meta9","array28","TextDecoder","decode","fromCharCode","escape","url5","source58","createImageBitmap","fetch","options16","url6","onLoad6","onProgress7","onError6","fetchOptions","credentials","headers","then","blob","colorSpaceConversion","imageBitmap","isImageBitmapLoader","$d81ab295f1227915$var$_context","AudioContext","webkitAudioContext","manager7","url7","onLoad7","onProgress8","onError7","bufferCopy","$d81ab295f1227915$var$AudioContext","decodeAudioData","audioBuffer","$d81ab295f1227915$var$LightProbe","skyColor1","groundColor1","intensity8","sky","ground","isHemisphereLightProbe","color20","intensity9","isAmbientLightProbe","binding","valueSize1","mixFunctionAdditive","setIdentity","mixFunction","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","_workIndex","_select","_setAdditiveIdentityOther","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","referenceCount","accuIndex","weight3","currentWeight","cumulativeWeight","mix","_mixBufferRegion","_addIndex","accuIndex1","weightAdditive","cumulativeWeightAdditive","originalValueOffset","_origIndex","getValue","targetIndex","t22","stride6","buffer21","dstOffset3","srcOffset2","t23","buffer1","buffer2","dstOffset4","srcOffset3","t24","stride2","workOffset","buffer3","dstOffset5","srcOffset4","t25","stride3","buffer4","dstOffset6","srcOffset5","t26","stride4","$d81ab295f1227915$var$_wordCharOrDot","source","$d81ab295f1227915$var$_propertyRe","$d81ab295f1227915$var$_directoryRe","$d81ab295f1227915$var$_nodeRe","$d81ab295f1227915$var$_objectRe","rootNode1","path2","parsedPath","$d81ab295f1227915$var$PropertyBinding","parseTrackName","findNode","rootNode","_getValue_unbound","_setValue_unbound","root4","path3","parsedPath1","isAnimationObjectGroup","Composite","name27","$d81ab295f1227915$var$_reservedRe","$d81ab295f1227915$var$_trackRe","matches","results","objectName","objectIndex","propertyIndex","lastDot","substring","$d81ab295f1227915$var$_supportedObjectNames","root1","getBoneByName","childNode","searchNodeSubtree","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","buffer5","offset29","targetObject","buffer6","offset30","resolvedProperty","buffer7","offset31","buffer8","offset32","buffer9","offset33","buffer10","offset34","buffer11","offset35","buffer12","offset36","dest","buffer13","offset37","buffer14","offset38","buffer15","offset39","buffer16","offset40","buffer17","offset41","buffer18","offset42","buffer19","offset43","buffer20","offset44","targetArray","offset45","bind","sourceArray1","offset46","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","targetGroup","path1","optionalParsedPath","_targetGroup","_bindings","subscribe_","offset27","nCachedObjects_","firstValidIndex","array29","offset28","bindings","array30","_getValue_array","_getValue_arrayElement","_getValue_toArray","_setValue_direct","_setValue_direct_setNeedsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","_setValue_array","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","$d81ab295f1227915$var$AnimationAction","mixer","clip1","localRoot","blendMode1","_clip","_localRoot","nTracks","interpolants","interpolantSettings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_weightInterpolant","loop","_startTime","_effectiveTimeScale","_effectiveWeight","paused","clampWhenFinished","zeroSlopeAtStart","_mixer","_activateAction","_deactivateAction","_loopCount","stopFading","stopWarping","_isActiveAction","startAt","time6","setLoop","repetitions","weight2","duration1","_scheduleFading","duration2","fadeOutAction","duration3","warp","fadeOut","fadeIn","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","duration4","warp1","crossFadeFrom","weightInterpolant","_takeBackControlInterpolant","timeScale1","getEffectiveTimeScale","duration5","action","duration6","startTimeScale","endTimeScale","duration7","now","_timeScaleInterpolant","_lendControlInterpolant","timeScaleInterpolant","_root","time1","deltaTime","timeDirection","accuIndex2","_updateWeight","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","accumulateAdditive","j2","accumulate","time2","interpolantValue","time3","deltaTime1","loopCount","pingPong","_setEndings","handle_stop","loopDelta","pending","atStart","atEnd","zeroSlopeAtEnd","duration8","weightNow","weightThen","$d81ab295f1227915$var$AnimationMixer","root2","_initMemoryManager","_accuIndex","_bindAction","action1","prototypeAction","root","rootUuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","_addInactiveBinding","$d81ab295f1227915$var$PropertyMixer","create","action2","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","useCount","_lendBinding","saveOriginalState","_lendAction","action3","restoreOriginalState","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","stats","actions","total","inUse","controlInterpolants","action4","action5","actionsByClip","actionByRoot","_removeInactiveAction","action6","lastInactiveAction","cacheIndex","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","action7","_removeInactiveBinding","action8","prevIndex","lastActiveIndex","firstInactiveAction","action9","firstInactiveIndex","lastActiveAction","binding1","rootUuid1","trackName1","bindingByName","binding2","propBinding","lastInactiveBinding","binding3","firstInactiveBinding","binding4","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","interpolant1","lastActiveInterpolant","clipAction","clip2","optionalRoot","blendMode2","clipObject","findByName","existingAction","newAction","clip3","optionalRoot1","stopAllAction","deltaTime2","nActions","_update","nBindings","i41","timeInSeconds","uncacheClip","clip4","actionsToRemove","uncacheRoot","root3","clip5","optionalRoot2","array31","stride5","meshPerAttribute1","source59","data14","data13","isInstancedInterleavedBuffer","$d81ab295f1227915$var$ascSort","$d81ab295f1227915$var$intersectObject","recursive","$d81ab295f1227915$var$Spherical","radius4","phi1","theta6","phi2","theta7","radius5","other","EPS","setFromVector3","v48","setFromCartesianCoords","x34","y34","z24","material9","colorArray","$d81ab295f1227915$var$_vector$2","$d81ab295f1227915$var$_boneMatrix","$d81ab295f1227915$var$_matrixWorldInv","$d81ab295f1227915$var$getBoneList","boneList","$d81ab295f1227915$var$_int32View","$d81ab295f1227915$var$_floatView","$d81ab295f1227915$var$DataUtils","val1","construct","fromPoints","$d81ab295f1227915$var$LineSegments","divisions7","color110","color22","setColors","object9","isSkeletonHelper","force3","extractUrlBase","$d81ab295f1227915$var$LoaderUtils","Handlers","optionalTarget","empty","isIntersectionBox","box","isIntersectionSphere","sphere","setFromMatrix","flattenToArrayOffset","multiplyVector3","multiplyVector3Array","applyToBufferAttribute","applyToVector3Array","getInverse","extractPosition","getPosition","setRotationFromQuaternion","multiplyToArray","multiplyVector4","rotateAxis","crossVector","rotateZ","rotateByAxis","makeFrustum","isIntersectionLine","line","isIntersectionPlane","area","barycoordFromPoint","midpoint","prototypenormal","extractAllPoints","divisions","extrude","makeGeometry","distanceToManhattan","manhattanDistanceTo","lengthManhattan","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","applyProjection","getChildByName","getObjectByName","renderDepth","axis","getWorldRotation","applyMatrix","setDrawMode","initBones","setLens","focalLength","setFocalLength","shadowMapHeight","defineProperties","dynamic","setDynamic","copyIndicesArray","setArray","addIndex","addAttribute","addDrawCall","clearDrawCalls","computeOffsets","getArrays","addShapeList","overdraw","clearTarget","animate","getCurrentRenderTarget","getPrecision","resetGLState","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","initMaterial","addPrePlugin","addPostPlugin","updateShadowMap","setFaceCulling","allocTextureUnit","setTexture","getActiveMipMapLevel","gammaOutput","renderReverseSided","listener3","gain","createGain","connect","getInput","autoplay","detune","loopStart","loopEnd","playbackRate","isPlaying","hasPlaybackControl","sourceType","_startedAt","_progress","_connected","filters","audioNode","mediaElement","createMediaElementSource","mediaStream","createMediaStreamSource","setBuffer","play","delay","currentTime","createBufferSource","onended","onEnded","setDetune","setPlaybackRate","pause","getOutput","setFilters","value55","value49","setTargetAtTime","getFilters","value50","value51","value52","value53","value54","$d81ab295f1227915$var$AudioLoader","updateCubeMap","$d81ab295f1227915$var$TextureLoader","loadTextureCube","urls","loadCompressedTextureCube","revision","__THREE__","$d81ab295f1227915$var$DRACOWorker","decoderConfig","decoderPending","decodeAttribute","draco","decoder","dracoGeometry","attributeName","attributeType","numComponents","num_components","numValues","num_points","byteLength","dataType","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","getDracoDataType","ptr","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","_free","onModuleLoaded","DracoDecoderModule","taskConfig","module","Decoder","decoderBuffer","Init","attributeIDs","attributeTypes","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","decodingStatus","DecodeBufferToMesh","geometryType","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","error_msg","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","numIndices","decodeIndex","postMessage","manager9","dracoLoader","ktx2Loader","meshoptDecoder","register","$d81ab295f1227915$var$GLTFMaterialsClearcoatExtension","$d81ab295f1227915$var$GLTFTextureBasisUExtension","$d81ab295f1227915$var$GLTFTextureWebPExtension","$d81ab295f1227915$var$GLTFMaterialsTransmissionExtension$1","$d81ab295f1227915$var$GLTFMaterialsVolumeExtension$1","$d81ab295f1227915$var$GLTFMaterialsIorExtension","$d81ab295f1227915$var$GLTFMaterialsSpecularExtension","$d81ab295f1227915$var$GLTFLightsExtension","$d81ab295f1227915$var$GLTFMeshoptCompression","onLoad9","onProgress10","onError9","url10","gltf","_onError","setDDSLoader","callback8","pluginCallbacks","callback9","path5","onLoad10","onError10","plugins","data16","decodeText","$d81ab295f1227915$var$BINARY_EXTENSION_HEADER_MAGIC","$d81ab295f1227915$var$EXTENSIONS","KHR_BINARY_GLTF","$d81ab295f1227915$var$GLTFBinaryExtension","asset","$d81ab295f1227915$var$GLTFParser","fileLoader","plugin","extensionsUsed","i42","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","$d81ab295f1227915$var$GLTFMaterialsUnlitExtension$1","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","$d81ab295f1227915$var$GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","$d81ab295f1227915$var$GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","$d81ab295f1227915$var$GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","$d81ab295f1227915$var$GLTFMeshQuantizationExtension","setExtensions","setPlugins","$d81ab295f1227915$var$GLTFRegistry","KHR_MATERIALS_SPECULAR","EXT_MESHOPT_COMPRESSION","parser12","KHR_LIGHTS_PUNCTUAL","refs","uses","_markDefs","nodeDefs","nodes","nodeLength","nodeDef","_addNodeRef","_loadLight","lightIndex","dependency","lightDef","lightNode","$d81ab295f1227915$var$SpotLight","innerConeAngle","outerConeAngle","createUniqueName","createNodeAttachment","_getNodeRef","getMaterialType","extendParams","materialParams","materialDef","parser1","metallicRoughness","pbrMetallicRoughness","baseColorFactor","baseColorTexture","assignTexture","all","parser2","KHR_MATERIALS_CLEARCOAT","extendMaterialParams","materialIndex2","materialParams1","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","parser3","KHR_MATERIALS_TRANSMISSION","materialIndex4","materialParams2","transmissionFactor","transmissionTexture","parser4","KHR_MATERIALS_VOLUME","materialIndex5","materialIndex6","materialParams3","thicknessFactor","thicknessTexture","parser5","KHR_MATERIALS_IOR","materialIndex7","materialIndex8","materialParams4","parser6","materialIndex9","materialIndex10","materialParams5","specularFactor","specularTexture","specularColorFactor","specularColorTexture","parser7","KHR_TEXTURE_BASISU","textureIndex","textureDef","loadTextureImage","parser8","EXT_TEXTURE_WEBP","isSupported","textureIndex1","textureLoader","uri","handler","detectSupport","Image","onload","onerror","parser9","index48","bufferView","bufferViews","extensionDef","getDependency","supported","ready","byteOffset","byteStride","data15","body","headerView","magic","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","$d81ab295f1227915$var$BINARY_EXTENSION_CHUNK_TYPES","contentArray","json16","dracoLoader1","preload","primitive1","parser10","gltfAttributeMap","$d81ab295f1227915$var$ATTRIBUTES","threeAttributeName","attributeName1","accessorDef","accessors","componentType","$d81ab295f1227915$var$WEBGL_COMPONENT_TYPES","bufferViewIndex","decodeDracoFile","attributeNormalizedMap","attributeTypeMap","transform1","texture7","$d81ab295f1227915$var$GLTFMeshStandardSGMaterial","params1","isGLTFSpecularGlossinessMaterial","specularMapParsFragmentChunk","glossinessMapParsFragmentChunk","specularMapFragmentChunk","lightPhysicalFragmentChunk","glossiness","glossinessMap","uniformName","glossinessMapFragmentChunk","USE_SPECULARMAP","USE_GLOSSINESSMAP","USE_UV","source63","specularGlossinessParams","materialParams6","materialDef1","parser11","pbrSpecularGlossiness","diffuseFactor","diffuseTexture","specGlossMapDef","materialParams7","parameterPositions5","sampleValues5","sampleSize5","resultBuffer5","index44","$d81ab295f1227915$var$GLTFCubicSplineInterpolant","td","m0","i116","t30","$d81ab295f1227915$var$_q","$d81ab295f1227915$var$WEBGL_CONSTANTS$1","$d81ab295f1227915$var$resolveURL","knownExtensions","objectDef","gltfExtensions","gltfDef","extras","meshDef","targetNames","$d81ab295f1227915$var$createPrimitiveKey","primitiveDef","dracoExtension","geometryKey","$d81ab295f1227915$var$createAttributesKey","attributesKey","$d81ab295f1227915$var$getNormalizedComponentScale$1","json17","associations","primitiveCache","meshCache","cameraCache","lightCache","textureCache","nodeNamesUsed","$d81ab295f1227915$var$ImageBitmapLoader","ext","_invokeAll","beforeRoot","getDependencies","dependencies","afterRoot","skinDefs","skins","meshDefs","meshes","skinLength","skin","cache3","index45","cache1","index46","object10","original","mappings","entries","updateMappings","func2","func1","type13","index47","loadScene","loadNode","_invokeOne","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","type12","defs","def","bufferIndex","bufferDef","bufferViewIndex1","bufferViewDef","accessorIndex1","sparse","pendingBufferViews","$d81ab295f1227915$var$WEBGL_TYPE_SIZES","TypedArray","elementBytes","bufferAttribute","itemBytes","ibSlice","ibCacheKey","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","textureIndex2","textureIndex3","source61","loader1","sampler","URL","webkitURL","sourceURI1","isObjectURL","createObjectURL","promise","sourceURI","revokeObjectURL","samplers","$d81ab295f1227915$var$WEBGL_FILTERS","$d81ab295f1227915$var$WEBGL_WRAPPINGS","catch","materialParams8","mapName","mapDef","texCoord","gltfReference","extendTexture","mesh1","useVertexColors","pointsMaterial","lineMaterial","useDerivativeTangents","useFlatShading","materialIndex11","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","materialType","alphaMode","$d81ab295f1227915$var$ALPHA_MODES","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","createMaterial","$d81ab295f1227915$var$assignExtrasToUserData","$d81ab295f1227915$var$addUnknownExtensionsToUserData","originalName","sanitizedName","sanitizeNodeName","createDracoPrimitive","primitive","decodePrimitive","$d81ab295f1227915$var$addPrimitiveAttributes","primitives","geometryPromise","meshIndex","i46","il10","loadGeometries","$d81ab295f1227915$var$SkinnedMesh","$d81ab295f1227915$var$toTrianglesDrawMode","$d81ab295f1227915$var$LineLoop","$d81ab295f1227915$var$Points","$d81ab295f1227915$var$updateMorphTargets","assignFinalMaterial","i44","il8","i45","il9","cameraIndex","cameraDef","$d81ab295f1227915$var$MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","accessor","animationIndex","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","il11","animationDef","channels","i47","input","pendingTargets","inputAccessors","outputAccessors","targets","inputAccessor","outputAccessor","$d81ab295f1227915$var$PATH_PROPERTIES$1","targetName","$d81ab295f1227915$var$INTERPOLATION","outputArray","scaled","$d81ab295f1227915$var$GLTFCubicSplineQuaternionInterpolant","nodeIndex1","nodeIndex2","meshPromise","createNodeMesh","translation","sceneIndex","node2","reducedAssociations","$d81ab295f1227915$var$buildNodeHierarchy","nodeId","parentObject","pendingJoints","jointNodes","jointNode","assignAttributeAccessor","accessorIndex","gltfAttributeName","accessor1","POSITION","boxScale","maxDisplacement","hasMorphPosition","hasMorphNormal","NORMAL","pendingPositionAccessors","i43","il7","pendingAccessor","pendingNormalAccessors","morphPositions","$d81ab295f1227915$var$addMorphTargets","drawMode","getIndex","numberOfTriangles","newIndices","newGeometry","$d81ab295f1227915$var$WorkerPool","pool","workers","workersResolve","workerStatus","_initWorker","workerId2","worker","workerCreator","_onMessage","workerId1","msg2","msg","transfer","setWorkerCreator","pool1","msg1","workerId","_getIdleWorker","terminate","manager10","transcoderPath","transcoderBinary","transcoderPending","workerPool","workerSourceURL","workerConfig","MSC_TRANSCODER","setWorkerLimit","astcSupported","etc1Supported","etc2Supported","dxtSupported","jsLoader","jsContent1","loadAsync","binaryLoader","binaryContent1","jsContent","binaryContent","fn","$d81ab295f1227915$var$KTX2Loader","BasisWorker","TranscoderFormat","BasisFormat","Worker","config","url12","onProgress11","onError12","$d81ab295f1227915$var$CompressedTexture","$d81ab295f1227915$var$_taskCache","_texture","transcodeResult","dfdTransferFn","dfdFlags","buffers1","config1","texturePending","_createTextureFrom","$d81ab295f1227915$var$_a$b","$d81ab295f1227915$var$_b$a","EngineFormat","RGB_PVRTC_4BPPV1_Format","wasmBinary","BasisModule","onRuntimeInitialized","BASIS","initializeBasis","KTX2File","hasAlpha","ktx2File","cleanup","close","isValid","getHeight","getHasAlpha","getDFDTransferFunc","getDFDFlags","basisFormat","engineFormat","transcoderFormat","mipWidth","mipHeight","transcode","FORMAT_OPTIONS","if","RGBA_ASTC_4x4_Format","priorityETC1S","priorityUASTC","ETC1S","UASTC_4x4","RGB_ETC2_Format","RGBA_ETC2_EAC_Format","ETC1","RGB_ETC1_Format","PVRTC1_4_RGBA","UASTC_OPTIONS","isPowerOfTwo","$d81ab295f1227915$var$$retainerCount","$d81ab295f1227915$var$$cache","cache2","evictionThreshold","value56","$d81ab295f1227915$var$$evict","$d81ab295f1227915$var$$evictionThreshold","key5","$d81ab295f1227915$var$$recentlyUsed","key3","recentlyUsedIndex","release","key4","variantNames","variant","variants","table","$d81ab295f1227915$var$GLTFMaterialsVariantsExtension","parser13","gltf7","knownNames","uniqueName","uniqueNames","$d81ab295f1227915$var$ensureUniqueNames","scenes","association","primitivesDef","extensionsDef","variantMaterials","$d81ab295f1227915$var$mappingsArrayToTable","$d81ab295f1227915$var$cache","$d81ab295f1227915$var$preloaded","$d81ab295f1227915$var$dracoDecoderLocation","$d81ab295f1227915$var$dracoLoader","manager8","decoderPath","decoderBinary","defaultAttributeTypes","path4","config2","workerLimit","url11","onLoad12","onProgress9","useUniqueIDs","decodeGeometry","buffer23","callback11","attributeIDs1","defaultAttributeIDs","buffer22","taskConfig1","$d81ab295f1227915$var$_taskCache$1","cachedTask","taskKey","taskID","workerNextTaskID","taskCost","geometryPending","_getWorker","_worker","_callbacks","_releaseTask","geometryData","url9","_initDecoder","useJS","WebAssembly","librariesPending","_loadLibrary","libraries","_taskCosts","_taskLoad","onmessage","worker1","taskID1","$d81ab295f1227915$var$meshoptDecoder","$d81ab295f1227915$var$$loader","$d81ab295f1227915$var$$evictionPolicy","$d81ab295f1227915$var$$GLTFInstance","GLTFInstance","setDRACOLoader","setKTX2Loader","$d81ab295f1227915$var$ktx2Loader","url15","setDecoderPath","url13","setTranscoderPath","url14","$d81ab295f1227915$var$meshoptDecoderLocation","script","MeshoptDecoder","_value","url20","url16","gltfLoads","element9","url18","setMeshoptDecoder","rawGLTFLoads","$d81ab295f1227915$var$loadWithLoader","progress","progressCallback","gltfInstanceLoads","rawGLTF","prepare","preparedGLTF","url19","element7","progressCallback1","retain","disposed","originalDispose","$d81ab295f1227915$var$_a$a","$d81ab295f1227915$var$CacheEvictionPolicy","$d81ab295f1227915$var$CachingGLTFLoader","element8","userSelect","Element","source62","isCSS2DObject","_widthHalf","_heightHalf","$d81ab295f1227915$var$_vector","$d81ab295f1227915$var$_viewProjectionMatrix","getDistanceToSquared","$d81ab295f1227915$var$_a$9","$d81ab295f1227915$var$_b$8","overflow","sorted","filterAndFlatten","distanceToCameraSquared","zIndex","zMax","missingApis","$d81ab295f1227915$var$toFullUrl","partialUrl","ms","timer","args","clearTimeout","$d81ab295f1227915$var$clamp","lowerLimit","upperLimit","$d81ab295f1227915$var$resolveDpr","metas","head","meta","HAS_META_VIEWPORT_TAG","devicePixelRatio","$d81ab295f1227915$var$isDebugMode","debugQueryParameter","ModelViewerElement","debugMode","search","$d81ab295f1227915$var$Damper","decayMilliseconds","velocity","naturalFrequency","setDecayTime","decayMilliseconds1","x33","xGoal","timeStepMilliseconds","xNormalization","nilSpeed","newVelocity","intermediateX","$d81ab295f1227915$var$numberNode","number","$d81ab295f1227915$var$parseExpressions","inputString","expressions","parseIterations","expressionParseResult","$d81ab295f1227915$var$parseExpression","expression","terms","remainingInput","IS_IDENT_RE","IS_OPERATOR_RE","IS_EXPRESSION_END_RE","$d81ab295f1227915$var$parseFunctionArguments","identParseResult","$d81ab295f1227915$var$parseIdent","identNode","$d81ab295f1227915$var$parseHex","$d81ab295f1227915$var$parseNumber","NOT_IDENT_RE","VALUE_RE","UNIT_RE","ALLOWED_UNITS","valueMatch","unitMatch","hexMatch","HEX_RE","expressionNodes","$d81ab295f1227915$var$$visitedTypes","callback10","remaining","ast2","$d81ab295f1227915$var$degreesToRadians","numberNode","fallbackRadianValue","$d81ab295f1227915$var$lengthToBaseMeters","fallbackMeterValue","$d81ab295f1227915$var$normalizeUnit","unitNormalizers","rad","deg","mm","cm","fallback","$d81ab295f1227915$var$ZERO","$d81ab295f1227915$var$CSS2DObject","config3","initialized","pivot","classList","updateNormal","facingCamera","contains","show","updateVisibility","updatePosition","position3","setComponent","positionNodes","normal7","normalNodes","assignedNodes","ELEMENT_NODE","visibilityAttribute","dataset","model","func","initialValue","$d81ab295f1227915$var$getNormalizedComponentScale","$d81ab295f1227915$var$Shadow","scene8","softness","shadowMaterial","shadowScale","isAnimated","setScene","scene4","softness1","side1","animationNames","maxDimension","expandByVector","subScalar","shadowOffset","setSoftness","softness2","setMapSize","maxMapSize","heightPad","setScaleAndOffset","widthPad","setIntensity","intensity10","radiansY","scale4","offset50","sizeY","setScalar","$d81ab295f1227915$var$DEFAULT_FOV_DEG","$d81ab295f1227915$var$DEFAULT_HALF_FOV","origin2","direction5","near8","far8","LOD","Sprite","direction6","origin3","setFromCamera","coords","camera3","unproject","intersectObject","object8","recursive6","intersects7","intersectObjects","objects1","recursive7","intersects6","$d81ab295f1227915$var$Scene","canvas1","element12","$d81ab295f1227915$var$CSS2DRenderer","xrCamera","modelContainer","idealCameraDistance","fieldOfViewAspect","framedFieldOfView","shadowIntensity","shadowSoftness","exposure","canScale","tightBounds","isDirty","goalTarget","targetDamperX","targetDamperY","targetDamperZ","_currentGLTF","cancelPendingSourceChange","animationsByName","currentAnimationAction","setSize","annotationRenderer","pointerEvents","shadowRoot","schemaElement","setupScene","url24","progressCallback2","externalRenderer","framingInfo","framedRadius","$d81ab295f1227915$var$SAFE_RADIUS_RATIO","frameModel","$d81ab295f1227915$var$$renderer","updateBoundingBox","getTarget","updateShadow","setShadowIntensity","queueRender","width16","height16","dpr","resize","center5","$d81ab295f1227915$var$reduceVertices","radiusXZ","$d81ab295f1227915$var$DEFAULT_TAN_FOV","vertical","clientX1","clientY1","$d81ab295f1227915$var$ndc","screen","rect","getBoundingClientRect","modelX","modelY","modelZ","decayMilliseconds2","$d81ab295f1227915$var$vector3$1","updateTarget","delta4","goal","setShadowRotation","yaw","worldX","worldZ","setTime","value60","animationTime","getClip","hasActiveAnimation","playAnimation","name30","crossfadeTime","animationClip","lastAnimationAction","step1","arPlacement","setRotation","softness3","radiansY2","scale3","offset48","$d81ab295f1227915$var$raycaster","ndcPosition1","object11","hits","hit","hotspot2","removeHotspot","hotspot1","forHotspots","hotspot","$d81ab295f1227915$var$Hotspot","viewerPosition","$d81ab295f1227915$var$view","$d81ab295f1227915$var$target","$d81ab295f1227915$var$normalWorld","radians1","orient","visible2","src2","alt","poster","iosSrc","contentUrl","encodingFormat","_a","structuredData","parentElement","shaderMaterial","$d81ab295f1227915$var$_getMipmapMaterial","$d81ab295f1227915$var$_mipmapMaterial","renderer7","$d81ab295f1227915$var$_renderer","$d81ab295f1227915$var$_mesh","$d81ab295f1227915$var$_flatCamera","material11","roughnessUpdated","oldTarget","$d81ab295f1227915$var$_tempTarget","newRoughnessTarget","mip","$d81ab295f1227915$var$__decorate$7","decorators","desc","getOwnPropertyDescriptor","xrLight","renderer8","environmentEstimation","estimationStartCallback","xrWebGLBinding","frameCallback","onXRFrame","cubeRenderTarget","updateReflection","cubeMap","getReflectionCubeMap","time4","getLightEstimate","lightEstimate","sphericalHarmonicsCoefficients","primaryLightIntensity","directionalLight","intensityScalar","primaryLightDirection","renderer9","environmentEstimation1","sessionLightProbe","estimationStarted","requestLightProbe","reflectionFormat","preferredReflectionFormat","$d81ab295f1227915$var$SessionLightProbe","$d81ab295f1227915$var$addCorner","cornerX","cornerY","$d81ab295f1227915$var$PlacementBox","scene5","side2","numVertices","i48","goalOpacity","opacityDamper","hitPlane","shadowHeight","screenX","screenY","hitResult","scene6","positionAndNormalFromPoint","$d81ab295f1227915$var$vector2","getHit","scene7","screenX1","screenY1","offsetHeight","offset49","visible1","updateOpacity","delta1","renderer10","currentSession","placeOnWall","placementBox","turntableRotation","oldShadowIntensity","oldBackground","oldEnvironment","resolveCleanup","exitWebXRButtonContainer","isTwoFingering","lastDragPosition","firstRatio","lastAngle","goalPosition","yDamper","zDamper","yawDamper","scaleDamper","onExitWebXRButtonContainerClick","stopPresenting","onUpdateScene","presentedScene","hitSource","transientHitTestSource","fingers","getHitTestResultsForTransientInput","gamepad","hitPosition","isTranslating","separation","fingerPolar","isRotating","threeRenderer","$d81ab295f1227915$var$assertIsArCandidate","requestSession","optionalFeatures","setSession","_presentedScene","waitForAnimationFrame","_reject","scene9","setHotspotsVisibility","overlay","environmentEstimation2","$d81ab295f1227915$var$XREstimatedLight","resolveARSession","exitButton","viewerRefSpace","tracking","frames","goalYaw","goalScale","oldFramedFieldOfView","XRRay","DOMPoint","space","offsetRay","hitTestSource","initialHitSource","placementComplete","lastTick","performance","$d81ab295f1227915$var$ARStatus","cleanupPromise","postSessionCleanup","setTarget","onSelectStart","onSelectEnd","setShadowScaleAndOffset","$d81ab295f1227915$var$$onResize","cancel","$d81ab295f1227915$var$camera","orientHotspots","placeInitially","recommendedViewportScale","requestViewportScale","getCameraOrbit","$d81ab295f1227915$var$vector3","cameraDirection","requestHitTestSourceForTransientInput","profile","getExpandedHit","refSpace","$d81ab295f1227915$var$matrix4","hitMatrix","$d81ab295f1227915$var$hitPosition","frame4","getHitTestResults","getHitPoint","hitPoint","fingerTwo","fingerOne","deltaY","deltaX","deltaYaw","frame2","finger","delta2","oldScale","xDamper","newScale","$d81ab295f1227915$var$ARTracking","$d81ab295f1227915$var$$sceneIsReady","isFirstView","updateView","moveToFloor","frame3","processInput","time5","moveScene","preRender","DEPTH_BUFFER_BIT","$d81ab295f1227915$var$Debugger","renderer11","THREE","ShaderMaterial","Texture","Scene","PlaneBufferGeometry","OrthographicCamera","WebGLRenderTarget","$d81ab295f1227915$var$clone","sourceLookup","cloneLookup","sourceNode","clonedNode","clonedMesh","sourceMesh","sourceBones","$d81ab295f1227915$var$parallelTraverse","$d81ab295f1227915$var$$prepared","$d81ab295f1227915$var$GLTFInstance","$d81ab295f1227915$var$$preparedGLTF","source66","prepared","$d81ab295f1227915$var$$prepare","source64","GLTFInstanceConstructor","$d81ab295f1227915$var$$clone","propertyValue","$d81ab295f1227915$var$cloneVariantMaterials","dst3","src3","originalMaterial","obj1","obj2","threeGLTF3","gltf1","threeObjectMap","gltfElementMap","$d81ab295f1227915$var$$threeGLTF","$d81ab295f1227915$var$$gltf","$d81ab295f1227915$var$$gltfElementMap","$d81ab295f1227915$var$$threeObjectMap","threeGLTF1","upstreamCorrelatedSceneGraph","$d81ab295f1227915$var$$correlateCloneThreeGLTF","$d81ab295f1227915$var$$correlateOriginalThreeGLTF","threeGLTF2","defaultMaterial","defaultReference","threeMaterial","threeObject","gltfMappings","objWithUserData","gltfElement","threeObjects","$d81ab295f1227915$var$CorrelatedSceneGraph","cloneThreeGLTF","upstreamCorrelatedSceneGraph1","originalThreeGLTF","threeGLTF","originalGLTF","cloneThreeObjectMap","cloneGLTFElementMap","$d81ab295f1227915$var$$parallelTraverseThreeScene","cloneObject","elementReference","cloneElement","cloneGLTF","cloneObjects","sceneOne","sceneTwo","callback14","$d81ab295f1227915$var$$cloneAndPatchMaterial","$d81ab295f1227915$var$$correlatedSceneGraph","$d81ab295f1227915$var$ModelViewerGLTFInstance","source65","nullSphere","sourceUUIDToClonedMaterial","correlatedSceneGraph","material12","roughnessMipmapper","$d81ab295f1227915$var$Renderer","singleton","$d81ab295f1227915$var$EnvironmentScene","boxMaterial","createAreaLightMaterial","light4","light5","light6","intensity11","mainLight","room","roomMaterial","light7","intensity12","manager11","buffer24","rgbe_error","rgbe_error_code","fgets","lineLimit","consume","pos","chunk","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","toHalfFloat","byteArray","gamma_re","exposure_re","format_re","dimensions_re","comments","programtype","gamma","RGBE_ReadHeader","rgbe_header_info","image_rgba_data","scanline_width","data_rgba","ptr_end","rgbeStart","scanline_buffer","num_scanlines","isEncodedRun","byteValue","off","RGBE_ReadPixels_RLE","numElements","floatArray","halfArray","j3","RGBEByteToRGBHalf","url21","onLoad13","onError13","setDataType","generatedEnvironmentMap","generatedEnvironmentMapAlt","skyboxCache","blurScene","progressCallback3","isHDR","$d81ab295f1227915$var$HDR_FILE_RE","url22","$d81ab295f1227915$var$hdrLoader","$d81ab295f1227915$var$ldrLoader","skyboxUrl","environmentMap","options22","progressTracker","updateGenerationProgress","beginActivity","useAltEnvironment","$d81ab295f1227915$var$deserializeUrl","environmentMapLoads","skyboxLoads","loadEquirectFromUrl","environmentMapUrl","loadGeneratedEnvironmentMapAlt","loadGeneratedEnvironmentMap","skybox","url23","skyboxMapLoads","scene12","name29","$d81ab295f1227915$var$timePasses","cubeTarget","blurCubemap","GenerateEnvironmentMap","$d81ab295f1227915$var$EnvironmentSceneAlt","getBlurShader","tempTarget","halfblur","targetIn1","targetOut1","sigmaRadians1","direction7","i49","options18","debugger","multipleScenesVisible","scaleStep","lastStep","avgFrameDuration","sourceEvent","onWebGLContextRestored","textureUtils","$d81ab295f1227915$var$TextureUtils","$d81ab295f1227915$var$RoughnessMipmapper","$d81ab295f1227915$var$$updateEnvironment","canvas3D","setPixelRatio","canRender","initializeKTX2Loader","onWebGLContextLost","updateRendererSize","_singleton","$d81ab295f1227915$var$$updateSize","scene13","widthCSS","heightCSS","scene14","scene19","scene15","removeScene","scene16","$d81ab295f1227915$var$$canvas","visibleScenes","visibleCanvas","modelIsVisible","scene17","orderedScenes","arRenderer","scene18","t28","delta3","$d81ab295f1227915$var$$tick","exposureIsNumber","isShadowDirty","t29","onWebXRFrame","selectCanvas","updateRendererScale","renderCount","shouldRender","visibleScene","createContext","context2D","clearRect","$d81ab295f1227915$var$_a$8","$d81ab295f1227915$var$_b$7","$d81ab295f1227915$var$$ongoingActivities","$d81ab295f1227915$var$ProgressTracker","$d81ab295f1227915$var$$eventDelegate","ongoingActivityCount","activity","$d81ab295f1227915$var$$announceTotalProgress","nextProgress","totalProgress","statusCount","completedActivities","$d81ab295f1227915$var$_b$6","$d81ab295f1227915$var$_c$3","$d81ab295f1227915$var$_d$2","$d81ab295f1227915$var$_e","$d81ab295f1227915$var$_f","$d81ab295f1227915$var$_g","$d81ab295f1227915$var$_h","$d81ab295f1227915$var$_j","$d81ab295f1227915$var$_k","$d81ab295f1227915$var$__decorate$6","$d81ab295f1227915$var$blobCanvas","$d81ab295f1227915$var$$fallbackResizeHandler","$d81ab295f1227915$var$$defaultAriaLabel","$d81ab295f1227915$var$ModelViewerElementBase","$d81ab295f1227915$var$_a$7","$d81ab295f1227915$var$debounce","boundingRect","oldVisibility","newVisibility","sourceError","$d81ab295f1227915$var$makeTemplate","$d81ab295f1227915$var$$container","$d81ab295f1227915$var$$userInputElement","isConnected","$d81ab295f1227915$var$$scene","$d81ab295f1227915$var$ModelScene","$d81ab295f1227915$var$$markLoaded","$d81ab295f1227915$var$$onModelLoad","$d81ab295f1227915$var$$resizeObserver","contentRect","$d81ab295f1227915$var$$intersectionObserver","$d81ab295f1227915$var$$isElementInViewport","isIntersecting","$d81ab295f1227915$var$$announceModelVisibility","$d81ab295f1227915$var$$updateSource","rootMargin","is","modelCacheSize","value58","minimumRenderScale","value59","minScale","$d81ab295f1227915$var$$getLoaded","$d81ab295f1227915$var$$loaded","$d81ab295f1227915$var$$loadedTime","$d81ab295f1227915$var$$clearModelTimeout","$d81ab295f1227915$var$$progressTracker","$d81ab295f1227915$var$$getModelIsVisible","observe","$d81ab295f1227915$var$$onContextLost","registerScene","unobserve","unregisterScene","changedProperties2","ariaLabel","type14","encoderOptions","displayCanvas","options19","qualityArgument","idealAspect","outputWidth","outputHeight","oldWidth","msToBlob","toBlob","base64DataUrl","typeMatch","base64","byteCharacters","byteArrays","byteNumbers","charCodeAt","$d81ab295f1227915$var$dataUrlToBlob","registerRenderer","renderer12","$d81ab295f1227915$var$$ariaLabel","$d81ab295f1227915$var$$shouldAttemptPreload","width17","height17","_time1","_delta","$d81ab295f1227915$var$$needsRender","e2","updateSourceProgress","setSource","$d81ab295f1227915$var$__decorate$5","$d81ab295f1227915$var$durl","e1","encodeURI","$d81ab295f1227915$var$u16","$d81ab295f1227915$var$u32","$d81ab295f1227915$var$fleb","$d81ab295f1227915$var$u8","$d81ab295f1227915$var$fdeb","eb","$d81ab295f1227915$var$_a$6","$d81ab295f1227915$var$freb","$d81ab295f1227915$var$fl","$d81ab295f1227915$var$revfl","$d81ab295f1227915$var$hMap","cd","mb","co","le","rvb","sv","r_1","$d81ab295f1227915$var$rev","$d81ab295f1227915$var$i","$d81ab295f1227915$var$flt","$d81ab295f1227915$var$fdt","maxSym","tr","cst","lft","i2_1","mbt","i2_2","i2_3","$d81ab295f1227915$var$ln","cli","cln","cls","cl","out","dat","final","syms","lf","li","bl","dlt","mlb","$d81ab295f1227915$var$hTree","ddt","_b","mdb","$d81ab295f1227915$var$lc","lclt","_c","nlc","lcdt","_d","ndc","lcfreq","lct","mlcb","nlcc","$d81ab295f1227915$var$clim","ll","dm","dl","dtlen","$d81ab295f1227915$var$clen","ftlen","$d81ab295f1227915$var$wfblk","$d81ab295f1227915$var$wbits","lcts","it","clct","llm","$d81ab295f1227915$var$flm","$d81ab295f1227915$var$fdm","lm","$d81ab295f1227915$var$wbits16","cr","$d81ab295f1227915$var$crct","opt","pre","post","st","lvl","plvl","lst","$d81ab295f1227915$var$deo","msk_1","bs1_1","bs2_1","hsh","rem","lc_1","$d81ab295f1227915$var$wblk","maxd","dif","ch_1","imod","pimod","nl","maxn","mmd","md","ti","$d81ab295f1227915$var$revfd","lin","din","wi","mem","$d81ab295f1227915$var$deflateSync","opts","$d81ab295f1227915$var$dopt","val","$d81ab295f1227915$var$mrg","TextEncoder","$d81ab295f1227915$var$td","$d81ab295f1227915$var$et","stream","ar","ai","latin1","ex","$d81ab295f1227915$var$wzh","crc","$d81ab295f1227915$var$wbytes","fl","exl","attrs","exf","$d81ab295f1227915$var$zipSync","$d81ab295f1227915$var$strToU8","comment","com","$d81ab295f1227915$var$exfl","extra","compression","$d81ab295f1227915$var$crc","tot","oe","cdl","badd","scene20","geometryFileName","$d81ab295f1227915$var$buildMeshVertexCount","$d81ab295f1227915$var$buildMeshVertexIndices","$d81ab295f1227915$var$buildVector3Array","$d81ab295f1227915$var$buildVector2Array","dataToInsert","$d81ab295f1227915$var$buildHeader","$d81ab295f1227915$var$buildMatrix","isRGBA","$d81ab295f1227915$var$imageToCanvas","arrayBuffer","filename","offsetMod64","padding","imagedata","toPrecision","mapType","inputs","pad","buildTexture","$d81ab295f1227915$var$buildColor","$d81ab295f1227915$var$__decorate$4","allowedNames","valueString","$d81ab295f1227915$var$_a$5","$d81ab295f1227915$var$_b$4","$d81ab295f1227915$var$_c$2","$d81ab295f1227915$var$$lastValue","$d81ab295f1227915$var$Evaluator","node4","basis","$d81ab295f1227915$var$PercentageEvaluator","$d81ab295f1227915$var$CalcEvaluator","$d81ab295f1227915$var$EnvEvaluator","evaluatable2","evaluatable1","isConstant","keywords","intrinsics","evaluatedNode","keyword","autoSubstituteNode","basisNode","$d81ab295f1227915$var$$evaluate","$d81ab295f1227915$var$$basis","$d81ab295f1227915$var$$identNode","envFunction","pageYOffset","scrollHeight","documentElement","clientHeight","innerHeight","calcFunction","basis2","secondOrderTerms","term","previousTerm","$d81ab295f1227915$var$IS_MULTIPLICATION_RE","operator","leftValue","$d81ab295f1227915$var$OperatorEvaluator","evaluatableFor","$d81ab295f1227915$var$$evaluator","$d81ab295f1227915$var$$operator","$d81ab295f1227915$var$$left","$d81ab295f1227915$var$$right","leftNode","rightNode","leftUnit","rightValue","rightUnit","$d81ab295f1227915$var$StyleEvaluator","intrinsics1","$d81ab295f1227915$var$$intrinsics","firstExpression","$d81ab295f1227915$var$$evaluatables","evaluatable","evaluated","applyIntrinsics","$d81ab295f1227915$var$_a$4","$d81ab295f1227915$var$_b$3","$d81ab295f1227915$var$_c$1","$d81ab295f1227915$var$_d$1","$d81ab295f1227915$var$$instances","$d81ab295f1227915$var$$activateListener","$d81ab295f1227915$var$$deactivateListener","$d81ab295f1227915$var$$notifyInstances","$d81ab295f1227915$var$$notify","$d81ab295f1227915$var$$scrollCallback","$d81ab295f1227915$var$ScrollObserver","callback12","callback13","$d81ab295f1227915$var$ASTWalker","$d81ab295f1227915$var$$computeStyleCallback","relatedState","ast1","$d81ab295f1227915$var$$dependencies","walk","functionNode","firstTerm","newDependencies","observer","oldDependencies","$d81ab295f1227915$var$$onScroll","environmentState","$d81ab295f1227915$var$$astWalker","Function","$styleEffector","$styleEvaluator","writable","$updateEvaluator","ast","getIntrinsics","observeEffects","$d81ab295f1227915$var$StyleEffector","$evaluateAndSync","observeEffectsFor","updateHandler","originalUpdated","originalConnectedCallback","originalDisconnectedCallback","$d81ab295f1227915$var$SmoothControls","element11","sensitivity","_interactionEnabled","_disableZoom","isUserChange","isUserPointing","spherical","goalSpherical","thetaDamper","phiDamper","radiusDamper","logFov","$d81ab295f1227915$var$DEFAULT_OPTIONS","maximumFieldOfView","goalLogFov","fovDamper","touchMode","cancelable","touchModeZoom","targetTouches","lastTouches","deltaZoom","twoTouchDistance","userAdjustOrbit","touchModeRotate","touchAction","_options","touchDecided","clientX","clientY","lastPointerPosition","handleSinglePointerMove","onMouseDown","onPointerDown","onMouseMove","onMouseUp","handleSinglePointerDown","onTouchStart","changedTouches","touches","onTouchChange","_event","onPointerUp","onTouchEnd","onWheel","canInteract","deltaMode","onKeyDown","relevantKey","keyCode","$d81ab295f1227915$var$KeyCode","$d81ab295f1227915$var$KEYBOARD_ORBIT_INCREMENT","setOrbit","setFieldOfView","jumpToGoal","enableInteraction","onTouchMove","cursor","updateTouchActionStyle","disableZoom","target36","getFieldOfView","applyOptions","updateAspect","aspect1","nextTheta","goalTheta","minimumAzimuthalAngle","maximumAzimuthalAngle","wrapAngle","nextPhi","goalPhi","minimumPolarAngle","maximumPolarAngle","nextRadius","goalRadius","minimumRadius","maximumRadius","makeSafe","fov1","minimumFieldOfView","decayMilliseconds3","deltaTheta2","deltaPhi","dThetaLimit","deltaRatio","_time","delta5","isStationary","moveCamera","setFromSpherical","setRotationFromEuler","$d81ab295f1227915$var$ChangeSource","radians2","pixelLengthToSphericalAngle","pixelLength","touchOne","touchTwo","xOne","yOne","xTwo","yTwo","xDelta","yDelta","pointer","deltaTheta","$d81ab295f1227915$var$easeInOutQuad","ease","$d81ab295f1227915$var$timeline","keyframes","keyframe","$d81ab295f1227915$var$interpolate","lastValue","ratio","$d81ab295f1227915$var$InteractionPromptStyle","auto","defaultTerms","$d81ab295f1227915$var$MINIMUM_RADIUS_RATIO","$d81ab295f1227915$var$cameraOrbitIntrinsics","orbitIntrinsics","defaultRadius","$d81ab295f1227915$var$cameraTargetIntrinsics","$d81ab295f1227915$var$HALF_PI","$d81ab295f1227915$var$TAU","$d81ab295f1227915$var$$controls","$d81ab295f1227915$var$$updateCameraForRadius","$d81ab295f1227915$var$$onBlur","$d81ab295f1227915$var$$onFocus","$d81ab295f1227915$var$$onChange","$d81ab295f1227915$var$$syncMaxFieldOfView","$d81ab295f1227915$var$_b$2","$d81ab295f1227915$var$$modelViewerStatusInstance","$d81ab295f1227915$var$$updateStatus","$d81ab295f1227915$var$__decorate$2","$d81ab295f1227915$var$_a$3","registeredInstanceStatuses","loadingPromises","statusElement","statusUpdateInProgress","updateStatus","modelViewer","onUnregistered","loadShouldBeMeasured","loadAttemptCompletes","resolveHandler","modelViewerStatusInstance","modelViewer1","statuses","instanceStatus","firstKey","_map","_error","$d81ab295f1227915$var$getFirstMapKey","value61","$d81ab295f1227915$var$$posterDismissalSource","$d81ab295f1227915$var$$hidePoster","$d81ab295f1227915$var$$transitioned","writer","$d81ab295f1227915$var$GLTFLightExtension","$d81ab295f1227915$var$GLTFMaterialsUnlitExtension","$d81ab295f1227915$var$GLTFMaterialsPBRSpecularGlossiness","$d81ab295f1227915$var$GLTFMaterialsTransmissionExtension","$d81ab295f1227915$var$GLTFMaterialsVolumeExtension","callback15","onDone","options20","$d81ab295f1227915$var$GLTFWriter","write","$d81ab295f1227915$var$WEBGL_CONSTANTS","$d81ab295f1227915$var$equalArray","array1","every","$d81ab295f1227915$var$getPaddedBufferSize","bufferSize","$d81ab295f1227915$var$getPaddedArrayBuffer","paddingByte","paddedLength","nodeMap","uids","uid","plugins1","trs","onlyVisible","truncateDrawRange","embedImages","includeCustomExtensions","options21","input1","extensionsUsedList","binary","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","binaryChunkPrefix","setUint32","jsonChunk","encode","$d81ab295f1227915$var$stringToArrayBuffer","jsonChunkPrefix","totalByteLength","glbBlob","glbReader","onDone1","readAsDataURL","base64data","object15","object12","normal9","attributesNormalized","mapDef1","texture11","transformDef","didTransform","buffer25","target37","componentSize","dataView","processBufferViewImage","blob1","processBuffer","attribute11","start3","count5","end2","minMax","POSITIVE_INFINITY","NEGATIVE_INFINITY","$d81ab295f1227915$var$getMinMax","bufferViewTarget","processBufferView","cachedImages","imageDef","$d81ab295f1227915$var$cachedCanvas","ctx","i50","processSampler","samplerDef","$d81ab295f1227915$var$THREE_TO_WEBGL","map1","processImage","writeTexture","material17","metalRoughMapDef","processTexture","applyTextureTransform","baseColorMapDef","maxEmissiveComponent","emissiveMapDef","normalMapDef","occlusionMapDef","serializeUserData","writeMaterial","meshCacheKeyParts","meshCacheKey","nameConversion","originalNormal","isNormalizedNormalAttribute","createNormalizedNormalAttribute","getUID","modifiedAttribute","processAccessor","reverseDictionary","warned","baseAttribute","relativeAttribute","isMultiMaterial","i51","processMaterial","isOrtho","camera5","orthographic","perspective","degToRad","processAnimation","clip6","root5","$d81ab295f1227915$var$GLTFExporter","Utils","mergeMorphTargetTracks","trackBinding","trackNode","trackProperty","$d81ab295f1227915$var$PATH_PROPERTIES","inputItemSize","outputItemSize","object13","rootJoint","temporaryBoneInverse","object14","processMesh","processCamera","processNode","writeNode","processScene","scene21","sceneDef","input2","beforeParse","objectsWithoutScene","i52","processSkin","i53","afterParse","func3","writer6","writer1","material13","materialDef2","writer2","material14","materialDef3","specularMapDef","specularGlossinessTexture","writer3","material15","transmissionMapDef","materialDef4","writer4","materialDef5","material16","thicknessMapDef","attenuationColor","tolerance","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","mergedTracks","mergedTrack","sourceInterpolant","targetCount","keyframeIndex","j4","$d81ab295f1227915$var$compatibleMaterial","writer5","objects2","variantNameSet","$d81ab295f1227915$var$compatibleObject","variantName","variantMaterial","mesh2","variantMaterialInstance","variantIndex","mappingTable","mappingsDef","originalMaterialIndex","variantsDef","correlatedObjects","$d81ab295f1227915$var$$onUpdate","$d81ab295f1227915$var$$sourceObject","$d81ab295f1227915$var$$correlatedObjects","$d81ab295f1227915$var$quad","$d81ab295f1227915$var$$threeTexture","$d81ab295f1227915$var$ThreeDOMElement","assert","uri1","$d81ab295f1227915$var$loader","width18","height18","$d81ab295f1227915$var$quadMaterial","readRenderTargetPixels","blobContext","createImageData","imageData","Filter","$d81ab295f1227915$var$Filter","$d81ab295f1227915$var$Wrap","Wrap","$d81ab295f1227915$var$isMinFilter","Nearest","Linear","NearestMipmapNearest","LinearMipmapLinear","NearestMipmapLinear","minFilterValues","magFilterValues","onUpdate2","texture9","gltfSampler","Repeat","$d81ab295f1227915$var$$sourceSampler","$d81ab295f1227915$var$$setProperty","$d81ab295f1227915$var$isMagFilter","$d81ab295f1227915$var$isWrapMode","$d81ab295f1227915$var$isValidSamplerValue","mutations","mutation","MutationRecord","addedNodes","$d81ab295f1227915$var$$addHotspot","removedNodes","$d81ab295f1227915$var$$removeHotspot","MutationObserver","$d81ab295f1227915$var$$mutationCallback","ShadyDOM","$d81ab295f1227915$var$$observer","childList","observeChildren","unobserveChildren","$d81ab295f1227915$var$$hotspotMap","updateHotspots","pixelX","pixelY","ndcPosition","getNDC","$d81ab295f1227915$var$worldToModel","$d81ab295f1227915$var$toVector3D","$d81ab295f1227915$var$worldToModelNormal","increment","addHotspot","node3","decrement","AnnotationModelViewerElement","skyboxImage","$d81ab295f1227915$var$$onPreload","setShadowSoftness","$d81ab295f1227915$var$$cancelEnvironmentUpdate","$d81ab295f1227915$var$$currentEnvironmentMap","$d81ab295f1227915$var$$applyEnvironmentMap","environmentImage","texturesLoad","generateEnvironmentMapAndSkybox","errorOrPromise","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","ControlsModelViewerElement","cameraControls","cameraOrbit","cameraTarget","fieldOfView","interactionPromptThreshold","interactionPromptStyle","interactionPrompt","$d81ab295f1227915$var$InteractionPromptStrategy","interactionPolicy","$d81ab295f1227915$var$InteractionPolicy","orbitSensitivity","$d81ab295f1227915$var$TouchAction","bounds","$d81ab295f1227915$var$$focusedTime","$d81ab295f1227915$var$$userHasInteracted","$d81ab295f1227915$var$$waitingToPromptUser","$d81ab295f1227915$var$$promptElement","$d81ab295f1227915$var$$promptElementVisibleTime","$d81ab295f1227915$var$$updateAria","$d81ab295f1227915$var$$deferInteractionPrompt","$d81ab295f1227915$var$$lastSpherical","getCameraTarget","getMinimumFieldOfView","getMaximumFieldOfView","jumpCameraToGoal","$d81ab295f1227915$var$$jumpCamera","resetInteractionPrompt","$d81ab295f1227915$var$$onPointerChange","controls","disableInteraction","toggle","setTargetDamperDecayTime","interpolationDecay","updateFraming","newFramedFieldOfView","$d81ab295f1227915$var$$zoomAdjustedFieldOfView","$d81ab295f1227915$var$$maintainThetaPhi","$d81ab295f1227915$var$$promptAnimatedContainer","$d81ab295f1227915$var$$lastPromptOffset","$d81ab295f1227915$var$$initialized","$d81ab295f1227915$var$$syncFieldOfView","$d81ab295f1227915$var$$syncCameraOrbit","style3","$d81ab295f1227915$var$$syncMinCameraOrbit","style4","style5","$d81ab295f1227915$var$$syncMinFieldOfView","style6","style7","style8","$d81ab295f1227915$var$$hasTransitioned","thresholdTime","$d81ab295f1227915$var$wiggle","$d81ab295f1227915$var$fade","adjustOrbit","updateNearFar","lastTheta","lastPhi","getCameraSpherical","getRootNode","activeElement","lastAzimuthalQuadrant","$d81ab295f1227915$var$QUARTER_PI","azimuthalQuadrant","lastPolarTrient","$d81ab295f1227915$var$THIRD_PI","polarTrient","$d81ab295f1227915$var$POLAR_TRIENT_LABELS","$d81ab295f1227915$var$AZIMUTHAL_QUADRANT_LABELS","maxFieldOfView","minCameraOrbit","maxCameraOrbit","$d81ab295f1227915$var$__decorate$3","$d81ab295f1227915$var$style","$d81ab295f1227915$var$fieldOfViewIntrinsics","$d81ab295f1227915$var$maxCameraOrbitIntrinsics","$d81ab295f1227915$var$$syncMaxCameraOrbit","$d81ab295f1227915$var$minFieldOfViewIntrinsics","$d81ab295f1227915$var$maxFieldOfViewIntrinsics","arScale","xrEnvironment","$d81ab295f1227915$var$ARMode","activateAR","canActivateAR","$d81ab295f1227915$var$$arMode","$d81ab295f1227915$var$$onARStatus","$d81ab295f1227915$var$$onARTracking","$d81ab295f1227915$var$$onARTap","$d81ab295f1227915$var$$arAnchor","$d81ab295f1227915$var$$arModes","$d81ab295f1227915$var$deserializeARModes","arModes","$d81ab295f1227915$var$$openIOSARQuickLook","$d81ab295f1227915$var$$enterARWithWebXR","$d81ab295f1227915$var$$openSceneViewer","$d81ab295f1227915$var$$canActivateAR","$d81ab295f1227915$var$$arButtonContainer","$d81ab295f1227915$var$$preload","$d81ab295f1227915$var$$onARButtonContainerClick","$d81ab295f1227915$var$$selectARMode","$d81ab295f1227915$var$isWebXRBlocked","supportsPresentation","$d81ab295f1227915$var$isSceneViewerBlocked","$d81ab295f1227915$var$$triggerLoad","predicate","$d81ab295f1227915$var$waitForEvent","locationUrl","URLSearchParams","modelUrl","linkUrl","intent","encodeURIComponent","history","back","click","generateUsdz","objectURL","prepareUSDZ","img","anchor","ARModelViewerElement","reveal","$d81ab295f1227915$var$RevealStrategy","loading","$d81ab295f1227915$var$LoadingStrategy","seamlessPoster","$d81ab295f1227915$var$$defaultPosterElement","flush","throttled","$d81ab295f1227915$var$throttle","$d81ab295f1227915$var$$defaultProgressBarElement","$d81ab295f1227915$var$$defaultProgressMaskElement","dismissPoster","$d81ab295f1227915$var$$lastReportedProgress","$d81ab295f1227915$var$$updateProgressBar","defaultPosterElement","tabIndex","dracoDecoderLocation","setDRACODecoderLocation","ktx2TranscoderLocation","setKTX2TranscoderLocation","meshoptDecoderLocation","setMeshoptDecoderLocation","getDRACODecoderLocation","value62","getKTX2TranscoderLocation","value63","getMeshoptDecoderLocation","$d81ab295f1227915$var$PosterDismissalSource","$d81ab295f1227915$var$$posterContainerElement","$d81ab295f1227915$var$$modelIsRevealed","getDimensions","$d81ab295f1227915$var$$onClick","$d81ab295f1227915$var$$onKeydown","$d81ab295f1227915$var$$onProgress","$d81ab295f1227915$var$loadingStatusAnnouncer","registerInstance","unregisterInstance","backgroundImage","$d81ab295f1227915$var$$ariaLabelCallToAction","generateSchema","updateSchema","$d81ab295f1227915$var$$onTransitionEnd","posterContainerElement","currentGLTF","showPoster","AnimationModelViewerElement","animationName","animationCrossfadeDuration","availableAnimations","$d81ab295f1227915$var$$paused","$d81ab295f1227915$var$$changeAnimation","updateAnimation","stopAnimation"],"version":3,"file":"index.2d9d0af6.js.map"}